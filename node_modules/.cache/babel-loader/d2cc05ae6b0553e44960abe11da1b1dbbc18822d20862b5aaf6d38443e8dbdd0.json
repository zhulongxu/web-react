{"ast":null,"code":"import { Line } from '../line';\nimport { Point } from '../point';\nimport { Segment } from './segment';\nexport class LineTo extends Segment {\n  constructor(x, y) {\n    super();\n    if (Line.isLine(x)) {\n      this.endPoint = x.end.clone().round(2);\n    } else {\n      this.endPoint = Point.create(x, y).round(2);\n    }\n  }\n  get type() {\n    return 'L';\n  }\n  get line() {\n    return new Line(this.start, this.end);\n  }\n  bbox() {\n    return this.line.bbox();\n  }\n  closestPoint(p) {\n    return this.line.closestPoint(p);\n  }\n  closestPointLength(p) {\n    return this.line.closestPointLength(p);\n  }\n  closestPointNormalizedLength(p) {\n    return this.line.closestPointNormalizedLength(p);\n  }\n  closestPointTangent(p) {\n    return this.line.closestPointTangent(p);\n  }\n  length() {\n    return this.line.length();\n  }\n  divideAt(ratio) {\n    const divided = this.line.divideAt(ratio);\n    return [new LineTo(divided[0]), new LineTo(divided[1])];\n  }\n  divideAtLength(length) {\n    const divided = this.line.divideAtLength(length);\n    return [new LineTo(divided[0]), new LineTo(divided[1])];\n  }\n  getSubdivisions() {\n    return [];\n  }\n  pointAt(ratio) {\n    return this.line.pointAt(ratio);\n  }\n  pointAtLength(length) {\n    return this.line.pointAtLength(length);\n  }\n  tangentAt(ratio) {\n    return this.line.tangentAt(ratio);\n  }\n  tangentAtLength(length) {\n    return this.line.tangentAtLength(length);\n  }\n  isDifferentiable() {\n    if (this.previousSegment == null) {\n      return false;\n    }\n    return !this.start.equals(this.end);\n  }\n  clone() {\n    return new LineTo(this.end);\n  }\n  scale(sx, sy, origin) {\n    this.end.scale(sx, sy, origin);\n    return this;\n  }\n  rotate(angle, origin) {\n    this.end.rotate(angle, origin);\n    return this;\n  }\n  translate(tx, ty) {\n    if (typeof tx === 'number') {\n      this.end.translate(tx, ty);\n    } else {\n      this.end.translate(tx);\n    }\n    return this;\n  }\n  equals(s) {\n    return this.type === s.type && this.start.equals(s.start) && this.end.equals(s.end);\n  }\n  toJSON() {\n    return {\n      type: this.type,\n      start: this.start.toJSON(),\n      end: this.end.toJSON()\n    };\n  }\n  serialize() {\n    const end = this.end;\n    return `${this.type} ${end.x} ${end.y}`;\n  }\n}\n(function (LineTo) {\n  function create(...args) {\n    const len = args.length;\n    const arg0 = args[0];\n    // line provided\n    if (Line.isLine(arg0)) {\n      return new LineTo(arg0);\n    }\n    // points provided\n    if (Point.isPointLike(arg0)) {\n      if (len === 1) {\n        return new LineTo(arg0);\n      }\n      // poly-line segment\n      return args.map(arg => new LineTo(arg));\n    }\n    // coordinates provided\n    if (len === 2) {\n      return new LineTo(+args[0], +args[1]);\n    }\n    // poly-line segment\n    const segments = [];\n    for (let i = 0; i < len; i += 2) {\n      const x = +args[i];\n      const y = +args[i + 1];\n      segments.push(new LineTo(x, y));\n    }\n    return segments;\n  }\n  LineTo.create = create;\n})(LineTo || (LineTo = {}));","map":{"version":3,"names":["Line","Point","Segment","LineTo","constructor","x","y","isLine","endPoint","end","clone","round","create","type","line","start","bbox","closestPoint","p","closestPointLength","closestPointNormalizedLength","closestPointTangent","length","divideAt","ratio","divided","divideAtLength","getSubdivisions","pointAt","pointAtLength","tangentAt","tangentAtLength","isDifferentiable","previousSegment","equals","scale","sx","sy","origin","rotate","angle","translate","tx","ty","s","toJSON","serialize","args","len","arg0","isPointLike","map","arg","segments","i","push"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6-geometry@2.0.5/node_modules/@antv/x6-geometry/src/path/lineto.ts"],"sourcesContent":["import { Line } from '../line'\nimport { Point } from '../point'\nimport { Segment } from './segment'\n\nexport class LineTo extends Segment {\n  constructor(line: Line)\n  constructor(x: number, y: number)\n  constructor(p: Point.PointLike | Point.PointData)\n  constructor(\n    x: number | Line | (Point.PointLike | Point.PointData),\n    y?: number,\n  ) {\n    super()\n\n    if (Line.isLine(x)) {\n      this.endPoint = x.end.clone().round(2)\n    } else {\n      this.endPoint = Point.create(x, y).round(2)\n    }\n  }\n\n  get type() {\n    return 'L'\n  }\n\n  get line() {\n    return new Line(this.start, this.end)\n  }\n\n  bbox() {\n    return this.line.bbox()\n  }\n\n  closestPoint(p: Point.PointLike | Point.PointData) {\n    return this.line.closestPoint(p)\n  }\n\n  closestPointLength(p: Point.PointLike | Point.PointData) {\n    return this.line.closestPointLength(p)\n  }\n\n  closestPointNormalizedLength(p: Point.PointLike | Point.PointData) {\n    return this.line.closestPointNormalizedLength(p)\n  }\n\n  closestPointTangent(p: Point.PointLike | Point.PointData) {\n    return this.line.closestPointTangent(p)\n  }\n\n  length() {\n    return this.line.length()\n  }\n\n  divideAt(ratio: number): [Segment, Segment] {\n    const divided = this.line.divideAt(ratio)\n    return [new LineTo(divided[0]), new LineTo(divided[1])]\n  }\n\n  divideAtLength(length: number): [Segment, Segment] {\n    const divided = this.line.divideAtLength(length)\n    return [new LineTo(divided[0]), new LineTo(divided[1])]\n  }\n\n  getSubdivisions() {\n    return []\n  }\n\n  pointAt(ratio: number) {\n    return this.line.pointAt(ratio)\n  }\n\n  pointAtLength(length: number) {\n    return this.line.pointAtLength(length)\n  }\n\n  tangentAt(ratio: number) {\n    return this.line.tangentAt(ratio)\n  }\n\n  tangentAtLength(length: number) {\n    return this.line.tangentAtLength(length)\n  }\n\n  isDifferentiable() {\n    if (this.previousSegment == null) {\n      return false\n    }\n\n    return !this.start.equals(this.end)\n  }\n\n  clone() {\n    return new LineTo(this.end)\n  }\n\n  scale(sx: number, sy: number, origin?: Point.PointLike | Point.PointData) {\n    this.end.scale(sx, sy, origin)\n    return this\n  }\n\n  rotate(angle: number, origin?: Point.PointLike | Point.PointData) {\n    this.end.rotate(angle, origin)\n    return this\n  }\n\n  translate(tx: number, ty: number): this\n  translate(p: Point.PointLike | Point.PointData): this\n  translate(tx: number | Point.PointLike | Point.PointData, ty?: number): this {\n    if (typeof tx === 'number') {\n      this.end.translate(tx, ty as number)\n    } else {\n      this.end.translate(tx)\n    }\n    return this\n  }\n\n  equals(s: Segment) {\n    return (\n      this.type === s.type &&\n      this.start.equals(s.start) &&\n      this.end.equals(s.end)\n    )\n  }\n\n  toJSON() {\n    return {\n      type: this.type,\n      start: this.start.toJSON(),\n      end: this.end.toJSON(),\n    }\n  }\n\n  serialize() {\n    const end = this.end\n    return `${this.type} ${end.x} ${end.y}`\n  }\n}\n\nexport namespace LineTo {\n  export function create(line: Line): LineTo\n  export function create(point: Point.PointLike): LineTo\n  export function create(x: number, y: number): LineTo\n  export function create(\n    point: Point.PointLike,\n    ...points: Point.PointLike[]\n  ): LineTo[]\n  export function create(x: number, y: number, ...coords: number[]): LineTo[]\n  export function create(...args: any[]): LineTo | LineTo[] {\n    const len = args.length\n    const arg0 = args[0]\n\n    // line provided\n    if (Line.isLine(arg0)) {\n      return new LineTo(arg0)\n    }\n\n    // points provided\n    if (Point.isPointLike(arg0)) {\n      if (len === 1) {\n        return new LineTo(arg0)\n      }\n\n      // poly-line segment\n      return args.map((arg) => new LineTo(arg as Point.PointLike))\n    }\n\n    // coordinates provided\n    if (len === 2) {\n      return new LineTo(+args[0], +args[1])\n    }\n\n    // poly-line segment\n    const segments: LineTo[] = []\n    for (let i = 0; i < len; i += 2) {\n      const x = +args[i]\n      const y = +args[i + 1]\n      segments.push(new LineTo(x, y))\n    }\n    return segments\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}