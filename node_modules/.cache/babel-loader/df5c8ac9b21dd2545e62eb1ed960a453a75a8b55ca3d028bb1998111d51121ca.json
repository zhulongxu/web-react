{"ast":null,"code":"import { Point, Path, Polyline } from '@antv/x6-geometry';\nimport { NumberExt, FunctionExt, Dom } from '@antv/x6-common';\nexport const ref = {\n  // We do not set `ref` attribute directly on an element.\n  // The attribute itself does not qualify for relative positioning.\n};\n// if `refX` is in [0, 1] then `refX` is a fraction of bounding box width\n// if `refX` is < 0 then `refX`'s absolute values is the right coordinate of the bounding box\n// otherwise, `refX` is the left coordinate of the bounding box\nexport const refX = {\n  position: positionWrapper('x', 'width', 'origin')\n};\nexport const refY = {\n  position: positionWrapper('y', 'height', 'origin')\n};\n// `ref-dx` and `ref-dy` define the offset of the subelement relative to the right and/or bottom\n// coordinate of the reference element.\nexport const refDx = {\n  position: positionWrapper('x', 'width', 'corner')\n};\nexport const refDy = {\n  position: positionWrapper('y', 'height', 'corner')\n};\n// 'ref-width'/'ref-height' defines the width/height of the subelement relatively to\n// the reference element size\n// val in 0..1         ref-width = 0.75 sets the width to 75% of the ref. el. width\n// val < 0 || val > 1  ref-height = -20 sets the height to the ref. el. height shorter by 20\nexport const refWidth = {\n  set: setWrapper('width', 'width')\n};\nexport const refHeight = {\n  set: setWrapper('height', 'height')\n};\nexport const refRx = {\n  set: setWrapper('rx', 'width')\n};\nexport const refRy = {\n  set: setWrapper('ry', 'height')\n};\nexport const refRInscribed = {\n  set: (attrName => {\n    const widthFn = setWrapper(attrName, 'width');\n    const heightFn = setWrapper(attrName, 'height');\n    return function (value, options) {\n      const refBBox = options.refBBox;\n      const fn = refBBox.height > refBBox.width ? widthFn : heightFn;\n      return FunctionExt.call(fn, this, value, options);\n    };\n  })('r')\n};\nexport const refRCircumscribed = {\n  set(val, {\n    refBBox\n  }) {\n    let value = parseFloat(val);\n    const percentage = NumberExt.isPercentage(val);\n    if (percentage) {\n      value /= 100;\n    }\n    const diagonalLength = Math.sqrt(refBBox.height * refBBox.height + refBBox.width * refBBox.width);\n    let rValue;\n    if (Number.isFinite(value)) {\n      if (percentage || value >= 0 && value <= 1) {\n        rValue = value * diagonalLength;\n      } else {\n        rValue = Math.max(value + diagonalLength, 0);\n      }\n    }\n    return {\n      r: rValue\n    };\n  }\n};\nexport const refCx = {\n  set: setWrapper('cx', 'width')\n};\nexport const refCy = {\n  set: setWrapper('cy', 'height')\n};\nexport const refDResetOffset = {\n  set: dWrapper({\n    resetOffset: true\n  })\n};\nexport const refDKeepOffset = {\n  set: dWrapper({\n    resetOffset: false\n  })\n};\nexport const refPointsResetOffset = {\n  set: pointsWrapper({\n    resetOffset: true\n  })\n};\nexport const refPointsKeepOffset = {\n  set: pointsWrapper({\n    resetOffset: false\n  })\n};\n// aliases\n// -------\nexport const refR = refRInscribed;\nexport const refD = refDResetOffset;\nexport const refPoints = refPointsResetOffset;\n// Allows to combine both absolute and relative positioning\n// refX: 50%, refX2: 20\nexport const refX2 = refX;\nexport const refY2 = refY;\nexport const refWidth2 = refWidth;\nexport const refHeight2 = refHeight;\n// utils\n// -----\nfunction positionWrapper(axis, dimension, origin) {\n  return (val, {\n    refBBox\n  }) => {\n    if (val == null) {\n      return null;\n    }\n    let value = parseFloat(val);\n    const percentage = NumberExt.isPercentage(val);\n    if (percentage) {\n      value /= 100;\n    }\n    let delta;\n    if (Number.isFinite(value)) {\n      const refOrigin = refBBox[origin];\n      if (percentage || value > 0 && value < 1) {\n        delta = refOrigin[axis] + refBBox[dimension] * value;\n      } else {\n        delta = refOrigin[axis] + value;\n      }\n    }\n    const point = new Point();\n    point[axis] = delta || 0;\n    return point;\n  };\n}\nfunction setWrapper(attrName, dimension) {\n  return function (val, {\n    refBBox\n  }) {\n    let value = parseFloat(val);\n    const percentage = NumberExt.isPercentage(val);\n    if (percentage) {\n      value /= 100;\n    }\n    const attrs = {};\n    if (Number.isFinite(value)) {\n      const attrValue = percentage || value >= 0 && value <= 1 ? value * refBBox[dimension] : Math.max(value + refBBox[dimension], 0);\n      attrs[attrName] = attrValue;\n    }\n    return attrs;\n  };\n}\nfunction shapeWrapper(shapeConstructor, options) {\n  const cacheName = 'x6-shape';\n  const resetOffset = options && options.resetOffset;\n  return function (value, {\n    elem,\n    refBBox\n  }) {\n    let cache = Dom.data(elem, cacheName);\n    if (!cache || cache.value !== value) {\n      // only recalculate if value has changed\n      const cachedShape = shapeConstructor(value);\n      cache = {\n        value,\n        shape: cachedShape,\n        shapeBBox: cachedShape.bbox()\n      };\n      Dom.data(elem, cacheName, cache);\n    }\n    const shape = cache.shape.clone();\n    const shapeBBox = cache.shapeBBox.clone();\n    const shapeOrigin = shapeBBox.getOrigin();\n    const refOrigin = refBBox.getOrigin();\n    shapeBBox.x = refOrigin.x;\n    shapeBBox.y = refOrigin.y;\n    const fitScale = refBBox.getMaxScaleToFit(shapeBBox, refOrigin);\n    // `maxRectScaleToFit` can give Infinity if width or height is 0\n    const sx = shapeBBox.width === 0 || refBBox.width === 0 ? 1 : fitScale.sx;\n    const sy = shapeBBox.height === 0 || refBBox.height === 0 ? 1 : fitScale.sy;\n    shape.scale(sx, sy, shapeOrigin);\n    if (resetOffset) {\n      shape.translate(-shapeOrigin.x, -shapeOrigin.y);\n    }\n    return shape;\n  };\n}\n// `d` attribute for SVGPaths\nfunction dWrapper(options) {\n  function pathConstructor(value) {\n    return Path.parse(value);\n  }\n  const shape = shapeWrapper(pathConstructor, options);\n  return (value, args) => {\n    const path = shape(value, args);\n    return {\n      d: path.serialize()\n    };\n  };\n}\n// `points` attribute for SVGPolylines and SVGPolygons\nfunction pointsWrapper(options) {\n  const shape = shapeWrapper(points => new Polyline(points), options);\n  return (value, args) => {\n    const polyline = shape(value, args);\n    return {\n      points: polyline.serialize()\n    };\n  };\n}","map":{"version":3,"names":["Point","Path","Polyline","NumberExt","FunctionExt","Dom","ref","refX","position","positionWrapper","refY","refDx","refDy","refWidth","set","setWrapper","refHeight","refRx","refRy","refRInscribed","attrName","widthFn","heightFn","value","options","refBBox","fn","height","width","call","refRCircumscribed","val","parseFloat","percentage","isPercentage","diagonalLength","Math","sqrt","rValue","Number","isFinite","max","r","refCx","refCy","refDResetOffset","dWrapper","resetOffset","refDKeepOffset","refPointsResetOffset","pointsWrapper","refPointsKeepOffset","refR","refD","refPoints","refX2","refY2","refWidth2","refHeight2","axis","dimension","origin","delta","refOrigin","point","attrs","attrValue","shapeWrapper","shapeConstructor","cacheName","elem","cache","data","cachedShape","shape","shapeBBox","bbox","clone","shapeOrigin","getOrigin","x","y","fitScale","getMaxScaleToFit","sx","sy","scale","translate","pathConstructor","parse","args","path","d","serialize","points","polyline"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/src/registry/attr/ref.ts"],"sourcesContent":["import { Point, Path, Polyline, Rectangle } from '@antv/x6-geometry'\nimport { NumberExt, FunctionExt, Dom } from '@antv/x6-common'\nimport { Attr } from './index'\n\nexport const ref: Attr.Definition = {\n  // We do not set `ref` attribute directly on an element.\n  // The attribute itself does not qualify for relative positioning.\n}\n\n// if `refX` is in [0, 1] then `refX` is a fraction of bounding box width\n// if `refX` is < 0 then `refX`'s absolute values is the right coordinate of the bounding box\n// otherwise, `refX` is the left coordinate of the bounding box\n\nexport const refX: Attr.Definition = {\n  position: positionWrapper('x', 'width', 'origin'),\n}\n\nexport const refY: Attr.Definition = {\n  position: positionWrapper('y', 'height', 'origin'),\n}\n\n// `ref-dx` and `ref-dy` define the offset of the subelement relative to the right and/or bottom\n// coordinate of the reference element.\n\nexport const refDx: Attr.Definition = {\n  position: positionWrapper('x', 'width', 'corner'),\n}\n\nexport const refDy: Attr.Definition = {\n  position: positionWrapper('y', 'height', 'corner'),\n}\n\n// 'ref-width'/'ref-height' defines the width/height of the subelement relatively to\n// the reference element size\n// val in 0..1         ref-width = 0.75 sets the width to 75% of the ref. el. width\n// val < 0 || val > 1  ref-height = -20 sets the height to the ref. el. height shorter by 20\nexport const refWidth: Attr.Definition = {\n  set: setWrapper('width', 'width'),\n}\n\nexport const refHeight: Attr.Definition = {\n  set: setWrapper('height', 'height'),\n}\n\nexport const refRx: Attr.Definition = {\n  set: setWrapper('rx', 'width'),\n}\n\nexport const refRy: Attr.Definition = {\n  set: setWrapper('ry', 'height'),\n}\n\nexport const refRInscribed: Attr.Definition = {\n  set: ((attrName): Attr.SetFunction => {\n    const widthFn = setWrapper(attrName, 'width')\n    const heightFn = setWrapper(attrName, 'height')\n    return function (value, options) {\n      const refBBox = options.refBBox\n      const fn = refBBox.height > refBBox.width ? widthFn : heightFn\n      return FunctionExt.call(fn, this, value, options)\n    }\n  })('r'),\n}\n\nexport const refRCircumscribed: Attr.Definition = {\n  set(val, { refBBox }) {\n    let value = parseFloat(val as string)\n    const percentage = NumberExt.isPercentage(val)\n    if (percentage) {\n      value /= 100\n    }\n\n    const diagonalLength = Math.sqrt(\n      refBBox.height * refBBox.height + refBBox.width * refBBox.width,\n    )\n\n    let rValue\n    if (Number.isFinite(value)) {\n      if (percentage || (value >= 0 && value <= 1)) {\n        rValue = value * diagonalLength\n      } else {\n        rValue = Math.max(value + diagonalLength, 0)\n      }\n    }\n\n    return { r: rValue } as Attr.SimpleAttrs\n  },\n}\n\nexport const refCx: Attr.Definition = {\n  set: setWrapper('cx', 'width'),\n}\n\nexport const refCy: Attr.Definition = {\n  set: setWrapper('cy', 'height'),\n}\n\nexport const refDResetOffset: Attr.Definition = {\n  set: dWrapper({ resetOffset: true }),\n}\n\nexport const refDKeepOffset: Attr.Definition = {\n  set: dWrapper({ resetOffset: false }),\n}\n\nexport const refPointsResetOffset: Attr.Definition = {\n  set: pointsWrapper({ resetOffset: true }),\n}\n\nexport const refPointsKeepOffset: Attr.Definition = {\n  set: pointsWrapper({ resetOffset: false }),\n}\n\n// aliases\n// -------\nexport const refR = refRInscribed\nexport const refD = refDResetOffset\nexport const refPoints = refPointsResetOffset\n// Allows to combine both absolute and relative positioning\n// refX: 50%, refX2: 20\nexport const refX2 = refX\nexport const refY2 = refY\nexport const refWidth2 = refWidth\nexport const refHeight2 = refHeight\n\n// utils\n// -----\n\nfunction positionWrapper(\n  axis: 'x' | 'y',\n  dimension: 'width' | 'height',\n  origin: 'origin' | 'corner',\n): Attr.PositionFunction {\n  return (val, { refBBox }) => {\n    if (val == null) {\n      return null\n    }\n\n    let value = parseFloat(val as string)\n    const percentage = NumberExt.isPercentage(val)\n    if (percentage) {\n      value /= 100\n    }\n\n    let delta\n    if (Number.isFinite(value)) {\n      const refOrigin = refBBox[origin]\n      if (percentage || (value > 0 && value < 1)) {\n        delta = refOrigin[axis] + refBBox[dimension] * value\n      } else {\n        delta = refOrigin[axis] + value\n      }\n    }\n\n    const point = new Point()\n    point[axis] = delta || 0\n    return point\n  }\n}\n\nfunction setWrapper(\n  attrName: string,\n  dimension: 'width' | 'height',\n): Attr.SetFunction {\n  return function (val, { refBBox }) {\n    let value = parseFloat(val as string)\n    const percentage = NumberExt.isPercentage(val)\n    if (percentage) {\n      value /= 100\n    }\n\n    const attrs: Attr.SimpleAttrs = {}\n\n    if (Number.isFinite(value)) {\n      const attrValue =\n        percentage || (value >= 0 && value <= 1)\n          ? value * refBBox[dimension]\n          : Math.max(value + refBBox[dimension], 0)\n      attrs[attrName] = attrValue\n    }\n\n    return attrs\n  }\n}\n\nfunction shapeWrapper(\n  shapeConstructor: (value: Attr.ComplexAttrValue) => any,\n  options: { resetOffset: boolean },\n): <T>(value: Attr.ComplexAttrValue, options: Attr.Options) => T {\n  const cacheName = 'x6-shape'\n  const resetOffset = options && options.resetOffset\n\n  return function (value, { elem, refBBox }) {\n    let cache = Dom.data(elem, cacheName)\n    if (!cache || cache.value !== value) {\n      // only recalculate if value has changed\n      const cachedShape = shapeConstructor(value)\n      cache = {\n        value,\n        shape: cachedShape,\n        shapeBBox: cachedShape.bbox(),\n      }\n      Dom.data(elem, cacheName, cache)\n    }\n\n    const shape = cache.shape.clone()\n    const shapeBBox = cache.shapeBBox.clone() as Rectangle\n    const shapeOrigin = shapeBBox.getOrigin()\n    const refOrigin = refBBox.getOrigin()\n\n    shapeBBox.x = refOrigin.x\n    shapeBBox.y = refOrigin.y\n\n    const fitScale = refBBox.getMaxScaleToFit(shapeBBox, refOrigin)\n    // `maxRectScaleToFit` can give Infinity if width or height is 0\n    const sx = shapeBBox.width === 0 || refBBox.width === 0 ? 1 : fitScale.sx\n    const sy = shapeBBox.height === 0 || refBBox.height === 0 ? 1 : fitScale.sy\n\n    shape.scale(sx, sy, shapeOrigin)\n    if (resetOffset) {\n      shape.translate(-shapeOrigin.x, -shapeOrigin.y)\n    }\n\n    return shape\n  }\n}\n\n// `d` attribute for SVGPaths\nfunction dWrapper(options: { resetOffset: boolean }): Attr.SetFunction {\n  function pathConstructor(value: string) {\n    return Path.parse(value)\n  }\n\n  const shape = shapeWrapper(pathConstructor, options)\n\n  return (value, args) => {\n    const path = shape<Path>(value, args)\n    return {\n      d: path.serialize(),\n    }\n  }\n}\n\n// `points` attribute for SVGPolylines and SVGPolygons\nfunction pointsWrapper(options: { resetOffset: boolean }): Attr.SetFunction {\n  const shape = shapeWrapper((points) => new Polyline(points as any), options)\n  return (value, args) => {\n    const polyline = shape<Polyline>(value, args)\n    return {\n      points: polyline.serialize(),\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}