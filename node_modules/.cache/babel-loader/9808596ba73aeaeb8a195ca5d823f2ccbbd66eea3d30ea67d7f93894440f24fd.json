{"ast":null,"code":"import { ObjectExt, Dom, Vector } from '@antv/x6-common';\nimport { Config } from '../../config';\nimport { Util } from '../../util';\nconst defaultOptions = {\n  padding: 3,\n  rx: 0,\n  ry: 0,\n  attrs: {\n    'stroke-width': 3,\n    stroke: '#FEB663'\n  }\n};\nexport const stroke = {\n  highlight(cellView, magnet, options) {\n    const id = Private.getHighlighterId(magnet, options);\n    if (Private.hasCache(id)) {\n      return;\n    }\n    // eslint-disable-next-line\n    options = ObjectExt.defaultsDeep({}, options, defaultOptions);\n    const magnetVel = Vector.create(magnet);\n    let pathData;\n    let magnetBBox;\n    try {\n      pathData = magnetVel.toPathData();\n    } catch (error) {\n      // Failed to get path data from magnet element.\n      // Draw a rectangle around the entire cell view instead.\n      magnetBBox = Util.bbox(magnetVel.node, true);\n      pathData = Dom.rectToPathData(Object.assign(Object.assign({}, options), magnetBBox));\n    }\n    const path = Dom.createSvgElement('path');\n    Dom.attr(path, Object.assign({\n      d: pathData,\n      'pointer-events': 'none',\n      'vector-effect': 'non-scaling-stroke',\n      fill: 'none'\n    }, options.attrs ? Dom.kebablizeAttrs(options.attrs) : null));\n    // const highlightVel = v.create('path').attr()\n    if (cellView.isEdgeElement(magnet)) {\n      Dom.attr(path, 'd', cellView.getConnectionPathData());\n    } else {\n      let highlightMatrix = magnetVel.getTransformToElement(cellView.container);\n      // Add padding to the highlight element.\n      const padding = options.padding;\n      if (padding) {\n        if (magnetBBox == null) {\n          magnetBBox = Util.bbox(magnetVel.node, true);\n        }\n        const cx = magnetBBox.x + magnetBBox.width / 2;\n        const cy = magnetBBox.y + magnetBBox.height / 2;\n        magnetBBox = Util.transformRectangle(magnetBBox, highlightMatrix);\n        const width = Math.max(magnetBBox.width, 1);\n        const height = Math.max(magnetBBox.height, 1);\n        const sx = (width + padding) / width;\n        const sy = (height + padding) / height;\n        const paddingMatrix = Dom.createSVGMatrix({\n          a: sx,\n          b: 0,\n          c: 0,\n          d: sy,\n          e: cx - sx * cx,\n          f: cy - sy * cy\n        });\n        highlightMatrix = highlightMatrix.multiply(paddingMatrix);\n      }\n      Dom.transform(path, highlightMatrix);\n    }\n    Dom.addClass(path, Config.prefix('highlight-stroke'));\n    const cell = cellView.cell;\n    const removeHandler = () => Private.removeHighlighter(id);\n    cell.on('removed', removeHandler);\n    if (cell.model) {\n      cell.model.on('reseted', removeHandler);\n    }\n    cellView.container.appendChild(path);\n    Private.setCache(id, path);\n  },\n  unhighlight(cellView, magnet, opt) {\n    Private.removeHighlighter(Private.getHighlighterId(magnet, opt));\n  }\n};\nvar Private;\n(function (Private) {\n  function getHighlighterId(magnet, options) {\n    Dom.ensureId(magnet);\n    return magnet.id + JSON.stringify(options);\n  }\n  Private.getHighlighterId = getHighlighterId;\n  const cache = {};\n  function setCache(id, elem) {\n    cache[id] = elem;\n  }\n  Private.setCache = setCache;\n  function hasCache(id) {\n    return cache[id] != null;\n  }\n  Private.hasCache = hasCache;\n  function removeHighlighter(id) {\n    const elem = cache[id];\n    if (elem) {\n      Dom.remove(elem);\n      delete cache[id];\n    }\n  }\n  Private.removeHighlighter = removeHighlighter;\n})(Private || (Private = {}));","map":{"version":3,"names":["ObjectExt","Dom","Vector","Config","Util","defaultOptions","padding","rx","ry","attrs","stroke","highlight","cellView","magnet","options","id","Private","getHighlighterId","hasCache","defaultsDeep","magnetVel","create","pathData","magnetBBox","toPathData","error","bbox","node","rectToPathData","Object","assign","path","createSvgElement","attr","d","fill","kebablizeAttrs","isEdgeElement","getConnectionPathData","highlightMatrix","getTransformToElement","container","cx","x","width","cy","y","height","transformRectangle","Math","max","sx","sy","paddingMatrix","createSVGMatrix","a","b","c","e","f","multiply","transform","addClass","prefix","cell","removeHandler","removeHighlighter","on","model","appendChild","setCache","unhighlight","opt","ensureId","JSON","stringify","cache","elem","remove"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/src/registry/highlighter/stroke.ts"],"sourcesContent":["import { ObjectExt, Dom, Vector } from '@antv/x6-common'\nimport { Attr } from '../attr'\nimport { Config } from '../../config'\nimport { EdgeView } from '../../view'\nimport { Highlighter } from './index'\nimport { Util } from '../../util'\n\nexport interface StrokeHighlighterOptions {\n  padding?: number\n  rx?: number\n  ry?: number\n  attrs?: Attr.SimpleAttrs\n}\n\nconst defaultOptions: StrokeHighlighterOptions = {\n  padding: 3,\n  rx: 0,\n  ry: 0,\n  attrs: {\n    'stroke-width': 3,\n    stroke: '#FEB663',\n  },\n}\n\nexport const stroke: Highlighter.Definition<StrokeHighlighterOptions> = {\n  highlight(cellView, magnet, options) {\n    const id = Private.getHighlighterId(magnet, options)\n    if (Private.hasCache(id)) {\n      return\n    }\n\n    // eslint-disable-next-line\n    options = ObjectExt.defaultsDeep({}, options, defaultOptions)\n\n    const magnetVel = Vector.create(magnet as SVGElement)\n    let pathData\n    let magnetBBox\n\n    try {\n      pathData = magnetVel.toPathData()\n    } catch (error) {\n      // Failed to get path data from magnet element.\n      // Draw a rectangle around the entire cell view instead.\n      magnetBBox = Util.bbox(magnetVel.node, true)\n      pathData = Dom.rectToPathData({ ...options, ...magnetBBox })\n    }\n\n    const path = Dom.createSvgElement('path')\n    Dom.attr(path, {\n      d: pathData,\n      'pointer-events': 'none',\n      'vector-effect': 'non-scaling-stroke',\n      fill: 'none',\n      ...(options.attrs ? Dom.kebablizeAttrs(options.attrs) : null),\n    })\n\n    // const highlightVel = v.create('path').attr()\n\n    if (cellView.isEdgeElement(magnet)) {\n      Dom.attr(path, 'd', (cellView as EdgeView).getConnectionPathData())\n    } else {\n      let highlightMatrix = magnetVel.getTransformToElement(\n        cellView.container as SVGElement,\n      )\n\n      // Add padding to the highlight element.\n      const padding = options.padding\n      if (padding) {\n        if (magnetBBox == null) {\n          magnetBBox = Util.bbox(magnetVel.node, true)\n        }\n\n        const cx = magnetBBox.x + magnetBBox.width / 2\n        const cy = magnetBBox.y + magnetBBox.height / 2\n\n        magnetBBox = Util.transformRectangle(magnetBBox, highlightMatrix)\n\n        const width = Math.max(magnetBBox.width, 1)\n        const height = Math.max(magnetBBox.height, 1)\n        const sx = (width + padding) / width\n        const sy = (height + padding) / height\n\n        const paddingMatrix = Dom.createSVGMatrix({\n          a: sx,\n          b: 0,\n          c: 0,\n          d: sy,\n          e: cx - sx * cx,\n          f: cy - sy * cy,\n        })\n\n        highlightMatrix = highlightMatrix.multiply(paddingMatrix)\n      }\n\n      Dom.transform(path, highlightMatrix)\n    }\n\n    Dom.addClass(path, Config.prefix('highlight-stroke'))\n\n    const cell = cellView.cell\n    const removeHandler = () => Private.removeHighlighter(id)\n\n    cell.on('removed', removeHandler)\n    if (cell.model) {\n      cell.model.on('reseted', removeHandler)\n    }\n\n    cellView.container.appendChild(path)\n    Private.setCache(id, path)\n  },\n\n  unhighlight(cellView, magnet, opt) {\n    Private.removeHighlighter(Private.getHighlighterId(magnet, opt))\n  },\n}\n\nnamespace Private {\n  export function getHighlighterId(\n    magnet: Element,\n    options: StrokeHighlighterOptions,\n  ) {\n    Dom.ensureId(magnet)\n    return magnet.id + JSON.stringify(options)\n  }\n\n  const cache: { [id: string]: Element } = {}\n\n  export function setCache(id: string, elem: Element) {\n    cache[id] = elem\n  }\n\n  export function hasCache(id: string) {\n    return cache[id] != null\n  }\n\n  export function removeHighlighter(id: string) {\n    const elem = cache[id]\n    if (elem) {\n      Dom.remove(elem)\n      delete cache[id]\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}