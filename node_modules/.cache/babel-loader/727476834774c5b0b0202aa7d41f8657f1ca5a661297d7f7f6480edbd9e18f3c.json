{"ast":null,"code":"import { Dom, ObjectExt, FunctionExt } from '@antv/x6-common';\nimport { Point, Line } from '@antv/x6-geometry';\nimport { View } from '../../view/view';\nimport { ToolsView } from '../../view/tool';\nimport * as Util from './util';\nexport class Segments extends ToolsView.ToolItem {\n  constructor() {\n    super(...arguments);\n    this.handles = [];\n  }\n  get vertices() {\n    return this.cellView.cell.getVertices();\n  }\n  update() {\n    this.render();\n    return this;\n  }\n  onRender() {\n    Dom.addClass(this.container, this.prefixClassName('edge-tool-segments'));\n    this.resetHandles();\n    const edgeView = this.cellView;\n    const vertices = [...this.vertices];\n    vertices.unshift(edgeView.sourcePoint);\n    vertices.push(edgeView.targetPoint);\n    for (let i = 0, l = vertices.length; i < l - 1; i += 1) {\n      const vertex = vertices[i];\n      const nextVertex = vertices[i + 1];\n      const handle = this.renderHandle(vertex, nextVertex, i);\n      this.stamp(handle.container);\n      this.handles.push(handle);\n    }\n    return this;\n  }\n  renderHandle(vertex, nextVertex, index) {\n    const handle = this.options.createHandle({\n      index,\n      graph: this.graph,\n      guard: evt => this.guard(evt),\n      attrs: this.options.attrs || {}\n    });\n    if (this.options.processHandle) {\n      this.options.processHandle(handle);\n    }\n    this.updateHandle(handle, vertex, nextVertex);\n    this.container.appendChild(handle.container);\n    this.startHandleListening(handle);\n    return handle;\n  }\n  startHandleListening(handle) {\n    handle.on('change', this.onHandleChange, this);\n    handle.on('changing', this.onHandleChanging, this);\n    handle.on('changed', this.onHandleChanged, this);\n  }\n  stopHandleListening(handle) {\n    handle.off('change', this.onHandleChange, this);\n    handle.off('changing', this.onHandleChanging, this);\n    handle.off('changed', this.onHandleChanged, this);\n  }\n  resetHandles() {\n    const handles = this.handles;\n    this.handles = [];\n    if (handles) {\n      handles.forEach(handle => {\n        this.stopHandleListening(handle);\n        handle.remove();\n      });\n    }\n  }\n  shiftHandleIndexes(delta) {\n    const handles = this.handles;\n    for (let i = 0, n = handles.length; i < n; i += 1) {\n      handles[i].options.index += delta;\n    }\n  }\n  resetAnchor(type, anchor) {\n    const edge = this.cellView.cell;\n    const options = {\n      ui: true,\n      toolId: this.cid\n    };\n    if (anchor) {\n      edge.prop([type, 'anchor'], anchor, options);\n    } else {\n      edge.removeProp([type, 'anchor'], options);\n    }\n  }\n  snapHandle(handle, position, data) {\n    const axis = handle.options.axis;\n    const index = handle.options.index;\n    const edgeView = this.cellView;\n    const edge = edgeView.cell;\n    const vertices = edge.getVertices();\n    const prev = vertices[index - 2] || data.sourceAnchor;\n    const next = vertices[index + 1] || data.targetAnchor;\n    const snapRadius = this.options.snapRadius;\n    if (Math.abs(position[axis] - prev[axis]) < snapRadius) {\n      position[axis] = prev[axis];\n    } else if (Math.abs(position[axis] - next[axis]) < snapRadius) {\n      position[axis] = next[axis];\n    }\n    return position;\n  }\n  onHandleChanging({\n    handle,\n    e\n  }) {\n    const graph = this.graph;\n    const options = this.options;\n    const edgeView = this.cellView;\n    const anchorFn = options.anchor;\n    const axis = handle.options.axis;\n    const index = handle.options.index - 1;\n    const data = this.getEventData(e);\n    const evt = this.normalizeEvent(e);\n    const coords = graph.snapToGrid(evt.clientX, evt.clientY);\n    const position = this.snapHandle(handle, coords.clone(), data);\n    const vertices = ObjectExt.cloneDeep(this.vertices);\n    let vertex = vertices[index];\n    let nextVertex = vertices[index + 1];\n    // First Segment\n    const sourceView = edgeView.sourceView;\n    const sourceBBox = edgeView.sourceBBox;\n    let changeSourceAnchor = false;\n    let deleteSourceAnchor = false;\n    if (!vertex) {\n      vertex = edgeView.sourceAnchor.toJSON();\n      vertex[axis] = position[axis];\n      if (sourceBBox.containsPoint(vertex)) {\n        changeSourceAnchor = true;\n      } else {\n        vertices.unshift(vertex);\n        this.shiftHandleIndexes(1);\n        deleteSourceAnchor = true;\n      }\n    } else if (index === 0) {\n      if (sourceBBox.containsPoint(vertex)) {\n        vertices.shift();\n        this.shiftHandleIndexes(-1);\n        changeSourceAnchor = true;\n      } else {\n        vertex[axis] = position[axis];\n        deleteSourceAnchor = true;\n      }\n    } else {\n      vertex[axis] = position[axis];\n    }\n    if (typeof anchorFn === 'function' && sourceView) {\n      if (changeSourceAnchor) {\n        const sourceAnchorPosition = data.sourceAnchor.clone();\n        sourceAnchorPosition[axis] = position[axis];\n        const sourceAnchor = FunctionExt.call(anchorFn, edgeView, sourceAnchorPosition, sourceView, edgeView.sourceMagnet || sourceView.container, 'source', edgeView, this);\n        this.resetAnchor('source', sourceAnchor);\n      }\n      if (deleteSourceAnchor) {\n        this.resetAnchor('source', data.sourceAnchorDef);\n      }\n    }\n    // Last segment\n    const targetView = edgeView.targetView;\n    const targetBBox = edgeView.targetBBox;\n    let changeTargetAnchor = false;\n    let deleteTargetAnchor = false;\n    if (!nextVertex) {\n      nextVertex = edgeView.targetAnchor.toJSON();\n      nextVertex[axis] = position[axis];\n      if (targetBBox.containsPoint(nextVertex)) {\n        changeTargetAnchor = true;\n      } else {\n        vertices.push(nextVertex);\n        deleteTargetAnchor = true;\n      }\n    } else if (index === vertices.length - 2) {\n      if (targetBBox.containsPoint(nextVertex)) {\n        vertices.pop();\n        changeTargetAnchor = true;\n      } else {\n        nextVertex[axis] = position[axis];\n        deleteTargetAnchor = true;\n      }\n    } else {\n      nextVertex[axis] = position[axis];\n    }\n    if (typeof anchorFn === 'function' && targetView) {\n      if (changeTargetAnchor) {\n        const targetAnchorPosition = data.targetAnchor.clone();\n        targetAnchorPosition[axis] = position[axis];\n        const targetAnchor = FunctionExt.call(anchorFn, edgeView, targetAnchorPosition, targetView, edgeView.targetMagnet || targetView.container, 'target', edgeView, this);\n        this.resetAnchor('target', targetAnchor);\n      }\n      if (deleteTargetAnchor) {\n        this.resetAnchor('target', data.targetAnchorDef);\n      }\n    }\n    if (!Point.equalPoints(vertices, this.vertices)) {\n      this.cellView.cell.setVertices(vertices, {\n        ui: true,\n        toolId: this.cid\n      });\n    }\n    this.updateHandle(handle, vertex, nextVertex, 0);\n    if (!options.stopPropagation) {\n      edgeView.notifyMouseMove(evt, coords.x, coords.y);\n    }\n  }\n  onHandleChange({\n    handle,\n    e\n  }) {\n    const options = this.options;\n    const handles = this.handles;\n    const edgeView = this.cellView;\n    const index = handle.options.index;\n    if (!Array.isArray(handles)) {\n      return;\n    }\n    for (let i = 0, n = handles.length; i < n; i += 1) {\n      if (i !== index) {\n        handles[i].hide();\n      }\n    }\n    this.focus();\n    this.setEventData(e, {\n      sourceAnchor: edgeView.sourceAnchor.clone(),\n      targetAnchor: edgeView.targetAnchor.clone(),\n      sourceAnchorDef: ObjectExt.cloneDeep(this.cell.prop(['source', 'anchor'])),\n      targetAnchorDef: ObjectExt.cloneDeep(this.cell.prop(['target', 'anchor']))\n    });\n    this.cell.startBatch('move-segment', {\n      ui: true,\n      toolId: this.cid\n    });\n    if (!options.stopPropagation) {\n      const normalizedEvent = this.normalizeEvent(e);\n      const coords = this.graph.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n      edgeView.notifyMouseDown(normalizedEvent, coords.x, coords.y);\n    }\n  }\n  onHandleChanged({\n    e\n  }) {\n    const options = this.options;\n    const edgeView = this.cellView;\n    if (options.removeRedundancies) {\n      edgeView.removeRedundantLinearVertices({\n        ui: true,\n        toolId: this.cid\n      });\n    }\n    const normalizedEvent = this.normalizeEvent(e);\n    const coords = this.graph.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n    this.render();\n    this.blur();\n    this.cell.stopBatch('move-segment', {\n      ui: true,\n      toolId: this.cid\n    });\n    if (!options.stopPropagation) {\n      edgeView.notifyMouseUp(normalizedEvent, coords.x, coords.y);\n    }\n    edgeView.checkMouseleave(normalizedEvent);\n    options.onChanged && options.onChanged({\n      edge: edgeView.cell,\n      edgeView\n    });\n  }\n  updateHandle(handle, vertex, nextVertex, offset = 0) {\n    const precision = this.options.precision || 0;\n    const vertical = Math.abs(vertex.x - nextVertex.x) < precision;\n    const horizontal = Math.abs(vertex.y - nextVertex.y) < precision;\n    if (vertical || horizontal) {\n      const segmentLine = new Line(vertex, nextVertex);\n      const length = segmentLine.length();\n      if (length < this.options.threshold) {\n        handle.hide();\n      } else {\n        const position = segmentLine.getCenter();\n        const axis = vertical ? 'x' : 'y';\n        position[axis] += offset || 0;\n        const angle = segmentLine.vector().vectorAngle(new Point(1, 0));\n        handle.updatePosition(position.x, position.y, angle, this.cellView);\n        handle.show();\n        handle.options.axis = axis;\n      }\n    } else {\n      handle.hide();\n    }\n  }\n  onRemove() {\n    this.resetHandles();\n  }\n}\n(function (Segments) {\n  class Handle extends View {\n    constructor(options) {\n      super();\n      this.options = options;\n      this.render();\n      this.delegateEvents({\n        mousedown: 'onMouseDown',\n        touchstart: 'onMouseDown'\n      });\n    }\n    render() {\n      this.container = View.createElement('rect', true);\n      const attrs = this.options.attrs;\n      if (typeof attrs === 'function') {\n        const defaults = Segments.getDefaults();\n        this.setAttrs(Object.assign(Object.assign({}, defaults.attrs), attrs(this)));\n      } else {\n        this.setAttrs(attrs);\n      }\n      this.addClass(this.prefixClassName('edge-tool-segment'));\n    }\n    updatePosition(x, y, angle, view) {\n      const p = view.getClosestPoint(new Point(x, y)) || new Point(x, y);\n      let matrix = Dom.createSVGMatrix().translate(p.x, p.y);\n      if (!p.equals({\n        x,\n        y\n      })) {\n        const line = new Line(x, y, p.x, p.y);\n        let deg = line.vector().vectorAngle(new Point(1, 0));\n        if (deg !== 0) {\n          deg += 90;\n        }\n        matrix = matrix.rotate(deg);\n      } else {\n        matrix = matrix.rotate(angle);\n      }\n      this.setAttrs({\n        transform: Dom.matrixToTransformString(matrix),\n        cursor: angle % 180 === 0 ? 'row-resize' : 'col-resize'\n      });\n    }\n    onMouseDown(evt) {\n      if (this.options.guard(evt)) {\n        return;\n      }\n      this.trigger('change', {\n        e: evt,\n        handle: this\n      });\n      evt.stopPropagation();\n      evt.preventDefault();\n      this.options.graph.view.undelegateEvents();\n      this.delegateDocumentEvents({\n        mousemove: 'onMouseMove',\n        touchmove: 'onMouseMove',\n        mouseup: 'onMouseUp',\n        touchend: 'onMouseUp',\n        touchcancel: 'onMouseUp'\n      }, evt.data);\n    }\n    onMouseMove(evt) {\n      this.emit('changing', {\n        e: evt,\n        handle: this\n      });\n    }\n    onMouseUp(evt) {\n      this.emit('changed', {\n        e: evt,\n        handle: this\n      });\n      this.undelegateDocumentEvents();\n      this.options.graph.view.delegateEvents();\n    }\n    show() {\n      this.container.style.display = '';\n    }\n    hide() {\n      this.container.style.display = 'none';\n    }\n  }\n  Segments.Handle = Handle;\n})(Segments || (Segments = {}));\n(function (Segments) {\n  Segments.config({\n    name: 'segments',\n    precision: 0.5,\n    threshold: 40,\n    snapRadius: 10,\n    stopPropagation: true,\n    removeRedundancies: true,\n    attrs: {\n      width: 20,\n      height: 8,\n      x: -10,\n      y: -4,\n      rx: 4,\n      ry: 4,\n      fill: '#333',\n      stroke: '#fff',\n      'stroke-width': 2\n    },\n    createHandle: options => new Segments.Handle(options),\n    anchor: Util.getAnchor\n  });\n})(Segments || (Segments = {}));","map":{"version":3,"names":["Dom","ObjectExt","FunctionExt","Point","Line","View","ToolsView","Util","Segments","ToolItem","constructor","handles","vertices","cellView","cell","getVertices","update","render","onRender","addClass","container","prefixClassName","resetHandles","edgeView","unshift","sourcePoint","push","targetPoint","i","l","length","vertex","nextVertex","handle","renderHandle","stamp","index","options","createHandle","graph","guard","evt","attrs","processHandle","updateHandle","appendChild","startHandleListening","on","onHandleChange","onHandleChanging","onHandleChanged","stopHandleListening","off","forEach","remove","shiftHandleIndexes","delta","n","resetAnchor","type","anchor","edge","ui","toolId","cid","prop","removeProp","snapHandle","position","data","axis","prev","sourceAnchor","next","targetAnchor","snapRadius","Math","abs","e","anchorFn","getEventData","normalizeEvent","coords","snapToGrid","clientX","clientY","clone","cloneDeep","sourceView","sourceBBox","changeSourceAnchor","deleteSourceAnchor","toJSON","containsPoint","shift","sourceAnchorPosition","call","sourceMagnet","sourceAnchorDef","targetView","targetBBox","changeTargetAnchor","deleteTargetAnchor","pop","targetAnchorPosition","targetMagnet","targetAnchorDef","equalPoints","setVertices","stopPropagation","notifyMouseMove","x","y","Array","isArray","hide","focus","setEventData","startBatch","normalizedEvent","notifyMouseDown","removeRedundancies","removeRedundantLinearVertices","blur","stopBatch","notifyMouseUp","checkMouseleave","onChanged","offset","precision","vertical","horizontal","segmentLine","threshold","getCenter","angle","vector","vectorAngle","updatePosition","show","onRemove","Handle","delegateEvents","mousedown","touchstart","createElement","defaults","getDefaults","setAttrs","Object","assign","view","p","getClosestPoint","matrix","createSVGMatrix","translate","equals","line","deg","rotate","transform","matrixToTransformString","cursor","onMouseDown","trigger","preventDefault","undelegateEvents","delegateDocumentEvents","mousemove","touchmove","mouseup","touchend","touchcancel","onMouseMove","emit","onMouseUp","undelegateDocumentEvents","style","display","config","name","width","height","rx","ry","fill","stroke","getAnchor"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/src/registry/tool/segments.ts"],"sourcesContent":["import { Dom, ObjectExt, FunctionExt } from '@antv/x6-common'\nimport { Point, Line } from '@antv/x6-geometry'\nimport { View } from '../../view/view'\nimport { ToolsView } from '../../view/tool'\nimport * as Util from './util'\nimport { Attr } from '../attr'\nimport { CellView } from '../../view/cell'\nimport { EdgeView } from '../../view/edge'\nimport { Edge } from '../../model/edge'\nimport { Graph } from '../../graph'\n\nexport class Segments extends ToolsView.ToolItem<EdgeView, Segments.Options> {\n  protected handles: Segments.Handle[] = []\n\n  protected get vertices() {\n    return this.cellView.cell.getVertices()\n  }\n\n  update() {\n    this.render()\n    return this\n  }\n\n  protected onRender() {\n    Dom.addClass(this.container, this.prefixClassName('edge-tool-segments'))\n    this.resetHandles()\n    const edgeView = this.cellView\n    const vertices = [...this.vertices]\n    vertices.unshift(edgeView.sourcePoint)\n    vertices.push(edgeView.targetPoint)\n\n    for (let i = 0, l = vertices.length; i < l - 1; i += 1) {\n      const vertex = vertices[i]\n      const nextVertex = vertices[i + 1]\n      const handle = this.renderHandle(vertex, nextVertex, i)\n      this.stamp(handle.container)\n      this.handles.push(handle)\n    }\n    return this\n  }\n\n  protected renderHandle(\n    vertex: Point.PointLike,\n    nextVertex: Point.PointLike,\n    index: number,\n  ) {\n    const handle = this.options.createHandle!({\n      index,\n      graph: this.graph,\n      guard: (evt) => this.guard(evt),\n      attrs: this.options.attrs || {},\n    })\n\n    if (this.options.processHandle) {\n      this.options.processHandle(handle)\n    }\n\n    this.updateHandle(handle, vertex, nextVertex)\n    this.container.appendChild(handle.container)\n    this.startHandleListening(handle)\n    return handle\n  }\n\n  protected startHandleListening(handle: Segments.Handle) {\n    handle.on('change', this.onHandleChange, this)\n    handle.on('changing', this.onHandleChanging, this)\n    handle.on('changed', this.onHandleChanged, this)\n  }\n\n  protected stopHandleListening(handle: Segments.Handle) {\n    handle.off('change', this.onHandleChange, this)\n    handle.off('changing', this.onHandleChanging, this)\n    handle.off('changed', this.onHandleChanged, this)\n  }\n\n  protected resetHandles() {\n    const handles = this.handles\n    this.handles = []\n    if (handles) {\n      handles.forEach((handle) => {\n        this.stopHandleListening(handle)\n        handle.remove()\n      })\n    }\n  }\n\n  protected shiftHandleIndexes(delta: number) {\n    const handles = this.handles\n    for (let i = 0, n = handles.length; i < n; i += 1) {\n      handles[i].options.index! += delta\n    }\n  }\n\n  protected resetAnchor(\n    type: Edge.TerminalType,\n    anchor: Edge.TerminalCellData['anchor'],\n  ) {\n    const edge = this.cellView.cell\n    const options = {\n      ui: true,\n      toolId: this.cid,\n    }\n\n    if (anchor) {\n      edge.prop([type, 'anchor'], anchor, options)\n    } else {\n      edge.removeProp([type, 'anchor'], options)\n    }\n  }\n\n  protected snapHandle(\n    handle: Segments.Handle,\n    position: Point.PointLike,\n    data: Segments.EventData,\n  ) {\n    const axis = handle.options.axis!\n    const index = handle.options.index!\n    const edgeView = this.cellView\n    const edge = edgeView.cell\n    const vertices = edge.getVertices()\n    const prev = vertices[index - 2] || data.sourceAnchor\n    const next = vertices[index + 1] || data.targetAnchor\n    const snapRadius = this.options.snapRadius\n    if (Math.abs(position[axis] - prev[axis]) < snapRadius) {\n      position[axis] = prev[axis]\n    } else if (Math.abs(position[axis] - next[axis]) < snapRadius) {\n      position[axis] = next[axis]\n    }\n    return position\n  }\n\n  protected onHandleChanging({\n    handle,\n    e,\n  }: Segments.Handle.EventArgs['changing']) {\n    const graph = this.graph\n    const options = this.options\n    const edgeView = this.cellView\n    const anchorFn = options.anchor\n\n    const axis = handle.options.axis!\n    const index = handle.options.index! - 1\n\n    const data = this.getEventData<Segments.EventData>(e)\n    const evt = this.normalizeEvent(e)\n    const coords = graph.snapToGrid(evt.clientX, evt.clientY)\n    const position = this.snapHandle(handle, coords.clone(), data)\n    const vertices = ObjectExt.cloneDeep(this.vertices)\n    let vertex = vertices[index]\n    let nextVertex = vertices[index + 1]\n\n    // First Segment\n    const sourceView = edgeView.sourceView\n    const sourceBBox = edgeView.sourceBBox\n    let changeSourceAnchor = false\n    let deleteSourceAnchor = false\n\n    if (!vertex) {\n      vertex = edgeView.sourceAnchor.toJSON()\n      vertex[axis] = position[axis]\n      if (sourceBBox.containsPoint(vertex)) {\n        changeSourceAnchor = true\n      } else {\n        vertices.unshift(vertex)\n        this.shiftHandleIndexes(1)\n        deleteSourceAnchor = true\n      }\n    } else if (index === 0) {\n      if (sourceBBox.containsPoint(vertex)) {\n        vertices.shift()\n        this.shiftHandleIndexes(-1)\n        changeSourceAnchor = true\n      } else {\n        vertex[axis] = position[axis]\n        deleteSourceAnchor = true\n      }\n    } else {\n      vertex[axis] = position[axis]\n    }\n\n    if (typeof anchorFn === 'function' && sourceView) {\n      if (changeSourceAnchor) {\n        const sourceAnchorPosition = data.sourceAnchor.clone()\n        sourceAnchorPosition[axis] = position[axis]\n        const sourceAnchor = FunctionExt.call(\n          anchorFn,\n          edgeView,\n          sourceAnchorPosition,\n          sourceView,\n          edgeView.sourceMagnet || sourceView.container,\n          'source',\n          edgeView,\n          this,\n        )\n        this.resetAnchor('source', sourceAnchor)\n      }\n\n      if (deleteSourceAnchor) {\n        this.resetAnchor('source', data.sourceAnchorDef)\n      }\n    }\n\n    // Last segment\n    const targetView = edgeView.targetView\n    const targetBBox = edgeView.targetBBox\n    let changeTargetAnchor = false\n    let deleteTargetAnchor = false\n    if (!nextVertex) {\n      nextVertex = edgeView.targetAnchor.toJSON()\n      nextVertex[axis] = position[axis]\n      if (targetBBox.containsPoint(nextVertex)) {\n        changeTargetAnchor = true\n      } else {\n        vertices.push(nextVertex)\n        deleteTargetAnchor = true\n      }\n    } else if (index === vertices.length - 2) {\n      if (targetBBox.containsPoint(nextVertex)) {\n        vertices.pop()\n        changeTargetAnchor = true\n      } else {\n        nextVertex[axis] = position[axis]\n        deleteTargetAnchor = true\n      }\n    } else {\n      nextVertex[axis] = position[axis]\n    }\n\n    if (typeof anchorFn === 'function' && targetView) {\n      if (changeTargetAnchor) {\n        const targetAnchorPosition = data.targetAnchor.clone()\n        targetAnchorPosition[axis] = position[axis]\n        const targetAnchor = FunctionExt.call(\n          anchorFn,\n          edgeView,\n          targetAnchorPosition,\n          targetView,\n          edgeView.targetMagnet || targetView.container,\n          'target',\n          edgeView,\n          this,\n        )\n        this.resetAnchor('target', targetAnchor)\n      }\n      if (deleteTargetAnchor) {\n        this.resetAnchor('target', data.targetAnchorDef)\n      }\n    }\n\n    if (!Point.equalPoints(vertices, this.vertices)) {\n      this.cellView.cell.setVertices(vertices, { ui: true, toolId: this.cid })\n    }\n\n    this.updateHandle(handle, vertex, nextVertex, 0)\n    if (!options.stopPropagation) {\n      edgeView.notifyMouseMove(evt, coords.x, coords.y)\n    }\n  }\n\n  protected onHandleChange({ handle, e }: Segments.Handle.EventArgs['change']) {\n    const options = this.options\n    const handles = this.handles\n    const edgeView = this.cellView\n\n    const index = handle.options.index\n    if (!Array.isArray(handles)) {\n      return\n    }\n\n    for (let i = 0, n = handles.length; i < n; i += 1) {\n      if (i !== index) {\n        handles[i].hide()\n      }\n    }\n\n    this.focus()\n    this.setEventData<Segments.EventData>(e, {\n      sourceAnchor: edgeView.sourceAnchor.clone(),\n      targetAnchor: edgeView.targetAnchor.clone(),\n      sourceAnchorDef: ObjectExt.cloneDeep(\n        this.cell.prop(['source', 'anchor']),\n      ),\n      targetAnchorDef: ObjectExt.cloneDeep(\n        this.cell.prop(['target', 'anchor']),\n      ),\n    })\n\n    this.cell.startBatch('move-segment', { ui: true, toolId: this.cid })\n\n    if (!options.stopPropagation) {\n      const normalizedEvent = this.normalizeEvent(e)\n      const coords = this.graph.snapToGrid(\n        normalizedEvent.clientX,\n        normalizedEvent.clientY,\n      )\n      edgeView.notifyMouseDown(normalizedEvent, coords.x, coords.y)\n    }\n  }\n\n  protected onHandleChanged({ e }: Segments.Handle.EventArgs['changed']) {\n    const options = this.options\n    const edgeView = this.cellView\n    if (options.removeRedundancies) {\n      edgeView.removeRedundantLinearVertices({ ui: true, toolId: this.cid })\n    }\n\n    const normalizedEvent = this.normalizeEvent(e)\n    const coords = this.graph.snapToGrid(\n      normalizedEvent.clientX,\n      normalizedEvent.clientY,\n    )\n\n    this.render()\n    this.blur()\n\n    this.cell.stopBatch('move-segment', { ui: true, toolId: this.cid })\n    if (!options.stopPropagation) {\n      edgeView.notifyMouseUp(normalizedEvent, coords.x, coords.y)\n    }\n    edgeView.checkMouseleave(normalizedEvent)\n\n    options.onChanged && options.onChanged({ edge: edgeView.cell, edgeView })\n  }\n\n  protected updateHandle(\n    handle: Segments.Handle,\n    vertex: Point.PointLike,\n    nextVertex: Point.PointLike,\n    offset = 0,\n  ) {\n    const precision = this.options.precision || 0\n    const vertical = Math.abs(vertex.x - nextVertex.x) < precision\n    const horizontal = Math.abs(vertex.y - nextVertex.y) < precision\n    if (vertical || horizontal) {\n      const segmentLine = new Line(vertex, nextVertex)\n      const length = segmentLine.length()\n      if (length < this.options.threshold) {\n        handle.hide()\n      } else {\n        const position = segmentLine.getCenter()\n        const axis = vertical ? 'x' : 'y'\n        position[axis] += offset || 0\n        const angle = segmentLine.vector().vectorAngle(new Point(1, 0))\n        handle.updatePosition(position.x, position.y, angle, this.cellView)\n        handle.show()\n        handle.options.axis = axis\n      }\n    } else {\n      handle.hide()\n    }\n  }\n\n  protected onRemove() {\n    this.resetHandles()\n  }\n}\n\nexport namespace Segments {\n  export interface Options extends ToolsView.ToolItem.Options {\n    threshold: number\n    precision?: number\n    snapRadius: number\n    stopPropagation: boolean\n    removeRedundancies: boolean\n    attrs: Attr.SimpleAttrs | ((handle: Handle) => Attr.SimpleAttrs)\n    anchor?: (\n      this: EdgeView,\n      pos: Point,\n      terminalView: CellView,\n      terminalMagnet: Element | null,\n      terminalType: Edge.TerminalType,\n      edgeView: EdgeView,\n      toolView: Segments,\n    ) => Edge.TerminalCellData['anchor']\n    createHandle?: (options: Handle.Options) => Handle\n    processHandle?: (handle: Handle) => void\n    onChanged?: (options: { edge: Edge; edgeView: EdgeView }) => void\n  }\n\n  export interface EventData {\n    sourceAnchor: Point\n    targetAnchor: Point\n    sourceAnchorDef: Edge.TerminalCellData['anchor']\n    targetAnchorDef: Edge.TerminalCellData['anchor']\n  }\n}\n\nexport namespace Segments {\n  export class Handle extends View<Handle.EventArgs> {\n    public container: SVGRectElement\n\n    constructor(public options: Handle.Options) {\n      super()\n      this.render()\n      this.delegateEvents({\n        mousedown: 'onMouseDown',\n        touchstart: 'onMouseDown',\n      })\n    }\n\n    render() {\n      this.container = View.createElement('rect', true) as SVGRectElement\n      const attrs = this.options.attrs\n      if (typeof attrs === 'function') {\n        const defaults = Segments.getDefaults<Segments.Options>()\n        this.setAttrs({\n          ...defaults.attrs,\n          ...attrs(this),\n        })\n      } else {\n        this.setAttrs(attrs)\n      }\n      this.addClass(this.prefixClassName('edge-tool-segment'))\n    }\n\n    updatePosition(x: number, y: number, angle: number, view: EdgeView) {\n      const p = view.getClosestPoint(new Point(x, y)) || new Point(x, y)\n      let matrix = Dom.createSVGMatrix().translate(p.x, p.y)\n      if (!p.equals({ x, y })) {\n        const line = new Line(x, y, p.x, p.y)\n        let deg = line.vector().vectorAngle(new Point(1, 0))\n        if (deg !== 0) {\n          deg += 90\n        }\n        matrix = matrix.rotate(deg)\n      } else {\n        matrix = matrix.rotate(angle)\n      }\n\n      this.setAttrs({\n        transform: Dom.matrixToTransformString(matrix),\n        cursor: angle % 180 === 0 ? 'row-resize' : 'col-resize',\n      })\n    }\n\n    protected onMouseDown(evt: Dom.MouseDownEvent) {\n      if (this.options.guard(evt)) {\n        return\n      }\n\n      this.trigger('change', { e: evt, handle: this })\n\n      evt.stopPropagation()\n      evt.preventDefault()\n      this.options.graph.view.undelegateEvents()\n      this.delegateDocumentEvents(\n        {\n          mousemove: 'onMouseMove',\n          touchmove: 'onMouseMove',\n          mouseup: 'onMouseUp',\n          touchend: 'onMouseUp',\n          touchcancel: 'onMouseUp',\n        },\n        evt.data,\n      )\n    }\n\n    protected onMouseMove(evt: Dom.MouseMoveEvent) {\n      this.emit('changing', { e: evt, handle: this })\n    }\n\n    protected onMouseUp(evt: Dom.MouseUpEvent) {\n      this.emit('changed', { e: evt, handle: this })\n      this.undelegateDocumentEvents()\n      this.options.graph.view.delegateEvents()\n    }\n\n    show() {\n      this.container.style.display = ''\n    }\n\n    hide() {\n      this.container.style.display = 'none'\n    }\n  }\n\n  export namespace Handle {\n    export interface Options {\n      graph: Graph\n      guard: (evt: Dom.EventObject) => boolean\n      attrs: Attr.SimpleAttrs | ((handle: Handle) => Attr.SimpleAttrs)\n      index?: number\n      axis?: 'x' | 'y'\n    }\n\n    export interface EventArgs {\n      change: { e: Dom.MouseDownEvent; handle: Handle }\n      changing: { e: Dom.MouseMoveEvent; handle: Handle }\n      changed: { e: Dom.MouseUpEvent; handle: Handle }\n    }\n  }\n}\n\nexport namespace Segments {\n  Segments.config<Options>({\n    name: 'segments',\n    precision: 0.5,\n    threshold: 40,\n    snapRadius: 10,\n    stopPropagation: true,\n    removeRedundancies: true,\n    attrs: {\n      width: 20,\n      height: 8,\n      x: -10,\n      y: -4,\n      rx: 4,\n      ry: 4,\n      fill: '#333',\n      stroke: '#fff',\n      'stroke-width': 2,\n    },\n    createHandle: (options) => new Handle(options),\n    anchor: Util.getAnchor,\n  })\n}\n"],"mappings":"AAAA,SAASA,GAAG,EAAEC,SAAS,EAAEC,WAAW,QAAQ,iBAAiB;AAC7D,SAASC,KAAK,EAAEC,IAAI,QAAQ,mBAAmB;AAC/C,SAASC,IAAI,QAAQ,iBAAiB;AACtC,SAASC,SAAS,QAAQ,iBAAiB;AAC3C,OAAO,KAAKC,IAAI,MAAM,QAAQ;AAO9B,OAAM,MAAOC,QAAS,SAAQF,SAAS,CAACG,QAAoC;EAA5EC,YAAA;;IACY,KAAAC,OAAO,GAAsB,EAAE;EAuV3C;EArVE,IAAcC,QAAQA,CAAA;IACpB,OAAO,IAAI,CAACC,QAAQ,CAACC,IAAI,CAACC,WAAW,EAAE;EACzC;EAEAC,MAAMA,CAAA;IACJ,IAAI,CAACC,MAAM,EAAE;IACb,OAAO,IAAI;EACb;EAEUC,QAAQA,CAAA;IAChBlB,GAAG,CAACmB,QAAQ,CAAC,IAAI,CAACC,SAAS,EAAE,IAAI,CAACC,eAAe,CAAC,oBAAoB,CAAC,CAAC;IACxE,IAAI,CAACC,YAAY,EAAE;IACnB,MAAMC,QAAQ,GAAG,IAAI,CAACV,QAAQ;IAC9B,MAAMD,QAAQ,GAAG,CAAC,GAAG,IAAI,CAACA,QAAQ,CAAC;IACnCA,QAAQ,CAACY,OAAO,CAACD,QAAQ,CAACE,WAAW,CAAC;IACtCb,QAAQ,CAACc,IAAI,CAACH,QAAQ,CAACI,WAAW,CAAC;IAEnC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGjB,QAAQ,CAACkB,MAAM,EAAEF,CAAC,GAAGC,CAAC,GAAG,CAAC,EAAED,CAAC,IAAI,CAAC,EAAE;MACtD,MAAMG,MAAM,GAAGnB,QAAQ,CAACgB,CAAC,CAAC;MAC1B,MAAMI,UAAU,GAAGpB,QAAQ,CAACgB,CAAC,GAAG,CAAC,CAAC;MAClC,MAAMK,MAAM,GAAG,IAAI,CAACC,YAAY,CAACH,MAAM,EAAEC,UAAU,EAAEJ,CAAC,CAAC;MACvD,IAAI,CAACO,KAAK,CAACF,MAAM,CAACb,SAAS,CAAC;MAC5B,IAAI,CAACT,OAAO,CAACe,IAAI,CAACO,MAAM,CAAC;;IAE3B,OAAO,IAAI;EACb;EAEUC,YAAYA,CACpBH,MAAuB,EACvBC,UAA2B,EAC3BI,KAAa;IAEb,MAAMH,MAAM,GAAG,IAAI,CAACI,OAAO,CAACC,YAAa,CAAC;MACxCF,KAAK;MACLG,KAAK,EAAE,IAAI,CAACA,KAAK;MACjBC,KAAK,EAAGC,GAAG,IAAK,IAAI,CAACD,KAAK,CAACC,GAAG,CAAC;MAC/BC,KAAK,EAAE,IAAI,CAACL,OAAO,CAACK,KAAK,IAAI;KAC9B,CAAC;IAEF,IAAI,IAAI,CAACL,OAAO,CAACM,aAAa,EAAE;MAC9B,IAAI,CAACN,OAAO,CAACM,aAAa,CAACV,MAAM,CAAC;;IAGpC,IAAI,CAACW,YAAY,CAACX,MAAM,EAAEF,MAAM,EAAEC,UAAU,CAAC;IAC7C,IAAI,CAACZ,SAAS,CAACyB,WAAW,CAACZ,MAAM,CAACb,SAAS,CAAC;IAC5C,IAAI,CAAC0B,oBAAoB,CAACb,MAAM,CAAC;IACjC,OAAOA,MAAM;EACf;EAEUa,oBAAoBA,CAACb,MAAuB;IACpDA,MAAM,CAACc,EAAE,CAAC,QAAQ,EAAE,IAAI,CAACC,cAAc,EAAE,IAAI,CAAC;IAC9Cf,MAAM,CAACc,EAAE,CAAC,UAAU,EAAE,IAAI,CAACE,gBAAgB,EAAE,IAAI,CAAC;IAClDhB,MAAM,CAACc,EAAE,CAAC,SAAS,EAAE,IAAI,CAACG,eAAe,EAAE,IAAI,CAAC;EAClD;EAEUC,mBAAmBA,CAAClB,MAAuB;IACnDA,MAAM,CAACmB,GAAG,CAAC,QAAQ,EAAE,IAAI,CAACJ,cAAc,EAAE,IAAI,CAAC;IAC/Cf,MAAM,CAACmB,GAAG,CAAC,UAAU,EAAE,IAAI,CAACH,gBAAgB,EAAE,IAAI,CAAC;IACnDhB,MAAM,CAACmB,GAAG,CAAC,SAAS,EAAE,IAAI,CAACF,eAAe,EAAE,IAAI,CAAC;EACnD;EAEU5B,YAAYA,CAAA;IACpB,MAAMX,OAAO,GAAG,IAAI,CAACA,OAAO;IAC5B,IAAI,CAACA,OAAO,GAAG,EAAE;IACjB,IAAIA,OAAO,EAAE;MACXA,OAAO,CAAC0C,OAAO,CAAEpB,MAAM,IAAI;QACzB,IAAI,CAACkB,mBAAmB,CAAClB,MAAM,CAAC;QAChCA,MAAM,CAACqB,MAAM,EAAE;MACjB,CAAC,CAAC;;EAEN;EAEUC,kBAAkBA,CAACC,KAAa;IACxC,MAAM7C,OAAO,GAAG,IAAI,CAACA,OAAO;IAC5B,KAAK,IAAIiB,CAAC,GAAG,CAAC,EAAE6B,CAAC,GAAG9C,OAAO,CAACmB,MAAM,EAAEF,CAAC,GAAG6B,CAAC,EAAE7B,CAAC,IAAI,CAAC,EAAE;MACjDjB,OAAO,CAACiB,CAAC,CAAC,CAACS,OAAO,CAACD,KAAM,IAAIoB,KAAK;;EAEtC;EAEUE,WAAWA,CACnBC,IAAuB,EACvBC,MAAuC;IAEvC,MAAMC,IAAI,GAAG,IAAI,CAAChD,QAAQ,CAACC,IAAI;IAC/B,MAAMuB,OAAO,GAAG;MACdyB,EAAE,EAAE,IAAI;MACRC,MAAM,EAAE,IAAI,CAACC;KACd;IAED,IAAIJ,MAAM,EAAE;MACVC,IAAI,CAACI,IAAI,CAAC,CAACN,IAAI,EAAE,QAAQ,CAAC,EAAEC,MAAM,EAAEvB,OAAO,CAAC;KAC7C,MAAM;MACLwB,IAAI,CAACK,UAAU,CAAC,CAACP,IAAI,EAAE,QAAQ,CAAC,EAAEtB,OAAO,CAAC;;EAE9C;EAEU8B,UAAUA,CAClBlC,MAAuB,EACvBmC,QAAyB,EACzBC,IAAwB;IAExB,MAAMC,IAAI,GAAGrC,MAAM,CAACI,OAAO,CAACiC,IAAK;IACjC,MAAMlC,KAAK,GAAGH,MAAM,CAACI,OAAO,CAACD,KAAM;IACnC,MAAMb,QAAQ,GAAG,IAAI,CAACV,QAAQ;IAC9B,MAAMgD,IAAI,GAAGtC,QAAQ,CAACT,IAAI;IAC1B,MAAMF,QAAQ,GAAGiD,IAAI,CAAC9C,WAAW,EAAE;IACnC,MAAMwD,IAAI,GAAG3D,QAAQ,CAACwB,KAAK,GAAG,CAAC,CAAC,IAAIiC,IAAI,CAACG,YAAY;IACrD,MAAMC,IAAI,GAAG7D,QAAQ,CAACwB,KAAK,GAAG,CAAC,CAAC,IAAIiC,IAAI,CAACK,YAAY;IACrD,MAAMC,UAAU,GAAG,IAAI,CAACtC,OAAO,CAACsC,UAAU;IAC1C,IAAIC,IAAI,CAACC,GAAG,CAACT,QAAQ,CAACE,IAAI,CAAC,GAAGC,IAAI,CAACD,IAAI,CAAC,CAAC,GAAGK,UAAU,EAAE;MACtDP,QAAQ,CAACE,IAAI,CAAC,GAAGC,IAAI,CAACD,IAAI,CAAC;KAC5B,MAAM,IAAIM,IAAI,CAACC,GAAG,CAACT,QAAQ,CAACE,IAAI,CAAC,GAAGG,IAAI,CAACH,IAAI,CAAC,CAAC,GAAGK,UAAU,EAAE;MAC7DP,QAAQ,CAACE,IAAI,CAAC,GAAGG,IAAI,CAACH,IAAI,CAAC;;IAE7B,OAAOF,QAAQ;EACjB;EAEUnB,gBAAgBA,CAAC;IACzBhB,MAAM;IACN6C;EAAC,CACqC;IACtC,MAAMvC,KAAK,GAAG,IAAI,CAACA,KAAK;IACxB,MAAMF,OAAO,GAAG,IAAI,CAACA,OAAO;IAC5B,MAAMd,QAAQ,GAAG,IAAI,CAACV,QAAQ;IAC9B,MAAMkE,QAAQ,GAAG1C,OAAO,CAACuB,MAAM;IAE/B,MAAMU,IAAI,GAAGrC,MAAM,CAACI,OAAO,CAACiC,IAAK;IACjC,MAAMlC,KAAK,GAAGH,MAAM,CAACI,OAAO,CAACD,KAAM,GAAG,CAAC;IAEvC,MAAMiC,IAAI,GAAG,IAAI,CAACW,YAAY,CAAqBF,CAAC,CAAC;IACrD,MAAMrC,GAAG,GAAG,IAAI,CAACwC,cAAc,CAACH,CAAC,CAAC;IAClC,MAAMI,MAAM,GAAG3C,KAAK,CAAC4C,UAAU,CAAC1C,GAAG,CAAC2C,OAAO,EAAE3C,GAAG,CAAC4C,OAAO,CAAC;IACzD,MAAMjB,QAAQ,GAAG,IAAI,CAACD,UAAU,CAAClC,MAAM,EAAEiD,MAAM,CAACI,KAAK,EAAE,EAAEjB,IAAI,CAAC;IAC9D,MAAMzD,QAAQ,GAAGX,SAAS,CAACsF,SAAS,CAAC,IAAI,CAAC3E,QAAQ,CAAC;IACnD,IAAImB,MAAM,GAAGnB,QAAQ,CAACwB,KAAK,CAAC;IAC5B,IAAIJ,UAAU,GAAGpB,QAAQ,CAACwB,KAAK,GAAG,CAAC,CAAC;IAEpC;IACA,MAAMoD,UAAU,GAAGjE,QAAQ,CAACiE,UAAU;IACtC,MAAMC,UAAU,GAAGlE,QAAQ,CAACkE,UAAU;IACtC,IAAIC,kBAAkB,GAAG,KAAK;IAC9B,IAAIC,kBAAkB,GAAG,KAAK;IAE9B,IAAI,CAAC5D,MAAM,EAAE;MACXA,MAAM,GAAGR,QAAQ,CAACiD,YAAY,CAACoB,MAAM,EAAE;MACvC7D,MAAM,CAACuC,IAAI,CAAC,GAAGF,QAAQ,CAACE,IAAI,CAAC;MAC7B,IAAImB,UAAU,CAACI,aAAa,CAAC9D,MAAM,CAAC,EAAE;QACpC2D,kBAAkB,GAAG,IAAI;OAC1B,MAAM;QACL9E,QAAQ,CAACY,OAAO,CAACO,MAAM,CAAC;QACxB,IAAI,CAACwB,kBAAkB,CAAC,CAAC,CAAC;QAC1BoC,kBAAkB,GAAG,IAAI;;KAE5B,MAAM,IAAIvD,KAAK,KAAK,CAAC,EAAE;MACtB,IAAIqD,UAAU,CAACI,aAAa,CAAC9D,MAAM,CAAC,EAAE;QACpCnB,QAAQ,CAACkF,KAAK,EAAE;QAChB,IAAI,CAACvC,kBAAkB,CAAC,CAAC,CAAC,CAAC;QAC3BmC,kBAAkB,GAAG,IAAI;OAC1B,MAAM;QACL3D,MAAM,CAACuC,IAAI,CAAC,GAAGF,QAAQ,CAACE,IAAI,CAAC;QAC7BqB,kBAAkB,GAAG,IAAI;;KAE5B,MAAM;MACL5D,MAAM,CAACuC,IAAI,CAAC,GAAGF,QAAQ,CAACE,IAAI,CAAC;;IAG/B,IAAI,OAAOS,QAAQ,KAAK,UAAU,IAAIS,UAAU,EAAE;MAChD,IAAIE,kBAAkB,EAAE;QACtB,MAAMK,oBAAoB,GAAG1B,IAAI,CAACG,YAAY,CAACc,KAAK,EAAE;QACtDS,oBAAoB,CAACzB,IAAI,CAAC,GAAGF,QAAQ,CAACE,IAAI,CAAC;QAC3C,MAAME,YAAY,GAAGtE,WAAW,CAAC8F,IAAI,CACnCjB,QAAQ,EACRxD,QAAQ,EACRwE,oBAAoB,EACpBP,UAAU,EACVjE,QAAQ,CAAC0E,YAAY,IAAIT,UAAU,CAACpE,SAAS,EAC7C,QAAQ,EACRG,QAAQ,EACR,IAAI,CACL;QACD,IAAI,CAACmC,WAAW,CAAC,QAAQ,EAAEc,YAAY,CAAC;;MAG1C,IAAImB,kBAAkB,EAAE;QACtB,IAAI,CAACjC,WAAW,CAAC,QAAQ,EAAEW,IAAI,CAAC6B,eAAe,CAAC;;;IAIpD;IACA,MAAMC,UAAU,GAAG5E,QAAQ,CAAC4E,UAAU;IACtC,MAAMC,UAAU,GAAG7E,QAAQ,CAAC6E,UAAU;IACtC,IAAIC,kBAAkB,GAAG,KAAK;IAC9B,IAAIC,kBAAkB,GAAG,KAAK;IAC9B,IAAI,CAACtE,UAAU,EAAE;MACfA,UAAU,GAAGT,QAAQ,CAACmD,YAAY,CAACkB,MAAM,EAAE;MAC3C5D,UAAU,CAACsC,IAAI,CAAC,GAAGF,QAAQ,CAACE,IAAI,CAAC;MACjC,IAAI8B,UAAU,CAACP,aAAa,CAAC7D,UAAU,CAAC,EAAE;QACxCqE,kBAAkB,GAAG,IAAI;OAC1B,MAAM;QACLzF,QAAQ,CAACc,IAAI,CAACM,UAAU,CAAC;QACzBsE,kBAAkB,GAAG,IAAI;;KAE5B,MAAM,IAAIlE,KAAK,KAAKxB,QAAQ,CAACkB,MAAM,GAAG,CAAC,EAAE;MACxC,IAAIsE,UAAU,CAACP,aAAa,CAAC7D,UAAU,CAAC,EAAE;QACxCpB,QAAQ,CAAC2F,GAAG,EAAE;QACdF,kBAAkB,GAAG,IAAI;OAC1B,MAAM;QACLrE,UAAU,CAACsC,IAAI,CAAC,GAAGF,QAAQ,CAACE,IAAI,CAAC;QACjCgC,kBAAkB,GAAG,IAAI;;KAE5B,MAAM;MACLtE,UAAU,CAACsC,IAAI,CAAC,GAAGF,QAAQ,CAACE,IAAI,CAAC;;IAGnC,IAAI,OAAOS,QAAQ,KAAK,UAAU,IAAIoB,UAAU,EAAE;MAChD,IAAIE,kBAAkB,EAAE;QACtB,MAAMG,oBAAoB,GAAGnC,IAAI,CAACK,YAAY,CAACY,KAAK,EAAE;QACtDkB,oBAAoB,CAAClC,IAAI,CAAC,GAAGF,QAAQ,CAACE,IAAI,CAAC;QAC3C,MAAMI,YAAY,GAAGxE,WAAW,CAAC8F,IAAI,CACnCjB,QAAQ,EACRxD,QAAQ,EACRiF,oBAAoB,EACpBL,UAAU,EACV5E,QAAQ,CAACkF,YAAY,IAAIN,UAAU,CAAC/E,SAAS,EAC7C,QAAQ,EACRG,QAAQ,EACR,IAAI,CACL;QACD,IAAI,CAACmC,WAAW,CAAC,QAAQ,EAAEgB,YAAY,CAAC;;MAE1C,IAAI4B,kBAAkB,EAAE;QACtB,IAAI,CAAC5C,WAAW,CAAC,QAAQ,EAAEW,IAAI,CAACqC,eAAe,CAAC;;;IAIpD,IAAI,CAACvG,KAAK,CAACwG,WAAW,CAAC/F,QAAQ,EAAE,IAAI,CAACA,QAAQ,CAAC,EAAE;MAC/C,IAAI,CAACC,QAAQ,CAACC,IAAI,CAAC8F,WAAW,CAAChG,QAAQ,EAAE;QAAEkD,EAAE,EAAE,IAAI;QAAEC,MAAM,EAAE,IAAI,CAACC;MAAG,CAAE,CAAC;;IAG1E,IAAI,CAACpB,YAAY,CAACX,MAAM,EAAEF,MAAM,EAAEC,UAAU,EAAE,CAAC,CAAC;IAChD,IAAI,CAACK,OAAO,CAACwE,eAAe,EAAE;MAC5BtF,QAAQ,CAACuF,eAAe,CAACrE,GAAG,EAAEyC,MAAM,CAAC6B,CAAC,EAAE7B,MAAM,CAAC8B,CAAC,CAAC;;EAErD;EAEUhE,cAAcA,CAAC;IAAEf,MAAM;IAAE6C;EAAC,CAAuC;IACzE,MAAMzC,OAAO,GAAG,IAAI,CAACA,OAAO;IAC5B,MAAM1B,OAAO,GAAG,IAAI,CAACA,OAAO;IAC5B,MAAMY,QAAQ,GAAG,IAAI,CAACV,QAAQ;IAE9B,MAAMuB,KAAK,GAAGH,MAAM,CAACI,OAAO,CAACD,KAAK;IAClC,IAAI,CAAC6E,KAAK,CAACC,OAAO,CAACvG,OAAO,CAAC,EAAE;MAC3B;;IAGF,KAAK,IAAIiB,CAAC,GAAG,CAAC,EAAE6B,CAAC,GAAG9C,OAAO,CAACmB,MAAM,EAAEF,CAAC,GAAG6B,CAAC,EAAE7B,CAAC,IAAI,CAAC,EAAE;MACjD,IAAIA,CAAC,KAAKQ,KAAK,EAAE;QACfzB,OAAO,CAACiB,CAAC,CAAC,CAACuF,IAAI,EAAE;;;IAIrB,IAAI,CAACC,KAAK,EAAE;IACZ,IAAI,CAACC,YAAY,CAAqBvC,CAAC,EAAE;MACvCN,YAAY,EAAEjD,QAAQ,CAACiD,YAAY,CAACc,KAAK,EAAE;MAC3CZ,YAAY,EAAEnD,QAAQ,CAACmD,YAAY,CAACY,KAAK,EAAE;MAC3CY,eAAe,EAAEjG,SAAS,CAACsF,SAAS,CAClC,IAAI,CAACzE,IAAI,CAACmD,IAAI,CAAC,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC,CACrC;MACDyC,eAAe,EAAEzG,SAAS,CAACsF,SAAS,CAClC,IAAI,CAACzE,IAAI,CAACmD,IAAI,CAAC,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;KAEvC,CAAC;IAEF,IAAI,CAACnD,IAAI,CAACwG,UAAU,CAAC,cAAc,EAAE;MAAExD,EAAE,EAAE,IAAI;MAAEC,MAAM,EAAE,IAAI,CAACC;IAAG,CAAE,CAAC;IAEpE,IAAI,CAAC3B,OAAO,CAACwE,eAAe,EAAE;MAC5B,MAAMU,eAAe,GAAG,IAAI,CAACtC,cAAc,CAACH,CAAC,CAAC;MAC9C,MAAMI,MAAM,GAAG,IAAI,CAAC3C,KAAK,CAAC4C,UAAU,CAClCoC,eAAe,CAACnC,OAAO,EACvBmC,eAAe,CAAClC,OAAO,CACxB;MACD9D,QAAQ,CAACiG,eAAe,CAACD,eAAe,EAAErC,MAAM,CAAC6B,CAAC,EAAE7B,MAAM,CAAC8B,CAAC,CAAC;;EAEjE;EAEU9D,eAAeA,CAAC;IAAE4B;EAAC,CAAwC;IACnE,MAAMzC,OAAO,GAAG,IAAI,CAACA,OAAO;IAC5B,MAAMd,QAAQ,GAAG,IAAI,CAACV,QAAQ;IAC9B,IAAIwB,OAAO,CAACoF,kBAAkB,EAAE;MAC9BlG,QAAQ,CAACmG,6BAA6B,CAAC;QAAE5D,EAAE,EAAE,IAAI;QAAEC,MAAM,EAAE,IAAI,CAACC;MAAG,CAAE,CAAC;;IAGxE,MAAMuD,eAAe,GAAG,IAAI,CAACtC,cAAc,CAACH,CAAC,CAAC;IAC9C,MAAMI,MAAM,GAAG,IAAI,CAAC3C,KAAK,CAAC4C,UAAU,CAClCoC,eAAe,CAACnC,OAAO,EACvBmC,eAAe,CAAClC,OAAO,CACxB;IAED,IAAI,CAACpE,MAAM,EAAE;IACb,IAAI,CAAC0G,IAAI,EAAE;IAEX,IAAI,CAAC7G,IAAI,CAAC8G,SAAS,CAAC,cAAc,EAAE;MAAE9D,EAAE,EAAE,IAAI;MAAEC,MAAM,EAAE,IAAI,CAACC;IAAG,CAAE,CAAC;IACnE,IAAI,CAAC3B,OAAO,CAACwE,eAAe,EAAE;MAC5BtF,QAAQ,CAACsG,aAAa,CAACN,eAAe,EAAErC,MAAM,CAAC6B,CAAC,EAAE7B,MAAM,CAAC8B,CAAC,CAAC;;IAE7DzF,QAAQ,CAACuG,eAAe,CAACP,eAAe,CAAC;IAEzClF,OAAO,CAAC0F,SAAS,IAAI1F,OAAO,CAAC0F,SAAS,CAAC;MAAElE,IAAI,EAAEtC,QAAQ,CAACT,IAAI;MAAES;IAAQ,CAAE,CAAC;EAC3E;EAEUqB,YAAYA,CACpBX,MAAuB,EACvBF,MAAuB,EACvBC,UAA2B,EAC3BgG,MAAM,GAAG,CAAC;IAEV,MAAMC,SAAS,GAAG,IAAI,CAAC5F,OAAO,CAAC4F,SAAS,IAAI,CAAC;IAC7C,MAAMC,QAAQ,GAAGtD,IAAI,CAACC,GAAG,CAAC9C,MAAM,CAACgF,CAAC,GAAG/E,UAAU,CAAC+E,CAAC,CAAC,GAAGkB,SAAS;IAC9D,MAAME,UAAU,GAAGvD,IAAI,CAACC,GAAG,CAAC9C,MAAM,CAACiF,CAAC,GAAGhF,UAAU,CAACgF,CAAC,CAAC,GAAGiB,SAAS;IAChE,IAAIC,QAAQ,IAAIC,UAAU,EAAE;MAC1B,MAAMC,WAAW,GAAG,IAAIhI,IAAI,CAAC2B,MAAM,EAAEC,UAAU,CAAC;MAChD,MAAMF,MAAM,GAAGsG,WAAW,CAACtG,MAAM,EAAE;MACnC,IAAIA,MAAM,GAAG,IAAI,CAACO,OAAO,CAACgG,SAAS,EAAE;QACnCpG,MAAM,CAACkF,IAAI,EAAE;OACd,MAAM;QACL,MAAM/C,QAAQ,GAAGgE,WAAW,CAACE,SAAS,EAAE;QACxC,MAAMhE,IAAI,GAAG4D,QAAQ,GAAG,GAAG,GAAG,GAAG;QACjC9D,QAAQ,CAACE,IAAI,CAAC,IAAI0D,MAAM,IAAI,CAAC;QAC7B,MAAMO,KAAK,GAAGH,WAAW,CAACI,MAAM,EAAE,CAACC,WAAW,CAAC,IAAItI,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/D8B,MAAM,CAACyG,cAAc,CAACtE,QAAQ,CAAC2C,CAAC,EAAE3C,QAAQ,CAAC4C,CAAC,EAAEuB,KAAK,EAAE,IAAI,CAAC1H,QAAQ,CAAC;QACnEoB,MAAM,CAAC0G,IAAI,EAAE;QACb1G,MAAM,CAACI,OAAO,CAACiC,IAAI,GAAGA,IAAI;;KAE7B,MAAM;MACLrC,MAAM,CAACkF,IAAI,EAAE;;EAEjB;EAEUyB,QAAQA,CAAA;IAChB,IAAI,CAACtH,YAAY,EAAE;EACrB;;AAiCF,WAAiBd,QAAQ;EACvB,MAAaqI,MAAO,SAAQxI,IAAsB;IAGhDK,YAAmB2B,OAAuB;MACxC,KAAK,EAAE;MADU,KAAAA,OAAO,GAAPA,OAAO;MAExB,IAAI,CAACpB,MAAM,EAAE;MACb,IAAI,CAAC6H,cAAc,CAAC;QAClBC,SAAS,EAAE,aAAa;QACxBC,UAAU,EAAE;OACb,CAAC;IACJ;IAEA/H,MAAMA,CAAA;MACJ,IAAI,CAACG,SAAS,GAAGf,IAAI,CAAC4I,aAAa,CAAC,MAAM,EAAE,IAAI,CAAmB;MACnE,MAAMvG,KAAK,GAAG,IAAI,CAACL,OAAO,CAACK,KAAK;MAChC,IAAI,OAAOA,KAAK,KAAK,UAAU,EAAE;QAC/B,MAAMwG,QAAQ,GAAG1I,QAAQ,CAAC2I,WAAW,EAAoB;QACzD,IAAI,CAACC,QAAQ,CAAAC,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACRJ,QAAQ,CAACxG,KAAK,GACdA,KAAK,CAAC,IAAI,CAAC,EACd;OACH,MAAM;QACL,IAAI,CAAC0G,QAAQ,CAAC1G,KAAK,CAAC;;MAEtB,IAAI,CAACvB,QAAQ,CAAC,IAAI,CAACE,eAAe,CAAC,mBAAmB,CAAC,CAAC;IAC1D;IAEAqH,cAAcA,CAAC3B,CAAS,EAAEC,CAAS,EAAEuB,KAAa,EAAEgB,IAAc;MAChE,MAAMC,CAAC,GAAGD,IAAI,CAACE,eAAe,CAAC,IAAItJ,KAAK,CAAC4G,CAAC,EAAEC,CAAC,CAAC,CAAC,IAAI,IAAI7G,KAAK,CAAC4G,CAAC,EAAEC,CAAC,CAAC;MAClE,IAAI0C,MAAM,GAAG1J,GAAG,CAAC2J,eAAe,EAAE,CAACC,SAAS,CAACJ,CAAC,CAACzC,CAAC,EAAEyC,CAAC,CAACxC,CAAC,CAAC;MACtD,IAAI,CAACwC,CAAC,CAACK,MAAM,CAAC;QAAE9C,CAAC;QAAEC;MAAC,CAAE,CAAC,EAAE;QACvB,MAAM8C,IAAI,GAAG,IAAI1J,IAAI,CAAC2G,CAAC,EAAEC,CAAC,EAAEwC,CAAC,CAACzC,CAAC,EAAEyC,CAAC,CAACxC,CAAC,CAAC;QACrC,IAAI+C,GAAG,GAAGD,IAAI,CAACtB,MAAM,EAAE,CAACC,WAAW,CAAC,IAAItI,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QACpD,IAAI4J,GAAG,KAAK,CAAC,EAAE;UACbA,GAAG,IAAI,EAAE;;QAEXL,MAAM,GAAGA,MAAM,CAACM,MAAM,CAACD,GAAG,CAAC;OAC5B,MAAM;QACLL,MAAM,GAAGA,MAAM,CAACM,MAAM,CAACzB,KAAK,CAAC;;MAG/B,IAAI,CAACa,QAAQ,CAAC;QACZa,SAAS,EAAEjK,GAAG,CAACkK,uBAAuB,CAACR,MAAM,CAAC;QAC9CS,MAAM,EAAE5B,KAAK,GAAG,GAAG,KAAK,CAAC,GAAG,YAAY,GAAG;OAC5C,CAAC;IACJ;IAEU6B,WAAWA,CAAC3H,GAAuB;MAC3C,IAAI,IAAI,CAACJ,OAAO,CAACG,KAAK,CAACC,GAAG,CAAC,EAAE;QAC3B;;MAGF,IAAI,CAAC4H,OAAO,CAAC,QAAQ,EAAE;QAAEvF,CAAC,EAAErC,GAAG;QAAER,MAAM,EAAE;MAAI,CAAE,CAAC;MAEhDQ,GAAG,CAACoE,eAAe,EAAE;MACrBpE,GAAG,CAAC6H,cAAc,EAAE;MACpB,IAAI,CAACjI,OAAO,CAACE,KAAK,CAACgH,IAAI,CAACgB,gBAAgB,EAAE;MAC1C,IAAI,CAACC,sBAAsB,CACzB;QACEC,SAAS,EAAE,aAAa;QACxBC,SAAS,EAAE,aAAa;QACxBC,OAAO,EAAE,WAAW;QACpBC,QAAQ,EAAE,WAAW;QACrBC,WAAW,EAAE;OACd,EACDpI,GAAG,CAAC4B,IAAI,CACT;IACH;IAEUyG,WAAWA,CAACrI,GAAuB;MAC3C,IAAI,CAACsI,IAAI,CAAC,UAAU,EAAE;QAAEjG,CAAC,EAAErC,GAAG;QAAER,MAAM,EAAE;MAAI,CAAE,CAAC;IACjD;IAEU+I,SAASA,CAACvI,GAAqB;MACvC,IAAI,CAACsI,IAAI,CAAC,SAAS,EAAE;QAAEjG,CAAC,EAAErC,GAAG;QAAER,MAAM,EAAE;MAAI,CAAE,CAAC;MAC9C,IAAI,CAACgJ,wBAAwB,EAAE;MAC/B,IAAI,CAAC5I,OAAO,CAACE,KAAK,CAACgH,IAAI,CAACT,cAAc,EAAE;IAC1C;IAEAH,IAAIA,CAAA;MACF,IAAI,CAACvH,SAAS,CAAC8J,KAAK,CAACC,OAAO,GAAG,EAAE;IACnC;IAEAhE,IAAIA,CAAA;MACF,IAAI,CAAC/F,SAAS,CAAC8J,KAAK,CAACC,OAAO,GAAG,MAAM;IACvC;;EArFW3K,QAAA,CAAAqI,MAAM,GAAAA,MAsFlB;AAiBH,CAAC,EAxGgBrI,QAAQ,KAARA,QAAQ;AA0GzB,WAAiBA,QAAQ;EACvBA,QAAQ,CAAC4K,MAAM,CAAU;IACvBC,IAAI,EAAE,UAAU;IAChBpD,SAAS,EAAE,GAAG;IACdI,SAAS,EAAE,EAAE;IACb1D,UAAU,EAAE,EAAE;IACdkC,eAAe,EAAE,IAAI;IACrBY,kBAAkB,EAAE,IAAI;IACxB/E,KAAK,EAAE;MACL4I,KAAK,EAAE,EAAE;MACTC,MAAM,EAAE,CAAC;MACTxE,CAAC,EAAE,CAAC,EAAE;MACNC,CAAC,EAAE,CAAC,CAAC;MACLwE,EAAE,EAAE,CAAC;MACLC,EAAE,EAAE,CAAC;MACLC,IAAI,EAAE,MAAM;MACZC,MAAM,EAAE,MAAM;MACd,cAAc,EAAE;KACjB;IACDrJ,YAAY,EAAGD,OAAO,IAAK,IAAI7B,QAAA,CAAAqI,MAAM,CAACxG,OAAO,CAAC;IAC9CuB,MAAM,EAAErD,IAAI,CAACqL;GACd,CAAC;AACJ,CAAC,EAtBgBpL,QAAQ,KAARA,QAAQ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}