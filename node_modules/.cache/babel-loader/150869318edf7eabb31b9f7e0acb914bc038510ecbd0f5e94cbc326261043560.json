{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { ObjectExt } from '@antv/x6-common';\nimport { Marker } from '../marker';\nfunction qualify(value) {\n  return typeof value === 'string' || ObjectExt.isPlainObject(value);\n}\nexport const sourceMarker = {\n  qualify,\n  set(marker, {\n    view,\n    attrs\n  }) {\n    return createMarker('marker-start', marker, view, attrs);\n  }\n};\nexport const targetMarker = {\n  qualify,\n  set(marker, {\n    view,\n    attrs\n  }) {\n    return createMarker('marker-end', marker, view, attrs, {\n      transform: 'rotate(180)'\n    });\n  }\n};\nexport const vertexMarker = {\n  qualify,\n  set(marker, {\n    view,\n    attrs\n  }) {\n    return createMarker('marker-mid', marker, view, attrs);\n  }\n};\nfunction createMarker(type, marker, view, attrs, manual = {}) {\n  const def = typeof marker === 'string' ? {\n    name: marker\n  } : marker;\n  const {\n      name,\n      args\n    } = def,\n    others = __rest(def, [\"name\", \"args\"]);\n  let preset = others;\n  if (name && typeof name === 'string') {\n    const fn = Marker.registry.get(name);\n    if (fn) {\n      preset = fn(Object.assign(Object.assign({}, others), args));\n    } else {\n      return Marker.registry.onNotFound(name);\n    }\n  }\n  const options = Object.assign(Object.assign(Object.assign({}, normalizeAttr(attrs, type)), manual), preset);\n  return {\n    [type]: `url(#${view.graph.defineMarker(options)})`\n  };\n}\nfunction normalizeAttr(attr, type) {\n  const result = {};\n  // The context 'fill' is disregared here. The usual case is to use the\n  // marker with a connection(for which 'fill' attribute is set to 'none').\n  const stroke = attr.stroke;\n  if (typeof stroke === 'string') {\n    result.stroke = stroke;\n    result.fill = stroke;\n  }\n  // Again the context 'fill-opacity' is ignored.\n  let strokeOpacity = attr.strokeOpacity;\n  if (strokeOpacity == null) {\n    strokeOpacity = attr['stroke-opacity'];\n  }\n  if (strokeOpacity == null) {\n    strokeOpacity = attr.opacity;\n  }\n  if (strokeOpacity != null) {\n    result['stroke-opacity'] = strokeOpacity;\n    result['fill-opacity'] = strokeOpacity;\n  }\n  if (type !== 'marker-mid') {\n    const strokeWidth = parseFloat(attr.strokeWidth || attr['stroke-width']);\n    if (Number.isFinite(strokeWidth) && strokeWidth > 1) {\n      const offset = Math.ceil(strokeWidth / 2);\n      result.refX = type === 'marker-start' ? offset : -offset;\n    }\n  }\n  return result;\n}","map":{"version":3,"names":["ObjectExt","Marker","qualify","value","isPlainObject","sourceMarker","set","marker","view","attrs","createMarker","targetMarker","transform","vertexMarker","type","manual","def","name","args","others","__rest","preset","fn","registry","get","Object","assign","onNotFound","options","normalizeAttr","graph","defineMarker","attr","result","stroke","fill","strokeOpacity","opacity","strokeWidth","parseFloat","Number","isFinite","offset","Math","ceil","refX"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/src/registry/attr/marker.ts"],"sourcesContent":["import { ObjectExt, JSONObject, KeyValue } from '@antv/x6-common'\nimport { CellView } from '../../view'\nimport { Marker } from '../marker'\nimport { Attr } from './index'\n\nfunction qualify(value: any) {\n  return typeof value === 'string' || ObjectExt.isPlainObject(value)\n}\n\nexport const sourceMarker: Attr.Definition = {\n  qualify,\n  set(marker: string | JSONObject, { view, attrs }) {\n    return createMarker('marker-start', marker, view, attrs)\n  },\n}\n\nexport const targetMarker: Attr.Definition = {\n  qualify,\n  set(marker: string | JSONObject, { view, attrs }) {\n    return createMarker('marker-end', marker, view, attrs, {\n      transform: 'rotate(180)',\n    })\n  },\n}\n\nexport const vertexMarker: Attr.Definition = {\n  qualify,\n  set(marker: string | JSONObject, { view, attrs }) {\n    return createMarker('marker-mid', marker, view, attrs)\n  },\n}\n\nfunction createMarker(\n  type: 'marker-start' | 'marker-end' | 'marker-mid',\n  marker: string | JSONObject,\n  view: CellView,\n  attrs: Attr.ComplexAttrs,\n  manual: Attr.SimpleAttrs = {},\n) {\n  const def = typeof marker === 'string' ? { name: marker } : marker\n  const { name, args, ...others } = def\n  let preset = others\n\n  if (name && typeof name === 'string') {\n    const fn = Marker.registry.get(name)\n    if (fn) {\n      preset = fn({ ...others, ...(args as KeyValue) })\n    } else {\n      return Marker.registry.onNotFound(name)\n    }\n  }\n\n  const options: any = {\n    ...normalizeAttr(attrs, type),\n    ...manual,\n    ...preset,\n  }\n\n  return {\n    [type]: `url(#${view.graph.defineMarker(options)})`,\n  }\n}\n\nfunction normalizeAttr(\n  attr: Attr.ComplexAttrs,\n  type: 'marker-start' | 'marker-end' | 'marker-mid',\n) {\n  const result: Attr.SimpleAttrs = {}\n\n  // The context 'fill' is disregared here. The usual case is to use the\n  // marker with a connection(for which 'fill' attribute is set to 'none').\n  const stroke = attr.stroke\n  if (typeof stroke === 'string') {\n    result.stroke = stroke\n    result.fill = stroke\n  }\n\n  // Again the context 'fill-opacity' is ignored.\n  let strokeOpacity = attr.strokeOpacity\n  if (strokeOpacity == null) {\n    strokeOpacity = attr['stroke-opacity']\n  }\n\n  if (strokeOpacity == null) {\n    strokeOpacity = attr.opacity\n  }\n\n  if (strokeOpacity != null) {\n    result['stroke-opacity'] = strokeOpacity as number\n    result['fill-opacity'] = strokeOpacity as number\n  }\n\n  if (type !== 'marker-mid') {\n    const strokeWidth = parseFloat(\n      (attr.strokeWidth || attr['stroke-width']) as string,\n    )\n    if (Number.isFinite(strokeWidth) && strokeWidth > 1) {\n      const offset = Math.ceil(strokeWidth / 2)\n      result.refX = type === 'marker-start' ? offset : -offset\n    }\n  }\n\n  return result\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}