{"ast":null,"code":"import { PriorityQueue } from './priorityqueue';\nexport var Dijkstra;\n(function (Dijkstra) {\n  function run(adjacencyList, source, weight = (u, v) => 1) {\n    const dist = {};\n    const previous = {};\n    const scanned = {};\n    const queue = new PriorityQueue();\n    dist[source] = 0;\n    Object.keys(adjacencyList).forEach(v => {\n      if (v !== source) {\n        dist[v] = Infinity;\n      }\n      queue.insert(dist[v], v, v);\n    });\n    while (!queue.isEmpty()) {\n      const u = queue.remove();\n      scanned[u] = true;\n      const neighbours = adjacencyList[u] || [];\n      for (let i = 0; i < neighbours.length; i += 1) {\n        const v = neighbours[i];\n        if (!scanned[v]) {\n          const alt = dist[u] + weight(u, v);\n          if (alt < dist[v]) {\n            dist[v] = alt;\n            previous[v] = u;\n            queue.updatePriority(v, alt);\n          }\n        }\n      }\n    }\n    return previous;\n  }\n  Dijkstra.run = run;\n})(Dijkstra || (Dijkstra = {}));","map":{"version":3,"names":["PriorityQueue","Dijkstra","run","adjacencyList","source","weight","u","v","dist","previous","scanned","queue","Object","keys","forEach","Infinity","insert","isEmpty","remove","neighbours","i","length","alt","updatePriority"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/src/algorithm/dijkstra.ts"],"sourcesContent":["import { PriorityQueue } from './priorityqueue'\n\nexport namespace Dijkstra {\n  export type AdjacencyList = { [key: string]: string[] }\n  export type Weight = (u: string, v: string) => number\n\n  export function run(\n    adjacencyList: AdjacencyList,\n    source: string,\n    weight: Weight = (u, v) => 1, // eslint-disable-line\n  ) {\n    const dist: { [key: string]: number } = {}\n    const previous: { [key: string]: string } = {}\n    const scanned: { [key: string]: boolean } = {}\n    const queue = new PriorityQueue<string>()\n\n    dist[source] = 0\n\n    Object.keys(adjacencyList).forEach((v) => {\n      if (v !== source) {\n        dist[v] = Infinity\n      }\n      queue.insert(dist[v], v, v)\n    })\n\n    while (!queue.isEmpty()) {\n      const u = queue.remove()!\n      scanned[u] = true\n\n      const neighbours = adjacencyList[u] || []\n      for (let i = 0; i < neighbours.length; i += 1) {\n        const v = neighbours[i]\n        if (!scanned[v]) {\n          const alt = dist[u] + weight(u, v)\n          if (alt < dist[v]) {\n            dist[v] = alt\n            previous[v] = u\n            queue.updatePriority(v, alt)\n          }\n        }\n      }\n    }\n\n    return previous\n  }\n}\n"],"mappings":"AAAA,SAASA,aAAa,QAAQ,iBAAiB;AAE/C,OAAM,IAAWC,QAAQ;AAAzB,WAAiBA,QAAQ;EAIvB,SAAgBC,GAAGA,CACjBC,aAA4B,EAC5BC,MAAc,EACdC,MAAA,GAAiBA,CAACC,CAAC,EAAEC,CAAC,KAAK,CAAC;IAE5B,MAAMC,IAAI,GAA8B,EAAE;IAC1C,MAAMC,QAAQ,GAA8B,EAAE;IAC9C,MAAMC,OAAO,GAA+B,EAAE;IAC9C,MAAMC,KAAK,GAAG,IAAIX,aAAa,EAAU;IAEzCQ,IAAI,CAACJ,MAAM,CAAC,GAAG,CAAC;IAEhBQ,MAAM,CAACC,IAAI,CAACV,aAAa,CAAC,CAACW,OAAO,CAAEP,CAAC,IAAI;MACvC,IAAIA,CAAC,KAAKH,MAAM,EAAE;QAChBI,IAAI,CAACD,CAAC,CAAC,GAAGQ,QAAQ;;MAEpBJ,KAAK,CAACK,MAAM,CAACR,IAAI,CAACD,CAAC,CAAC,EAAEA,CAAC,EAAEA,CAAC,CAAC;IAC7B,CAAC,CAAC;IAEF,OAAO,CAACI,KAAK,CAACM,OAAO,EAAE,EAAE;MACvB,MAAMX,CAAC,GAAGK,KAAK,CAACO,MAAM,EAAG;MACzBR,OAAO,CAACJ,CAAC,CAAC,GAAG,IAAI;MAEjB,MAAMa,UAAU,GAAGhB,aAAa,CAACG,CAAC,CAAC,IAAI,EAAE;MACzC,KAAK,IAAIc,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,UAAU,CAACE,MAAM,EAAED,CAAC,IAAI,CAAC,EAAE;QAC7C,MAAMb,CAAC,GAAGY,UAAU,CAACC,CAAC,CAAC;QACvB,IAAI,CAACV,OAAO,CAACH,CAAC,CAAC,EAAE;UACf,MAAMe,GAAG,GAAGd,IAAI,CAACF,CAAC,CAAC,GAAGD,MAAM,CAACC,CAAC,EAAEC,CAAC,CAAC;UAClC,IAAIe,GAAG,GAAGd,IAAI,CAACD,CAAC,CAAC,EAAE;YACjBC,IAAI,CAACD,CAAC,CAAC,GAAGe,GAAG;YACbb,QAAQ,CAACF,CAAC,CAAC,GAAGD,CAAC;YACfK,KAAK,CAACY,cAAc,CAAChB,CAAC,EAAEe,GAAG,CAAC;;;;;IAMpC,OAAOb,QAAQ;EACjB;EAtCgBR,QAAA,CAAAC,GAAG,GAAAA,GAsClB;AACH,CAAC,EA3CgBD,QAAQ,KAARA,QAAQ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}