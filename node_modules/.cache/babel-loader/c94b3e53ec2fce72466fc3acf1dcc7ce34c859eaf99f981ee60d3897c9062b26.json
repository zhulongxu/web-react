{"ast":null,"code":"import { ObjectExt, NumberExt, Dom, FunctionExt } from '@antv/x6-common';\nexport const text = {\n  qualify(text, {\n    attrs\n  }) {\n    return attrs.textWrap == null || !ObjectExt.isPlainObject(attrs.textWrap);\n  },\n  set(text, {\n    view,\n    elem,\n    attrs\n  }) {\n    const cacheName = 'x6-text';\n    const cache = Dom.data(elem, cacheName);\n    const json = str => {\n      try {\n        return JSON.parse(str);\n      } catch (error) {\n        return str;\n      }\n    };\n    const options = {\n      x: attrs.x,\n      eol: attrs.eol,\n      annotations: json(attrs.annotations),\n      textPath: json(attrs['text-path'] || attrs.textPath),\n      textVerticalAnchor: attrs['text-vertical-anchor'] || attrs.textVerticalAnchor,\n      displayEmpty: (attrs['display-empty'] || attrs.displayEmpty) === 'true',\n      lineHeight: attrs['line-height'] || attrs.lineHeight\n    };\n    const fontSize = attrs['font-size'] || attrs.fontSize;\n    const textHash = JSON.stringify([text, options]);\n    if (fontSize) {\n      elem.setAttribute('font-size', fontSize);\n    }\n    // Updates the text only if there was a change in the string\n    // or any of its attributes.\n    if (cache == null || cache !== textHash) {\n      // Text Along Path Selector\n      const textPath = options.textPath;\n      if (textPath != null && typeof textPath === 'object') {\n        const selector = textPath.selector;\n        if (typeof selector === 'string') {\n          const pathNode = view.find(selector)[0];\n          if (pathNode instanceof SVGPathElement) {\n            Dom.ensureId(pathNode);\n            options.textPath = Object.assign({\n              'xlink:href': `#${pathNode.id}`\n            }, textPath);\n          }\n        }\n      }\n      Dom.text(elem, `${text}`, options);\n      Dom.data(elem, cacheName, textHash);\n    }\n  }\n};\nexport const textWrap = {\n  qualify: ObjectExt.isPlainObject,\n  set(val, {\n    view,\n    elem,\n    attrs,\n    refBBox\n  }) {\n    const info = val;\n    // option `width`\n    const width = info.width || 0;\n    if (NumberExt.isPercentage(width)) {\n      refBBox.width *= parseFloat(width) / 100;\n    } else if (width <= 0) {\n      refBBox.width += width;\n    } else {\n      refBBox.width = width;\n    }\n    // option `height`\n    const height = info.height || 0;\n    if (NumberExt.isPercentage(height)) {\n      refBBox.height *= parseFloat(height) / 100;\n    } else if (height <= 0) {\n      refBBox.height += height;\n    } else {\n      refBBox.height = height;\n    }\n    // option `text`\n    let wrappedText;\n    let txt = info.text;\n    if (txt == null) {\n      // the edge of the label is assigned to txt\n      txt = attrs.text || (elem === null || elem === void 0 ? void 0 : elem.textContent);\n    }\n    if (txt != null) {\n      wrappedText = Dom.breakText(`${txt}`, refBBox, {\n        'font-weight': attrs['font-weight'] || attrs.fontWeight,\n        'font-size': attrs['font-size'] || attrs.fontSize,\n        'font-family': attrs['font-family'] || attrs.fontFamily,\n        lineHeight: attrs.lineHeight\n      }, {\n        // svgDocument: view.graph.view.svg,\n        ellipsis: info.ellipsis\n        // hyphen: info.hyphen as string,\n        // breakWord: info.breakWord as boolean,\n      });\n    } else {\n      wrappedText = '';\n    }\n    FunctionExt.call(text.set, this, wrappedText, {\n      view,\n      elem,\n      attrs,\n      refBBox,\n      cell: view.cell\n    });\n  }\n};\nconst isTextInUse = (val, {\n  attrs\n}) => {\n  return attrs.text !== undefined;\n};\nexport const lineHeight = {\n  qualify: isTextInUse\n};\nexport const textVerticalAnchor = {\n  qualify: isTextInUse\n};\nexport const textPath = {\n  qualify: isTextInUse\n};\nexport const annotations = {\n  qualify: isTextInUse\n};\nexport const eol = {\n  qualify: isTextInUse\n};\nexport const displayEmpty = {\n  qualify: isTextInUse\n};","map":{"version":3,"names":["ObjectExt","NumberExt","Dom","FunctionExt","text","qualify","attrs","textWrap","isPlainObject","set","view","elem","cacheName","cache","data","json","str","JSON","parse","error","options","x","eol","annotations","textPath","textVerticalAnchor","displayEmpty","lineHeight","fontSize","textHash","stringify","setAttribute","selector","pathNode","find","SVGPathElement","ensureId","Object","assign","id","val","refBBox","info","width","isPercentage","parseFloat","height","wrappedText","txt","textContent","breakText","fontWeight","fontFamily","ellipsis","call","cell","isTextInUse","undefined"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/src/registry/attr/text.ts"],"sourcesContent":["import {\n  ObjectExt,\n  JSONObject,\n  NumberExt,\n  Dom,\n  FunctionExt,\n  Text,\n} from '@antv/x6-common'\nimport { Attr } from './index'\n\nexport const text: Attr.Definition = {\n  qualify(text, { attrs }) {\n    return attrs.textWrap == null || !ObjectExt.isPlainObject(attrs.textWrap)\n  },\n  set(text, { view, elem, attrs }) {\n    const cacheName = 'x6-text'\n    const cache = Dom.data(elem, cacheName)\n    const json = <T>(str: any) => {\n      try {\n        return JSON.parse(str) as T\n      } catch (error) {\n        return str\n      }\n    }\n    const options: Dom.TextOptions = {\n      x: attrs.x as string | number,\n      eol: attrs.eol as string,\n      annotations: json(attrs.annotations) as\n        | Text.Annotation\n        | Text.Annotation[],\n      textPath: json(attrs['text-path'] || attrs.textPath),\n      textVerticalAnchor: (attrs['text-vertical-anchor'] ||\n        attrs.textVerticalAnchor) as 'middle' | 'bottom' | 'top' | number,\n      displayEmpty: (attrs['display-empty'] || attrs.displayEmpty) === 'true',\n      lineHeight: (attrs['line-height'] || attrs.lineHeight) as string,\n    }\n\n    const fontSize = (attrs['font-size'] || attrs.fontSize) as string\n    const textHash = JSON.stringify([text, options])\n\n    if (fontSize) {\n      elem.setAttribute('font-size', fontSize)\n    }\n\n    // Updates the text only if there was a change in the string\n    // or any of its attributes.\n    if (cache == null || cache !== textHash) {\n      // Text Along Path Selector\n      const textPath = options.textPath as any\n      if (textPath != null && typeof textPath === 'object') {\n        const selector = textPath.selector\n        if (typeof selector === 'string') {\n          const pathNode = view.find(selector)[0]\n          if (pathNode instanceof SVGPathElement) {\n            Dom.ensureId(pathNode)\n            options.textPath = {\n              'xlink:href': `#${pathNode.id}`,\n              ...textPath,\n            }\n          }\n        }\n      }\n\n      Dom.text(elem as SVGElement, `${text}`, options)\n      Dom.data(elem, cacheName, textHash)\n    }\n  },\n}\n\nexport const textWrap: Attr.Definition = {\n  qualify: ObjectExt.isPlainObject,\n  set(val, { view, elem, attrs, refBBox }) {\n    const info = val as JSONObject\n\n    // option `width`\n    const width = info.width || 0\n    if (NumberExt.isPercentage(width)) {\n      refBBox.width *= parseFloat(width) / 100\n    } else if (width <= 0) {\n      refBBox.width += width as number\n    } else {\n      refBBox.width = width as number\n    }\n\n    // option `height`\n    const height = info.height || 0\n    if (NumberExt.isPercentage(height)) {\n      refBBox.height *= parseFloat(height) / 100\n    } else if (height <= 0) {\n      refBBox.height += height as number\n    } else {\n      refBBox.height = height as number\n    }\n\n    // option `text`\n    let wrappedText\n    let txt = info.text\n    if (txt == null) {\n      // the edge of the label is assigned to txt\n      txt = attrs.text || elem?.textContent\n    }\n\n    if (txt != null) {\n      wrappedText = Dom.breakText(\n        `${txt}`,\n        refBBox,\n        {\n          'font-weight': attrs['font-weight'] || attrs.fontWeight,\n          'font-size': attrs['font-size'] || attrs.fontSize,\n          'font-family': attrs['font-family'] || attrs.fontFamily,\n          lineHeight: attrs.lineHeight,\n        },\n        {\n          // svgDocument: view.graph.view.svg,\n          ellipsis: info.ellipsis as string,\n          // hyphen: info.hyphen as string,\n          // breakWord: info.breakWord as boolean,\n        },\n      )\n    } else {\n      wrappedText = ''\n    }\n\n    FunctionExt.call(text.set, this, wrappedText, {\n      view,\n      elem,\n      attrs,\n      refBBox,\n      cell: view.cell,\n    })\n  },\n}\n\nconst isTextInUse: Attr.QualifyFucntion = (val, { attrs }) => {\n  return attrs.text !== undefined\n}\n\nexport const lineHeight: Attr.Definition = {\n  qualify: isTextInUse,\n}\n\nexport const textVerticalAnchor: Attr.Definition = {\n  qualify: isTextInUse,\n}\n\nexport const textPath: Attr.Definition = {\n  qualify: isTextInUse,\n}\n\nexport const annotations: Attr.Definition = {\n  qualify: isTextInUse,\n}\n\nexport const eol: Attr.Definition = {\n  qualify: isTextInUse,\n}\n\nexport const displayEmpty: Attr.Definition = {\n  qualify: isTextInUse,\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}