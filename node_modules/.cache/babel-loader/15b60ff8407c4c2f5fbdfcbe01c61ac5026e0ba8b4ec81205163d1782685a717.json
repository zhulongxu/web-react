{"ast":null,"code":"import { attr } from './attr';\nimport { isSVGGraphicsElement } from './elem';\nimport { createSVGTransform, parseTransformString, transformStringToMatrix, matrixToTransformString, createSVGMatrix } from './matrix';\nexport function transform(elem, matrix, options = {}) {\n  if (matrix == null) {\n    return transformStringToMatrix(attr(elem, 'transform'));\n  }\n  if (options.absolute) {\n    elem.setAttribute('transform', matrixToTransformString(matrix));\n    return;\n  }\n  const transformList = elem.transform;\n  const svgTransform = createSVGTransform(matrix);\n  transformList.baseVal.appendItem(svgTransform);\n}\nexport function translate(elem, tx, ty = 0, options = {}) {\n  let transformAttr = attr(elem, 'transform');\n  const transform = parseTransformString(transformAttr);\n  if (tx == null) {\n    return transform.translation;\n  }\n  transformAttr = transform.raw;\n  transformAttr = transformAttr.replace(/translate\\([^)]*\\)/g, '').trim();\n  const newTx = options.absolute ? tx : transform.translation.tx + tx;\n  const newTy = options.absolute ? ty : transform.translation.ty + ty;\n  const newTranslate = `translate(${newTx},${newTy})`;\n  // Note that `translate()` is always the first transformation. This is\n  // usually the desired case.\n  elem.setAttribute('transform', `${newTranslate} ${transformAttr}`.trim());\n}\nexport function rotate(elem, angle, cx, cy, options = {}) {\n  let transformAttr = attr(elem, 'transform');\n  const transform = parseTransformString(transformAttr);\n  if (angle == null) {\n    return transform.rotation;\n  }\n  transformAttr = transform.raw;\n  transformAttr = transformAttr.replace(/rotate\\([^)]*\\)/g, '').trim();\n  angle %= 360; // eslint-disable-line\n  const newAngle = options.absolute ? angle : transform.rotation.angle + angle;\n  const newOrigin = cx != null && cy != null ? `,${cx},${cy}` : '';\n  const newRotate = `rotate(${newAngle}${newOrigin})`;\n  elem.setAttribute('transform', `${transformAttr} ${newRotate}`.trim());\n}\nexport function scale(elem, sx, sy) {\n  let transformAttr = attr(elem, 'transform');\n  const transform = parseTransformString(transformAttr);\n  if (sx == null) {\n    return transform.scale;\n  }\n  sy = sy == null ? sx : sy; // eslint-disable-line\n  transformAttr = transform.raw;\n  transformAttr = transformAttr.replace(/scale\\([^)]*\\)/g, '').trim();\n  const newScale = `scale(${sx},${sy})`;\n  elem.setAttribute('transform', `${transformAttr} ${newScale}`.trim());\n}\n/**\n * Returns an DOMMatrix that specifies the transformation necessary\n * to convert `elem` coordinate system into `target` coordinate system.\n */\nexport function getTransformToElement(elem, target) {\n  if (isSVGGraphicsElement(target) && isSVGGraphicsElement(elem)) {\n    const targetCTM = target.getScreenCTM();\n    const nodeCTM = elem.getScreenCTM();\n    if (targetCTM && nodeCTM) {\n      return targetCTM.inverse().multiply(nodeCTM);\n    }\n  }\n  // Could not get actual transformation matrix\n  return createSVGMatrix();\n}\n/**\n * Returns an DOMMatrix that specifies the transformation necessary\n * to convert `elem` coordinate system into `target` coordinate system.\n * Unlike getTransformToElement, elem is child of target,Because of the reduction in DOM API calls,\n * there is a significant performance improvement.\n */\nexport function getTransformToParentElement(elem, target) {\n  let matrix = createSVGMatrix();\n  if (isSVGGraphicsElement(target) && isSVGGraphicsElement(elem)) {\n    let node = elem;\n    const matrixList = [];\n    while (node && node !== target) {\n      const transform = node.getAttribute('transform') || null;\n      const nodeMatrix = transformStringToMatrix(transform);\n      matrixList.push(nodeMatrix);\n      node = node.parentNode;\n    }\n    matrixList.reverse().forEach(m => {\n      matrix = matrix.multiply(m);\n    });\n  }\n  return matrix;\n}\n/**\n * Converts a global point with coordinates `x` and `y` into the\n * coordinate space of the element.\n */\nexport function toLocalPoint(elem, x, y) {\n  const svg = elem instanceof SVGSVGElement ? elem : elem.ownerSVGElement;\n  const p = svg.createSVGPoint();\n  p.x = x;\n  p.y = y;\n  try {\n    const ctm = svg.getScreenCTM();\n    const globalPoint = p.matrixTransform(ctm.inverse());\n    const globalToLocalMatrix = getTransformToElement(elem, svg).inverse();\n    return globalPoint.matrixTransform(globalToLocalMatrix);\n  } catch (e) {\n    return p;\n  }\n}","map":{"version":3,"names":["attr","isSVGGraphicsElement","createSVGTransform","parseTransformString","transformStringToMatrix","matrixToTransformString","createSVGMatrix","transform","elem","matrix","options","absolute","setAttribute","transformList","svgTransform","baseVal","appendItem","translate","tx","ty","transformAttr","translation","raw","replace","trim","newTx","newTy","newTranslate","rotate","angle","cx","cy","rotation","newAngle","newOrigin","newRotate","scale","sx","sy","newScale","getTransformToElement","target","targetCTM","getScreenCTM","nodeCTM","inverse","multiply","getTransformToParentElement","node","matrixList","getAttribute","nodeMatrix","push","parentNode","reverse","forEach","m","toLocalPoint","x","y","svg","SVGSVGElement","ownerSVGElement","p","createSVGPoint","ctm","globalPoint","matrixTransform","globalToLocalMatrix","e"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/src/dom/transform.ts"],"sourcesContent":["import { attr } from './attr'\nimport { isSVGGraphicsElement } from './elem'\nimport {\n  Scale,\n  Rotation,\n  Translation,\n  createSVGTransform,\n  parseTransformString,\n  transformStringToMatrix,\n  matrixToTransformString,\n  createSVGMatrix,\n} from './matrix'\n\nexport interface TransformOptions {\n  absolute?: boolean\n}\n\nexport function transform(elem: Element): DOMMatrix\nexport function transform(\n  elem: SVGElement,\n  matrix: DOMMatrix,\n  options?: TransformOptions,\n): void\nexport function transform(\n  elem: SVGGraphicsElement,\n  matrix?: DOMMatrix,\n  options: TransformOptions = {},\n) {\n  if (matrix == null) {\n    return transformStringToMatrix(attr(elem, 'transform'))\n  }\n\n  if (options.absolute) {\n    elem.setAttribute('transform', matrixToTransformString(matrix))\n    return\n  }\n\n  const transformList = elem.transform\n  const svgTransform = createSVGTransform(matrix)\n  transformList.baseVal.appendItem(svgTransform)\n}\n\nexport function translate(elem: Element): Translation\nexport function translate(\n  elem: Element,\n  tx: number,\n  ty?: number,\n  options?: TransformOptions,\n): void\nexport function translate(\n  elem: Element,\n  tx?: number,\n  ty = 0,\n  options: TransformOptions = {},\n) {\n  let transformAttr = attr(elem, 'transform')\n  const transform = parseTransformString(transformAttr)\n  if (tx == null) {\n    return transform.translation\n  }\n\n  transformAttr = transform.raw\n  transformAttr = transformAttr.replace(/translate\\([^)]*\\)/g, '').trim()\n\n  const newTx = options.absolute ? tx : transform.translation.tx + tx\n  const newTy = options.absolute ? ty : transform.translation.ty + ty\n  const newTranslate = `translate(${newTx},${newTy})`\n\n  // Note that `translate()` is always the first transformation. This is\n  // usually the desired case.\n  elem.setAttribute('transform', `${newTranslate} ${transformAttr}`.trim())\n}\n\nexport function rotate(elem: Element): Rotation\nexport function rotate(\n  elem: Element,\n  angle: number,\n  cx?: number,\n  cy?: number,\n  options?: TransformOptions,\n): void\nexport function rotate(\n  elem: Element,\n  angle?: number,\n  cx?: number,\n  cy?: number,\n  options: TransformOptions = {},\n) {\n  let transformAttr = attr(elem, 'transform')\n  const transform = parseTransformString(transformAttr)\n\n  if (angle == null) {\n    return transform.rotation\n  }\n\n  transformAttr = transform.raw\n  transformAttr = transformAttr.replace(/rotate\\([^)]*\\)/g, '').trim()\n\n  angle %= 360 // eslint-disable-line\n  const newAngle = options.absolute ? angle : transform.rotation.angle + angle\n  const newOrigin = cx != null && cy != null ? `,${cx},${cy}` : ''\n  const newRotate = `rotate(${newAngle}${newOrigin})`\n  elem.setAttribute('transform', `${transformAttr} ${newRotate}`.trim())\n}\n\nexport function scale(elem: Element): Scale\nexport function scale(elem: Element, sx: number, sy?: number): void\nexport function scale(elem: Element, sx?: number, sy?: number) {\n  let transformAttr = attr(elem, 'transform')\n  const transform = parseTransformString(transformAttr)\n\n  if (sx == null) {\n    return transform.scale\n  }\n\n  sy = sy == null ? sx : sy // eslint-disable-line\n\n  transformAttr = transform.raw\n  transformAttr = transformAttr.replace(/scale\\([^)]*\\)/g, '').trim()\n  const newScale = `scale(${sx},${sy})`\n  elem.setAttribute('transform', `${transformAttr} ${newScale}`.trim())\n}\n\n/**\n * Returns an DOMMatrix that specifies the transformation necessary\n * to convert `elem` coordinate system into `target` coordinate system.\n */\nexport function getTransformToElement(elem: SVGElement, target: SVGElement) {\n  if (isSVGGraphicsElement(target) && isSVGGraphicsElement(elem)) {\n    const targetCTM = target.getScreenCTM()\n    const nodeCTM = elem.getScreenCTM()\n    if (targetCTM && nodeCTM) {\n      return targetCTM.inverse().multiply(nodeCTM)\n    }\n  }\n\n  // Could not get actual transformation matrix\n  return createSVGMatrix()\n}\n\n/**\n * Returns an DOMMatrix that specifies the transformation necessary\n * to convert `elem` coordinate system into `target` coordinate system.\n * Unlike getTransformToElement, elem is child of target,Because of the reduction in DOM API calls,\n * there is a significant performance improvement.\n */\nexport function getTransformToParentElement(\n  elem: SVGElement,\n  target: SVGElement,\n) {\n  let matrix = createSVGMatrix()\n\n  if (isSVGGraphicsElement(target) && isSVGGraphicsElement(elem)) {\n    let node = elem\n    const matrixList = []\n    while (node && node !== target) {\n      const transform = node.getAttribute('transform') || null\n      const nodeMatrix = transformStringToMatrix(transform)\n      matrixList.push(nodeMatrix)\n      node = node.parentNode as SVGGraphicsElement\n    }\n    matrixList.reverse().forEach((m) => {\n      matrix = matrix.multiply(m)\n    })\n  }\n\n  return matrix\n}\n\n/**\n * Converts a global point with coordinates `x` and `y` into the\n * coordinate space of the element.\n */\nexport function toLocalPoint(\n  elem: SVGElement | SVGSVGElement,\n  x: number,\n  y: number,\n) {\n  const svg =\n    elem instanceof SVGSVGElement\n      ? elem\n      : (elem.ownerSVGElement as SVGSVGElement)\n\n  const p = svg.createSVGPoint()\n  p.x = x\n  p.y = y\n\n  try {\n    const ctm = svg.getScreenCTM()!\n    const globalPoint = p.matrixTransform(ctm.inverse())\n    const globalToLocalMatrix = getTransformToElement(elem, svg).inverse()\n    return globalPoint.matrixTransform(globalToLocalMatrix)\n  } catch (e) {\n    return p\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}