{"ast":null,"code":"import { Point, Line, Rectangle, Polyline, Ellipse, Path } from '@antv/x6-geometry';\nimport { Dom } from '@antv/x6-common';\nimport { normalize } from '../registry/marker/util';\nexport var Util;\n(function (Util) {\n  Util.normalizeMarker = normalize;\n  /**\n   * Transforms point by an SVG transformation represented by `matrix`.\n   */\n  function transformPoint(point, matrix) {\n    const ret = Dom.createSVGPoint(point.x, point.y).matrixTransform(matrix);\n    return new Point(ret.x, ret.y);\n  }\n  Util.transformPoint = transformPoint;\n  /**\n   * Transforms line by an SVG transformation represented by `matrix`.\n   */\n  function transformLine(line, matrix) {\n    return new Line(transformPoint(line.start, matrix), transformPoint(line.end, matrix));\n  }\n  Util.transformLine = transformLine;\n  /**\n   * Transforms polyline by an SVG transformation represented by `matrix`.\n   */\n  function transformPolyline(polyline, matrix) {\n    let points = polyline instanceof Polyline ? polyline.points : polyline;\n    if (!Array.isArray(points)) {\n      points = [];\n    }\n    return new Polyline(points.map(p => transformPoint(p, matrix)));\n  }\n  Util.transformPolyline = transformPolyline;\n  function transformRectangle(rect, matrix) {\n    const svgDocument = Dom.createSvgElement('svg');\n    const p = svgDocument.createSVGPoint();\n    p.x = rect.x;\n    p.y = rect.y;\n    const corner1 = p.matrixTransform(matrix);\n    p.x = rect.x + rect.width;\n    p.y = rect.y;\n    const corner2 = p.matrixTransform(matrix);\n    p.x = rect.x + rect.width;\n    p.y = rect.y + rect.height;\n    const corner3 = p.matrixTransform(matrix);\n    p.x = rect.x;\n    p.y = rect.y + rect.height;\n    const corner4 = p.matrixTransform(matrix);\n    const minX = Math.min(corner1.x, corner2.x, corner3.x, corner4.x);\n    const maxX = Math.max(corner1.x, corner2.x, corner3.x, corner4.x);\n    const minY = Math.min(corner1.y, corner2.y, corner3.y, corner4.y);\n    const maxY = Math.max(corner1.y, corner2.y, corner3.y, corner4.y);\n    return new Rectangle(minX, minY, maxX - minX, maxY - minY);\n  }\n  Util.transformRectangle = transformRectangle;\n  /**\n   * Returns the bounding box of the element after transformations are\n   * applied. If `withoutTransformations` is `true`, transformations of\n   * the element will not be considered when computing the bounding box.\n   * If `target` is specified, bounding box will be computed relatively\n   * to the `target` element.\n   */\n  function bbox(elem, withoutTransformations, target) {\n    let box;\n    const ownerSVGElement = elem.ownerSVGElement;\n    // If the element is not in the live DOM, it does not have a bounding\n    // box defined and so fall back to 'zero' dimension element.\n    if (!ownerSVGElement) {\n      return new Rectangle(0, 0, 0, 0);\n    }\n    try {\n      box = elem.getBBox();\n    } catch (e) {\n      // Fallback for IE.\n      box = {\n        x: elem.clientLeft,\n        y: elem.clientTop,\n        width: elem.clientWidth,\n        height: elem.clientHeight\n      };\n    }\n    if (withoutTransformations) {\n      return Rectangle.create(box);\n    }\n    const matrix = Dom.getTransformToElement(elem, target || ownerSVGElement);\n    return transformRectangle(box, matrix);\n  }\n  Util.bbox = bbox;\n  /**\n   * Returns the bounding box of the element after transformations are\n   * applied. Unlike `bbox()`, this function fixes a browser implementation\n   * bug to return the correct bounding box if this elemenent is a group of\n   * svg elements (if `options.recursive` is specified).\n   */\n  function getBBox(elem, options = {}) {\n    let outputBBox;\n    const ownerSVGElement = elem.ownerSVGElement;\n    // If the element is not in the live DOM, it does not have a bounding box\n    // defined and so fall back to 'zero' dimension element.\n    // If the element is not an SVGGraphicsElement, we could not measure the\n    // bounding box either\n    if (!ownerSVGElement || !Dom.isSVGGraphicsElement(elem)) {\n      if (Dom.isHTMLElement(elem)) {\n        // If the element is a HTMLElement, return the position relative to the body\n        const {\n          left,\n          top,\n          width,\n          height\n        } = getBoundingOffsetRect(elem);\n        return new Rectangle(left, top, width, height);\n      }\n      return new Rectangle(0, 0, 0, 0);\n    }\n    let target = options.target;\n    const recursive = options.recursive;\n    if (!recursive) {\n      try {\n        outputBBox = elem.getBBox();\n      } catch (e) {\n        outputBBox = {\n          x: elem.clientLeft,\n          y: elem.clientTop,\n          width: elem.clientWidth,\n          height: elem.clientHeight\n        };\n      }\n      if (!target) {\n        return Rectangle.create(outputBBox);\n      }\n      // transform like target\n      const matrix = Dom.getTransformToElement(elem, target);\n      return transformRectangle(outputBBox, matrix);\n    }\n    // recursive\n    {\n      const children = elem.childNodes;\n      const n = children.length;\n      if (n === 0) {\n        return getBBox(elem, {\n          target\n        });\n      }\n      if (!target) {\n        target = elem; // eslint-disable-line\n      }\n      for (let i = 0; i < n; i += 1) {\n        const child = children[i];\n        let childBBox;\n        if (child.childNodes.length === 0) {\n          childBBox = getBBox(child, {\n            target\n          });\n        } else {\n          // if child is a group element, enter it with a recursive call\n          childBBox = getBBox(child, {\n            target,\n            recursive: true\n          });\n        }\n        if (!outputBBox) {\n          outputBBox = childBBox;\n        } else {\n          outputBBox = outputBBox.union(childBBox);\n        }\n      }\n      return outputBBox;\n    }\n  }\n  Util.getBBox = getBBox;\n  function getBoundingOffsetRect(elem) {\n    let left = 0;\n    let top = 0;\n    let width = 0;\n    let height = 0;\n    if (elem) {\n      let current = elem;\n      while (current) {\n        left += current.offsetLeft;\n        top += current.offsetTop;\n        current = current.offsetParent;\n        if (current) {\n          left += parseInt(Dom.getComputedStyle(current, 'borderLeft'), 10);\n          top += parseInt(Dom.getComputedStyle(current, 'borderTop'), 10);\n        }\n      }\n      width = elem.offsetWidth;\n      height = elem.offsetHeight;\n    }\n    return {\n      left,\n      top,\n      width,\n      height\n    };\n  }\n  Util.getBoundingOffsetRect = getBoundingOffsetRect;\n  /**\n   * Convert the SVGElement to an equivalent geometric shape. The element's\n   * transformations are not taken into account.\n   *\n   * SVGRectElement      => Rectangle\n   *\n   * SVGLineElement      => Line\n   *\n   * SVGCircleElement    => Ellipse\n   *\n   * SVGEllipseElement   => Ellipse\n   *\n   * SVGPolygonElement   => Polyline\n   *\n   * SVGPolylineElement  => Polyline\n   *\n   * SVGPathElement      => Path\n   *\n   * others              => Rectangle\n   */\n  function toGeometryShape(elem) {\n    const attr = name => {\n      const s = elem.getAttribute(name);\n      const v = s ? parseFloat(s) : 0;\n      return Number.isNaN(v) ? 0 : v;\n    };\n    switch (elem instanceof SVGElement && elem.nodeName.toLowerCase()) {\n      case 'rect':\n        return new Rectangle(attr('x'), attr('y'), attr('width'), attr('height'));\n      case 'circle':\n        return new Ellipse(attr('cx'), attr('cy'), attr('r'), attr('r'));\n      case 'ellipse':\n        return new Ellipse(attr('cx'), attr('cy'), attr('rx'), attr('ry'));\n      case 'polyline':\n        {\n          const points = Dom.getPointsFromSvgElement(elem);\n          return new Polyline(points);\n        }\n      case 'polygon':\n        {\n          const points = Dom.getPointsFromSvgElement(elem);\n          if (points.length > 1) {\n            points.push(points[0]);\n          }\n          return new Polyline(points);\n        }\n      case 'path':\n        {\n          let d = elem.getAttribute('d');\n          if (!Path.isValid(d)) {\n            d = Path.normalize(d);\n          }\n          return Path.parse(d);\n        }\n      case 'line':\n        {\n          return new Line(attr('x1'), attr('y1'), attr('x2'), attr('y2'));\n        }\n      default:\n        break;\n    }\n    // Anything else is a rectangle\n    return getBBox(elem);\n  }\n  Util.toGeometryShape = toGeometryShape;\n  function translateAndAutoOrient(elem, position, reference, target) {\n    const pos = Point.create(position);\n    const ref = Point.create(reference);\n    if (!target) {\n      const svg = elem instanceof SVGSVGElement ? elem : elem.ownerSVGElement;\n      target = svg; // eslint-disable-line\n    }\n    // Clean-up previously set transformations except the scale.\n    // If we didn't clean up the previous transformations then they'd\n    // add up with the old ones. Scale is an exception as it doesn't\n    // add up, consider: `this.scale(2).scale(2).scale(2)`. The result\n    // is that the element is scaled by the factor 2, not 8.\n    const s = Dom.scale(elem);\n    elem.setAttribute('transform', '');\n    const bbox = getBBox(elem, {\n      target\n    }).scale(s.sx, s.sy);\n    // 1. Translate to origin.\n    const translateToOrigin = Dom.createSVGTransform();\n    translateToOrigin.setTranslate(-bbox.x - bbox.width / 2, -bbox.y - bbox.height / 2);\n    // 2. Rotate around origin.\n    const rotateAroundOrigin = Dom.createSVGTransform();\n    const angle = pos.angleBetween(ref, pos.clone().translate(1, 0));\n    if (angle) rotateAroundOrigin.setRotate(angle, 0, 0);\n    // 3. Translate to the `position` + the offset (half my width)\n    //    towards the `reference` point.\n    const translateFromOrigin = Dom.createSVGTransform();\n    const finalPosition = pos.clone().move(ref, bbox.width / 2);\n    translateFromOrigin.setTranslate(2 * pos.x - finalPosition.x, 2 * pos.y - finalPosition.y);\n    // 4. Get the current transformation matrix of this node\n    const ctm = Dom.getTransformToElement(elem, target);\n    // 5. Apply transformations and the scale\n    const transform = Dom.createSVGTransform();\n    transform.setMatrix(translateFromOrigin.matrix.multiply(rotateAroundOrigin.matrix.multiply(translateToOrigin.matrix.multiply(ctm.scale(s.sx, s.sy)))));\n    elem.setAttribute('transform', Dom.matrixToTransformString(transform.matrix));\n  }\n  Util.translateAndAutoOrient = translateAndAutoOrient;\n  function findShapeNode(magnet) {\n    if (magnet == null) {\n      return null;\n    }\n    let node = magnet;\n    do {\n      let tagName = node.tagName;\n      if (typeof tagName !== 'string') return null;\n      tagName = tagName.toUpperCase();\n      if (Dom.hasClass(node, 'x6-port')) {\n        node = node.nextElementSibling;\n      } else if (tagName === 'G') {\n        node = node.firstElementChild;\n      } else if (tagName === 'TITLE') {\n        node = node.nextElementSibling;\n      } else break;\n    } while (node);\n    return node;\n  }\n  Util.findShapeNode = findShapeNode;\n  // BBox is calculated by the attribute and shape of the node.\n  // Because of the reduction in DOM API calls, there is a significant performance improvement.\n  function getBBoxV2(elem) {\n    const node = findShapeNode(elem);\n    if (!Dom.isSVGGraphicsElement(node)) {\n      if (Dom.isHTMLElement(elem)) {\n        const {\n          left,\n          top,\n          width,\n          height\n        } = getBoundingOffsetRect(elem);\n        return new Rectangle(left, top, width, height);\n      }\n      return new Rectangle(0, 0, 0, 0);\n    }\n    const shape = toGeometryShape(node);\n    const bbox = shape.bbox() || Rectangle.create();\n    // const transform = node.getAttribute('transform')\n    // if (transform) {\n    //   const nodeMatrix = Dom.transformStringToMatrix(transform)\n    //   return transformRectangle(bbox, nodeMatrix)\n    // }\n    return bbox;\n  }\n  Util.getBBoxV2 = getBBoxV2;\n})(Util || (Util = {}));","map":{"version":3,"names":["Point","Line","Rectangle","Polyline","Ellipse","Path","Dom","normalize","Util","normalizeMarker","transformPoint","point","matrix","ret","createSVGPoint","x","y","matrixTransform","transformLine","line","start","end","transformPolyline","polyline","points","Array","isArray","map","p","transformRectangle","rect","svgDocument","createSvgElement","corner1","width","corner2","height","corner3","corner4","minX","Math","min","maxX","max","minY","maxY","bbox","elem","withoutTransformations","target","box","ownerSVGElement","getBBox","e","clientLeft","clientTop","clientWidth","clientHeight","create","getTransformToElement","options","outputBBox","isSVGGraphicsElement","isHTMLElement","left","top","getBoundingOffsetRect","recursive","children","childNodes","n","length","i","child","childBBox","union","current","offsetLeft","offsetTop","offsetParent","parseInt","getComputedStyle","offsetWidth","offsetHeight","toGeometryShape","attr","name","s","getAttribute","v","parseFloat","Number","isNaN","SVGElement","nodeName","toLowerCase","getPointsFromSvgElement","push","d","isValid","parse","translateAndAutoOrient","position","reference","pos","ref","svg","SVGSVGElement","scale","setAttribute","sx","sy","translateToOrigin","createSVGTransform","setTranslate","rotateAroundOrigin","angle","angleBetween","clone","translate","setRotate","translateFromOrigin","finalPosition","move","ctm","transform","setMatrix","multiply","matrixToTransformString","findShapeNode","magnet","node","tagName","toUpperCase","hasClass","nextElementSibling","firstElementChild","getBBoxV2","shape"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/src/util/index.ts"],"sourcesContent":["import {\n  Point,\n  Line,\n  Rectangle,\n  Polyline,\n  Ellipse,\n  Path,\n} from '@antv/x6-geometry'\nimport { Dom, PointData, PointLike } from '@antv/x6-common'\nimport { normalize } from '../registry/marker/util'\n\nexport namespace Util {\n  export const normalizeMarker = normalize\n  /**\n   * Transforms point by an SVG transformation represented by `matrix`.\n   */\n  export function transformPoint(point: Point.PointLike, matrix: DOMMatrix) {\n    const ret = Dom.createSVGPoint(point.x, point.y).matrixTransform(matrix)\n    return new Point(ret.x, ret.y)\n  }\n\n  /**\n   * Transforms line by an SVG transformation represented by `matrix`.\n   */\n  export function transformLine(line: Line, matrix: DOMMatrix) {\n    return new Line(\n      transformPoint(line.start, matrix),\n      transformPoint(line.end, matrix),\n    )\n  }\n\n  /**\n   * Transforms polyline by an SVG transformation represented by `matrix`.\n   */\n  export function transformPolyline(polyline: Polyline, matrix: DOMMatrix) {\n    let points = polyline instanceof Polyline ? polyline.points : polyline\n    if (!Array.isArray(points)) {\n      points = []\n    }\n\n    return new Polyline(points.map((p) => transformPoint(p, matrix)))\n  }\n\n  export function transformRectangle(\n    rect: Rectangle.RectangleLike,\n    matrix: DOMMatrix,\n  ) {\n    const svgDocument = Dom.createSvgElement('svg') as SVGSVGElement\n    const p = svgDocument.createSVGPoint()\n\n    p.x = rect.x\n    p.y = rect.y\n    const corner1 = p.matrixTransform(matrix)\n\n    p.x = rect.x + rect.width\n    p.y = rect.y\n    const corner2 = p.matrixTransform(matrix)\n\n    p.x = rect.x + rect.width\n    p.y = rect.y + rect.height\n    const corner3 = p.matrixTransform(matrix)\n\n    p.x = rect.x\n    p.y = rect.y + rect.height\n    const corner4 = p.matrixTransform(matrix)\n\n    const minX = Math.min(corner1.x, corner2.x, corner3.x, corner4.x)\n    const maxX = Math.max(corner1.x, corner2.x, corner3.x, corner4.x)\n    const minY = Math.min(corner1.y, corner2.y, corner3.y, corner4.y)\n    const maxY = Math.max(corner1.y, corner2.y, corner3.y, corner4.y)\n\n    return new Rectangle(minX, minY, maxX - minX, maxY - minY)\n  }\n\n  /**\n   * Returns the bounding box of the element after transformations are\n   * applied. If `withoutTransformations` is `true`, transformations of\n   * the element will not be considered when computing the bounding box.\n   * If `target` is specified, bounding box will be computed relatively\n   * to the `target` element.\n   */\n  export function bbox(\n    elem: SVGElement,\n    withoutTransformations?: boolean,\n    target?: SVGElement,\n  ): Rectangle {\n    let box\n    const ownerSVGElement = elem.ownerSVGElement\n\n    // If the element is not in the live DOM, it does not have a bounding\n    // box defined and so fall back to 'zero' dimension element.\n    if (!ownerSVGElement) {\n      return new Rectangle(0, 0, 0, 0)\n    }\n\n    try {\n      box = (elem as SVGGraphicsElement).getBBox()\n    } catch (e) {\n      // Fallback for IE.\n      box = {\n        x: elem.clientLeft,\n        y: elem.clientTop,\n        width: elem.clientWidth,\n        height: elem.clientHeight,\n      }\n    }\n\n    if (withoutTransformations) {\n      return Rectangle.create(box)\n    }\n\n    const matrix = Dom.getTransformToElement(elem, target || ownerSVGElement)\n    return transformRectangle(box, matrix)\n  }\n\n  /**\n   * Returns the bounding box of the element after transformations are\n   * applied. Unlike `bbox()`, this function fixes a browser implementation\n   * bug to return the correct bounding box if this elemenent is a group of\n   * svg elements (if `options.recursive` is specified).\n   */\n  export function getBBox(\n    elem: SVGElement,\n    options: {\n      target?: SVGElement | null\n      recursive?: boolean\n    } = {},\n  ): Rectangle {\n    let outputBBox\n    const ownerSVGElement = elem.ownerSVGElement\n\n    // If the element is not in the live DOM, it does not have a bounding box\n    // defined and so fall back to 'zero' dimension element.\n    // If the element is not an SVGGraphicsElement, we could not measure the\n    // bounding box either\n    if (!ownerSVGElement || !Dom.isSVGGraphicsElement(elem)) {\n      if (Dom.isHTMLElement(elem)) {\n        // If the element is a HTMLElement, return the position relative to the body\n        const { left, top, width, height } = getBoundingOffsetRect(elem as any)\n        return new Rectangle(left, top, width, height)\n      }\n      return new Rectangle(0, 0, 0, 0)\n    }\n\n    let target = options.target\n    const recursive = options.recursive\n\n    if (!recursive) {\n      try {\n        outputBBox = elem.getBBox()\n      } catch (e) {\n        outputBBox = {\n          x: elem.clientLeft,\n          y: elem.clientTop,\n          width: elem.clientWidth,\n          height: elem.clientHeight,\n        }\n      }\n\n      if (!target) {\n        return Rectangle.create(outputBBox)\n      }\n\n      // transform like target\n      const matrix = Dom.getTransformToElement(elem, target)\n      return transformRectangle(outputBBox, matrix)\n    }\n\n    // recursive\n    {\n      const children = elem.childNodes\n      const n = children.length\n\n      if (n === 0) {\n        return getBBox(elem, {\n          target,\n        })\n      }\n\n      if (!target) {\n        target = elem // eslint-disable-line\n      }\n\n      for (let i = 0; i < n; i += 1) {\n        const child = children[i] as SVGElement\n        let childBBox\n\n        if (child.childNodes.length === 0) {\n          childBBox = getBBox(child, {\n            target,\n          })\n        } else {\n          // if child is a group element, enter it with a recursive call\n          childBBox = getBBox(child, {\n            target,\n            recursive: true,\n          })\n        }\n\n        if (!outputBBox) {\n          outputBBox = childBBox\n        } else {\n          outputBBox = outputBBox.union(childBBox)\n        }\n      }\n\n      return outputBBox as Rectangle\n    }\n  }\n\n  export function getBoundingOffsetRect(elem: HTMLElement) {\n    let left = 0\n    let top = 0\n    let width = 0\n    let height = 0\n    if (elem) {\n      let current = elem as any\n      while (current) {\n        left += current.offsetLeft\n        top += current.offsetTop\n        current = current.offsetParent\n        if (current) {\n          left += parseInt(Dom.getComputedStyle(current, 'borderLeft'), 10)\n          top += parseInt(Dom.getComputedStyle(current, 'borderTop'), 10)\n        }\n      }\n      width = elem.offsetWidth\n      height = elem.offsetHeight\n    }\n    return {\n      left,\n      top,\n      width,\n      height,\n    }\n  }\n\n  /**\n   * Convert the SVGElement to an equivalent geometric shape. The element's\n   * transformations are not taken into account.\n   *\n   * SVGRectElement      => Rectangle\n   *\n   * SVGLineElement      => Line\n   *\n   * SVGCircleElement    => Ellipse\n   *\n   * SVGEllipseElement   => Ellipse\n   *\n   * SVGPolygonElement   => Polyline\n   *\n   * SVGPolylineElement  => Polyline\n   *\n   * SVGPathElement      => Path\n   *\n   * others              => Rectangle\n   */\n  export function toGeometryShape(elem: SVGElement) {\n    const attr = (name: string) => {\n      const s = elem.getAttribute(name)\n      const v = s ? parseFloat(s) : 0\n      return Number.isNaN(v) ? 0 : v\n    }\n\n    switch (elem instanceof SVGElement && elem.nodeName.toLowerCase()) {\n      case 'rect':\n        return new Rectangle(\n          attr('x'),\n          attr('y'),\n          attr('width'),\n          attr('height'),\n        )\n      case 'circle':\n        return new Ellipse(attr('cx'), attr('cy'), attr('r'), attr('r'))\n      case 'ellipse':\n        return new Ellipse(attr('cx'), attr('cy'), attr('rx'), attr('ry'))\n      case 'polyline': {\n        const points = Dom.getPointsFromSvgElement(elem as SVGPolylineElement)\n        return new Polyline(points)\n      }\n      case 'polygon': {\n        const points = Dom.getPointsFromSvgElement(elem as SVGPolygonElement)\n        if (points.length > 1) {\n          points.push(points[0])\n        }\n        return new Polyline(points)\n      }\n      case 'path': {\n        let d = elem.getAttribute('d') as string\n        if (!Path.isValid(d)) {\n          d = Path.normalize(d)\n        }\n        return Path.parse(d)\n      }\n      case 'line': {\n        return new Line(attr('x1'), attr('y1'), attr('x2'), attr('y2'))\n      }\n      default:\n        break\n    }\n\n    // Anything else is a rectangle\n    return getBBox(elem)\n  }\n\n  export function translateAndAutoOrient(\n    elem: SVGElement,\n    position: PointLike | PointData,\n    reference: PointLike | PointData,\n    target?: SVGElement,\n  ) {\n    const pos = Point.create(position)\n    const ref = Point.create(reference)\n\n    if (!target) {\n      const svg = elem instanceof SVGSVGElement ? elem : elem.ownerSVGElement!\n      target = svg // eslint-disable-line\n    }\n\n    // Clean-up previously set transformations except the scale.\n    // If we didn't clean up the previous transformations then they'd\n    // add up with the old ones. Scale is an exception as it doesn't\n    // add up, consider: `this.scale(2).scale(2).scale(2)`. The result\n    // is that the element is scaled by the factor 2, not 8.\n    const s = Dom.scale(elem)\n    elem.setAttribute('transform', '')\n    const bbox = getBBox(elem, {\n      target,\n    }).scale(s.sx, s.sy)\n\n    // 1. Translate to origin.\n    const translateToOrigin = Dom.createSVGTransform()\n    translateToOrigin.setTranslate(\n      -bbox.x - bbox.width / 2,\n      -bbox.y - bbox.height / 2,\n    )\n\n    // 2. Rotate around origin.\n    const rotateAroundOrigin = Dom.createSVGTransform()\n    const angle = pos.angleBetween(ref, pos.clone().translate(1, 0))\n    if (angle) rotateAroundOrigin.setRotate(angle, 0, 0)\n\n    // 3. Translate to the `position` + the offset (half my width)\n    //    towards the `reference` point.\n    const translateFromOrigin = Dom.createSVGTransform()\n    const finalPosition = pos.clone().move(ref, bbox.width / 2)\n    translateFromOrigin.setTranslate(\n      2 * pos.x - finalPosition.x,\n      2 * pos.y - finalPosition.y,\n    )\n\n    // 4. Get the current transformation matrix of this node\n    const ctm = Dom.getTransformToElement(elem, target)\n\n    // 5. Apply transformations and the scale\n    const transform = Dom.createSVGTransform()\n    transform.setMatrix(\n      translateFromOrigin.matrix.multiply(\n        rotateAroundOrigin.matrix.multiply(\n          translateToOrigin.matrix.multiply(ctm.scale(s.sx, s.sy)),\n        ),\n      ),\n    )\n\n    elem.setAttribute(\n      'transform',\n      Dom.matrixToTransformString(transform.matrix),\n    )\n  }\n\n  export function findShapeNode(magnet: Element) {\n    if (magnet == null) {\n      return null\n    }\n\n    let node = magnet\n    do {\n      let tagName = node.tagName\n      if (typeof tagName !== 'string') return null\n      tagName = tagName.toUpperCase()\n      if (Dom.hasClass(node, 'x6-port')) {\n        node = node.nextElementSibling as Element\n      } else if (tagName === 'G') {\n        node = node.firstElementChild as Element\n      } else if (tagName === 'TITLE') {\n        node = node.nextElementSibling as Element\n      } else break\n    } while (node)\n\n    return node\n  }\n\n  // BBox is calculated by the attribute and shape of the node.\n  // Because of the reduction in DOM API calls, there is a significant performance improvement.\n  export function getBBoxV2(elem: SVGElement) {\n    const node = findShapeNode(elem)\n\n    if (!Dom.isSVGGraphicsElement(node)) {\n      if (Dom.isHTMLElement(elem)) {\n        const { left, top, width, height } = getBoundingOffsetRect(elem as any)\n        return new Rectangle(left, top, width, height)\n      }\n      return new Rectangle(0, 0, 0, 0)\n    }\n\n    const shape = toGeometryShape(node)\n    const bbox = shape.bbox() || Rectangle.create()\n\n    // const transform = node.getAttribute('transform')\n    // if (transform) {\n    //   const nodeMatrix = Dom.transformStringToMatrix(transform)\n    //   return transformRectangle(bbox, nodeMatrix)\n    // }\n\n    return bbox\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}