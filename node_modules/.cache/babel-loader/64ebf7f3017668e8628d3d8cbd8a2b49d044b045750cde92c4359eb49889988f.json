{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport * as React from 'react';\nimport { getPtg } from './useSizes';\n/**\n * Handle user drag resize logic.\n */\nexport default function useResize(items, resizableInfos, percentSizes, containerSize, updateSizes) {\n  const limitSizes = items.map(item => [item.min, item.max]);\n  const mergedContainerSize = containerSize || 0;\n  const ptg2px = ptg => ptg * mergedContainerSize;\n  // ======================== Resize ========================\n  function getLimitSize(str, defaultLimit) {\n    if (typeof str === 'string') {\n      return ptg2px(getPtg(str));\n    }\n    return str !== null && str !== void 0 ? str : defaultLimit;\n  }\n  // Real px sizes\n  const [cacheSizes, setCacheSizes] = React.useState([]);\n  /**\n   * When start drag, check the direct is `start` or `end`.\n   * This will handle when 2 splitter bar are in the same position.\n   */\n  const [movingIndex, setMovingIndex] = React.useState(null);\n  const getPxSizes = () => percentSizes.map(ptg2px);\n  const onOffsetStart = index => {\n    setCacheSizes(getPxSizes());\n    setMovingIndex({\n      index,\n      confirmed: false\n    });\n  };\n  const onOffsetUpdate = (index, offset) => {\n    var _a;\n    // First time trigger move index update is not sync in the state\n    let confirmedIndex = null;\n    // We need to know what the real index is.\n    if ((!movingIndex || !movingIndex.confirmed) && offset !== 0) {\n      // Search for the real index\n      if (offset > 0) {\n        confirmedIndex = index;\n        setMovingIndex({\n          index,\n          confirmed: true\n        });\n      } else {\n        for (let i = index; i >= 0; i -= 1) {\n          if (cacheSizes[i] > 0 && resizableInfos[i].resizable) {\n            confirmedIndex = i;\n            setMovingIndex({\n              index: i,\n              confirmed: true\n            });\n            break;\n          }\n        }\n      }\n    }\n    const mergedIndex = (_a = confirmedIndex !== null && confirmedIndex !== void 0 ? confirmedIndex : movingIndex === null || movingIndex === void 0 ? void 0 : movingIndex.index) !== null && _a !== void 0 ? _a : index;\n    const numSizes = _toConsumableArray(cacheSizes);\n    const nextIndex = mergedIndex + 1;\n    // Get boundary\n    const startMinSize = getLimitSize(limitSizes[mergedIndex][0], 0);\n    const endMinSize = getLimitSize(limitSizes[nextIndex][0], 0);\n    const startMaxSize = getLimitSize(limitSizes[mergedIndex][1], mergedContainerSize);\n    const endMaxSize = getLimitSize(limitSizes[nextIndex][1], mergedContainerSize);\n    let mergedOffset = offset;\n    // Align with the boundary\n    if (numSizes[mergedIndex] + mergedOffset < startMinSize) {\n      mergedOffset = startMinSize - numSizes[mergedIndex];\n    }\n    if (numSizes[nextIndex] - mergedOffset < endMinSize) {\n      mergedOffset = numSizes[nextIndex] - endMinSize;\n    }\n    if (numSizes[mergedIndex] + mergedOffset > startMaxSize) {\n      mergedOffset = startMaxSize - numSizes[mergedIndex];\n    }\n    if (numSizes[nextIndex] - mergedOffset > endMaxSize) {\n      mergedOffset = numSizes[nextIndex] - endMaxSize;\n    }\n    // Do offset\n    numSizes[mergedIndex] += mergedOffset;\n    numSizes[nextIndex] -= mergedOffset;\n    updateSizes(numSizes);\n    return numSizes;\n  };\n  const onOffsetEnd = () => {\n    setMovingIndex(null);\n  };\n  // ======================= Collapse =======================\n  const onCollapse = (index, type) => {\n    const currentSizes = getPxSizes();\n    const currentIndex = type === 'start' ? index : index + 1;\n    const targetIndex = type === 'start' ? index + 1 : index;\n    const currentSize = currentSizes[currentIndex];\n    const targetSize = currentSizes[targetIndex];\n    if (currentSize !== 0 && targetSize !== 0) {\n      // Collapse directly\n      currentSizes[currentIndex] = 0;\n      currentSizes[targetIndex] += currentSize;\n    } else {\n      const totalSize = currentSize + targetSize;\n      const currentSizeMin = getLimitSize(limitSizes[currentIndex][0], 0);\n      const currentSizeMax = getLimitSize(limitSizes[currentIndex][1], mergedContainerSize);\n      const targetSizeMin = getLimitSize(limitSizes[targetIndex][0], 0);\n      const targetSizeMax = getLimitSize(limitSizes[targetIndex][1], mergedContainerSize);\n      const limitStart = Math.max(currentSizeMin, totalSize - targetSizeMax);\n      const limitEnd = Math.min(currentSizeMax, totalSize - targetSizeMin);\n      const halfOffset = (limitEnd - limitStart) / 2;\n      currentSizes[currentIndex] -= halfOffset;\n      currentSizes[targetIndex] += halfOffset;\n    }\n    updateSizes(currentSizes);\n    return currentSizes;\n  };\n  return [onOffsetStart, onOffsetUpdate, onOffsetEnd, onCollapse, movingIndex === null || movingIndex === void 0 ? void 0 : movingIndex.index];\n}","map":{"version":3,"names":["_toConsumableArray","React","getPtg","useResize","items","resizableInfos","percentSizes","containerSize","updateSizes","limitSizes","map","item","min","max","mergedContainerSize","ptg2px","ptg","getLimitSize","str","defaultLimit","cacheSizes","setCacheSizes","useState","movingIndex","setMovingIndex","getPxSizes","onOffsetStart","index","confirmed","onOffsetUpdate","offset","_a","confirmedIndex","i","resizable","mergedIndex","numSizes","nextIndex","startMinSize","endMinSize","startMaxSize","endMaxSize","mergedOffset","onOffsetEnd","onCollapse","type","currentSizes","currentIndex","targetIndex","currentSize","targetSize","totalSize","currentSizeMin","currentSizeMax","targetSizeMin","targetSizeMax","limitStart","Math","limitEnd","halfOffset"],"sources":["/home/devbox/project/node_modules/.pnpm/antd@5.22.2_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/splitter/hooks/useResize.js"],"sourcesContent":["import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport * as React from 'react';\nimport { getPtg } from './useSizes';\n/**\n * Handle user drag resize logic.\n */\nexport default function useResize(items, resizableInfos, percentSizes, containerSize, updateSizes) {\n  const limitSizes = items.map(item => [item.min, item.max]);\n  const mergedContainerSize = containerSize || 0;\n  const ptg2px = ptg => ptg * mergedContainerSize;\n  // ======================== Resize ========================\n  function getLimitSize(str, defaultLimit) {\n    if (typeof str === 'string') {\n      return ptg2px(getPtg(str));\n    }\n    return str !== null && str !== void 0 ? str : defaultLimit;\n  }\n  // Real px sizes\n  const [cacheSizes, setCacheSizes] = React.useState([]);\n  /**\n   * When start drag, check the direct is `start` or `end`.\n   * This will handle when 2 splitter bar are in the same position.\n   */\n  const [movingIndex, setMovingIndex] = React.useState(null);\n  const getPxSizes = () => percentSizes.map(ptg2px);\n  const onOffsetStart = index => {\n    setCacheSizes(getPxSizes());\n    setMovingIndex({\n      index,\n      confirmed: false\n    });\n  };\n  const onOffsetUpdate = (index, offset) => {\n    var _a;\n    // First time trigger move index update is not sync in the state\n    let confirmedIndex = null;\n    // We need to know what the real index is.\n    if ((!movingIndex || !movingIndex.confirmed) && offset !== 0) {\n      // Search for the real index\n      if (offset > 0) {\n        confirmedIndex = index;\n        setMovingIndex({\n          index,\n          confirmed: true\n        });\n      } else {\n        for (let i = index; i >= 0; i -= 1) {\n          if (cacheSizes[i] > 0 && resizableInfos[i].resizable) {\n            confirmedIndex = i;\n            setMovingIndex({\n              index: i,\n              confirmed: true\n            });\n            break;\n          }\n        }\n      }\n    }\n    const mergedIndex = (_a = confirmedIndex !== null && confirmedIndex !== void 0 ? confirmedIndex : movingIndex === null || movingIndex === void 0 ? void 0 : movingIndex.index) !== null && _a !== void 0 ? _a : index;\n    const numSizes = _toConsumableArray(cacheSizes);\n    const nextIndex = mergedIndex + 1;\n    // Get boundary\n    const startMinSize = getLimitSize(limitSizes[mergedIndex][0], 0);\n    const endMinSize = getLimitSize(limitSizes[nextIndex][0], 0);\n    const startMaxSize = getLimitSize(limitSizes[mergedIndex][1], mergedContainerSize);\n    const endMaxSize = getLimitSize(limitSizes[nextIndex][1], mergedContainerSize);\n    let mergedOffset = offset;\n    // Align with the boundary\n    if (numSizes[mergedIndex] + mergedOffset < startMinSize) {\n      mergedOffset = startMinSize - numSizes[mergedIndex];\n    }\n    if (numSizes[nextIndex] - mergedOffset < endMinSize) {\n      mergedOffset = numSizes[nextIndex] - endMinSize;\n    }\n    if (numSizes[mergedIndex] + mergedOffset > startMaxSize) {\n      mergedOffset = startMaxSize - numSizes[mergedIndex];\n    }\n    if (numSizes[nextIndex] - mergedOffset > endMaxSize) {\n      mergedOffset = numSizes[nextIndex] - endMaxSize;\n    }\n    // Do offset\n    numSizes[mergedIndex] += mergedOffset;\n    numSizes[nextIndex] -= mergedOffset;\n    updateSizes(numSizes);\n    return numSizes;\n  };\n  const onOffsetEnd = () => {\n    setMovingIndex(null);\n  };\n  // ======================= Collapse =======================\n  const onCollapse = (index, type) => {\n    const currentSizes = getPxSizes();\n    const currentIndex = type === 'start' ? index : index + 1;\n    const targetIndex = type === 'start' ? index + 1 : index;\n    const currentSize = currentSizes[currentIndex];\n    const targetSize = currentSizes[targetIndex];\n    if (currentSize !== 0 && targetSize !== 0) {\n      // Collapse directly\n      currentSizes[currentIndex] = 0;\n      currentSizes[targetIndex] += currentSize;\n    } else {\n      const totalSize = currentSize + targetSize;\n      const currentSizeMin = getLimitSize(limitSizes[currentIndex][0], 0);\n      const currentSizeMax = getLimitSize(limitSizes[currentIndex][1], mergedContainerSize);\n      const targetSizeMin = getLimitSize(limitSizes[targetIndex][0], 0);\n      const targetSizeMax = getLimitSize(limitSizes[targetIndex][1], mergedContainerSize);\n      const limitStart = Math.max(currentSizeMin, totalSize - targetSizeMax);\n      const limitEnd = Math.min(currentSizeMax, totalSize - targetSizeMin);\n      const halfOffset = (limitEnd - limitStart) / 2;\n      currentSizes[currentIndex] -= halfOffset;\n      currentSizes[targetIndex] += halfOffset;\n    }\n    updateSizes(currentSizes);\n    return currentSizes;\n  };\n  return [onOffsetStart, onOffsetUpdate, onOffsetEnd, onCollapse, movingIndex === null || movingIndex === void 0 ? void 0 : movingIndex.index];\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}