{"ast":null,"code":"import { ObjectExt, Dom } from '@antv/x6-common';\nimport { Path, Rectangle, Ellipse } from '@antv/x6-geometry';\nimport { offset, getStrokeWidth, findShapeNode } from './util';\nimport { Util } from '../../util';\n/**\n * Places the connection point at the intersection between the\n * edge path end segment and the actual shape of the target magnet.\n */\nexport const boundary = function (line, view, magnet, options) {\n  let node;\n  let intersection;\n  const anchor = line.end;\n  const selector = options.selector;\n  if (typeof selector === 'string') {\n    node = view.findOne(selector);\n  } else if (Array.isArray(selector)) {\n    node = ObjectExt.getByPath(magnet, selector);\n  } else {\n    node = findShapeNode(magnet);\n  }\n  if (!Dom.isSVGGraphicsElement(node)) {\n    if (node === magnet || !Dom.isSVGGraphicsElement(magnet)) {\n      return anchor;\n    }\n    node = magnet;\n  }\n  const localShape = view.getShapeOfElement(node);\n  const magnetMatrix = view.getMatrixOfElement(node);\n  const translateMatrix = view.getRootTranslatedMatrix();\n  const rotateMatrix = view.getRootRotatedMatrix();\n  const targetMatrix = translateMatrix.multiply(rotateMatrix).multiply(magnetMatrix);\n  const localMatrix = targetMatrix.inverse();\n  const localLine = Util.transformLine(line, localMatrix);\n  const localRef = localLine.start.clone();\n  const data = view.getDataOfElement(node);\n  if (options.insideout === false) {\n    if (data.shapeBBox == null) {\n      data.shapeBBox = localShape.bbox();\n    }\n    const localBBox = data.shapeBBox;\n    if (localBBox != null && localBBox.containsPoint(localRef)) {\n      return anchor;\n    }\n  }\n  if (options.extrapolate === true) {\n    localLine.setLength(1e6);\n  }\n  // Caching segment subdivisions for paths\n  let pathOptions;\n  if (Path.isPath(localShape)) {\n    const precision = options.precision || 2;\n    if (data.segmentSubdivisions == null) {\n      data.segmentSubdivisions = localShape.getSegmentSubdivisions({\n        precision\n      });\n    }\n    pathOptions = {\n      precision,\n      segmentSubdivisions: data.segmentSubdivisions\n    };\n    intersection = localLine.intersect(localShape, pathOptions);\n  } else {\n    intersection = localLine.intersect(localShape);\n  }\n  if (intersection) {\n    if (Array.isArray(intersection)) {\n      intersection = localRef.closest(intersection);\n    }\n  } else if (options.sticky === true) {\n    // No intersection, find the closest point instead\n    if (Rectangle.isRectangle(localShape)) {\n      intersection = localShape.getNearestPointToPoint(localRef);\n    } else if (Ellipse.isEllipse(localShape)) {\n      intersection = localShape.intersectsWithLineFromCenterToPoint(localRef);\n    } else {\n      intersection = localShape.closestPoint(localRef, pathOptions);\n    }\n  }\n  const cp = intersection ? Util.transformPoint(intersection, targetMatrix) : anchor;\n  let cpOffset = options.offset || 0;\n  if (options.stroked !== false) {\n    if (typeof cpOffset === 'object') {\n      cpOffset = Object.assign({}, cpOffset);\n      if (cpOffset.x == null) {\n        cpOffset.x = 0;\n      }\n      cpOffset.x += getStrokeWidth(node) / 2;\n    } else {\n      cpOffset += getStrokeWidth(node) / 2;\n    }\n  }\n  return offset(cp, line.start, cpOffset);\n};","map":{"version":3,"names":["ObjectExt","Dom","Path","Rectangle","Ellipse","offset","getStrokeWidth","findShapeNode","Util","boundary","line","view","magnet","options","node","intersection","anchor","end","selector","findOne","Array","isArray","getByPath","isSVGGraphicsElement","localShape","getShapeOfElement","magnetMatrix","getMatrixOfElement","translateMatrix","getRootTranslatedMatrix","rotateMatrix","getRootRotatedMatrix","targetMatrix","multiply","localMatrix","inverse","localLine","transformLine","localRef","start","clone","data","getDataOfElement","insideout","shapeBBox","bbox","localBBox","containsPoint","extrapolate","setLength","pathOptions","isPath","precision","segmentSubdivisions","getSegmentSubdivisions","intersect","closest","sticky","isRectangle","getNearestPointToPoint","isEllipse","intersectsWithLineFromCenterToPoint","closestPoint","cp","transformPoint","cpOffset","stroked","Object","assign","x"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/src/registry/connection-point/boundary.ts"],"sourcesContent":["import { ObjectExt, Dom } from '@antv/x6-common'\nimport { Path, Rectangle, Ellipse, Segment } from '@antv/x6-geometry'\nimport { offset, getStrokeWidth, findShapeNode } from './util'\nimport { ConnectionPoint } from './index'\nimport { Util } from '../../util'\n\nexport interface BoundaryOptions extends ConnectionPoint.StrokedOptions {\n  selector?: string | string[]\n  insideout?: boolean\n  precision?: number\n  extrapolate?: boolean\n  sticky?: boolean\n}\n\nexport interface BoundaryCache {\n  shapeBBox?: Rectangle | null\n  segmentSubdivisions?: Segment[][]\n}\n\n/**\n * Places the connection point at the intersection between the\n * edge path end segment and the actual shape of the target magnet.\n */\nexport const boundary: ConnectionPoint.Definition<BoundaryOptions> = function (\n  line,\n  view,\n  magnet,\n  options,\n) {\n  let node\n  let intersection\n  const anchor = line.end\n  const selector = options.selector\n\n  if (typeof selector === 'string') {\n    node = view.findOne(selector)\n  } else if (Array.isArray(selector)) {\n    node = ObjectExt.getByPath(magnet, selector)\n  } else {\n    node = findShapeNode(magnet)\n  }\n\n  if (!Dom.isSVGGraphicsElement(node)) {\n    if (node === magnet || !Dom.isSVGGraphicsElement(magnet)) {\n      return anchor\n    }\n    node = magnet\n  }\n\n  const localShape = view.getShapeOfElement(node)\n  const magnetMatrix = view.getMatrixOfElement(node)\n  const translateMatrix = view.getRootTranslatedMatrix()\n  const rotateMatrix = view.getRootRotatedMatrix()\n  const targetMatrix = translateMatrix\n    .multiply(rotateMatrix)\n    .multiply(magnetMatrix)\n  const localMatrix = targetMatrix.inverse()\n  const localLine = Util.transformLine(line, localMatrix)\n  const localRef = localLine.start.clone()\n  const data = view.getDataOfElement(node) as BoundaryCache\n\n  if (options.insideout === false) {\n    if (data.shapeBBox == null) {\n      data.shapeBBox = localShape.bbox()\n    }\n    const localBBox = data.shapeBBox\n    if (localBBox != null && localBBox.containsPoint(localRef)) {\n      return anchor\n    }\n  }\n\n  if (options.extrapolate === true) {\n    localLine.setLength(1e6)\n  }\n\n  // Caching segment subdivisions for paths\n  let pathOptions\n  if (Path.isPath(localShape)) {\n    const precision = options.precision || 2\n    if (data.segmentSubdivisions == null) {\n      data.segmentSubdivisions = localShape.getSegmentSubdivisions({\n        precision,\n      })\n    }\n    pathOptions = {\n      precision,\n      segmentSubdivisions: data.segmentSubdivisions,\n    }\n\n    intersection = localLine.intersect(localShape, pathOptions)\n  } else {\n    intersection = localLine.intersect(localShape)\n  }\n\n  if (intersection) {\n    if (Array.isArray(intersection)) {\n      intersection = localRef.closest(intersection)\n    }\n  } else if (options.sticky === true) {\n    // No intersection, find the closest point instead\n    if (Rectangle.isRectangle(localShape)) {\n      intersection = localShape.getNearestPointToPoint(localRef)\n    } else if (Ellipse.isEllipse(localShape)) {\n      intersection = localShape.intersectsWithLineFromCenterToPoint(localRef)\n    } else {\n      intersection = localShape.closestPoint(localRef, pathOptions)\n    }\n  }\n\n  const cp = intersection\n    ? Util.transformPoint(intersection, targetMatrix)\n    : anchor\n  let cpOffset = options.offset || 0\n  if (options.stroked !== false) {\n    if (typeof cpOffset === 'object') {\n      cpOffset = { ...cpOffset }\n      if (cpOffset.x == null) {\n        cpOffset.x = 0\n      }\n      cpOffset.x += getStrokeWidth(node) / 2\n    } else {\n      cpOffset += getStrokeWidth(node) / 2\n    }\n  }\n\n  return offset(cp, line.start, cpOffset)\n}\n"],"mappings":"AAAA,SAASA,SAAS,EAAEC,GAAG,QAAQ,iBAAiB;AAChD,SAASC,IAAI,EAAEC,SAAS,EAAEC,OAAO,QAAiB,mBAAmB;AACrE,SAASC,MAAM,EAAEC,cAAc,EAAEC,aAAa,QAAQ,QAAQ;AAE9D,SAASC,IAAI,QAAQ,YAAY;AAejC;;;;AAIA,OAAO,MAAMC,QAAQ,GAAgD,SAAAA,CACnEC,IAAI,EACJC,IAAI,EACJC,MAAM,EACNC,OAAO;EAEP,IAAIC,IAAI;EACR,IAAIC,YAAY;EAChB,MAAMC,MAAM,GAAGN,IAAI,CAACO,GAAG;EACvB,MAAMC,QAAQ,GAAGL,OAAO,CAACK,QAAQ;EAEjC,IAAI,OAAOA,QAAQ,KAAK,QAAQ,EAAE;IAChCJ,IAAI,GAAGH,IAAI,CAACQ,OAAO,CAACD,QAAQ,CAAC;GAC9B,MAAM,IAAIE,KAAK,CAACC,OAAO,CAACH,QAAQ,CAAC,EAAE;IAClCJ,IAAI,GAAGd,SAAS,CAACsB,SAAS,CAACV,MAAM,EAAEM,QAAQ,CAAC;GAC7C,MAAM;IACLJ,IAAI,GAAGP,aAAa,CAACK,MAAM,CAAC;;EAG9B,IAAI,CAACX,GAAG,CAACsB,oBAAoB,CAACT,IAAI,CAAC,EAAE;IACnC,IAAIA,IAAI,KAAKF,MAAM,IAAI,CAACX,GAAG,CAACsB,oBAAoB,CAACX,MAAM,CAAC,EAAE;MACxD,OAAOI,MAAM;;IAEfF,IAAI,GAAGF,MAAM;;EAGf,MAAMY,UAAU,GAAGb,IAAI,CAACc,iBAAiB,CAACX,IAAI,CAAC;EAC/C,MAAMY,YAAY,GAAGf,IAAI,CAACgB,kBAAkB,CAACb,IAAI,CAAC;EAClD,MAAMc,eAAe,GAAGjB,IAAI,CAACkB,uBAAuB,EAAE;EACtD,MAAMC,YAAY,GAAGnB,IAAI,CAACoB,oBAAoB,EAAE;EAChD,MAAMC,YAAY,GAAGJ,eAAe,CACjCK,QAAQ,CAACH,YAAY,CAAC,CACtBG,QAAQ,CAACP,YAAY,CAAC;EACzB,MAAMQ,WAAW,GAAGF,YAAY,CAACG,OAAO,EAAE;EAC1C,MAAMC,SAAS,GAAG5B,IAAI,CAAC6B,aAAa,CAAC3B,IAAI,EAAEwB,WAAW,CAAC;EACvD,MAAMI,QAAQ,GAAGF,SAAS,CAACG,KAAK,CAACC,KAAK,EAAE;EACxC,MAAMC,IAAI,GAAG9B,IAAI,CAAC+B,gBAAgB,CAAC5B,IAAI,CAAkB;EAEzD,IAAID,OAAO,CAAC8B,SAAS,KAAK,KAAK,EAAE;IAC/B,IAAIF,IAAI,CAACG,SAAS,IAAI,IAAI,EAAE;MAC1BH,IAAI,CAACG,SAAS,GAAGpB,UAAU,CAACqB,IAAI,EAAE;;IAEpC,MAAMC,SAAS,GAAGL,IAAI,CAACG,SAAS;IAChC,IAAIE,SAAS,IAAI,IAAI,IAAIA,SAAS,CAACC,aAAa,CAACT,QAAQ,CAAC,EAAE;MAC1D,OAAOtB,MAAM;;;EAIjB,IAAIH,OAAO,CAACmC,WAAW,KAAK,IAAI,EAAE;IAChCZ,SAAS,CAACa,SAAS,CAAC,GAAG,CAAC;;EAG1B;EACA,IAAIC,WAAW;EACf,IAAIhD,IAAI,CAACiD,MAAM,CAAC3B,UAAU,CAAC,EAAE;IAC3B,MAAM4B,SAAS,GAAGvC,OAAO,CAACuC,SAAS,IAAI,CAAC;IACxC,IAAIX,IAAI,CAACY,mBAAmB,IAAI,IAAI,EAAE;MACpCZ,IAAI,CAACY,mBAAmB,GAAG7B,UAAU,CAAC8B,sBAAsB,CAAC;QAC3DF;OACD,CAAC;;IAEJF,WAAW,GAAG;MACZE,SAAS;MACTC,mBAAmB,EAAEZ,IAAI,CAACY;KAC3B;IAEDtC,YAAY,GAAGqB,SAAS,CAACmB,SAAS,CAAC/B,UAAU,EAAE0B,WAAW,CAAC;GAC5D,MAAM;IACLnC,YAAY,GAAGqB,SAAS,CAACmB,SAAS,CAAC/B,UAAU,CAAC;;EAGhD,IAAIT,YAAY,EAAE;IAChB,IAAIK,KAAK,CAACC,OAAO,CAACN,YAAY,CAAC,EAAE;MAC/BA,YAAY,GAAGuB,QAAQ,CAACkB,OAAO,CAACzC,YAAY,CAAC;;GAEhD,MAAM,IAAIF,OAAO,CAAC4C,MAAM,KAAK,IAAI,EAAE;IAClC;IACA,IAAItD,SAAS,CAACuD,WAAW,CAAClC,UAAU,CAAC,EAAE;MACrCT,YAAY,GAAGS,UAAU,CAACmC,sBAAsB,CAACrB,QAAQ,CAAC;KAC3D,MAAM,IAAIlC,OAAO,CAACwD,SAAS,CAACpC,UAAU,CAAC,EAAE;MACxCT,YAAY,GAAGS,UAAU,CAACqC,mCAAmC,CAACvB,QAAQ,CAAC;KACxE,MAAM;MACLvB,YAAY,GAAGS,UAAU,CAACsC,YAAY,CAACxB,QAAQ,EAAEY,WAAW,CAAC;;;EAIjE,MAAMa,EAAE,GAAGhD,YAAY,GACnBP,IAAI,CAACwD,cAAc,CAACjD,YAAY,EAAEiB,YAAY,CAAC,GAC/ChB,MAAM;EACV,IAAIiD,QAAQ,GAAGpD,OAAO,CAACR,MAAM,IAAI,CAAC;EAClC,IAAIQ,OAAO,CAACqD,OAAO,KAAK,KAAK,EAAE;IAC7B,IAAI,OAAOD,QAAQ,KAAK,QAAQ,EAAE;MAChCA,QAAQ,GAAAE,MAAA,CAAAC,MAAA,KAAQH,QAAQ,CAAE;MAC1B,IAAIA,QAAQ,CAACI,CAAC,IAAI,IAAI,EAAE;QACtBJ,QAAQ,CAACI,CAAC,GAAG,CAAC;;MAEhBJ,QAAQ,CAACI,CAAC,IAAI/D,cAAc,CAACQ,IAAI,CAAC,GAAG,CAAC;KACvC,MAAM;MACLmD,QAAQ,IAAI3D,cAAc,CAACQ,IAAI,CAAC,GAAG,CAAC;;;EAIxC,OAAOT,MAAM,CAAC0D,EAAE,EAAErD,IAAI,CAAC6B,KAAK,EAAE0B,QAAQ,CAAC;AACzC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}