{"ast":null,"code":"import { createSvgElement } from './elem';\nconst transformRegex = /(\\w+)\\(([^,)]+),?([^)]+)?\\)/gi;\nconst transformSeparatorRegex = /[ ,]+/;\nconst transformationListRegex = /^(\\w+)\\((.*)\\)/;\n/**\n * Returns a SVG point object initialized with the `x` and `y` coordinates.\n * @see https://developer.mozilla.org/en/docs/Web/API/SVGPoint\n */\nexport function createSVGPoint(x, y) {\n  const svgDocument = createSvgElement('svg');\n  const p = svgDocument.createSVGPoint();\n  p.x = x;\n  p.y = y;\n  return p;\n}\n/**\n * Returns the SVG transformation matrix initialized with the given matrix.\n *\n * The given matrix is an object of the form:\n * {\n *   a: number\n *   b: number\n *   c: number\n *   d: number\n *   e: number\n *   f: number\n * }\n *\n * @see https://developer.mozilla.org/en/docs/Web/API/SVGMatrix\n */\nexport function createSVGMatrix(matrix) {\n  const svgDocument = createSvgElement('svg');\n  const mat = svgDocument.createSVGMatrix();\n  if (matrix != null) {\n    const source = matrix;\n    const target = mat;\n    // eslint-disable-next-line\n    for (const key in source) {\n      target[key] = source[key];\n    }\n  }\n  return mat;\n}\n/**\n * Returns a SVG transform object.\n * @see https://developer.mozilla.org/en/docs/Web/API/SVGTransform\n */\nexport function createSVGTransform(matrix) {\n  const svgDocument = createSvgElement('svg');\n  if (matrix != null) {\n    if (!(matrix instanceof DOMMatrix)) {\n      matrix = createSVGMatrix(matrix); // eslint-disable-line\n    }\n    return svgDocument.createSVGTransformFromMatrix(matrix);\n  }\n  return svgDocument.createSVGTransform();\n}\n/**\n * Returns the SVG transformation matrix built from the `transformString`.\n *\n * E.g. 'translate(10,10) scale(2,2)' will result in matrix:\n * `{ a: 2, b: 0, c: 0, d: 2, e: 10, f: 10}`\n */\nexport function transformStringToMatrix(transform) {\n  let mat = createSVGMatrix();\n  const matches = transform != null && transform.match(transformRegex);\n  if (!matches) {\n    return mat;\n  }\n  for (let i = 0, n = matches.length; i < n; i += 1) {\n    const transformationString = matches[i];\n    const transformationMatch = transformationString.match(transformationListRegex);\n    if (transformationMatch) {\n      let sx;\n      let sy;\n      let tx;\n      let ty;\n      let angle;\n      let ctm = createSVGMatrix();\n      const args = transformationMatch[2].split(transformSeparatorRegex);\n      switch (transformationMatch[1].toLowerCase()) {\n        case 'scale':\n          sx = parseFloat(args[0]);\n          sy = args[1] === undefined ? sx : parseFloat(args[1]);\n          ctm = ctm.scaleNonUniform(sx, sy);\n          break;\n        case 'translate':\n          tx = parseFloat(args[0]);\n          ty = parseFloat(args[1]);\n          ctm = ctm.translate(tx, ty);\n          break;\n        case 'rotate':\n          angle = parseFloat(args[0]);\n          tx = parseFloat(args[1]) || 0;\n          ty = parseFloat(args[2]) || 0;\n          if (tx !== 0 || ty !== 0) {\n            ctm = ctm.translate(tx, ty).rotate(angle).translate(-tx, -ty);\n          } else {\n            ctm = ctm.rotate(angle);\n          }\n          break;\n        case 'skewx':\n          angle = parseFloat(args[0]);\n          ctm = ctm.skewX(angle);\n          break;\n        case 'skewy':\n          angle = parseFloat(args[0]);\n          ctm = ctm.skewY(angle);\n          break;\n        case 'matrix':\n          ctm.a = parseFloat(args[0]);\n          ctm.b = parseFloat(args[1]);\n          ctm.c = parseFloat(args[2]);\n          ctm.d = parseFloat(args[3]);\n          ctm.e = parseFloat(args[4]);\n          ctm.f = parseFloat(args[5]);\n          break;\n        default:\n          continue;\n      }\n      mat = mat.multiply(ctm);\n    }\n  }\n  return mat;\n}\nexport function matrixToTransformString(matrix) {\n  const m = matrix || {};\n  const a = m.a != null ? m.a : 1;\n  const b = m.b != null ? m.b : 0;\n  const c = m.c != null ? m.c : 0;\n  const d = m.d != null ? m.d : 1;\n  const e = m.e != null ? m.e : 0;\n  const f = m.f != null ? m.f : 0;\n  return `matrix(${a},${b},${c},${d},${e},${f})`;\n}\nexport function parseTransformString(transform) {\n  let translation;\n  let rotation;\n  let scale;\n  if (transform) {\n    const separator = transformSeparatorRegex;\n    // Allow reading transform string with a single matrix\n    if (transform.trim().indexOf('matrix') >= 0) {\n      const matrix = transformStringToMatrix(transform);\n      const decomposedMatrix = decomposeMatrix(matrix);\n      translation = [decomposedMatrix.translateX, decomposedMatrix.translateY];\n      rotation = [decomposedMatrix.rotation];\n      scale = [decomposedMatrix.scaleX, decomposedMatrix.scaleY];\n      const transformations = [];\n      if (translation[0] !== 0 || translation[1] !== 0) {\n        transformations.push(`translate(${translation.join(',')})`);\n      }\n      if (scale[0] !== 1 || scale[1] !== 1) {\n        transformations.push(`scale(${scale.join(',')})`);\n      }\n      if (rotation[0] !== 0) {\n        transformations.push(`rotate(${rotation[0]})`);\n      }\n      transform = transformations.join(' '); // eslint-disable-line\n    } else {\n      const translateMatch = transform.match(/translate\\((.*?)\\)/);\n      if (translateMatch) {\n        translation = translateMatch[1].split(separator);\n      }\n      const rotateMatch = transform.match(/rotate\\((.*?)\\)/);\n      if (rotateMatch) {\n        rotation = rotateMatch[1].split(separator);\n      }\n      const scaleMatch = transform.match(/scale\\((.*?)\\)/);\n      if (scaleMatch) {\n        scale = scaleMatch[1].split(separator);\n      }\n    }\n  }\n  const sx = scale && scale[0] ? parseFloat(scale[0]) : 1;\n  return {\n    raw: transform || '',\n    translation: {\n      tx: translation && translation[0] ? parseInt(translation[0], 10) : 0,\n      ty: translation && translation[1] ? parseInt(translation[1], 10) : 0\n    },\n    rotation: {\n      angle: rotation && rotation[0] ? parseInt(rotation[0], 10) : 0,\n      cx: rotation && rotation[1] ? parseInt(rotation[1], 10) : undefined,\n      cy: rotation && rotation[2] ? parseInt(rotation[2], 10) : undefined\n    },\n    scale: {\n      sx,\n      sy: scale && scale[1] ? parseFloat(scale[1]) : sx\n    }\n  };\n}\nfunction deltaTransformPoint(matrix, point) {\n  const dx = point.x * matrix.a + point.y * matrix.c + 0;\n  const dy = point.x * matrix.b + point.y * matrix.d + 0;\n  return {\n    x: dx,\n    y: dy\n  };\n}\n/**\n * Decomposes the SVG transformation matrix into separate transformations.\n *\n * Returns an object of the form:\n * {\n *   translateX: number\n *   translateY: number\n *   scaleX: number\n *   scaleY: number\n *   skewX: number\n *   skewY: number\n *   rotation: number\n * }\n *\n * @see https://developer.mozilla.org/en/docs/Web/API/SVGMatrix\n */\nexport function decomposeMatrix(matrix) {\n  // @see https://gist.github.com/2052247\n  const px = deltaTransformPoint(matrix, {\n    x: 0,\n    y: 1\n  });\n  const py = deltaTransformPoint(matrix, {\n    x: 1,\n    y: 0\n  });\n  const skewX = 180 / Math.PI * Math.atan2(px.y, px.x) - 90;\n  const skewY = 180 / Math.PI * Math.atan2(py.y, py.x);\n  return {\n    skewX,\n    skewY,\n    translateX: matrix.e,\n    translateY: matrix.f,\n    scaleX: Math.sqrt(matrix.a * matrix.a + matrix.b * matrix.b),\n    scaleY: Math.sqrt(matrix.c * matrix.c + matrix.d * matrix.d),\n    rotation: skewX\n  };\n}\nexport function matrixToScale(matrix) {\n  let a;\n  let b;\n  let c;\n  let d;\n  if (matrix) {\n    a = matrix.a == null ? 1 : matrix.a;\n    d = matrix.d == null ? 1 : matrix.d;\n    b = matrix.b;\n    c = matrix.c;\n  } else {\n    a = d = 1;\n  }\n  return {\n    sx: b ? Math.sqrt(a * a + b * b) : a,\n    sy: c ? Math.sqrt(c * c + d * d) : d\n  };\n}\nexport function matrixToRotation(matrix) {\n  let p = {\n    x: 0,\n    y: 1\n  };\n  if (matrix) {\n    p = deltaTransformPoint(matrix, p);\n  }\n  const deg = 180 * Math.atan2(p.y, p.x) / Math.PI % 360 - 90;\n  const angle = deg % 360 + (deg < 0 ? 360 : 0);\n  return {\n    angle\n  };\n}\nexport function matrixToTranslation(matrix) {\n  return {\n    tx: matrix && matrix.e || 0,\n    ty: matrix && matrix.f || 0\n  };\n}","map":{"version":3,"names":["createSvgElement","transformRegex","transformSeparatorRegex","transformationListRegex","createSVGPoint","x","y","svgDocument","p","createSVGMatrix","matrix","mat","source","target","key","createSVGTransform","DOMMatrix","createSVGTransformFromMatrix","transformStringToMatrix","transform","matches","match","i","n","length","transformationString","transformationMatch","sx","sy","tx","ty","angle","ctm","args","split","toLowerCase","parseFloat","undefined","scaleNonUniform","translate","rotate","skewX","skewY","a","b","c","d","e","f","multiply","matrixToTransformString","m","parseTransformString","translation","rotation","scale","separator","trim","indexOf","decomposedMatrix","decomposeMatrix","translateX","translateY","scaleX","scaleY","transformations","push","join","translateMatch","rotateMatch","scaleMatch","raw","parseInt","cx","cy","deltaTransformPoint","point","dx","dy","px","py","Math","PI","atan2","sqrt","matrixToScale","matrixToRotation","deg","matrixToTranslation"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/src/dom/matrix.ts"],"sourcesContent":["import { PointLike } from '../types'\nimport { createSvgElement } from './elem'\n\nconst transformRegex = /(\\w+)\\(([^,)]+),?([^)]+)?\\)/gi\nconst transformSeparatorRegex = /[ ,]+/\nconst transformationListRegex = /^(\\w+)\\((.*)\\)/\n\nexport interface MatrixLike {\n  a: number\n  b: number\n  c: number\n  d: number\n  e: number\n  f: number\n}\n\nexport interface Translation {\n  tx: number\n  ty: number\n}\n\nexport interface Rotation {\n  angle: number\n  cx?: number\n  cy?: number\n}\n\nexport interface Scale {\n  sx: number\n  sy: number\n}\n\n/**\n * Returns a SVG point object initialized with the `x` and `y` coordinates.\n * @see https://developer.mozilla.org/en/docs/Web/API/SVGPoint\n */\nexport function createSVGPoint(x: number, y: number) {\n  const svgDocument = createSvgElement('svg') as SVGSVGElement\n  const p = svgDocument.createSVGPoint()\n  p.x = x\n  p.y = y\n  return p\n}\n\n/**\n * Returns the SVG transformation matrix initialized with the given matrix.\n *\n * The given matrix is an object of the form:\n * {\n *   a: number\n *   b: number\n *   c: number\n *   d: number\n *   e: number\n *   f: number\n * }\n *\n * @see https://developer.mozilla.org/en/docs/Web/API/SVGMatrix\n */\nexport function createSVGMatrix(matrix?: DOMMatrix | MatrixLike | null) {\n  const svgDocument = createSvgElement('svg') as SVGSVGElement\n  const mat = svgDocument.createSVGMatrix()\n  if (matrix != null) {\n    const source = matrix as any\n    const target = mat as any\n    // eslint-disable-next-line\n    for (const key in source) {\n      target[key] = source[key]\n    }\n  }\n  return mat\n}\n\n/**\n * Returns a SVG transform object.\n * @see https://developer.mozilla.org/en/docs/Web/API/SVGTransform\n */\nexport function createSVGTransform(matrix?: DOMMatrix | MatrixLike) {\n  const svgDocument = createSvgElement('svg') as SVGSVGElement\n  if (matrix != null) {\n    if (!(matrix instanceof DOMMatrix)) {\n      matrix = createSVGMatrix(matrix) // eslint-disable-line\n    }\n\n    return svgDocument.createSVGTransformFromMatrix(matrix as DOMMatrix)\n  }\n\n  return svgDocument.createSVGTransform()\n}\n\n/**\n * Returns the SVG transformation matrix built from the `transformString`.\n *\n * E.g. 'translate(10,10) scale(2,2)' will result in matrix:\n * `{ a: 2, b: 0, c: 0, d: 2, e: 10, f: 10}`\n */\nexport function transformStringToMatrix(transform?: string | null) {\n  let mat = createSVGMatrix()\n  const matches = transform != null && transform.match(transformRegex)\n  if (!matches) {\n    return mat\n  }\n\n  for (let i = 0, n = matches.length; i < n; i += 1) {\n    const transformationString = matches[i]\n\n    const transformationMatch = transformationString.match(\n      transformationListRegex,\n    )\n\n    if (transformationMatch) {\n      let sx\n      let sy\n      let tx\n      let ty\n      let angle\n      let ctm = createSVGMatrix()\n      const args = transformationMatch[2].split(transformSeparatorRegex)\n      switch (transformationMatch[1].toLowerCase()) {\n        case 'scale':\n          sx = parseFloat(args[0])\n          sy = args[1] === undefined ? sx : parseFloat(args[1])\n          ctm = ctm.scaleNonUniform(sx, sy)\n          break\n        case 'translate':\n          tx = parseFloat(args[0])\n          ty = parseFloat(args[1])\n          ctm = ctm.translate(tx, ty)\n          break\n        case 'rotate':\n          angle = parseFloat(args[0])\n          tx = parseFloat(args[1]) || 0\n          ty = parseFloat(args[2]) || 0\n          if (tx !== 0 || ty !== 0) {\n            ctm = ctm.translate(tx, ty).rotate(angle).translate(-tx, -ty)\n          } else {\n            ctm = ctm.rotate(angle)\n          }\n          break\n        case 'skewx':\n          angle = parseFloat(args[0])\n          ctm = ctm.skewX(angle)\n          break\n        case 'skewy':\n          angle = parseFloat(args[0])\n          ctm = ctm.skewY(angle)\n          break\n        case 'matrix':\n          ctm.a = parseFloat(args[0])\n          ctm.b = parseFloat(args[1])\n          ctm.c = parseFloat(args[2])\n          ctm.d = parseFloat(args[3])\n          ctm.e = parseFloat(args[4])\n          ctm.f = parseFloat(args[5])\n          break\n        default:\n          continue\n      }\n\n      mat = mat.multiply(ctm)\n    }\n  }\n  return mat\n}\n\nexport function matrixToTransformString(\n  matrix?: DOMMatrix | Partial<MatrixLike>,\n) {\n  const m = matrix || ({} as DOMMatrix)\n  const a = m.a != null ? m.a : 1\n  const b = m.b != null ? m.b : 0\n  const c = m.c != null ? m.c : 0\n  const d = m.d != null ? m.d : 1\n  const e = m.e != null ? m.e : 0\n  const f = m.f != null ? m.f : 0\n  return `matrix(${a},${b},${c},${d},${e},${f})`\n}\n\nexport function parseTransformString(transform: string) {\n  let translation\n  let rotation\n  let scale\n\n  if (transform) {\n    const separator = transformSeparatorRegex\n\n    // Allow reading transform string with a single matrix\n    if (transform.trim().indexOf('matrix') >= 0) {\n      const matrix = transformStringToMatrix(transform)\n      const decomposedMatrix = decomposeMatrix(matrix)\n\n      translation = [decomposedMatrix.translateX, decomposedMatrix.translateY]\n      rotation = [decomposedMatrix.rotation]\n      scale = [decomposedMatrix.scaleX, decomposedMatrix.scaleY]\n\n      const transformations = []\n      if (translation[0] !== 0 || translation[1] !== 0) {\n        transformations.push(`translate(${translation.join(',')})`)\n      }\n\n      if (scale[0] !== 1 || scale[1] !== 1) {\n        transformations.push(`scale(${scale.join(',')})`)\n      }\n\n      if (rotation[0] !== 0) {\n        transformations.push(`rotate(${rotation[0]})`)\n      }\n\n      transform = transformations.join(' ') // eslint-disable-line\n    } else {\n      const translateMatch = transform.match(/translate\\((.*?)\\)/)\n      if (translateMatch) {\n        translation = translateMatch[1].split(separator)\n      }\n      const rotateMatch = transform.match(/rotate\\((.*?)\\)/)\n      if (rotateMatch) {\n        rotation = rotateMatch[1].split(separator)\n      }\n      const scaleMatch = transform.match(/scale\\((.*?)\\)/)\n      if (scaleMatch) {\n        scale = scaleMatch[1].split(separator)\n      }\n    }\n  }\n\n  const sx = scale && scale[0] ? parseFloat(scale[0] as string) : 1\n\n  return {\n    raw: transform || '',\n    translation: {\n      tx:\n        translation && translation[0]\n          ? parseInt(translation[0] as string, 10)\n          : 0,\n      ty:\n        translation && translation[1]\n          ? parseInt(translation[1] as string, 10)\n          : 0,\n    } as Translation,\n\n    rotation: {\n      angle: rotation && rotation[0] ? parseInt(rotation[0] as string, 10) : 0,\n      cx:\n        rotation && rotation[1]\n          ? parseInt(rotation[1] as string, 10)\n          : undefined,\n      cy:\n        rotation && rotation[2]\n          ? parseInt(rotation[2] as string, 10)\n          : undefined,\n    } as Rotation,\n\n    scale: {\n      sx,\n      sy: scale && scale[1] ? parseFloat(scale[1] as string) : sx,\n    } as Scale,\n  }\n}\n\nfunction deltaTransformPoint(matrix: DOMMatrix | MatrixLike, point: PointLike) {\n  const dx = point.x * matrix.a + point.y * matrix.c + 0\n  const dy = point.x * matrix.b + point.y * matrix.d + 0\n  return { x: dx, y: dy }\n}\n\n/**\n * Decomposes the SVG transformation matrix into separate transformations.\n *\n * Returns an object of the form:\n * {\n *   translateX: number\n *   translateY: number\n *   scaleX: number\n *   scaleY: number\n *   skewX: number\n *   skewY: number\n *   rotation: number\n * }\n *\n * @see https://developer.mozilla.org/en/docs/Web/API/SVGMatrix\n */\nexport function decomposeMatrix(matrix: DOMMatrix | MatrixLike) {\n  // @see https://gist.github.com/2052247\n\n  const px = deltaTransformPoint(matrix, { x: 0, y: 1 })\n  const py = deltaTransformPoint(matrix, { x: 1, y: 0 })\n\n  const skewX = (180 / Math.PI) * Math.atan2(px.y, px.x) - 90\n  const skewY = (180 / Math.PI) * Math.atan2(py.y, py.x)\n\n  return {\n    skewX,\n    skewY,\n    translateX: matrix.e,\n    translateY: matrix.f,\n    scaleX: Math.sqrt(matrix.a * matrix.a + matrix.b * matrix.b),\n    scaleY: Math.sqrt(matrix.c * matrix.c + matrix.d * matrix.d),\n    rotation: skewX,\n  }\n}\n\nexport function matrixToScale(matrix: DOMMatrix | MatrixLike): Scale {\n  let a\n  let b\n  let c\n  let d\n\n  if (matrix) {\n    a = matrix.a == null ? 1 : matrix.a\n    d = matrix.d == null ? 1 : matrix.d\n    b = matrix.b\n    c = matrix.c\n  } else {\n    a = d = 1\n  }\n  return {\n    sx: b ? Math.sqrt(a * a + b * b) : a,\n    sy: c ? Math.sqrt(c * c + d * d) : d,\n  }\n}\n\nexport function matrixToRotation(matrix: DOMMatrix | MatrixLike): Rotation {\n  let p = { x: 0, y: 1 }\n  if (matrix) {\n    p = deltaTransformPoint(matrix, p)\n  }\n\n  const deg = (((180 * Math.atan2(p.y, p.x)) / Math.PI) % 360) - 90\n  const angle = (deg % 360) + (deg < 0 ? 360 : 0)\n  return {\n    angle,\n  }\n}\n\nexport function matrixToTranslation(\n  matrix: DOMMatrix | MatrixLike,\n): Translation {\n  return {\n    tx: (matrix && matrix.e) || 0,\n    ty: (matrix && matrix.f) || 0,\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}