{"ast":null,"code":"import { ArrayExt } from '@antv/x6-common';\nimport { Point, Line, Angle } from '@antv/x6-geometry';\nimport * as Util from './util';\n/**\n * Returns a route with orthogonal line segments.\n */\nexport const orth = function (vertices, options, edgeView) {\n  let sourceBBox = Util.getSourceBBox(edgeView, options);\n  let targetBBox = Util.getTargetBBox(edgeView, options);\n  const sourceAnchor = Util.getSourceAnchor(edgeView, options);\n  const targetAnchor = Util.getTargetAnchor(edgeView, options);\n  // If anchor lies outside of bbox, the bbox expands to include it\n  sourceBBox = sourceBBox.union(Util.getPointBBox(sourceAnchor));\n  targetBBox = targetBBox.union(Util.getPointBBox(targetAnchor));\n  const points = vertices.map(p => Point.create(p));\n  points.unshift(sourceAnchor);\n  points.push(targetAnchor);\n  // bearing of previous route segment\n  let bearing = null;\n  const result = [];\n  for (let i = 0, len = points.length - 1; i < len; i += 1) {\n    let route = null;\n    const from = points[i];\n    const to = points[i + 1];\n    const isOrthogonal = Private.getBearing(from, to) != null;\n    if (i === 0) {\n      // source\n      if (i + 1 === len) {\n        // source -> target\n        // Expand one of the nodes by 1px to detect situations when the two\n        // nodes are positioned next to each other with no gap in between.\n        if (sourceBBox.intersectsWithRect(targetBBox.clone().inflate(1))) {\n          route = Private.insideNode(from, to, sourceBBox, targetBBox);\n        } else if (!isOrthogonal) {\n          route = Private.nodeToNode(from, to, sourceBBox, targetBBox);\n        }\n      } else {\n        // source -> vertex\n        if (sourceBBox.containsPoint(to)) {\n          route = Private.insideNode(from, to, sourceBBox, Util.getPointBBox(to).moveAndExpand(Util.getPaddingBox(options)));\n        } else if (!isOrthogonal) {\n          route = Private.nodeToVertex(from, to, sourceBBox);\n        }\n      }\n    } else if (i + 1 === len) {\n      // vertex -> target\n      // prevent overlaps with previous line segment\n      const isOrthogonalLoop = isOrthogonal && Private.getBearing(to, from) === bearing;\n      if (targetBBox.containsPoint(from) || isOrthogonalLoop) {\n        route = Private.insideNode(from, to, Util.getPointBBox(from).moveAndExpand(Util.getPaddingBox(options)), targetBBox, bearing);\n      } else if (!isOrthogonal) {\n        route = Private.vertexToNode(from, to, targetBBox, bearing);\n      }\n    } else if (!isOrthogonal) {\n      // vertex -> vertex\n      route = Private.vertexToVertex(from, to, bearing);\n    }\n    // set bearing for next iteration\n    if (route) {\n      result.push(...route.points);\n      bearing = route.direction;\n    } else {\n      // orthogonal route and not looped\n      bearing = Private.getBearing(from, to);\n    }\n    // push `to` point to identified orthogonal vertices array\n    if (i + 1 < len) {\n      result.push(to);\n    }\n  }\n  return result;\n};\nvar Private;\n(function (Private) {\n  /**\n   * Bearing to opposite bearing map\n   */\n  const opposites = {\n    N: 'S',\n    S: 'N',\n    E: 'W',\n    W: 'E'\n  };\n  /**\n   * Bearing to radians map\n   */\n  const radians = {\n    N: -Math.PI / 2 * 3,\n    S: -Math.PI / 2,\n    E: 0,\n    W: Math.PI\n  };\n  /**\n   * Returns a point `p` where lines p,p1 and p,p2 are perpendicular\n   * and p is not contained in the given box\n   */\n  function freeJoin(p1, p2, bbox) {\n    let p = new Point(p1.x, p2.y);\n    if (bbox.containsPoint(p)) {\n      p = new Point(p2.x, p1.y);\n    }\n    // kept for reference\n    // if (bbox.containsPoint(p)) {\n    //   return null\n    // }\n    return p;\n  }\n  /**\n   * Returns either width or height of a bbox based on the given bearing.\n   */\n  function getBBoxSize(bbox, bearing) {\n    return bbox[bearing === 'W' || bearing === 'E' ? 'width' : 'height'];\n  }\n  Private.getBBoxSize = getBBoxSize;\n  function getBearing(from, to) {\n    if (from.x === to.x) {\n      return from.y > to.y ? 'N' : 'S';\n    }\n    if (from.y === to.y) {\n      return from.x > to.x ? 'W' : 'E';\n    }\n    return null;\n  }\n  Private.getBearing = getBearing;\n  function vertexToVertex(from, to, bearing) {\n    const p1 = new Point(from.x, to.y);\n    const p2 = new Point(to.x, from.y);\n    const d1 = getBearing(from, p1);\n    const d2 = getBearing(from, p2);\n    const opposite = bearing ? opposites[bearing] : null;\n    const p = d1 === bearing || d1 !== opposite && (d2 === opposite || d2 !== bearing) ? p1 : p2;\n    return {\n      points: [p],\n      direction: getBearing(p, to)\n    };\n  }\n  Private.vertexToVertex = vertexToVertex;\n  function nodeToVertex(from, to, fromBBox) {\n    const p = freeJoin(from, to, fromBBox);\n    return {\n      points: [p],\n      direction: getBearing(p, to)\n    };\n  }\n  Private.nodeToVertex = nodeToVertex;\n  function vertexToNode(from, to, toBBox, bearing) {\n    const points = [new Point(from.x, to.y), new Point(to.x, from.y)];\n    const freePoints = points.filter(p => !toBBox.containsPoint(p));\n    const freeBearingPoints = freePoints.filter(p => getBearing(p, from) !== bearing);\n    let p;\n    if (freeBearingPoints.length > 0) {\n      // Try to pick a point which bears the same direction as the previous segment.\n      p = freeBearingPoints.filter(p => getBearing(from, p) === bearing).pop();\n      p = p || freeBearingPoints[0];\n      return {\n        points: [p],\n        direction: getBearing(p, to)\n      };\n    }\n    {\n      // Here we found only points which are either contained in the element or they would create\n      // a link segment going in opposite direction from the previous one.\n      // We take the point inside element and move it outside the element in the direction the\n      // route is going. Now we can join this point with the current end (using freeJoin).\n      p = ArrayExt.difference(points, freePoints)[0];\n      const p2 = Point.create(to).move(p, -getBBoxSize(toBBox, bearing) / 2);\n      const p1 = freeJoin(p2, from, toBBox);\n      return {\n        points: [p1, p2],\n        direction: getBearing(p2, to)\n      };\n    }\n  }\n  Private.vertexToNode = vertexToNode;\n  function nodeToNode(from, to, fromBBox, toBBox) {\n    let route = nodeToVertex(to, from, toBBox);\n    const p1 = route.points[0];\n    if (fromBBox.containsPoint(p1)) {\n      route = nodeToVertex(from, to, fromBBox);\n      const p2 = route.points[0];\n      if (toBBox.containsPoint(p2)) {\n        const fromBorder = Point.create(from).move(p2, -getBBoxSize(fromBBox, getBearing(from, p2)) / 2);\n        const toBorder = Point.create(to).move(p1, -getBBoxSize(toBBox, getBearing(to, p1)) / 2);\n        const mid = new Line(fromBorder, toBorder).getCenter();\n        const startRoute = nodeToVertex(from, mid, fromBBox);\n        const endRoute = vertexToVertex(mid, to, startRoute.direction);\n        route.points = [startRoute.points[0], endRoute.points[0]];\n        route.direction = endRoute.direction;\n      }\n    }\n    return route;\n  }\n  Private.nodeToNode = nodeToNode;\n  // Finds route for situations where one node is inside the other.\n  // Typically the route is directed outside the outer node first and\n  // then back towards the inner node.\n  function insideNode(from, to, fromBBox, toBBox, bearing) {\n    const boundary = fromBBox.union(toBBox).inflate(1);\n    // start from the point which is closer to the boundary\n    const center = boundary.getCenter();\n    const reversed = center.distance(to) > center.distance(from);\n    const start = reversed ? to : from;\n    const end = reversed ? from : to;\n    let p1;\n    let p2;\n    let p3;\n    if (bearing) {\n      // Points on circle with radius equals 'W + H` are always outside the rectangle\n      // with width W and height H if the center of that circle is the center of that rectangle.\n      p1 = Point.fromPolar(boundary.width + boundary.height, radians[bearing], start);\n      p1 = boundary.getNearestPointToPoint(p1).move(p1, -1);\n    } else {\n      p1 = boundary.getNearestPointToPoint(start).move(start, 1);\n    }\n    p2 = freeJoin(p1, end, boundary);\n    let points;\n    if (p1.round().equals(p2.round())) {\n      p2 = Point.fromPolar(boundary.width + boundary.height, Angle.toRad(p1.theta(start)) + Math.PI / 2, end);\n      p2 = boundary.getNearestPointToPoint(p2).move(end, 1).round();\n      p3 = freeJoin(p1, p2, boundary);\n      points = reversed ? [p2, p3, p1] : [p1, p3, p2];\n    } else {\n      points = reversed ? [p2, p1] : [p1, p2];\n    }\n    const direction = reversed ? getBearing(p1, to) : getBearing(p2, to);\n    return {\n      points,\n      direction\n    };\n  }\n  Private.insideNode = insideNode;\n})(Private || (Private = {}));","map":{"version":3,"names":["ArrayExt","Point","Line","Angle","Util","orth","vertices","options","edgeView","sourceBBox","getSourceBBox","targetBBox","getTargetBBox","sourceAnchor","getSourceAnchor","targetAnchor","getTargetAnchor","union","getPointBBox","points","map","p","create","unshift","push","bearing","result","i","len","length","route","from","to","isOrthogonal","Private","getBearing","intersectsWithRect","clone","inflate","insideNode","nodeToNode","containsPoint","moveAndExpand","getPaddingBox","nodeToVertex","isOrthogonalLoop","vertexToNode","vertexToVertex","direction","opposites","N","S","E","W","radians","Math","PI","freeJoin","p1","p2","bbox","x","y","getBBoxSize","d1","d2","opposite","fromBBox","toBBox","freePoints","filter","freeBearingPoints","pop","difference","move","fromBorder","toBorder","mid","getCenter","startRoute","endRoute","boundary","center","reversed","distance","start","end","p3","fromPolar","width","height","getNearestPointToPoint","round","equals","toRad","theta"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/src/registry/router/orth.ts"],"sourcesContent":["import { ArrayExt } from '@antv/x6-common'\nimport { Point, Rectangle, Line, Angle } from '@antv/x6-geometry'\nimport { Router } from './index'\nimport * as Util from './util'\n\nexport interface OrthRouterOptions extends Util.PaddingOptions {}\n\n/**\n * Returns a route with orthogonal line segments.\n */\nexport const orth: Router.Definition<OrthRouterOptions> = function (\n  vertices,\n  options,\n  edgeView,\n) {\n  let sourceBBox = Util.getSourceBBox(edgeView, options)\n  let targetBBox = Util.getTargetBBox(edgeView, options)\n  const sourceAnchor = Util.getSourceAnchor(edgeView, options)\n  const targetAnchor = Util.getTargetAnchor(edgeView, options)\n\n  // If anchor lies outside of bbox, the bbox expands to include it\n  sourceBBox = sourceBBox.union(Util.getPointBBox(sourceAnchor))\n  targetBBox = targetBBox.union(Util.getPointBBox(targetAnchor))\n\n  const points = vertices.map((p) => Point.create(p))\n  points.unshift(sourceAnchor)\n  points.push(targetAnchor)\n\n  // bearing of previous route segment\n  let bearing: Private.Bearings | null = null\n  const result = []\n\n  for (let i = 0, len = points.length - 1; i < len; i += 1) {\n    let route = null\n\n    const from = points[i]\n    const to = points[i + 1]\n    const isOrthogonal = Private.getBearing(from, to) != null\n\n    if (i === 0) {\n      // source\n\n      if (i + 1 === len) {\n        // source -> target\n\n        // Expand one of the nodes by 1px to detect situations when the two\n        // nodes are positioned next to each other with no gap in between.\n        if (sourceBBox.intersectsWithRect(targetBBox.clone().inflate(1))) {\n          route = Private.insideNode(from, to, sourceBBox, targetBBox)\n        } else if (!isOrthogonal) {\n          route = Private.nodeToNode(from, to, sourceBBox, targetBBox)\n        }\n      } else {\n        // source -> vertex\n        if (sourceBBox.containsPoint(to)) {\n          route = Private.insideNode(\n            from,\n            to,\n            sourceBBox,\n            Util.getPointBBox(to).moveAndExpand(Util.getPaddingBox(options)),\n          )\n        } else if (!isOrthogonal) {\n          route = Private.nodeToVertex(from, to, sourceBBox)\n        }\n      }\n    } else if (i + 1 === len) {\n      // vertex -> target\n\n      // prevent overlaps with previous line segment\n      const isOrthogonalLoop =\n        isOrthogonal && Private.getBearing(to, from) === bearing\n\n      if (targetBBox.containsPoint(from) || isOrthogonalLoop) {\n        route = Private.insideNode(\n          from,\n          to,\n          Util.getPointBBox(from).moveAndExpand(Util.getPaddingBox(options)),\n          targetBBox,\n          bearing,\n        )\n      } else if (!isOrthogonal) {\n        route = Private.vertexToNode(from, to, targetBBox, bearing)\n      }\n    } else if (!isOrthogonal) {\n      // vertex -> vertex\n      route = Private.vertexToVertex(from, to, bearing)\n    }\n\n    // set bearing for next iteration\n    if (route) {\n      result.push(...route.points)\n      bearing = route.direction as Private.Bearings\n    } else {\n      // orthogonal route and not looped\n      bearing = Private.getBearing(from, to)\n    }\n\n    // push `to` point to identified orthogonal vertices array\n    if (i + 1 < len) {\n      result.push(to)\n    }\n  }\n\n  return result\n}\n\nnamespace Private {\n  /**\n   * Bearing to opposite bearing map\n   */\n  const opposites = {\n    N: 'S',\n    S: 'N',\n    E: 'W',\n    W: 'E',\n  }\n\n  /**\n   * Bearing to radians map\n   */\n  const radians = {\n    N: (-Math.PI / 2) * 3,\n    S: -Math.PI / 2,\n    E: 0,\n    W: Math.PI,\n  }\n\n  /**\n   * Returns a point `p` where lines p,p1 and p,p2 are perpendicular\n   * and p is not contained in the given box\n   */\n  function freeJoin(p1: Point, p2: Point, bbox: Rectangle) {\n    let p = new Point(p1.x, p2.y)\n    if (bbox.containsPoint(p)) {\n      p = new Point(p2.x, p1.y)\n    }\n\n    // kept for reference\n    // if (bbox.containsPoint(p)) {\n    //   return null\n    // }\n\n    return p\n  }\n\n  /**\n   * Returns either width or height of a bbox based on the given bearing.\n   */\n  export function getBBoxSize(bbox: Rectangle, bearing: Bearings) {\n    return bbox[bearing === 'W' || bearing === 'E' ? 'width' : 'height']\n  }\n\n  export type Bearings = ReturnType<typeof getBearing>\n\n  export function getBearing(from: Point.PointLike, to: Point.PointLike) {\n    if (from.x === to.x) {\n      return from.y > to.y ? 'N' : 'S'\n    }\n\n    if (from.y === to.y) {\n      return from.x > to.x ? 'W' : 'E'\n    }\n\n    return null\n  }\n\n  export function vertexToVertex(from: Point, to: Point, bearing: Bearings) {\n    const p1 = new Point(from.x, to.y)\n    const p2 = new Point(to.x, from.y)\n    const d1 = getBearing(from, p1)\n    const d2 = getBearing(from, p2)\n    const opposite = bearing ? opposites[bearing] : null\n\n    const p =\n      d1 === bearing || (d1 !== opposite && (d2 === opposite || d2 !== bearing))\n        ? p1\n        : p2\n\n    return { points: [p], direction: getBearing(p, to) }\n  }\n\n  export function nodeToVertex(from: Point, to: Point, fromBBox: Rectangle) {\n    const p = freeJoin(from, to, fromBBox)\n\n    return { points: [p], direction: getBearing(p, to) }\n  }\n\n  export function vertexToNode(\n    from: Point,\n    to: Point,\n    toBBox: Rectangle,\n    bearing: Bearings,\n  ) {\n    const points = [new Point(from.x, to.y), new Point(to.x, from.y)]\n    const freePoints = points.filter((p) => !toBBox.containsPoint(p))\n    const freeBearingPoints = freePoints.filter(\n      (p) => getBearing(p, from) !== bearing,\n    )\n\n    let p\n\n    if (freeBearingPoints.length > 0) {\n      // Try to pick a point which bears the same direction as the previous segment.\n\n      p = freeBearingPoints.filter((p) => getBearing(from, p) === bearing).pop()\n      p = p || freeBearingPoints[0]\n\n      return {\n        points: [p],\n        direction: getBearing(p, to),\n      }\n    }\n\n    {\n      // Here we found only points which are either contained in the element or they would create\n      // a link segment going in opposite direction from the previous one.\n      // We take the point inside element and move it outside the element in the direction the\n      // route is going. Now we can join this point with the current end (using freeJoin).\n\n      p = ArrayExt.difference(points, freePoints)[0]\n\n      const p2 = Point.create(to).move(p, -getBBoxSize(toBBox, bearing) / 2)\n      const p1 = freeJoin(p2, from, toBBox)\n\n      return {\n        points: [p1, p2],\n        direction: getBearing(p2, to),\n      }\n    }\n  }\n\n  export function nodeToNode(\n    from: Point,\n    to: Point,\n    fromBBox: Rectangle,\n    toBBox: Rectangle,\n  ) {\n    let route = nodeToVertex(to, from, toBBox)\n    const p1 = route.points[0]\n\n    if (fromBBox.containsPoint(p1)) {\n      route = nodeToVertex(from, to, fromBBox)\n      const p2 = route.points[0]\n\n      if (toBBox.containsPoint(p2)) {\n        const fromBorder = Point.create(from).move(\n          p2,\n          -getBBoxSize(fromBBox, getBearing(from, p2)) / 2,\n        )\n        const toBorder = Point.create(to).move(\n          p1,\n          -getBBoxSize(toBBox, getBearing(to, p1)) / 2,\n        )\n\n        const mid = new Line(fromBorder, toBorder).getCenter()\n        const startRoute = nodeToVertex(from, mid, fromBBox)\n        const endRoute = vertexToVertex(\n          mid,\n          to,\n          startRoute.direction as Bearings,\n        )\n\n        route.points = [startRoute.points[0], endRoute.points[0]]\n        route.direction = endRoute.direction\n      }\n    }\n\n    return route\n  }\n\n  // Finds route for situations where one node is inside the other.\n  // Typically the route is directed outside the outer node first and\n  // then back towards the inner node.\n  export function insideNode(\n    from: Point,\n    to: Point,\n    fromBBox: Rectangle,\n    toBBox: Rectangle,\n    bearing?: Bearings,\n  ) {\n    const boundary = fromBBox.union(toBBox).inflate(1)\n\n    // start from the point which is closer to the boundary\n    const center = boundary.getCenter()\n    const reversed = center.distance(to) > center.distance(from)\n    const start = reversed ? to : from\n    const end = reversed ? from : to\n\n    let p1: Point\n    let p2: Point\n    let p3: Point\n\n    if (bearing) {\n      // Points on circle with radius equals 'W + H` are always outside the rectangle\n      // with width W and height H if the center of that circle is the center of that rectangle.\n      p1 = Point.fromPolar(\n        boundary.width + boundary.height,\n        radians[bearing],\n        start,\n      )\n      p1 = boundary.getNearestPointToPoint(p1).move(p1, -1)\n    } else {\n      p1 = boundary.getNearestPointToPoint(start).move(start, 1)\n    }\n\n    p2 = freeJoin(p1, end, boundary)\n\n    let points: Point[]\n\n    if (p1.round().equals(p2.round())) {\n      p2 = Point.fromPolar(\n        boundary.width + boundary.height,\n        Angle.toRad(p1.theta(start)) + Math.PI / 2,\n        end,\n      )\n      p2 = boundary.getNearestPointToPoint(p2).move(end, 1).round()\n      p3 = freeJoin(p1, p2, boundary)\n      points = reversed ? [p2, p3, p1] : [p1, p3, p2]\n    } else {\n      points = reversed ? [p2, p1] : [p1, p2]\n    }\n\n    const direction = reversed ? getBearing(p1, to) : getBearing(p2, to)\n\n    return {\n      points,\n      direction,\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}