{"ast":null,"code":"import { Curve, Path } from '@antv/x6-geometry';\nexport const smooth = function (sourcePoint, targetPoint, routePoints, options = {}) {\n  let path;\n  let direction = options.direction;\n  if (routePoints && routePoints.length !== 0) {\n    const points = [sourcePoint, ...routePoints, targetPoint];\n    const curves = Curve.throughPoints(points);\n    path = new Path(curves);\n  } else {\n    // If we have no route, use a default cubic bezier curve, cubic bezier\n    // requires two control points, the control points have `x` midway\n    // between source and target. This produces an S-like curve.\n    path = new Path();\n    path.appendSegment(Path.createSegment('M', sourcePoint));\n    if (!direction) {\n      direction = Math.abs(sourcePoint.x - targetPoint.x) >= Math.abs(sourcePoint.y - targetPoint.y) ? 'H' : 'V';\n    }\n    if (direction === 'H') {\n      const controlPointX = (sourcePoint.x + targetPoint.x) / 2;\n      path.appendSegment(Path.createSegment('C', controlPointX, sourcePoint.y, controlPointX, targetPoint.y, targetPoint.x, targetPoint.y));\n    } else {\n      const controlPointY = (sourcePoint.y + targetPoint.y) / 2;\n      path.appendSegment(Path.createSegment('C', sourcePoint.x, controlPointY, targetPoint.x, controlPointY, targetPoint.x, targetPoint.y));\n    }\n  }\n  return options.raw ? path : path.serialize();\n};","map":{"version":3,"names":["Curve","Path","smooth","sourcePoint","targetPoint","routePoints","options","path","direction","length","points","curves","throughPoints","appendSegment","createSegment","Math","abs","x","y","controlPointX","controlPointY","raw","serialize"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/src/registry/connector/smooth.ts"],"sourcesContent":["import { Curve, Path } from '@antv/x6-geometry'\nimport { Connector } from './index'\n\nexport interface SmoothConnectorOptions extends Connector.BaseOptions {\n  direction?: 'H' | 'V'\n}\n\nexport const smooth: Connector.Definition<SmoothConnectorOptions> = function (\n  sourcePoint,\n  targetPoint,\n  routePoints,\n  options = {},\n) {\n  let path\n  let direction = options.direction\n\n  if (routePoints && routePoints.length !== 0) {\n    const points = [sourcePoint, ...routePoints, targetPoint]\n    const curves = Curve.throughPoints(points)\n    path = new Path(curves)\n  } else {\n    // If we have no route, use a default cubic bezier curve, cubic bezier\n    // requires two control points, the control points have `x` midway\n    // between source and target. This produces an S-like curve.\n\n    path = new Path()\n    path.appendSegment(Path.createSegment('M', sourcePoint))\n\n    if (!direction) {\n      direction =\n        Math.abs(sourcePoint.x - targetPoint.x) >=\n        Math.abs(sourcePoint.y - targetPoint.y)\n          ? 'H'\n          : 'V'\n    }\n\n    if (direction === 'H') {\n      const controlPointX = (sourcePoint.x + targetPoint.x) / 2\n      path.appendSegment(\n        Path.createSegment(\n          'C',\n          controlPointX,\n          sourcePoint.y,\n          controlPointX,\n          targetPoint.y,\n          targetPoint.x,\n          targetPoint.y,\n        ),\n      )\n    } else {\n      const controlPointY = (sourcePoint.y + targetPoint.y) / 2\n      path.appendSegment(\n        Path.createSegment(\n          'C',\n          sourcePoint.x,\n          controlPointY,\n          targetPoint.x,\n          controlPointY,\n          targetPoint.x,\n          targetPoint.y,\n        ),\n      )\n    }\n  }\n\n  return options.raw ? path : path.serialize()\n}\n"],"mappings":"AAAA,SAASA,KAAK,EAAEC,IAAI,QAAQ,mBAAmB;AAO/C,OAAO,MAAMC,MAAM,GAAiD,SAAAA,CAClEC,WAAW,EACXC,WAAW,EACXC,WAAW,EACXC,OAAO,GAAG,EAAE;EAEZ,IAAIC,IAAI;EACR,IAAIC,SAAS,GAAGF,OAAO,CAACE,SAAS;EAEjC,IAAIH,WAAW,IAAIA,WAAW,CAACI,MAAM,KAAK,CAAC,EAAE;IAC3C,MAAMC,MAAM,GAAG,CAACP,WAAW,EAAE,GAAGE,WAAW,EAAED,WAAW,CAAC;IACzD,MAAMO,MAAM,GAAGX,KAAK,CAACY,aAAa,CAACF,MAAM,CAAC;IAC1CH,IAAI,GAAG,IAAIN,IAAI,CAACU,MAAM,CAAC;GACxB,MAAM;IACL;IACA;IACA;IAEAJ,IAAI,GAAG,IAAIN,IAAI,EAAE;IACjBM,IAAI,CAACM,aAAa,CAACZ,IAAI,CAACa,aAAa,CAAC,GAAG,EAAEX,WAAW,CAAC,CAAC;IAExD,IAAI,CAACK,SAAS,EAAE;MACdA,SAAS,GACPO,IAAI,CAACC,GAAG,CAACb,WAAW,CAACc,CAAC,GAAGb,WAAW,CAACa,CAAC,CAAC,IACvCF,IAAI,CAACC,GAAG,CAACb,WAAW,CAACe,CAAC,GAAGd,WAAW,CAACc,CAAC,CAAC,GACnC,GAAG,GACH,GAAG;;IAGX,IAAIV,SAAS,KAAK,GAAG,EAAE;MACrB,MAAMW,aAAa,GAAG,CAAChB,WAAW,CAACc,CAAC,GAAGb,WAAW,CAACa,CAAC,IAAI,CAAC;MACzDV,IAAI,CAACM,aAAa,CAChBZ,IAAI,CAACa,aAAa,CAChB,GAAG,EACHK,aAAa,EACbhB,WAAW,CAACe,CAAC,EACbC,aAAa,EACbf,WAAW,CAACc,CAAC,EACbd,WAAW,CAACa,CAAC,EACbb,WAAW,CAACc,CAAC,CACd,CACF;KACF,MAAM;MACL,MAAME,aAAa,GAAG,CAACjB,WAAW,CAACe,CAAC,GAAGd,WAAW,CAACc,CAAC,IAAI,CAAC;MACzDX,IAAI,CAACM,aAAa,CAChBZ,IAAI,CAACa,aAAa,CAChB,GAAG,EACHX,WAAW,CAACc,CAAC,EACbG,aAAa,EACbhB,WAAW,CAACa,CAAC,EACbG,aAAa,EACbhB,WAAW,CAACa,CAAC,EACbb,WAAW,CAACc,CAAC,CACd,CACF;;;EAIL,OAAOZ,OAAO,CAACe,GAAG,GAAGd,IAAI,GAAGA,IAAI,CAACe,SAAS,EAAE;AAC9C,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}