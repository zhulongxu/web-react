{"ast":null,"code":"import { ObjectExt, ArrayExt, Dom, FunctionExt, Dictionary, StringExt } from '@antv/x6-common';\nimport { Point } from '@antv/x6-geometry';\nimport { Attr } from '../registry/attr';\nimport { View } from './view';\nimport { Util } from '../util';\nexport class AttrManager {\n  constructor(view) {\n    this.view = view;\n  }\n  get cell() {\n    return this.view.cell;\n  }\n  getDefinition(attrName) {\n    return this.cell.getAttrDefinition(attrName);\n  }\n  processAttrs(elem, raw) {\n    let normal;\n    let set;\n    let offset;\n    let position;\n    const specials = [];\n    // divide the attributes between normal and special\n    Object.keys(raw).forEach(name => {\n      const val = raw[name];\n      const definition = this.getDefinition(name);\n      const isValid = FunctionExt.call(Attr.isValidDefinition, this.view, definition, val, {\n        elem,\n        attrs: raw,\n        cell: this.cell,\n        view: this.view\n      });\n      if (definition && isValid) {\n        if (typeof definition === 'string') {\n          if (normal == null) {\n            normal = {};\n          }\n          normal[definition] = val;\n        } else if (val !== null) {\n          specials.push({\n            name,\n            definition\n          });\n        }\n      } else {\n        if (normal == null) {\n          normal = {};\n        }\n        const normalName = Dom.CASE_SENSITIVE_ATTR.includes(name) ? name : StringExt.kebabCase(name);\n        normal[normalName] = val;\n      }\n    });\n    specials.forEach(({\n      name,\n      definition\n    }) => {\n      const val = raw[name];\n      const setDefine = definition;\n      if (typeof setDefine.set === 'function') {\n        if (set == null) {\n          set = {};\n        }\n        set[name] = val;\n      }\n      const offsetDefine = definition;\n      if (typeof offsetDefine.offset === 'function') {\n        if (offset == null) {\n          offset = {};\n        }\n        offset[name] = val;\n      }\n      const positionDefine = definition;\n      if (typeof positionDefine.position === 'function') {\n        if (position == null) {\n          position = {};\n        }\n        position[name] = val;\n      }\n    });\n    return {\n      raw,\n      normal,\n      set,\n      offset,\n      position\n    };\n  }\n  mergeProcessedAttrs(allProcessedAttrs, roProcessedAttrs) {\n    allProcessedAttrs.set = Object.assign(Object.assign({}, allProcessedAttrs.set), roProcessedAttrs.set);\n    allProcessedAttrs.position = Object.assign(Object.assign({}, allProcessedAttrs.position), roProcessedAttrs.position);\n    allProcessedAttrs.offset = Object.assign(Object.assign({}, allProcessedAttrs.offset), roProcessedAttrs.offset);\n    // Handle also the special transform property.\n    const transform = allProcessedAttrs.normal && allProcessedAttrs.normal.transform;\n    if (transform != null && roProcessedAttrs.normal) {\n      roProcessedAttrs.normal.transform = transform;\n    }\n    allProcessedAttrs.normal = roProcessedAttrs.normal;\n  }\n  findAttrs(cellAttrs, rootNode, selectorCache, selectors) {\n    const merge = [];\n    const result = new Dictionary();\n    Object.keys(cellAttrs).forEach(selector => {\n      const attrs = cellAttrs[selector];\n      if (!ObjectExt.isPlainObject(attrs)) {\n        return;\n      }\n      const {\n        isCSSSelector,\n        elems\n      } = View.find(selector, rootNode, selectors);\n      selectorCache[selector] = elems;\n      for (let i = 0, l = elems.length; i < l; i += 1) {\n        const elem = elems[i];\n        const unique = selectors && selectors[selector] === elem;\n        const prev = result.get(elem);\n        if (prev) {\n          if (!prev.array) {\n            merge.push(elem);\n            prev.array = true;\n            prev.attrs = [prev.attrs];\n            prev.priority = [prev.priority];\n          }\n          const attributes = prev.attrs;\n          const selectedLength = prev.priority;\n          if (unique) {\n            // node referenced by `selector`\n            attributes.unshift(attrs);\n            selectedLength.unshift(-1);\n          } else {\n            // node referenced by `groupSelector` or CSSSelector\n            const sortIndex = ArrayExt.sortedIndex(selectedLength, isCSSSelector ? -1 : l);\n            attributes.splice(sortIndex, 0, attrs);\n            selectedLength.splice(sortIndex, 0, l);\n          }\n        } else {\n          result.set(elem, {\n            elem,\n            attrs,\n            priority: unique ? -1 : l,\n            array: false\n          });\n        }\n      }\n    });\n    merge.forEach(node => {\n      const item = result.get(node);\n      const arr = item.attrs;\n      item.attrs = arr.reduceRight((memo, attrs) => ObjectExt.merge(memo, attrs), {});\n    });\n    return result;\n  }\n  updateRelativeAttrs(elem, processedAttrs, refBBox) {\n    const rawAttrs = processedAttrs.raw || {};\n    let nodeAttrs = processedAttrs.normal || {};\n    const setAttrs = processedAttrs.set;\n    const positionAttrs = processedAttrs.position;\n    const offsetAttrs = processedAttrs.offset;\n    const getOptions = () => ({\n      elem,\n      cell: this.cell,\n      view: this.view,\n      attrs: rawAttrs,\n      refBBox: refBBox.clone()\n    });\n    if (setAttrs != null) {\n      Object.keys(setAttrs).forEach(name => {\n        const val = setAttrs[name];\n        const def = this.getDefinition(name);\n        if (def != null) {\n          const ret = FunctionExt.call(def.set, this.view, val, getOptions());\n          if (typeof ret === 'object') {\n            nodeAttrs = Object.assign(Object.assign({}, nodeAttrs), ret);\n          } else if (ret != null) {\n            nodeAttrs[name] = ret;\n          }\n        }\n      });\n    }\n    if (elem instanceof HTMLElement) {\n      // TODO: setting the `transform` attribute on HTMLElements\n      // via `node.style.transform = 'matrix(...)';` would introduce\n      // a breaking change (e.g. basic.TextBlock).\n      this.view.setAttrs(nodeAttrs, elem);\n      return;\n    }\n    // The final translation of the subelement.\n    const nodeTransform = nodeAttrs.transform;\n    const transform = nodeTransform ? `${nodeTransform}` : null;\n    const nodeMatrix = Dom.transformStringToMatrix(transform);\n    const nodePosition = new Point(nodeMatrix.e, nodeMatrix.f);\n    if (nodeTransform) {\n      delete nodeAttrs.transform;\n      nodeMatrix.e = 0;\n      nodeMatrix.f = 0;\n    }\n    let positioned = false;\n    if (positionAttrs != null) {\n      Object.keys(positionAttrs).forEach(name => {\n        const val = positionAttrs[name];\n        const def = this.getDefinition(name);\n        if (def != null) {\n          const ts = FunctionExt.call(def.position, this.view, val, getOptions());\n          if (ts != null) {\n            positioned = true;\n            nodePosition.translate(Point.create(ts));\n          }\n        }\n      });\n    }\n    // The node bounding box could depend on the `size`\n    // set from the previous loop.\n    this.view.setAttrs(nodeAttrs, elem);\n    let offseted = false;\n    if (offsetAttrs != null) {\n      // Check if the node is visible\n      const nodeBoundingRect = this.view.getBoundingRectOfElement(elem);\n      if (nodeBoundingRect.width > 0 && nodeBoundingRect.height > 0) {\n        const nodeBBox = Util.transformRectangle(nodeBoundingRect, nodeMatrix);\n        Object.keys(offsetAttrs).forEach(name => {\n          const val = offsetAttrs[name];\n          const def = this.getDefinition(name);\n          if (def != null) {\n            const ts = FunctionExt.call(def.offset, this.view, val, {\n              elem,\n              cell: this.cell,\n              view: this.view,\n              attrs: rawAttrs,\n              refBBox: nodeBBox\n            });\n            if (ts != null) {\n              offseted = true;\n              nodePosition.translate(Point.create(ts));\n            }\n          }\n        });\n      }\n    }\n    if (nodeTransform != null || positioned || offseted) {\n      nodePosition.round(1);\n      nodeMatrix.e = nodePosition.x;\n      nodeMatrix.f = nodePosition.y;\n      elem.setAttribute('transform', Dom.matrixToTransformString(nodeMatrix));\n    }\n  }\n  update(rootNode, attrs, options) {\n    const selectorCache = {};\n    const nodesAttrs = this.findAttrs(options.attrs || attrs, rootNode, selectorCache, options.selectors);\n    // `nodesAttrs` are different from all attributes, when\n    // rendering only attributes sent to this method.\n    const nodesAllAttrs = options.attrs ? this.findAttrs(attrs, rootNode, selectorCache, options.selectors) : nodesAttrs;\n    const specialItems = [];\n    nodesAttrs.each(data => {\n      const node = data.elem;\n      const nodeAttrs = data.attrs;\n      const processed = this.processAttrs(node, nodeAttrs);\n      if (processed.set == null && processed.position == null && processed.offset == null) {\n        this.view.setAttrs(processed.normal, node);\n      } else {\n        const data = nodesAllAttrs.get(node);\n        const nodeAllAttrs = data ? data.attrs : null;\n        const refSelector = nodeAllAttrs && nodeAttrs.ref == null ? nodeAllAttrs.ref : nodeAttrs.ref;\n        let refNode;\n        if (refSelector) {\n          refNode = (selectorCache[refSelector] || this.view.find(refSelector, rootNode, options.selectors))[0];\n          if (!refNode) {\n            throw new Error(`\"${refSelector}\" reference does not exist.`);\n          }\n        } else {\n          refNode = null;\n        }\n        const item = {\n          node,\n          refNode,\n          attributes: nodeAllAttrs,\n          processedAttributes: processed\n        };\n        // If an element in the list is positioned relative to this one, then\n        // we want to insert this one before it in the list.\n        const index = specialItems.findIndex(item => item.refNode === node);\n        if (index > -1) {\n          specialItems.splice(index, 0, item);\n        } else {\n          specialItems.push(item);\n        }\n      }\n    });\n    const bboxCache = new Dictionary();\n    let rotatableMatrix;\n    specialItems.forEach(item => {\n      const node = item.node;\n      const refNode = item.refNode;\n      let unrotatedRefBBox;\n      const isRefNodeRotatable = refNode != null && options.rotatableNode != null && Dom.contains(options.rotatableNode, refNode);\n      // Find the reference element bounding box. If no reference was\n      // provided, we use the optional bounding box.\n      if (refNode) {\n        unrotatedRefBBox = bboxCache.get(refNode);\n      }\n      if (!unrotatedRefBBox) {\n        const target = isRefNodeRotatable ? options.rotatableNode : rootNode;\n        unrotatedRefBBox = refNode ? Util.getBBox(refNode, {\n          target\n        }) : options.rootBBox;\n        if (refNode) {\n          bboxCache.set(refNode, unrotatedRefBBox);\n        }\n      }\n      let processedAttrs;\n      if (options.attrs && item.attributes) {\n        // If there was a special attribute affecting the position amongst\n        // passed-in attributes we have to merge it with the rest of the\n        // element's attributes as they are necessary to update the position\n        // relatively (i.e `ref-x` && 'ref-dx').\n        processedAttrs = this.processAttrs(node, item.attributes);\n        this.mergeProcessedAttrs(processedAttrs, item.processedAttributes);\n      } else {\n        processedAttrs = item.processedAttributes;\n      }\n      let refBBox = unrotatedRefBBox;\n      if (isRefNodeRotatable && options.rotatableNode != null && !options.rotatableNode.contains(node)) {\n        // If the referenced node is inside the rotatable group while the\n        // updated node is outside, we need to take the rotatable node\n        // transformation into account.\n        if (!rotatableMatrix) {\n          rotatableMatrix = Dom.transformStringToMatrix(Dom.attr(options.rotatableNode, 'transform'));\n        }\n        refBBox = Util.transformRectangle(unrotatedRefBBox, rotatableMatrix);\n      }\n      this.updateRelativeAttrs(node, processedAttrs, refBBox);\n    });\n  }\n}","map":{"version":3,"names":["ObjectExt","ArrayExt","Dom","FunctionExt","Dictionary","StringExt","Point","Attr","View","Util","AttrManager","constructor","view","cell","getDefinition","attrName","getAttrDefinition","processAttrs","elem","raw","normal","set","offset","position","specials","Object","keys","forEach","name","val","definition","isValid","call","isValidDefinition","attrs","push","normalName","CASE_SENSITIVE_ATTR","includes","kebabCase","setDefine","offsetDefine","positionDefine","mergeProcessedAttrs","allProcessedAttrs","roProcessedAttrs","assign","transform","findAttrs","cellAttrs","rootNode","selectorCache","selectors","merge","result","selector","isPlainObject","isCSSSelector","elems","find","i","l","length","unique","prev","get","array","priority","attributes","selectedLength","unshift","sortIndex","sortedIndex","splice","node","item","arr","reduceRight","memo","updateRelativeAttrs","processedAttrs","refBBox","rawAttrs","nodeAttrs","setAttrs","positionAttrs","offsetAttrs","getOptions","clone","def","ret","HTMLElement","nodeTransform","nodeMatrix","transformStringToMatrix","nodePosition","e","f","positioned","ts","translate","create","offseted","nodeBoundingRect","getBoundingRectOfElement","width","height","nodeBBox","transformRectangle","round","x","y","setAttribute","matrixToTransformString","update","options","nodesAttrs","nodesAllAttrs","specialItems","each","data","processed","nodeAllAttrs","refSelector","ref","refNode","Error","processedAttributes","index","findIndex","bboxCache","rotatableMatrix","unrotatedRefBBox","isRefNodeRotatable","rotatableNode","contains","target","getBBox","rootBBox","attr"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/src/view/attr.ts"],"sourcesContent":["import {\n  ObjectExt,\n  ArrayExt,\n  Dom,\n  FunctionExt,\n  Dictionary,\n  StringExt,\n} from '@antv/x6-common'\nimport { Rectangle, Point } from '@antv/x6-geometry'\nimport { Attr } from '../registry/attr'\nimport { View } from './view'\nimport { Markup } from './markup'\nimport { CellView } from './cell'\nimport { Util } from '../util'\n\nexport class AttrManager {\n  constructor(protected view: CellView) {}\n\n  protected get cell() {\n    return this.view.cell\n  }\n\n  protected getDefinition(attrName: string): Attr.Definition | null {\n    return this.cell.getAttrDefinition(attrName)\n  }\n\n  protected processAttrs(\n    elem: Element,\n    raw: Attr.ComplexAttrs,\n  ): AttrManager.ProcessedAttrs {\n    let normal: Attr.SimpleAttrs | undefined\n    let set: Attr.ComplexAttrs | undefined\n    let offset: Attr.ComplexAttrs | undefined\n    let position: Attr.ComplexAttrs | undefined\n\n    const specials: { name: string; definition: Attr.Definition }[] = []\n\n    // divide the attributes between normal and special\n    Object.keys(raw).forEach((name) => {\n      const val = raw[name]\n      const definition = this.getDefinition(name)\n      const isValid = FunctionExt.call(\n        Attr.isValidDefinition,\n        this.view,\n        definition,\n        val,\n        {\n          elem,\n          attrs: raw,\n          cell: this.cell,\n          view: this.view,\n        },\n      )\n\n      if (definition && isValid) {\n        if (typeof definition === 'string') {\n          if (normal == null) {\n            normal = {}\n          }\n          normal[definition] = val as Attr.SimpleAttrValue\n        } else if (val !== null) {\n          specials.push({ name, definition })\n        }\n      } else {\n        if (normal == null) {\n          normal = {}\n        }\n        const normalName = Dom.CASE_SENSITIVE_ATTR.includes(name)\n          ? name\n          : StringExt.kebabCase(name)\n        normal[normalName] = val as Attr.SimpleAttrValue\n      }\n    })\n\n    specials.forEach(({ name, definition }) => {\n      const val = raw[name]\n\n      const setDefine = definition as Attr.SetDefinition\n      if (typeof setDefine.set === 'function') {\n        if (set == null) {\n          set = {}\n        }\n        set[name] = val\n      }\n\n      const offsetDefine = definition as Attr.OffsetDefinition\n      if (typeof offsetDefine.offset === 'function') {\n        if (offset == null) {\n          offset = {}\n        }\n        offset[name] = val\n      }\n\n      const positionDefine = definition as Attr.PositionDefinition\n      if (typeof positionDefine.position === 'function') {\n        if (position == null) {\n          position = {}\n        }\n        position[name] = val\n      }\n    })\n\n    return {\n      raw,\n      normal,\n      set,\n      offset,\n      position,\n    }\n  }\n\n  protected mergeProcessedAttrs(\n    allProcessedAttrs: AttrManager.ProcessedAttrs,\n    roProcessedAttrs: AttrManager.ProcessedAttrs,\n  ) {\n    allProcessedAttrs.set = {\n      ...allProcessedAttrs.set,\n      ...roProcessedAttrs.set,\n    }\n\n    allProcessedAttrs.position = {\n      ...allProcessedAttrs.position,\n      ...roProcessedAttrs.position,\n    }\n\n    allProcessedAttrs.offset = {\n      ...allProcessedAttrs.offset,\n      ...roProcessedAttrs.offset,\n    }\n\n    // Handle also the special transform property.\n    const transform =\n      allProcessedAttrs.normal && allProcessedAttrs.normal.transform\n    if (transform != null && roProcessedAttrs.normal) {\n      roProcessedAttrs.normal.transform = transform\n    }\n    allProcessedAttrs.normal = roProcessedAttrs.normal\n  }\n\n  protected findAttrs(\n    cellAttrs: Attr.CellAttrs,\n    rootNode: Element,\n    selectorCache: { [selector: string]: Element[] },\n    selectors: Markup.Selectors,\n  ) {\n    const merge: Element[] = []\n    const result: Dictionary<\n      Element,\n      {\n        elem: Element\n        array: boolean\n        priority: number | number[]\n        attrs: Attr.ComplexAttrs | Attr.ComplexAttrs[]\n      }\n    > = new Dictionary()\n\n    Object.keys(cellAttrs).forEach((selector) => {\n      const attrs = cellAttrs[selector]\n      if (!ObjectExt.isPlainObject(attrs)) {\n        return\n      }\n\n      const { isCSSSelector, elems } = View.find(selector, rootNode, selectors)\n      selectorCache[selector] = elems\n      for (let i = 0, l = elems.length; i < l; i += 1) {\n        const elem = elems[i]\n        const unique = selectors && selectors[selector] === elem\n        const prev = result.get(elem)\n        if (prev) {\n          if (!prev.array) {\n            merge.push(elem)\n            prev.array = true\n            prev.attrs = [prev.attrs as Attr.ComplexAttrs]\n            prev.priority = [prev.priority as number]\n          }\n\n          const attributes = prev.attrs as Attr.ComplexAttrs[]\n          const selectedLength = prev.priority as number[]\n          if (unique) {\n            // node referenced by `selector`\n            attributes.unshift(attrs)\n            selectedLength.unshift(-1)\n          } else {\n            // node referenced by `groupSelector` or CSSSelector\n            const sortIndex = ArrayExt.sortedIndex(\n              selectedLength,\n              isCSSSelector ? -1 : l,\n            )\n\n            attributes.splice(sortIndex, 0, attrs)\n            selectedLength.splice(sortIndex, 0, l)\n          }\n        } else {\n          result.set(elem, {\n            elem,\n            attrs,\n            priority: unique ? -1 : l,\n            array: false,\n          })\n        }\n      }\n    })\n\n    merge.forEach((node) => {\n      const item = result.get(node)!\n      const arr = item.attrs as Attr.ComplexAttrs[]\n      item.attrs = arr.reduceRight(\n        (memo, attrs) => ObjectExt.merge(memo, attrs),\n        {},\n      )\n    })\n\n    return result as Dictionary<\n      Element,\n      {\n        elem: Element\n        array: boolean\n        priority: number | number[]\n        attrs: Attr.ComplexAttrs\n      }\n    >\n  }\n\n  protected updateRelativeAttrs(\n    elem: Element,\n    processedAttrs: AttrManager.ProcessedAttrs,\n    refBBox: Rectangle,\n  ) {\n    const rawAttrs = processedAttrs.raw || {}\n    let nodeAttrs = processedAttrs.normal || {}\n    const setAttrs = processedAttrs.set\n    const positionAttrs = processedAttrs.position\n    const offsetAttrs = processedAttrs.offset\n    const getOptions = () => ({\n      elem,\n      cell: this.cell,\n      view: this.view,\n      attrs: rawAttrs,\n      refBBox: refBBox.clone(),\n    })\n\n    if (setAttrs != null) {\n      Object.keys(setAttrs).forEach((name) => {\n        const val = setAttrs[name]\n        const def = this.getDefinition(name)\n        if (def != null) {\n          const ret = FunctionExt.call(\n            (def as Attr.SetDefinition).set,\n            this.view,\n            val,\n            getOptions(),\n          )\n          if (typeof ret === 'object') {\n            nodeAttrs = {\n              ...nodeAttrs,\n              ...ret,\n            }\n          } else if (ret != null) {\n            nodeAttrs[name] = ret\n          }\n        }\n      })\n    }\n\n    if (elem instanceof HTMLElement) {\n      // TODO: setting the `transform` attribute on HTMLElements\n      // via `node.style.transform = 'matrix(...)';` would introduce\n      // a breaking change (e.g. basic.TextBlock).\n      this.view.setAttrs(nodeAttrs, elem)\n      return\n    }\n\n    // The final translation of the subelement.\n    const nodeTransform = nodeAttrs.transform\n    const transform = nodeTransform ? `${nodeTransform}` : null\n    const nodeMatrix = Dom.transformStringToMatrix(transform)\n    const nodePosition = new Point(nodeMatrix.e, nodeMatrix.f)\n    if (nodeTransform) {\n      delete nodeAttrs.transform\n      nodeMatrix.e = 0\n      nodeMatrix.f = 0\n    }\n\n    let positioned = false\n    if (positionAttrs != null) {\n      Object.keys(positionAttrs).forEach((name) => {\n        const val = positionAttrs[name]\n        const def = this.getDefinition(name)\n        if (def != null) {\n          const ts = FunctionExt.call(\n            (def as Attr.PositionDefinition).position,\n            this.view,\n            val,\n            getOptions(),\n          )\n\n          if (ts != null) {\n            positioned = true\n            nodePosition.translate(Point.create(ts))\n          }\n        }\n      })\n    }\n\n    // The node bounding box could depend on the `size`\n    // set from the previous loop.\n    this.view.setAttrs(nodeAttrs, elem)\n\n    let offseted = false\n    if (offsetAttrs != null) {\n      // Check if the node is visible\n      const nodeBoundingRect = this.view.getBoundingRectOfElement(elem)\n      if (nodeBoundingRect.width > 0 && nodeBoundingRect.height > 0) {\n        const nodeBBox = Util.transformRectangle(nodeBoundingRect, nodeMatrix)\n\n        Object.keys(offsetAttrs).forEach((name) => {\n          const val = offsetAttrs[name]\n          const def = this.getDefinition(name)\n          if (def != null) {\n            const ts = FunctionExt.call(\n              (def as Attr.OffsetDefinition).offset,\n              this.view,\n              val,\n              {\n                elem,\n                cell: this.cell,\n                view: this.view,\n                attrs: rawAttrs,\n                refBBox: nodeBBox,\n              },\n            )\n\n            if (ts != null) {\n              offseted = true\n              nodePosition.translate(Point.create(ts))\n            }\n          }\n        })\n      }\n    }\n\n    if (nodeTransform != null || positioned || offseted) {\n      nodePosition.round(1)\n      nodeMatrix.e = nodePosition.x\n      nodeMatrix.f = nodePosition.y\n      elem.setAttribute('transform', Dom.matrixToTransformString(nodeMatrix))\n    }\n  }\n\n  update(\n    rootNode: Element,\n    attrs: Attr.CellAttrs,\n    options: AttrManager.UpdateOptions,\n  ) {\n    const selectorCache: { [selector: string]: Element[] } = {}\n    const nodesAttrs = this.findAttrs(\n      options.attrs || attrs,\n      rootNode,\n      selectorCache,\n      options.selectors,\n    )\n\n    // `nodesAttrs` are different from all attributes, when\n    // rendering only attributes sent to this method.\n    const nodesAllAttrs = options.attrs\n      ? this.findAttrs(attrs, rootNode, selectorCache, options.selectors)\n      : nodesAttrs\n\n    const specialItems: {\n      node: Element\n      refNode: Element | null\n      attributes: Attr.ComplexAttrs | null\n      processedAttributes: AttrManager.ProcessedAttrs\n    }[] = []\n\n    nodesAttrs.each((data) => {\n      const node = data.elem\n      const nodeAttrs = data.attrs\n      const processed = this.processAttrs(node, nodeAttrs)\n      if (\n        processed.set == null &&\n        processed.position == null &&\n        processed.offset == null\n      ) {\n        this.view.setAttrs(processed.normal, node)\n      } else {\n        const data = nodesAllAttrs.get(node)\n        const nodeAllAttrs = data ? data.attrs : null\n        const refSelector =\n          nodeAllAttrs && nodeAttrs.ref == null\n            ? nodeAllAttrs.ref\n            : nodeAttrs.ref\n\n        let refNode: Element | null\n        if (refSelector) {\n          refNode = (selectorCache[refSelector as string] ||\n            this.view.find(\n              refSelector as string,\n              rootNode,\n              options.selectors,\n            ))[0]\n          if (!refNode) {\n            throw new Error(`\"${refSelector}\" reference does not exist.`)\n          }\n        } else {\n          refNode = null\n        }\n\n        const item = {\n          node,\n          refNode,\n          attributes: nodeAllAttrs,\n          processedAttributes: processed,\n        }\n\n        // If an element in the list is positioned relative to this one, then\n        // we want to insert this one before it in the list.\n        const index = specialItems.findIndex((item) => item.refNode === node)\n        if (index > -1) {\n          specialItems.splice(index, 0, item)\n        } else {\n          specialItems.push(item)\n        }\n      }\n    })\n\n    const bboxCache: Dictionary<Element, Rectangle> = new Dictionary()\n    let rotatableMatrix: DOMMatrix\n    specialItems.forEach((item) => {\n      const node = item.node\n      const refNode = item.refNode\n\n      let unrotatedRefBBox: Rectangle | undefined\n      const isRefNodeRotatable =\n        refNode != null &&\n        options.rotatableNode != null &&\n        Dom.contains(options.rotatableNode, refNode)\n\n      // Find the reference element bounding box. If no reference was\n      // provided, we use the optional bounding box.\n      if (refNode) {\n        unrotatedRefBBox = bboxCache.get(refNode)\n      }\n\n      if (!unrotatedRefBBox) {\n        const target = (\n          isRefNodeRotatable ? options.rotatableNode! : rootNode\n        ) as SVGElement\n\n        unrotatedRefBBox = refNode\n          ? Util.getBBox(refNode as SVGElement, { target })\n          : options.rootBBox\n\n        if (refNode) {\n          bboxCache.set(refNode, unrotatedRefBBox!)\n        }\n      }\n\n      let processedAttrs\n      if (options.attrs && item.attributes) {\n        // If there was a special attribute affecting the position amongst\n        // passed-in attributes we have to merge it with the rest of the\n        // element's attributes as they are necessary to update the position\n        // relatively (i.e `ref-x` && 'ref-dx').\n        processedAttrs = this.processAttrs(node, item.attributes)\n        this.mergeProcessedAttrs(processedAttrs, item.processedAttributes)\n      } else {\n        processedAttrs = item.processedAttributes\n      }\n\n      let refBBox = unrotatedRefBBox!\n      if (\n        isRefNodeRotatable &&\n        options.rotatableNode != null &&\n        !options.rotatableNode.contains(node)\n      ) {\n        // If the referenced node is inside the rotatable group while the\n        // updated node is outside, we need to take the rotatable node\n        // transformation into account.\n        if (!rotatableMatrix) {\n          rotatableMatrix = Dom.transformStringToMatrix(\n            Dom.attr(options.rotatableNode, 'transform'),\n          )\n        }\n        refBBox = Util.transformRectangle(unrotatedRefBBox!, rotatableMatrix)\n      }\n\n      this.updateRelativeAttrs(node, processedAttrs, refBBox)\n    })\n  }\n}\n\nexport namespace AttrManager {\n  export interface UpdateOptions {\n    rootBBox: Rectangle\n    selectors: Markup.Selectors\n    scalableNode?: Element | null\n    rotatableNode?: Element | null\n    /**\n     * Rendering only the specified attributes.\n     */\n    attrs?: Attr.CellAttrs | null\n  }\n\n  export interface ProcessedAttrs {\n    raw: Attr.ComplexAttrs\n    normal?: Attr.SimpleAttrs | undefined\n    set?: Attr.ComplexAttrs | undefined\n    offset?: Attr.ComplexAttrs | undefined\n    position?: Attr.ComplexAttrs | undefined\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}