{"ast":null,"code":"import { Line } from '../line';\nimport { Curve } from '../curve';\nimport { Point } from '../point';\nimport { LineTo } from './lineto';\nimport { Segment } from './segment';\nexport class MoveTo extends Segment {\n  constructor(x, y) {\n    super();\n    this.isVisible = false;\n    this.isSubpathStart = true;\n    if (Line.isLine(x) || Curve.isCurve(x)) {\n      this.endPoint = x.end.clone().round(2);\n    } else {\n      this.endPoint = Point.create(x, y).round(2);\n    }\n  }\n  get start() {\n    throw new Error('Illegal access. Moveto segments should not need a start property.');\n  }\n  get type() {\n    return 'M';\n  }\n  bbox() {\n    return null;\n  }\n  closestPoint() {\n    return this.end.clone();\n  }\n  closestPointLength() {\n    return 0;\n  }\n  closestPointNormalizedLength() {\n    return 0;\n  }\n  closestPointT() {\n    return 1;\n  }\n  closestPointTangent() {\n    return null;\n  }\n  length() {\n    return 0;\n  }\n  lengthAtT() {\n    return 0;\n  }\n  divideAt() {\n    return [this.clone(), this.clone()];\n  }\n  divideAtLength() {\n    return [this.clone(), this.clone()];\n  }\n  getSubdivisions() {\n    return [];\n  }\n  pointAt() {\n    return this.end.clone();\n  }\n  pointAtLength() {\n    return this.end.clone();\n  }\n  pointAtT() {\n    return this.end.clone();\n  }\n  tangentAt() {\n    return null;\n  }\n  tangentAtLength() {\n    return null;\n  }\n  tangentAtT() {\n    return null;\n  }\n  isDifferentiable() {\n    return false;\n  }\n  scale(sx, sy, origin) {\n    this.end.scale(sx, sy, origin);\n    return this;\n  }\n  rotate(angle, origin) {\n    this.end.rotate(angle, origin);\n    return this;\n  }\n  translate(tx, ty) {\n    if (typeof tx === 'number') {\n      this.end.translate(tx, ty);\n    } else {\n      this.end.translate(tx);\n    }\n    return this;\n  }\n  clone() {\n    return new MoveTo(this.end);\n  }\n  equals(s) {\n    return this.type === s.type && this.end.equals(s.end);\n  }\n  toJSON() {\n    return {\n      type: this.type,\n      end: this.end.toJSON()\n    };\n  }\n  serialize() {\n    const end = this.end;\n    return `${this.type} ${end.x} ${end.y}`;\n  }\n}\n(function (MoveTo) {\n  function create(...args) {\n    const len = args.length;\n    const arg0 = args[0];\n    // line provided\n    if (Line.isLine(arg0)) {\n      return new MoveTo(arg0);\n    }\n    // curve provided\n    if (Curve.isCurve(arg0)) {\n      return new MoveTo(arg0);\n    }\n    // points provided\n    if (Point.isPointLike(arg0)) {\n      if (len === 1) {\n        return new MoveTo(arg0);\n      }\n      // this is a moveto-with-subsequent-poly-line segment\n      const segments = [];\n      // points come one by one\n      for (let i = 0; i < len; i += 1) {\n        if (i === 0) {\n          segments.push(new MoveTo(args[i]));\n        } else {\n          segments.push(new LineTo(args[i]));\n        }\n      }\n      return segments;\n    }\n    // coordinates provided\n    if (len === 2) {\n      return new MoveTo(+args[0], +args[1]);\n    }\n    // this is a moveto-with-subsequent-poly-line segment\n    const segments = [];\n    for (let i = 0; i < len; i += 2) {\n      const x = +args[i];\n      const y = +args[i + 1];\n      if (i === 0) {\n        segments.push(new MoveTo(x, y));\n      } else {\n        segments.push(new LineTo(x, y));\n      }\n    }\n    return segments;\n  }\n  MoveTo.create = create;\n})(MoveTo || (MoveTo = {}));","map":{"version":3,"names":["Line","Curve","Point","LineTo","Segment","MoveTo","constructor","x","y","isVisible","isSubpathStart","isLine","isCurve","endPoint","end","clone","round","create","start","Error","type","bbox","closestPoint","closestPointLength","closestPointNormalizedLength","closestPointT","closestPointTangent","length","lengthAtT","divideAt","divideAtLength","getSubdivisions","pointAt","pointAtLength","pointAtT","tangentAt","tangentAtLength","tangentAtT","isDifferentiable","scale","sx","sy","origin","rotate","angle","translate","tx","ty","equals","s","toJSON","serialize","args","len","arg0","isPointLike","segments","i","push"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6-geometry@2.0.5/node_modules/@antv/x6-geometry/src/path/moveto.ts"],"sourcesContent":["import { Line } from '../line'\nimport { Curve } from '../curve'\nimport { Point } from '../point'\nimport { LineTo } from './lineto'\nimport { Segment } from './segment'\n\nexport class MoveTo extends Segment {\n  constructor(line: Line)\n  constructor(curve: Curve)\n  constructor(x: number, y: number)\n  constructor(p: Point.PointLike | Point.PointData)\n  constructor(\n    x: number | Curve | Line | (Point.PointLike | Point.PointData),\n    y?: number,\n  ) {\n    super()\n\n    this.isVisible = false\n    this.isSubpathStart = true\n\n    if (Line.isLine(x) || Curve.isCurve(x)) {\n      this.endPoint = x.end.clone().round(2)\n    } else {\n      this.endPoint = Point.create(x, y).round(2)\n    }\n  }\n\n  get start(): Point {\n    throw new Error(\n      'Illegal access. Moveto segments should not need a start property.',\n    )\n  }\n\n  get type() {\n    return 'M'\n  }\n\n  bbox() {\n    return null\n  }\n\n  closestPoint() {\n    return this.end.clone()\n  }\n\n  closestPointLength() {\n    return 0\n  }\n\n  closestPointNormalizedLength() {\n    return 0\n  }\n\n  closestPointT() {\n    return 1\n  }\n\n  closestPointTangent() {\n    return null\n  }\n\n  length() {\n    return 0\n  }\n\n  lengthAtT() {\n    return 0\n  }\n\n  divideAt(): [Segment, Segment] {\n    return [this.clone(), this.clone()]\n  }\n\n  divideAtLength(): [Segment, Segment] {\n    return [this.clone(), this.clone()]\n  }\n\n  getSubdivisions() {\n    return []\n  }\n\n  pointAt() {\n    return this.end.clone()\n  }\n\n  pointAtLength() {\n    return this.end.clone()\n  }\n\n  pointAtT() {\n    return this.end.clone()\n  }\n\n  tangentAt() {\n    return null\n  }\n\n  tangentAtLength() {\n    return null\n  }\n\n  tangentAtT() {\n    return null\n  }\n\n  isDifferentiable() {\n    return false\n  }\n\n  scale(sx: number, sy: number, origin?: Point.PointLike | Point.PointData) {\n    this.end.scale(sx, sy, origin)\n    return this\n  }\n\n  rotate(angle: number, origin?: Point.PointLike | Point.PointData) {\n    this.end.rotate(angle, origin)\n    return this\n  }\n\n  translate(tx: number, ty: number): this\n  translate(p: Point.PointLike | Point.PointData): this\n  translate(tx: number | Point.PointLike | Point.PointData, ty?: number) {\n    if (typeof tx === 'number') {\n      this.end.translate(tx, ty as number)\n    } else {\n      this.end.translate(tx)\n    }\n    return this\n  }\n\n  clone() {\n    return new MoveTo(this.end)\n  }\n\n  equals(s: Segment) {\n    return this.type === s.type && this.end.equals(s.end)\n  }\n\n  toJSON() {\n    return {\n      type: this.type,\n      end: this.end.toJSON(),\n    }\n  }\n\n  serialize() {\n    const end = this.end\n    return `${this.type} ${end.x} ${end.y}`\n  }\n}\n\nexport namespace MoveTo {\n  export function create(line: Line): MoveTo\n  export function create(curve: Curve): MoveTo\n  export function create(point: Point.PointLike): MoveTo\n  export function create(x: number, y: number): MoveTo\n  export function create(\n    point: Point.PointLike,\n    ...points: Point.PointLike[]\n  ): Segment[]\n  export function create(x: number, y: number, ...coords: number[]): Segment[]\n  export function create(...args: any[]): MoveTo | Segment[] {\n    const len = args.length\n    const arg0 = args[0]\n\n    // line provided\n    if (Line.isLine(arg0)) {\n      return new MoveTo(arg0)\n    }\n\n    // curve provided\n    if (Curve.isCurve(arg0)) {\n      return new MoveTo(arg0)\n    }\n\n    // points provided\n    if (Point.isPointLike(arg0)) {\n      if (len === 1) {\n        return new MoveTo(arg0)\n      }\n\n      // this is a moveto-with-subsequent-poly-line segment\n      const segments: Segment[] = []\n      // points come one by one\n      for (let i = 0; i < len; i += 1) {\n        if (i === 0) {\n          segments.push(new MoveTo(args[i]))\n        } else {\n          segments.push(new LineTo(args[i]))\n        }\n      }\n      return segments\n    }\n\n    // coordinates provided\n    if (len === 2) {\n      return new MoveTo(+args[0], +args[1])\n    }\n\n    // this is a moveto-with-subsequent-poly-line segment\n    const segments: Segment[] = []\n    for (let i = 0; i < len; i += 2) {\n      const x = +args[i]\n      const y = +args[i + 1]\n      if (i === 0) {\n        segments.push(new MoveTo(x, y))\n      } else {\n        segments.push(new LineTo(x, y))\n      }\n    }\n    return segments\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}