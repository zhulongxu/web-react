{"ast":null,"code":"import { Path, Point } from '@antv/x6-geometry';\nexport const loop = function (sourcePoint, targetPoint, routePoints, options = {}) {\n  const fix = routePoints.length === 3 ? 0 : 1;\n  const p1 = Point.create(routePoints[0 + fix]);\n  const p2 = Point.create(routePoints[2 + fix]);\n  const center = Point.create(routePoints[1 + fix]);\n  if (!Point.equals(sourcePoint, targetPoint)) {\n    const middle = new Point((sourcePoint.x + targetPoint.x) / 2, (sourcePoint.y + targetPoint.y) / 2);\n    const angle = middle.angleBetween(Point.create(sourcePoint).rotate(90, middle), center);\n    if (angle > 1) {\n      p1.rotate(180 - angle, middle);\n      p2.rotate(180 - angle, middle);\n      center.rotate(180 - angle, middle);\n    }\n  }\n  const pathData = `\n     M ${sourcePoint.x} ${sourcePoint.y}\n     Q ${p1.x} ${p1.y} ${center.x} ${center.y}\n     Q ${p2.x} ${p2.y} ${targetPoint.x} ${targetPoint.y}\n  `;\n  return options.raw ? Path.parse(pathData) : pathData;\n};","map":{"version":3,"names":["Path","Point","loop","sourcePoint","targetPoint","routePoints","options","fix","length","p1","create","p2","center","equals","middle","x","y","angle","angleBetween","rotate","pathData","raw","parse"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/src/registry/connector/loop.ts"],"sourcesContent":["import { Path, Point } from '@antv/x6-geometry'\nimport { Connector } from './index'\n\nexport interface LoopConnectorOptions extends Connector.BaseOptions {\n  split?: boolean | number\n}\n\nexport const loop: Connector.Definition<LoopConnectorOptions> = function (\n  sourcePoint,\n  targetPoint,\n  routePoints,\n  options = {},\n) {\n  const fix = routePoints.length === 3 ? 0 : 1\n  const p1 = Point.create(routePoints[0 + fix])\n  const p2 = Point.create(routePoints[2 + fix])\n  const center = Point.create(routePoints[1 + fix])\n\n  if (!Point.equals(sourcePoint, targetPoint)) {\n    const middle = new Point(\n      (sourcePoint.x + targetPoint.x) / 2,\n      (sourcePoint.y + targetPoint.y) / 2,\n    )\n    const angle = middle.angleBetween(\n      Point.create(sourcePoint).rotate(90, middle),\n      center,\n    )\n    if (angle > 1) {\n      p1.rotate(180 - angle, middle)\n      p2.rotate(180 - angle, middle)\n      center.rotate(180 - angle, middle)\n    }\n  }\n\n  const pathData = `\n     M ${sourcePoint.x} ${sourcePoint.y}\n     Q ${p1.x} ${p1.y} ${center.x} ${center.y}\n     Q ${p2.x} ${p2.y} ${targetPoint.x} ${targetPoint.y}\n  `\n\n  return options.raw ? Path.parse(pathData) : pathData\n}\n"],"mappings":"AAAA,SAASA,IAAI,EAAEC,KAAK,QAAQ,mBAAmB;AAO/C,OAAO,MAAMC,IAAI,GAA+C,SAAAA,CAC9DC,WAAW,EACXC,WAAW,EACXC,WAAW,EACXC,OAAO,GAAG,EAAE;EAEZ,MAAMC,GAAG,GAAGF,WAAW,CAACG,MAAM,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC;EAC5C,MAAMC,EAAE,GAAGR,KAAK,CAACS,MAAM,CAACL,WAAW,CAAC,CAAC,GAAGE,GAAG,CAAC,CAAC;EAC7C,MAAMI,EAAE,GAAGV,KAAK,CAACS,MAAM,CAACL,WAAW,CAAC,CAAC,GAAGE,GAAG,CAAC,CAAC;EAC7C,MAAMK,MAAM,GAAGX,KAAK,CAACS,MAAM,CAACL,WAAW,CAAC,CAAC,GAAGE,GAAG,CAAC,CAAC;EAEjD,IAAI,CAACN,KAAK,CAACY,MAAM,CAACV,WAAW,EAAEC,WAAW,CAAC,EAAE;IAC3C,MAAMU,MAAM,GAAG,IAAIb,KAAK,CACtB,CAACE,WAAW,CAACY,CAAC,GAAGX,WAAW,CAACW,CAAC,IAAI,CAAC,EACnC,CAACZ,WAAW,CAACa,CAAC,GAAGZ,WAAW,CAACY,CAAC,IAAI,CAAC,CACpC;IACD,MAAMC,KAAK,GAAGH,MAAM,CAACI,YAAY,CAC/BjB,KAAK,CAACS,MAAM,CAACP,WAAW,CAAC,CAACgB,MAAM,CAAC,EAAE,EAAEL,MAAM,CAAC,EAC5CF,MAAM,CACP;IACD,IAAIK,KAAK,GAAG,CAAC,EAAE;MACbR,EAAE,CAACU,MAAM,CAAC,GAAG,GAAGF,KAAK,EAAEH,MAAM,CAAC;MAC9BH,EAAE,CAACQ,MAAM,CAAC,GAAG,GAAGF,KAAK,EAAEH,MAAM,CAAC;MAC9BF,MAAM,CAACO,MAAM,CAAC,GAAG,GAAGF,KAAK,EAAEH,MAAM,CAAC;;;EAItC,MAAMM,QAAQ,GAAG;SACVjB,WAAW,CAACY,CAAC,IAAIZ,WAAW,CAACa,CAAC;SAC9BP,EAAE,CAACM,CAAC,IAAIN,EAAE,CAACO,CAAC,IAAIJ,MAAM,CAACG,CAAC,IAAIH,MAAM,CAACI,CAAC;SACpCL,EAAE,CAACI,CAAC,IAAIJ,EAAE,CAACK,CAAC,IAAIZ,WAAW,CAACW,CAAC,IAAIX,WAAW,CAACY,CAAC;GACpD;EAED,OAAOV,OAAO,CAACe,GAAG,GAAGrB,IAAI,CAACsB,KAAK,CAACF,QAAQ,CAAC,GAAGA,QAAQ;AACtD,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}