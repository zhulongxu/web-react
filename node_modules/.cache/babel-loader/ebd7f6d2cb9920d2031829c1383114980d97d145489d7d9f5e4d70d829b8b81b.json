{"ast":null,"code":"import { Angle, Point, Line } from '@antv/x6-geometry';\nfunction rollup(points, merge) {\n  if (merge != null && merge !== false) {\n    const amount = typeof merge === 'boolean' ? 0 : merge;\n    if (amount > 0) {\n      const center1 = Point.create(points[1]).move(points[2], amount);\n      const center2 = Point.create(points[1]).move(points[0], amount);\n      return [center1.toJSON(), ...points, center2.toJSON()];\n    }\n    {\n      const center = points[1];\n      return [Object.assign({}, center), ...points, Object.assign({}, center)];\n    }\n  }\n  return points;\n}\nexport const loop = function (vertices, options, edgeView) {\n  const width = options.width || 50;\n  const height = options.height || 80;\n  const halfHeight = height / 2;\n  const angle = options.angle || 'auto';\n  const sourceAnchor = edgeView.sourceAnchor;\n  const targetAnchor = edgeView.targetAnchor;\n  const sourceBBox = edgeView.sourceBBox;\n  const targetBBox = edgeView.targetBBox;\n  if (sourceAnchor.equals(targetAnchor)) {\n    const getVertices = angle => {\n      const rad = Angle.toRad(angle);\n      const sin = Math.sin(rad);\n      const cos = Math.cos(rad);\n      const center = new Point(sourceAnchor.x + cos * width, sourceAnchor.y + sin * width);\n      const ref = new Point(center.x - cos * halfHeight, center.y - sin * halfHeight);\n      const p1 = ref.clone().rotate(-90, center);\n      const p2 = ref.clone().rotate(90, center);\n      return [p1.toJSON(), center.toJSON(), p2.toJSON()];\n    };\n    const validate = end => {\n      const start = sourceAnchor.clone().move(end, -1);\n      const line = new Line(start, end);\n      return !sourceBBox.containsPoint(end) && !sourceBBox.intersectsWithLine(line);\n    };\n    const angles = [0, 90, 180, 270, 45, 135, 225, 315];\n    if (typeof angle === 'number') {\n      return rollup(getVertices(angle), options.merge);\n    }\n    const center = sourceBBox.getCenter();\n    if (center.equals(sourceAnchor)) {\n      return rollup(getVertices(0), options.merge);\n    }\n    const deg = center.angleBetween(sourceAnchor, center.clone().translate(1, 0));\n    let ret = getVertices(deg);\n    if (validate(ret[1])) {\n      return rollup(ret, options.merge);\n    }\n    // return the best vertices\n    for (let i = 1, l = angles.length; i < l; i += 1) {\n      ret = getVertices(deg + angles[i]);\n      if (validate(ret[1])) {\n        return rollup(ret, options.merge);\n      }\n    }\n    return rollup(ret, options.merge);\n  }\n  {\n    const line = new Line(sourceAnchor, targetAnchor);\n    let parallel = line.parallel(-width);\n    let center = parallel.getCenter();\n    let p1 = parallel.start.clone().move(parallel.end, halfHeight);\n    let p2 = parallel.end.clone().move(parallel.start, halfHeight);\n    const ref = line.parallel(-1);\n    const line1 = new Line(ref.start, center);\n    const line2 = new Line(ref.end, center);\n    if (sourceBBox.containsPoint(center) || targetBBox.containsPoint(center) || sourceBBox.intersectsWithLine(line1) || sourceBBox.intersectsWithLine(line2) || targetBBox.intersectsWithLine(line1) || targetBBox.intersectsWithLine(line2)) {\n      parallel = line.parallel(width);\n      center = parallel.getCenter();\n      p1 = parallel.start.clone().move(parallel.end, halfHeight);\n      p2 = parallel.end.clone().move(parallel.start, halfHeight);\n    }\n    if (options.merge) {\n      const line = new Line(sourceAnchor, targetAnchor);\n      const normal = new Line(center, line.center).setLength(Number.MAX_SAFE_INTEGER);\n      const intersects1 = sourceBBox.intersectsWithLine(normal);\n      const intersects2 = targetBBox.intersectsWithLine(normal);\n      const intersects = intersects1 ? Array.isArray(intersects1) ? intersects1 : [intersects1] : [];\n      if (intersects2) {\n        if (Array.isArray(intersects2)) {\n          intersects.push(...intersects2);\n        } else {\n          intersects.push(intersects2);\n        }\n      }\n      const anchor = line.center.closest(intersects);\n      if (anchor) {\n        edgeView.sourceAnchor = anchor.clone();\n        edgeView.targetAnchor = anchor.clone();\n      } else {\n        edgeView.sourceAnchor = line.center.clone();\n        edgeView.targetAnchor = line.center.clone();\n      }\n    }\n    return rollup([p1.toJSON(), center.toJSON(), p2.toJSON()], options.merge);\n  }\n};","map":{"version":3,"names":["Angle","Point","Line","rollup","points","merge","amount","center1","create","move","center2","toJSON","center","Object","assign","loop","vertices","options","edgeView","width","height","halfHeight","angle","sourceAnchor","targetAnchor","sourceBBox","targetBBox","equals","getVertices","rad","toRad","sin","Math","cos","x","y","ref","p1","clone","rotate","p2","validate","end","start","line","containsPoint","intersectsWithLine","angles","getCenter","deg","angleBetween","translate","ret","i","l","length","parallel","line1","line2","normal","setLength","Number","MAX_SAFE_INTEGER","intersects1","intersects2","intersects","Array","isArray","push","anchor","closest"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/src/registry/router/loop.ts"],"sourcesContent":["import { Angle, Point, Line } from '@antv/x6-geometry'\nimport { Router } from './index'\n\nexport interface LoopRouterOptions {\n  width?: number\n  height?: number\n  angle?: 'auto' | number\n  merge?: boolean | number\n}\n\nfunction rollup(points: Point.PointLike[], merge?: boolean | number) {\n  if (merge != null && merge !== false) {\n    const amount = typeof merge === 'boolean' ? 0 : merge\n    if (amount > 0) {\n      const center1 = Point.create(points[1]).move(points[2], amount)\n      const center2 = Point.create(points[1]).move(points[0], amount)\n      return [center1.toJSON(), ...points, center2.toJSON()]\n    }\n    {\n      const center = points[1]\n      return [{ ...center }, ...points, { ...center }]\n    }\n  }\n  return points\n}\n\nexport const loop: Router.Definition<LoopRouterOptions> = function (\n  vertices,\n  options,\n  edgeView,\n) {\n  const width = options.width || 50\n  const height = options.height || 80\n  const halfHeight = height / 2\n  const angle = options.angle || 'auto'\n\n  const sourceAnchor = edgeView.sourceAnchor\n  const targetAnchor = edgeView.targetAnchor\n  const sourceBBox = edgeView.sourceBBox\n  const targetBBox = edgeView.targetBBox\n\n  if (sourceAnchor.equals(targetAnchor)) {\n    const getVertices = (angle: number) => {\n      const rad = Angle.toRad(angle)\n      const sin = Math.sin(rad)\n      const cos = Math.cos(rad)\n\n      const center = new Point(\n        sourceAnchor.x + cos * width,\n        sourceAnchor.y + sin * width,\n      )\n      const ref = new Point(\n        center.x - cos * halfHeight,\n        center.y - sin * halfHeight,\n      )\n      const p1 = ref.clone().rotate(-90, center)\n      const p2 = ref.clone().rotate(90, center)\n\n      return [p1.toJSON(), center.toJSON(), p2.toJSON()]\n    }\n\n    const validate = (end: Point.PointLike) => {\n      const start = sourceAnchor.clone().move(end, -1)\n      const line = new Line(start, end)\n      return (\n        !sourceBBox.containsPoint(end) && !sourceBBox.intersectsWithLine(line)\n      )\n    }\n\n    const angles = [0, 90, 180, 270, 45, 135, 225, 315]\n\n    if (typeof angle === 'number') {\n      return rollup(getVertices(angle), options.merge)\n    }\n\n    const center = sourceBBox.getCenter()\n    if (center.equals(sourceAnchor)) {\n      return rollup(getVertices(0), options.merge)\n    }\n\n    const deg = center.angleBetween(\n      sourceAnchor,\n      center.clone().translate(1, 0),\n    )\n    let ret = getVertices(deg)\n    if (validate(ret[1])) {\n      return rollup(ret, options.merge)\n    }\n\n    // return the best vertices\n    for (let i = 1, l = angles.length; i < l; i += 1) {\n      ret = getVertices(deg + angles[i])\n      if (validate(ret[1])) {\n        return rollup(ret, options.merge)\n      }\n    }\n    return rollup(ret, options.merge)\n  }\n  {\n    const line = new Line(sourceAnchor, targetAnchor)\n    let parallel = line.parallel(-width)\n    let center = parallel.getCenter()\n    let p1 = parallel.start.clone().move(parallel.end, halfHeight)\n    let p2 = parallel.end.clone().move(parallel.start, halfHeight)\n\n    const ref = line.parallel(-1)\n    const line1 = new Line(ref.start, center)\n    const line2 = new Line(ref.end, center)\n\n    if (\n      sourceBBox.containsPoint(center) ||\n      targetBBox.containsPoint(center) ||\n      sourceBBox.intersectsWithLine(line1) ||\n      sourceBBox.intersectsWithLine(line2) ||\n      targetBBox.intersectsWithLine(line1) ||\n      targetBBox.intersectsWithLine(line2)\n    ) {\n      parallel = line.parallel(width)\n      center = parallel.getCenter()\n      p1 = parallel.start.clone().move(parallel.end, halfHeight)\n      p2 = parallel.end.clone().move(parallel.start, halfHeight)\n    }\n\n    if (options.merge) {\n      const line = new Line(sourceAnchor, targetAnchor)\n      const normal = new Line(center, line.center).setLength(\n        Number.MAX_SAFE_INTEGER,\n      )\n      const intersects1 = sourceBBox.intersectsWithLine(normal)\n      const intersects2 = targetBBox.intersectsWithLine(normal)\n      const intersects = intersects1\n        ? Array.isArray(intersects1)\n          ? intersects1\n          : [intersects1]\n        : []\n      if (intersects2) {\n        if (Array.isArray(intersects2)) {\n          intersects.push(...intersects2)\n        } else {\n          intersects.push(intersects2)\n        }\n      }\n      const anchor = line.center.closest(intersects)\n      if (anchor) {\n        edgeView.sourceAnchor = anchor.clone()\n        edgeView.targetAnchor = anchor.clone()\n      } else {\n        edgeView.sourceAnchor = line.center.clone()\n        edgeView.targetAnchor = line.center.clone()\n      }\n    }\n\n    return rollup([p1.toJSON(), center.toJSON(), p2.toJSON()], options.merge)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}