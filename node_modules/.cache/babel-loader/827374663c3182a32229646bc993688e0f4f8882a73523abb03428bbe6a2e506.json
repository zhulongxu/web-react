{"ast":null,"code":"import { Geometry } from '../geometry';\nexport class Segment extends Geometry {\n  constructor() {\n    super(...arguments);\n    this.isVisible = true;\n    this.isSegment = true;\n    this.isSubpathStart = false;\n  }\n  get end() {\n    return this.endPoint;\n  }\n  get start() {\n    if (this.previousSegment == null) {\n      throw new Error('Missing previous segment. (This segment cannot be the ' + 'first segment of a path, or segment has not yet been ' + 'added to a path.)');\n    }\n    return this.previousSegment.end;\n  }\n  closestPointT(p, options) {\n    if (this.closestPointNormalizedLength) {\n      return this.closestPointNormalizedLength(p);\n    }\n    throw new Error('Neither `closestPointT` nor `closestPointNormalizedLength` method is implemented.');\n  }\n  // eslint-disable-next-line\n  lengthAtT(t, options) {\n    if (t <= 0) {\n      return 0;\n    }\n    const length = this.length();\n    if (t >= 1) {\n      return length;\n    }\n    return length * t;\n  }\n  divideAtT(t) {\n    if (this.divideAt) {\n      return this.divideAt(t);\n    }\n    throw new Error('Neither `divideAtT` nor `divideAt` method is implemented.');\n  }\n  pointAtT(t) {\n    if (this.pointAt) {\n      return this.pointAt(t);\n    }\n    throw new Error('Neither `pointAtT` nor `pointAt` method is implemented.');\n  }\n  tangentAtT(t) {\n    if (this.tangentAt) {\n      return this.tangentAt(t);\n    }\n    throw new Error('Neither `tangentAtT` nor `tangentAt` method is implemented.');\n  }\n}","map":{"version":3,"names":["Geometry","Segment","constructor","isVisible","isSegment","isSubpathStart","end","endPoint","start","previousSegment","Error","closestPointT","p","options","closestPointNormalizedLength","lengthAtT","t","length","divideAtT","divideAt","pointAtT","pointAt","tangentAtT","tangentAt"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6-geometry@2.0.5/node_modules/@antv/x6-geometry/src/path/segment.ts"],"sourcesContent":["import { Geometry } from '../geometry'\nimport { Line } from '../line'\nimport { Point } from '../point'\nimport { Rectangle } from '../rectangle'\n\nexport abstract class Segment extends Geometry {\n  isVisible = true\n  isSegment = true\n  isSubpathStart = false\n  nextSegment: Segment | null\n  previousSegment: Segment | null\n  subpathStartSegment: Segment | null\n  protected endPoint: Point\n\n  get end() {\n    return this.endPoint\n  }\n\n  get start() {\n    if (this.previousSegment == null) {\n      throw new Error(\n        'Missing previous segment. (This segment cannot be the ' +\n          'first segment of a path, or segment has not yet been ' +\n          'added to a path.)',\n      )\n    }\n\n    return this.previousSegment.end\n  }\n\n  abstract get type(): string\n\n  abstract bbox(): Rectangle | null\n\n  abstract closestPoint(p: Point.PointLike | Point.PointData): Point\n\n  abstract closestPointLength(p: Point.PointLike | Point.PointData): number\n\n  abstract closestPointNormalizedLength(\n    p: Point.PointLike | Point.PointData,\n  ): number\n\n  closestPointT(\n    p: Point.PointLike | Point.PointData,\n    options?: Segment.Options, // eslint-disable-line\n  ) {\n    if (this.closestPointNormalizedLength) {\n      return this.closestPointNormalizedLength(p)\n    }\n\n    throw new Error(\n      'Neither `closestPointT` nor `closestPointNormalizedLength` method is implemented.',\n    )\n  }\n\n  abstract closestPointTangent(\n    p: Point.PointLike | Point.PointData,\n  ): Line | null\n\n  abstract length(options?: Segment.Options): number\n\n  // eslint-disable-next-line\n  lengthAtT(t: number, options?: Segment.Options) {\n    if (t <= 0) {\n      return 0\n    }\n\n    const length = this.length()\n    if (t >= 1) {\n      return length\n    }\n\n    return length * t\n  }\n\n  abstract divideAt(\n    ratio: number,\n    options?: Segment.Options,\n  ): [Segment, Segment]\n\n  abstract divideAtLength(\n    length: number,\n    options?: Segment.Options,\n  ): [Segment, Segment]\n\n  divideAtT(t: number) {\n    if (this.divideAt) {\n      return this.divideAt(t)\n    }\n\n    throw new Error('Neither `divideAtT` nor `divideAt` method is implemented.')\n  }\n\n  abstract getSubdivisions(options?: Segment.Options): Segment[]\n\n  abstract pointAt(ratio: number): Point\n\n  abstract pointAtLength(length: number, options?: Segment.Options): Point\n\n  pointAtT(t: number): Point {\n    if (this.pointAt) {\n      return this.pointAt(t)\n    }\n\n    throw new Error('Neither `pointAtT` nor `pointAt` method is implemented.')\n  }\n\n  abstract tangentAt(ratio: number): Line | null\n\n  abstract tangentAtLength(\n    length: number,\n    options?: Segment.Options,\n  ): Line | null\n\n  tangentAtT(t: number): Line | null {\n    if (this.tangentAt) {\n      return this.tangentAt(t)\n    }\n\n    throw new Error(\n      'Neither `tangentAtT` nor `tangentAt` method is implemented.',\n    )\n  }\n\n  abstract isDifferentiable(): boolean\n\n  abstract clone(): Segment\n}\n\nexport namespace Segment {\n  export interface Options {\n    precision?: number\n    subdivisions?: Segment[]\n  }\n}\n"],"mappings":"AAAA,SAASA,QAAQ,QAAQ,aAAa;AAKtC,OAAM,MAAgBC,OAAQ,SAAQD,QAAQ;EAA9CE,YAAA;;IACE,KAAAC,SAAS,GAAG,IAAI;IAChB,KAAAC,SAAS,GAAG,IAAI;IAChB,KAAAC,cAAc,GAAG,KAAK;EAuHxB;EAjHE,IAAIC,GAAGA,CAAA;IACL,OAAO,IAAI,CAACC,QAAQ;EACtB;EAEA,IAAIC,KAAKA,CAAA;IACP,IAAI,IAAI,CAACC,eAAe,IAAI,IAAI,EAAE;MAChC,MAAM,IAAIC,KAAK,CACb,wDAAwD,GACtD,uDAAuD,GACvD,mBAAmB,CACtB;;IAGH,OAAO,IAAI,CAACD,eAAe,CAACH,GAAG;EACjC;EAcAK,aAAaA,CACXC,CAAoC,EACpCC,OAAyB;IAEzB,IAAI,IAAI,CAACC,4BAA4B,EAAE;MACrC,OAAO,IAAI,CAACA,4BAA4B,CAACF,CAAC,CAAC;;IAG7C,MAAM,IAAIF,KAAK,CACb,mFAAmF,CACpF;EACH;EAQA;EACAK,SAASA,CAACC,CAAS,EAAEH,OAAyB;IAC5C,IAAIG,CAAC,IAAI,CAAC,EAAE;MACV,OAAO,CAAC;;IAGV,MAAMC,MAAM,GAAG,IAAI,CAACA,MAAM,EAAE;IAC5B,IAAID,CAAC,IAAI,CAAC,EAAE;MACV,OAAOC,MAAM;;IAGf,OAAOA,MAAM,GAAGD,CAAC;EACnB;EAYAE,SAASA,CAACF,CAAS;IACjB,IAAI,IAAI,CAACG,QAAQ,EAAE;MACjB,OAAO,IAAI,CAACA,QAAQ,CAACH,CAAC,CAAC;;IAGzB,MAAM,IAAIN,KAAK,CAAC,2DAA2D,CAAC;EAC9E;EAQAU,QAAQA,CAACJ,CAAS;IAChB,IAAI,IAAI,CAACK,OAAO,EAAE;MAChB,OAAO,IAAI,CAACA,OAAO,CAACL,CAAC,CAAC;;IAGxB,MAAM,IAAIN,KAAK,CAAC,yDAAyD,CAAC;EAC5E;EASAY,UAAUA,CAACN,CAAS;IAClB,IAAI,IAAI,CAACO,SAAS,EAAE;MAClB,OAAO,IAAI,CAACA,SAAS,CAACP,CAAC,CAAC;;IAG1B,MAAM,IAAIN,KAAK,CACb,6DAA6D,CAC9D;EACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}