{"ast":null,"code":"var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Dom, Disposable, FunctionExt } from '@antv/x6-common';\nimport { CellView, NodeView, EdgeView } from '../view';\nimport { JobQueue, JOB_PRIORITY } from './queueJob';\nexport class Scheduler extends Disposable {\n  get model() {\n    return this.graph.model;\n  }\n  get container() {\n    return this.graph.view.stage;\n  }\n  constructor(graph) {\n    super();\n    this.views = {};\n    this.willRemoveViews = {};\n    this.queue = new JobQueue();\n    this.graph = graph;\n    this.init();\n  }\n  init() {\n    this.startListening();\n    this.renderViews(this.model.getCells());\n  }\n  startListening() {\n    this.model.on('reseted', this.onModelReseted, this);\n    this.model.on('cell:added', this.onCellAdded, this);\n    this.model.on('cell:removed', this.onCellRemoved, this);\n    this.model.on('cell:change:zIndex', this.onCellZIndexChanged, this);\n    this.model.on('cell:change:visible', this.onCellVisibleChanged, this);\n  }\n  stopListening() {\n    this.model.off('reseted', this.onModelReseted, this);\n    this.model.off('cell:added', this.onCellAdded, this);\n    this.model.off('cell:removed', this.onCellRemoved, this);\n    this.model.off('cell:change:zIndex', this.onCellZIndexChanged, this);\n    this.model.off('cell:change:visible', this.onCellVisibleChanged, this);\n  }\n  onModelReseted({\n    options\n  }) {\n    this.queue.clearJobs();\n    this.removeZPivots();\n    this.resetViews();\n    const cells = this.model.getCells();\n    this.renderViews(cells, Object.assign(Object.assign({}, options), {\n      queue: cells.map(cell => cell.id)\n    }));\n  }\n  onCellAdded({\n    cell,\n    options\n  }) {\n    this.renderViews([cell], options);\n  }\n  onCellRemoved({\n    cell\n  }) {\n    this.removeViews([cell]);\n  }\n  onCellZIndexChanged({\n    cell,\n    options\n  }) {\n    const viewItem = this.views[cell.id];\n    if (viewItem) {\n      this.requestViewUpdate(viewItem.view, Scheduler.FLAG_INSERT, options, JOB_PRIORITY.Update, true);\n    }\n  }\n  onCellVisibleChanged({\n    cell,\n    current\n  }) {\n    this.toggleVisible(cell, !!current);\n  }\n  requestViewUpdate(view, flag, options = {}, priority = JOB_PRIORITY.Update, flush = true) {\n    const id = view.cell.id;\n    const viewItem = this.views[id];\n    if (!viewItem) {\n      return;\n    }\n    viewItem.flag = flag;\n    viewItem.options = options;\n    const priorAction = view.hasAction(flag, ['translate', 'resize', 'rotate']);\n    if (priorAction || options.async === false) {\n      priority = JOB_PRIORITY.PRIOR; // eslint-disable-line\n      flush = false; // eslint-disable-line\n    }\n    this.queue.queueJob({\n      id,\n      priority,\n      cb: () => {\n        this.renderViewInArea(view, flag, options);\n        const queue = options.queue;\n        if (queue) {\n          const index = queue.indexOf(view.cell.id);\n          if (index >= 0) {\n            queue.splice(index, 1);\n          }\n          if (queue.length === 0) {\n            this.graph.trigger('render:done');\n          }\n        }\n      }\n    });\n    const effectedEdges = this.getEffectedEdges(view);\n    effectedEdges.forEach(edge => {\n      this.requestViewUpdate(edge.view, edge.flag, options, priority, false);\n    });\n    if (flush) {\n      this.flush();\n    }\n  }\n  setRenderArea(area) {\n    this.renderArea = area;\n    this.flushWaitingViews();\n  }\n  isViewMounted(view) {\n    if (view == null) {\n      return false;\n    }\n    const viewItem = this.views[view.cell.id];\n    if (!viewItem) {\n      return false;\n    }\n    return viewItem.state === Scheduler.ViewState.MOUNTED;\n  }\n  renderViews(cells, options = {}) {\n    cells.sort((c1, c2) => {\n      if (c1.isNode() && c2.isEdge()) {\n        return -1;\n      }\n      return 0;\n    });\n    cells.forEach(cell => {\n      const id = cell.id;\n      const views = this.views;\n      let flag = 0;\n      let viewItem = views[id];\n      if (viewItem) {\n        flag = Scheduler.FLAG_INSERT;\n      } else {\n        const cellView = this.createCellView(cell);\n        if (cellView) {\n          cellView.graph = this.graph;\n          flag = Scheduler.FLAG_INSERT | cellView.getBootstrapFlag();\n          viewItem = {\n            view: cellView,\n            flag,\n            options,\n            state: Scheduler.ViewState.CREATED\n          };\n          this.views[id] = viewItem;\n        }\n      }\n      if (viewItem) {\n        this.requestViewUpdate(viewItem.view, flag, options, this.getRenderPriority(viewItem.view), false);\n      }\n    });\n    this.flush();\n  }\n  renderViewInArea(view, flag, options = {}) {\n    const cell = view.cell;\n    const id = cell.id;\n    const viewItem = this.views[id];\n    if (!viewItem) {\n      return;\n    }\n    let result = 0;\n    if (this.isUpdatable(view)) {\n      result = this.updateView(view, flag, options);\n      viewItem.flag = result;\n    } else {\n      if (viewItem.state === Scheduler.ViewState.MOUNTED) {\n        result = this.updateView(view, flag, options);\n        viewItem.flag = result;\n      } else {\n        viewItem.state = Scheduler.ViewState.WAITING;\n      }\n    }\n    if (result) {\n      if (cell.isEdge() && (result & view.getFlag(['source', 'target'])) === 0) {\n        this.queue.queueJob({\n          id,\n          priority: JOB_PRIORITY.RenderEdge,\n          cb: () => {\n            this.updateView(view, flag, options);\n          }\n        });\n      }\n    }\n  }\n  removeViews(cells) {\n    cells.forEach(cell => {\n      const id = cell.id;\n      const viewItem = this.views[id];\n      if (viewItem) {\n        this.willRemoveViews[id] = viewItem;\n        delete this.views[id];\n        this.queue.queueJob({\n          id,\n          priority: this.getRenderPriority(viewItem.view),\n          cb: () => {\n            this.removeView(viewItem.view);\n          }\n        });\n      }\n    });\n    this.flush();\n  }\n  flush() {\n    this.graph.options.async ? this.queue.queueFlush() : this.queue.queueFlushSync();\n  }\n  flushWaitingViews() {\n    Object.values(this.views).forEach(viewItem => {\n      if (viewItem && viewItem.state === Scheduler.ViewState.WAITING) {\n        const {\n          view,\n          flag,\n          options\n        } = viewItem;\n        this.requestViewUpdate(view, flag, options, this.getRenderPriority(view), false);\n      }\n    });\n    this.flush();\n  }\n  updateView(view, flag, options = {}) {\n    if (view == null) {\n      return 0;\n    }\n    if (CellView.isCellView(view)) {\n      if (flag & Scheduler.FLAG_REMOVE) {\n        this.removeView(view.cell);\n        return 0;\n      }\n      if (flag & Scheduler.FLAG_INSERT) {\n        this.insertView(view);\n        flag ^= Scheduler.FLAG_INSERT; // eslint-disable-line\n      }\n    }\n    if (!flag) {\n      return 0;\n    }\n    return view.confirmUpdate(flag, options);\n  }\n  insertView(view) {\n    const viewItem = this.views[view.cell.id];\n    if (viewItem) {\n      const zIndex = view.cell.getZIndex();\n      const pivot = this.addZPivot(zIndex);\n      this.container.insertBefore(view.container, pivot);\n      if (!view.cell.isVisible()) {\n        this.toggleVisible(view.cell, false);\n      }\n      viewItem.state = Scheduler.ViewState.MOUNTED;\n      this.graph.trigger('view:mounted', {\n        view\n      });\n    }\n  }\n  resetViews() {\n    this.willRemoveViews = Object.assign(Object.assign({}, this.views), this.willRemoveViews);\n    Object.values(this.willRemoveViews).forEach(viewItem => {\n      if (viewItem) {\n        this.removeView(viewItem.view);\n      }\n    });\n    this.views = {};\n    this.willRemoveViews = {};\n  }\n  removeView(view) {\n    const cell = view.cell;\n    const viewItem = this.willRemoveViews[cell.id];\n    if (viewItem && view) {\n      viewItem.view.remove();\n      delete this.willRemoveViews[cell.id];\n      this.graph.trigger('view:unmounted', {\n        view\n      });\n    }\n  }\n  toggleVisible(cell, visible) {\n    const edges = this.model.getConnectedEdges(cell);\n    for (let i = 0, len = edges.length; i < len; i += 1) {\n      const edge = edges[i];\n      if (visible) {\n        const source = edge.getSourceCell();\n        const target = edge.getTargetCell();\n        if (source && !source.isVisible() || target && !target.isVisible()) {\n          continue;\n        }\n        this.toggleVisible(edge, true);\n      } else {\n        this.toggleVisible(edge, false);\n      }\n    }\n    const viewItem = this.views[cell.id];\n    if (viewItem) {\n      Dom.css(viewItem.view.container, {\n        display: visible ? 'unset' : 'none'\n      });\n    }\n  }\n  addZPivot(zIndex = 0) {\n    if (this.zPivots == null) {\n      this.zPivots = {};\n    }\n    const pivots = this.zPivots;\n    let pivot = pivots[zIndex];\n    if (pivot) {\n      return pivot;\n    }\n    pivot = pivots[zIndex] = document.createComment(`z-index:${zIndex + 1}`);\n    let neighborZ = -Infinity;\n    // eslint-disable-next-line\n    for (const key in pivots) {\n      const currentZ = +key;\n      if (currentZ < zIndex && currentZ > neighborZ) {\n        neighborZ = currentZ;\n        if (neighborZ === zIndex - 1) {\n          continue;\n        }\n      }\n    }\n    const layer = this.container;\n    if (neighborZ !== -Infinity) {\n      const neighborPivot = pivots[neighborZ];\n      layer.insertBefore(pivot, neighborPivot.nextSibling);\n    } else {\n      layer.insertBefore(pivot, layer.firstChild);\n    }\n    return pivot;\n  }\n  removeZPivots() {\n    if (this.zPivots) {\n      Object.values(this.zPivots).forEach(elem => {\n        if (elem && elem.parentNode) {\n          elem.parentNode.removeChild(elem);\n        }\n      });\n    }\n    this.zPivots = {};\n  }\n  createCellView(cell) {\n    const options = {\n      graph: this.graph\n    };\n    const createViewHook = this.graph.options.createCellView;\n    if (createViewHook) {\n      const ret = FunctionExt.call(createViewHook, this.graph, cell);\n      if (ret) {\n        return new ret(cell, options); // eslint-disable-line new-cap\n      }\n      if (ret === null) {\n        // null means not render\n        return null;\n      }\n    }\n    const view = cell.view;\n    if (view != null && typeof view === 'string') {\n      const def = CellView.registry.get(view);\n      if (def) {\n        return new def(cell, options); // eslint-disable-line new-cap\n      }\n      return CellView.registry.onNotFound(view);\n    }\n    if (cell.isNode()) {\n      return new NodeView(cell, options);\n    }\n    if (cell.isEdge()) {\n      return new EdgeView(cell, options);\n    }\n    return null;\n  }\n  getEffectedEdges(view) {\n    const effectedEdges = [];\n    const cell = view.cell;\n    const edges = this.model.getConnectedEdges(cell);\n    for (let i = 0, n = edges.length; i < n; i += 1) {\n      const edge = edges[i];\n      const viewItem = this.views[edge.id];\n      if (!viewItem) {\n        continue;\n      }\n      const edgeView = viewItem.view;\n      if (!this.isViewMounted(edgeView)) {\n        continue;\n      }\n      const flagLabels = ['update'];\n      if (edge.getTargetCell() === cell) {\n        flagLabels.push('target');\n      }\n      if (edge.getSourceCell() === cell) {\n        flagLabels.push('source');\n      }\n      effectedEdges.push({\n        id: edge.id,\n        view: edgeView,\n        flag: edgeView.getFlag(flagLabels)\n      });\n    }\n    return effectedEdges;\n  }\n  isUpdatable(view) {\n    if (view.isNodeView()) {\n      if (this.renderArea) {\n        return this.renderArea.isIntersectWithRect(view.cell.getBBox());\n      }\n      return true;\n    }\n    if (view.isEdgeView()) {\n      const edge = view.cell;\n      const sourceCell = edge.getSourceCell();\n      const targetCell = edge.getTargetCell();\n      if (this.renderArea && sourceCell && targetCell) {\n        return this.renderArea.isIntersectWithRect(sourceCell.getBBox()) || this.renderArea.isIntersectWithRect(targetCell.getBBox());\n      }\n    }\n    return true;\n  }\n  getRenderPriority(view) {\n    return view.cell.isNode() ? JOB_PRIORITY.RenderNode : JOB_PRIORITY.RenderEdge;\n  }\n  dispose() {\n    this.stopListening();\n    // clear views\n    Object.keys(this.views).forEach(id => {\n      this.views[id].view.dispose();\n    });\n    this.views = {};\n  }\n}\n__decorate([Disposable.dispose()], Scheduler.prototype, \"dispose\", null);\n(function (Scheduler) {\n  Scheduler.FLAG_INSERT = 1 << 30;\n  Scheduler.FLAG_REMOVE = 1 << 29;\n  Scheduler.FLAG_RENDER = (1 << 26) - 1;\n})(Scheduler || (Scheduler = {}));\n(function (Scheduler) {\n  let ViewState;\n  (function (ViewState) {\n    ViewState[ViewState[\"CREATED\"] = 0] = \"CREATED\";\n    ViewState[ViewState[\"MOUNTED\"] = 1] = \"MOUNTED\";\n    ViewState[ViewState[\"WAITING\"] = 2] = \"WAITING\";\n  })(ViewState = Scheduler.ViewState || (Scheduler.ViewState = {}));\n})(Scheduler || (Scheduler = {}));","map":{"version":3,"names":["Dom","Disposable","FunctionExt","CellView","NodeView","EdgeView","JobQueue","JOB_PRIORITY","Scheduler","model","graph","container","view","stage","constructor","views","willRemoveViews","queue","init","startListening","renderViews","getCells","on","onModelReseted","onCellAdded","onCellRemoved","onCellZIndexChanged","onCellVisibleChanged","stopListening","off","options","clearJobs","removeZPivots","resetViews","cells","Object","assign","map","cell","id","removeViews","viewItem","requestViewUpdate","FLAG_INSERT","Update","current","toggleVisible","flag","priority","flush","priorAction","hasAction","async","PRIOR","queueJob","cb","renderViewInArea","index","indexOf","splice","length","trigger","effectedEdges","getEffectedEdges","forEach","edge","setRenderArea","area","renderArea","flushWaitingViews","isViewMounted","state","ViewState","MOUNTED","sort","c1","c2","isNode","isEdge","cellView","createCellView","getBootstrapFlag","CREATED","getRenderPriority","result","isUpdatable","updateView","WAITING","getFlag","RenderEdge","removeView","queueFlush","queueFlushSync","values","isCellView","FLAG_REMOVE","insertView","confirmUpdate","zIndex","getZIndex","pivot","addZPivot","insertBefore","isVisible","remove","visible","edges","getConnectedEdges","i","len","source","getSourceCell","target","getTargetCell","css","display","zPivots","pivots","document","createComment","neighborZ","Infinity","key","currentZ","layer","neighborPivot","nextSibling","firstChild","elem","parentNode","removeChild","createViewHook","ret","call","def","registry","get","onNotFound","n","edgeView","flagLabels","push","isNodeView","isIntersectWithRect","getBBox","isEdgeView","sourceCell","targetCell","RenderNode","dispose","keys","__decorate","FLAG_RENDER"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/src/renderer/scheduler.ts"],"sourcesContent":["import { KeyValue, Dom, Disposable, FunctionExt } from '@antv/x6-common'\nimport { Rectangle } from '@antv/x6-geometry'\nimport { Model, Cell } from '../model'\nimport { View, CellView, NodeView, EdgeView } from '../view'\nimport { JobQueue, JOB_PRIORITY } from './queueJob'\nimport { FlagManager } from '../view/flag'\nimport { Graph } from '../graph'\n\nexport class Scheduler extends Disposable {\n  public views: KeyValue<Scheduler.View> = {}\n  public willRemoveViews: KeyValue<Scheduler.View> = {}\n  protected zPivots: KeyValue<Comment>\n  private graph: Graph\n  private renderArea?: Rectangle\n  private queue: JobQueue\n\n  get model() {\n    return this.graph.model\n  }\n\n  get container() {\n    return this.graph.view.stage\n  }\n\n  constructor(graph: Graph) {\n    super()\n    this.queue = new JobQueue()\n    this.graph = graph\n    this.init()\n  }\n\n  protected init() {\n    this.startListening()\n    this.renderViews(this.model.getCells())\n  }\n\n  protected startListening() {\n    this.model.on('reseted', this.onModelReseted, this)\n    this.model.on('cell:added', this.onCellAdded, this)\n    this.model.on('cell:removed', this.onCellRemoved, this)\n    this.model.on('cell:change:zIndex', this.onCellZIndexChanged, this)\n    this.model.on('cell:change:visible', this.onCellVisibleChanged, this)\n  }\n\n  protected stopListening() {\n    this.model.off('reseted', this.onModelReseted, this)\n    this.model.off('cell:added', this.onCellAdded, this)\n    this.model.off('cell:removed', this.onCellRemoved, this)\n    this.model.off('cell:change:zIndex', this.onCellZIndexChanged, this)\n    this.model.off('cell:change:visible', this.onCellVisibleChanged, this)\n  }\n\n  protected onModelReseted({ options }: Model.EventArgs['reseted']) {\n    this.queue.clearJobs()\n    this.removeZPivots()\n    this.resetViews()\n    const cells = this.model.getCells()\n    this.renderViews(cells, { ...options, queue: cells.map((cell) => cell.id) })\n  }\n\n  protected onCellAdded({ cell, options }: Model.EventArgs['cell:added']) {\n    this.renderViews([cell], options)\n  }\n\n  protected onCellRemoved({ cell }: Model.EventArgs['cell:removed']) {\n    this.removeViews([cell])\n  }\n\n  protected onCellZIndexChanged({\n    cell,\n    options,\n  }: Model.EventArgs['cell:change:zIndex']) {\n    const viewItem = this.views[cell.id]\n    if (viewItem) {\n      this.requestViewUpdate(\n        viewItem.view,\n        Scheduler.FLAG_INSERT,\n        options,\n        JOB_PRIORITY.Update,\n        true,\n      )\n    }\n  }\n\n  protected onCellVisibleChanged({\n    cell,\n    current,\n  }: Model.EventArgs['cell:change:visible']) {\n    this.toggleVisible(cell, !!current)\n  }\n\n  requestViewUpdate(\n    view: CellView,\n    flag: number,\n    options: any = {},\n    priority: JOB_PRIORITY = JOB_PRIORITY.Update,\n    flush = true,\n  ) {\n    const id = view.cell.id\n    const viewItem = this.views[id]\n\n    if (!viewItem) {\n      return\n    }\n\n    viewItem.flag = flag\n    viewItem.options = options\n\n    const priorAction = view.hasAction(flag, ['translate', 'resize', 'rotate'])\n    if (priorAction || options.async === false) {\n      priority = JOB_PRIORITY.PRIOR // eslint-disable-line\n      flush = false // eslint-disable-line\n    }\n\n    this.queue.queueJob({\n      id,\n      priority,\n      cb: () => {\n        this.renderViewInArea(view, flag, options)\n        const queue = options.queue\n        if (queue) {\n          const index = queue.indexOf(view.cell.id)\n          if (index >= 0) {\n            queue.splice(index, 1)\n          }\n          if (queue.length === 0) {\n            this.graph.trigger('render:done')\n          }\n        }\n      },\n    })\n\n    const effectedEdges = this.getEffectedEdges(view)\n    effectedEdges.forEach((edge) => {\n      this.requestViewUpdate(edge.view, edge.flag, options, priority, false)\n    })\n\n    if (flush) {\n      this.flush()\n    }\n  }\n\n  setRenderArea(area?: Rectangle) {\n    this.renderArea = area\n    this.flushWaitingViews()\n  }\n\n  isViewMounted(view: CellView) {\n    if (view == null) {\n      return false\n    }\n\n    const viewItem = this.views[view.cell.id]\n\n    if (!viewItem) {\n      return false\n    }\n\n    return viewItem.state === Scheduler.ViewState.MOUNTED\n  }\n\n  protected renderViews(cells: Cell[], options: any = {}) {\n    cells.sort((c1, c2) => {\n      if (c1.isNode() && c2.isEdge()) {\n        return -1\n      }\n      return 0\n    })\n\n    cells.forEach((cell) => {\n      const id = cell.id\n      const views = this.views\n      let flag = 0\n      let viewItem = views[id]\n\n      if (viewItem) {\n        flag = Scheduler.FLAG_INSERT\n      } else {\n        const cellView = this.createCellView(cell)\n        if (cellView) {\n          cellView.graph = this.graph\n          flag = Scheduler.FLAG_INSERT | cellView.getBootstrapFlag()\n          viewItem = {\n            view: cellView,\n            flag,\n            options,\n            state: Scheduler.ViewState.CREATED,\n          }\n          this.views[id] = viewItem\n        }\n      }\n\n      if (viewItem) {\n        this.requestViewUpdate(\n          viewItem.view,\n          flag,\n          options,\n          this.getRenderPriority(viewItem.view),\n          false,\n        )\n      }\n    })\n\n    this.flush()\n  }\n\n  protected renderViewInArea(view: CellView, flag: number, options: any = {}) {\n    const cell = view.cell\n    const id = cell.id\n    const viewItem = this.views[id]\n\n    if (!viewItem) {\n      return\n    }\n\n    let result = 0\n    if (this.isUpdatable(view)) {\n      result = this.updateView(view, flag, options)\n      viewItem.flag = result\n    } else {\n      if (viewItem.state === Scheduler.ViewState.MOUNTED) {\n        result = this.updateView(view, flag, options)\n        viewItem.flag = result\n      } else {\n        viewItem.state = Scheduler.ViewState.WAITING\n      }\n    }\n\n    if (result) {\n      if (\n        cell.isEdge() &&\n        (result & view.getFlag(['source', 'target'])) === 0\n      ) {\n        this.queue.queueJob({\n          id,\n          priority: JOB_PRIORITY.RenderEdge,\n          cb: () => {\n            this.updateView(view, flag, options)\n          },\n        })\n      }\n    }\n  }\n\n  protected removeViews(cells: Cell[]) {\n    cells.forEach((cell) => {\n      const id = cell.id\n      const viewItem = this.views[id]\n\n      if (viewItem) {\n        this.willRemoveViews[id] = viewItem\n        delete this.views[id]\n\n        this.queue.queueJob({\n          id,\n          priority: this.getRenderPriority(viewItem.view),\n          cb: () => {\n            this.removeView(viewItem.view)\n          },\n        })\n      }\n    })\n\n    this.flush()\n  }\n\n  protected flush() {\n    this.graph.options.async\n      ? this.queue.queueFlush()\n      : this.queue.queueFlushSync()\n  }\n\n  protected flushWaitingViews() {\n    Object.values(this.views).forEach((viewItem) => {\n      if (viewItem && viewItem.state === Scheduler.ViewState.WAITING) {\n        const { view, flag, options } = viewItem\n        this.requestViewUpdate(\n          view,\n          flag,\n          options,\n          this.getRenderPriority(view),\n          false,\n        )\n      }\n    })\n\n    this.flush()\n  }\n\n  protected updateView(view: View, flag: number, options: any = {}) {\n    if (view == null) {\n      return 0\n    }\n\n    if (CellView.isCellView(view)) {\n      if (flag & Scheduler.FLAG_REMOVE) {\n        this.removeView(view.cell as any)\n        return 0\n      }\n\n      if (flag & Scheduler.FLAG_INSERT) {\n        this.insertView(view)\n        flag ^= Scheduler.FLAG_INSERT // eslint-disable-line\n      }\n    }\n\n    if (!flag) {\n      return 0\n    }\n\n    return view.confirmUpdate(flag, options)\n  }\n\n  protected insertView(view: CellView) {\n    const viewItem = this.views[view.cell.id]\n    if (viewItem) {\n      const zIndex = view.cell.getZIndex()\n      const pivot = this.addZPivot(zIndex)\n      this.container.insertBefore(view.container, pivot)\n\n      if (!view.cell.isVisible()) {\n        this.toggleVisible(view.cell, false)\n      }\n\n      viewItem.state = Scheduler.ViewState.MOUNTED\n      this.graph.trigger('view:mounted', { view })\n    }\n  }\n\n  protected resetViews() {\n    this.willRemoveViews = { ...this.views, ...this.willRemoveViews }\n    Object.values(this.willRemoveViews).forEach((viewItem) => {\n      if (viewItem) {\n        this.removeView(viewItem.view)\n      }\n    })\n    this.views = {}\n    this.willRemoveViews = {}\n  }\n\n  protected removeView(view: CellView) {\n    const cell = view.cell\n    const viewItem = this.willRemoveViews[cell.id]\n    if (viewItem && view) {\n      viewItem.view.remove()\n      delete this.willRemoveViews[cell.id]\n      this.graph.trigger('view:unmounted', { view })\n    }\n  }\n\n  protected toggleVisible(cell: Cell, visible: boolean) {\n    const edges = this.model.getConnectedEdges(cell)\n\n    for (let i = 0, len = edges.length; i < len; i += 1) {\n      const edge = edges[i]\n      if (visible) {\n        const source = edge.getSourceCell()\n        const target = edge.getTargetCell()\n        if (\n          (source && !source.isVisible()) ||\n          (target && !target.isVisible())\n        ) {\n          continue\n        }\n        this.toggleVisible(edge, true)\n      } else {\n        this.toggleVisible(edge, false)\n      }\n    }\n\n    const viewItem = this.views[cell.id]\n    if (viewItem) {\n      Dom.css(viewItem.view.container, {\n        display: visible ? 'unset' : 'none',\n      })\n    }\n  }\n\n  protected addZPivot(zIndex = 0) {\n    if (this.zPivots == null) {\n      this.zPivots = {}\n    }\n\n    const pivots = this.zPivots\n    let pivot = pivots[zIndex]\n    if (pivot) {\n      return pivot\n    }\n\n    pivot = pivots[zIndex] = document.createComment(`z-index:${zIndex + 1}`)\n    let neighborZ = -Infinity\n    // eslint-disable-next-line\n    for (const key in pivots) {\n      const currentZ = +key\n      if (currentZ < zIndex && currentZ > neighborZ) {\n        neighborZ = currentZ\n        if (neighborZ === zIndex - 1) {\n          continue\n        }\n      }\n    }\n\n    const layer = this.container\n    if (neighborZ !== -Infinity) {\n      const neighborPivot = pivots[neighborZ]\n      layer.insertBefore(pivot, neighborPivot.nextSibling)\n    } else {\n      layer.insertBefore(pivot, layer.firstChild)\n    }\n    return pivot\n  }\n\n  protected removeZPivots() {\n    if (this.zPivots) {\n      Object.values(this.zPivots).forEach((elem) => {\n        if (elem && elem.parentNode) {\n          elem.parentNode.removeChild(elem)\n        }\n      })\n    }\n    this.zPivots = {}\n  }\n\n  protected createCellView(cell: Cell) {\n    const options = { graph: this.graph }\n\n    const createViewHook = this.graph.options.createCellView\n    if (createViewHook) {\n      const ret = FunctionExt.call(createViewHook, this.graph, cell)\n      if (ret) {\n        return new ret(cell, options) // eslint-disable-line new-cap\n      }\n      if (ret === null) {\n        // null means not render\n        return null\n      }\n    }\n\n    const view = cell.view\n\n    if (view != null && typeof view === 'string') {\n      const def = CellView.registry.get(view)\n      if (def) {\n        return new def(cell, options) // eslint-disable-line new-cap\n      }\n      return CellView.registry.onNotFound(view)\n    }\n\n    if (cell.isNode()) {\n      return new NodeView(cell, options)\n    }\n\n    if (cell.isEdge()) {\n      return new EdgeView(cell, options)\n    }\n\n    return null\n  }\n\n  protected getEffectedEdges(view: CellView) {\n    const effectedEdges: { id: string; view: CellView; flag: number }[] = []\n    const cell = view.cell\n    const edges = this.model.getConnectedEdges(cell)\n\n    for (let i = 0, n = edges.length; i < n; i += 1) {\n      const edge = edges[i]\n      const viewItem = this.views[edge.id]\n\n      if (!viewItem) {\n        continue\n      }\n\n      const edgeView = viewItem.view\n      if (!this.isViewMounted(edgeView)) {\n        continue\n      }\n\n      const flagLabels: FlagManager.Action[] = ['update']\n      if (edge.getTargetCell() === cell) {\n        flagLabels.push('target')\n      }\n      if (edge.getSourceCell() === cell) {\n        flagLabels.push('source')\n      }\n      effectedEdges.push({\n        id: edge.id,\n        view: edgeView,\n        flag: edgeView.getFlag(flagLabels),\n      })\n    }\n\n    return effectedEdges\n  }\n\n  protected isUpdatable(view: CellView) {\n    if (view.isNodeView()) {\n      if (this.renderArea) {\n        return this.renderArea.isIntersectWithRect(view.cell.getBBox())\n      }\n      return true\n    }\n\n    if (view.isEdgeView()) {\n      const edge = view.cell\n      const sourceCell = edge.getSourceCell()\n      const targetCell = edge.getTargetCell()\n      if (this.renderArea && sourceCell && targetCell) {\n        return (\n          this.renderArea.isIntersectWithRect(sourceCell.getBBox()) ||\n          this.renderArea.isIntersectWithRect(targetCell.getBBox())\n        )\n      }\n    }\n\n    return true\n  }\n\n  protected getRenderPriority(view: CellView) {\n    return view.cell.isNode()\n      ? JOB_PRIORITY.RenderNode\n      : JOB_PRIORITY.RenderEdge\n  }\n\n  @Disposable.dispose()\n  dispose() {\n    this.stopListening()\n    // clear views\n    Object.keys(this.views).forEach((id) => {\n      this.views[id].view.dispose()\n    })\n    this.views = {}\n  }\n}\nexport namespace Scheduler {\n  export const FLAG_INSERT = 1 << 30\n  export const FLAG_REMOVE = 1 << 29\n  export const FLAG_RENDER = (1 << 26) - 1\n}\n\nexport namespace Scheduler {\n  export enum ViewState {\n    CREATED,\n    MOUNTED,\n    WAITING,\n  }\n  export interface View {\n    view: CellView\n    flag: number\n    options: any\n    state: ViewState\n  }\n\n  export interface EventArgs {\n    'view:mounted': { view: CellView }\n    'view:unmounted': { view: CellView }\n    'render:done': null\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}