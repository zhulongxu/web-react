{"ast":null,"code":"export var EventHook;\n(function (EventHook) {\n  const cache = {};\n  function get(type) {\n    return cache[type] || {};\n  }\n  EventHook.get = get;\n  function register(type, hook) {\n    cache[type] = hook;\n  }\n  EventHook.register = register;\n  function unregister(type) {\n    delete cache[type];\n  }\n  EventHook.unregister = unregister;\n})(EventHook || (EventHook = {}));","map":{"version":3,"names":["EventHook","cache","get","type","register","hook","unregister"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/src/dom/event/hook.ts"],"sourcesContent":["import { Store } from './store'\nimport { EventObject } from './object'\nimport { EventHandler } from './types'\n\nexport namespace EventHook {\n  const cache: { [type: string]: EventHook } = {}\n\n  export function get(type: string) {\n    return cache[type] || {}\n  }\n\n  export function register(type: string, hook: EventHook) {\n    cache[type] = hook\n  }\n\n  export function unregister(type: string) {\n    delete cache[type]\n  }\n}\n\nexport interface EventHook {\n  /**\n   * Indicates whether this event type should be bubbled when the `.trigger()`\n   * method is called; by default it is `false`, meaning that a triggered event\n   * will bubble to the element's parents up to the document (if attached to a\n   * document) and then to the window. Note that defining `noBubble` on an event\n   * will effectively prevent that event from being used for delegated events\n   * with `.trigger()`.\n   */\n  noBubble?: boolean\n\n  /**\n   * When defined, these string properties specify that a special event should\n   * be handled like another event type until the event is delivered.\n   *\n   * The `bindType` is used if the event is attached directly, and the\n   * `delegateType` is used for delegated events. These types are generally DOM\n   * event types, and should not be a special event themselves.\n   */\n  bindType?: string\n\n  /**\n   * When defined, these string properties specify that a special event should\n   * be handled like another event type until the event is delivered.\n   *\n   * The `bindType` is used if the event is attached directly, and the\n   * `delegateType` is used for delegated events. These types are generally DOM\n   * event types, and should not be a special event themselves.\n   */\n  delegateType?: string\n\n  /**\n   * The setup hook is called the first time an event of a particular type is\n   * attached to an element; this provides the hook an opportunity to do\n   * processing that will apply to all events of this type on the element.\n   *\n   * The `elem` is the reference to the element where the event is being\n   * attached and `eventHandle` is the event handler function. In most cases\n   * the `namespaces` argument should not be used, since it only represents the\n   * namespaces of the first event being attached; subsequent events may not\n   * have this same namespaces.\n   *\n   * This hook can perform whatever processing it desires, including attaching\n   * its own event handlers to the element or to other elements and recording\n   * setup information on the element using the `.data()` method. If the\n   * setup hook wants me to add a browser event (via `addEventListener` or\n   * `attachEvent`, depending on browser) it should return `false`. In all\n   * other cases, me will not add the browser event, but will continue all its\n   * other bookkeeping for the event. This would be appropriate, for example,\n   * if the event was never fired by the browser but invoked by `.trigger()`.\n   * To attach the me event handler in the setup hook, use the `eventHandle`\n   * argument.\n   *\n   */\n  setup?: (\n    elem: Store.EventTarget,\n    data: any,\n    namespaces: string[],\n    eventHandle: EventHandler<Store.EventTarget, any>,\n  ) => any | false\n\n  /**\n   * The teardown hook is called when the final event of a particular type is\n   * removed from an element. The `elem` is the reference to the element where\n   * the event is being cleaned up. This hook should return `false` if it wants\n   * me to remove the event from the browser's event system (via\n   * `removeEventListener` or `detachEvent`). In most cases, the setup and\n   * teardown hooks should return the same value.\n   *\n   * If the setup hook attached event handlers or added data to an element\n   * through a mechanism such as `.data()`, the teardown hook should reverse\n   * the process and remove them. me will generally remove the data and events\n   * when an element is totally removed from the document, but failing to remove\n   * data or events on teardown will cause a memory leak if the element stays in\n   * the document.\n   *\n   */\n  teardown?: (\n    elem: Store.EventTarget,\n    namespaces: string[],\n    eventHandle: EventHandler<Store.EventTarget, any>,\n  ) => any | false\n\n  /**\n   * Each time an event handler is added to an element through an API such as\n   * `.on()`, me calls this hook. The `elem` is the element to which the event\n   * handler is being added, and the `handleObj` argument is as described in the\n   * section above. The return value of this hook is ignored.\n   */\n  add?: (elem: Store.EventTarget, handleObj: Store.HandlerObject) => void\n\n  /**\n   * When an event handler is removed from an element using an API such as\n   * `.off()`, this hook is called. The `elem` is the element where the handler\n   * is being removed, and the `handleObj` argument is as described in the\n   * section above. The return value of this hook is ignored.\n   *\n   */\n  remove?: (elem: Store.EventTarget, handleObj: Store.HandlerObject) => void\n\n  /**\n   * The handle hook is called when the event has occurred and me would\n   * normally call the user's event handler specified by `.on()` or another\n   * event binding method. If the hook exists, me calls it instead of that\n   * event handler, passing it the event and any data passed from `.trigger()`\n   * if it was not a native event. The `elem` argument is the DOM element being\n   * handled, and `event.handleObj` property has the detailed event information.\n   *\n   */\n  handle?: (elem: Store.EventTarget, event: EventObject, ...args: any[]) => void\n\n  /**\n   * Called when the `.trigger()` method is used to trigger an event for the\n   * special type from code, as opposed to events that originate from within\n   * the browser. The `elem` argument will be the element being triggered, and\n   * the `event` argument will be a `EventObject` object constructed from the\n   * caller's input. At minimum, the event type, data, namespace, and target\n   * properties are set on the event. The data argument represents additional\n   * data passed by `.trigger()` if present.\n   *\n   */\n  trigger?: (\n    elem: Store.EventTarget,\n    event: EventObject,\n    data: any,\n  ) => any | false\n\n  /**\n   * When the `.trigger()` method finishes running all the event handlers for\n   * an event, it also looks for and runs any method on the target object by\n   * the same name unless of the handlers called `event.preventDefault()`. So,\n   * `.trigger(\"submit\")` will execute the `submit()` method on the element if\n   * one exists. When a `preventDefault` hook is specified, the hook is called\n   * just prior to checking for and executing the element's default method. If\n   * this hook returns the value `false` the element's default method will be\n   * called; otherwise it is not.\n   */\n  preventDefault?: (\n    elem: Store.EventTarget,\n    event: EventObject,\n    data: any,\n  ) => any | false\n\n  preDispatch?: (elem: Store.EventTarget, event: EventObject) => void | false\n\n  postDispatch?: (elem: Store.EventTarget, event: EventObject) => void\n}\n"],"mappings":"AAIA,OAAM,IAAWA,SAAS;AAA1B,WAAiBA,SAAS;EACxB,MAAMC,KAAK,GAAkC,EAAE;EAE/C,SAAgBC,GAAGA,CAACC,IAAY;IAC9B,OAAOF,KAAK,CAACE,IAAI,CAAC,IAAI,EAAE;EAC1B;EAFgBH,SAAA,CAAAE,GAAG,GAAAA,GAElB;EAED,SAAgBE,QAAQA,CAACD,IAAY,EAAEE,IAAe;IACpDJ,KAAK,CAACE,IAAI,CAAC,GAAGE,IAAI;EACpB;EAFgBL,SAAA,CAAAI,QAAQ,GAAAA,QAEvB;EAED,SAAgBE,UAAUA,CAACH,IAAY;IACrC,OAAOF,KAAK,CAACE,IAAI,CAAC;EACpB;EAFgBH,SAAA,CAAAM,UAAU,GAAAA,UAEzB;AACH,CAAC,EAdgBN,SAAS,KAATA,SAAS","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}