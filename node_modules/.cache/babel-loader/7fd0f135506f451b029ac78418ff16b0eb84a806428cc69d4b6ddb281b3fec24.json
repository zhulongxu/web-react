{"ast":null,"code":"/* eslint-disable no-underscore-dangle */\nimport { Point, Line, Path } from '@antv/x6-geometry';\n// takes care of math. error for case when jump is too close to end of line\nconst CLOSE_PROXIMITY_PADDING = 1;\nconst F13 = 1 / 3;\nconst F23 = 2 / 3;\nfunction setupUpdating(view) {\n  let updateList = view.graph._jumpOverUpdateList;\n  // first time setup for this paper\n  if (updateList == null) {\n    updateList = view.graph._jumpOverUpdateList = [];\n    view.graph.on('cell:mouseup', () => {\n      const list = view.graph._jumpOverUpdateList;\n      // add timeout to wait for the target node to be connected\n      // fix https://github.com/antvis/X6/issues/3387\n      setTimeout(() => {\n        for (let i = 0; i < list.length; i += 1) {\n          list[i].update();\n        }\n      });\n    });\n    view.graph.on('model:reseted', () => {\n      updateList = view.graph._jumpOverUpdateList = [];\n    });\n  }\n  // add this link to a list so it can be updated when some other link is updated\n  if (updateList.indexOf(view) < 0) {\n    updateList.push(view);\n    // watch for change of connector type or removal of link itself\n    // to remove the link from a list of jump over connectors\n    const clean = () => updateList.splice(updateList.indexOf(view), 1);\n    view.cell.once('change:connector', clean);\n    view.cell.once('removed', clean);\n  }\n}\nfunction createLines(sourcePoint, targetPoint, route = []) {\n  const points = [sourcePoint, ...route, targetPoint];\n  const lines = [];\n  points.forEach((point, idx) => {\n    const next = points[idx + 1];\n    if (next != null) {\n      lines.push(new Line(point, next));\n    }\n  });\n  return lines;\n}\nfunction findLineIntersections(line, crossCheckLines) {\n  const intersections = [];\n  crossCheckLines.forEach(crossCheckLine => {\n    const intersection = line.intersectsWithLine(crossCheckLine);\n    if (intersection) {\n      intersections.push(intersection);\n    }\n  });\n  return intersections;\n}\nfunction getDistence(p1, p2) {\n  return new Line(p1, p2).squaredLength();\n}\n/**\n * Split input line into multiple based on intersection points.\n */\nfunction createJumps(line, intersections, jumpSize) {\n  return intersections.reduce((memo, point, idx) => {\n    // skipping points that were merged with the previous line\n    // to make bigger arc over multiple lines that are close to each other\n    if (skippedPoints.includes(point)) {\n      return memo;\n    }\n    // always grab the last line from buffer and modify it\n    const lastLine = memo.pop() || line;\n    // calculate start and end of jump by moving by a given size of jump\n    const jumpStart = Point.create(point).move(lastLine.start, -jumpSize);\n    let jumpEnd = Point.create(point).move(lastLine.start, +jumpSize);\n    // now try to look at the next intersection point\n    const nextPoint = intersections[idx + 1];\n    if (nextPoint != null) {\n      const distance = jumpEnd.distance(nextPoint);\n      if (distance <= jumpSize) {\n        // next point is close enough, move the jump end by this\n        // difference and mark the next point to be skipped\n        jumpEnd = nextPoint.move(lastLine.start, distance);\n        skippedPoints.push(nextPoint);\n      }\n    } else {\n      // this block is inside of `else` as an optimization so the distance is\n      // not calculated when we know there are no other intersection points\n      const endDistance = jumpStart.distance(lastLine.end);\n      // if the end is too close to possible jump, draw remaining line instead of a jump\n      if (endDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n        memo.push(lastLine);\n        return memo;\n      }\n    }\n    const startDistance = jumpEnd.distance(lastLine.start);\n    if (startDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n      // if the start of line is too close to jump, draw that line instead of a jump\n      memo.push(lastLine);\n      return memo;\n    }\n    // finally create a jump line\n    const jumpLine = new Line(jumpStart, jumpEnd);\n    // it's just simple line but with a `isJump` property\n    jumppedLines.push(jumpLine);\n    memo.push(new Line(lastLine.start, jumpStart), jumpLine, new Line(jumpEnd, lastLine.end));\n    return memo;\n  }, []);\n}\nfunction buildPath(lines, jumpSize, jumpType, radius) {\n  const path = new Path();\n  let segment;\n  // first move to the start of a first line\n  segment = Path.createSegment('M', lines[0].start);\n  path.appendSegment(segment);\n  lines.forEach((line, index) => {\n    if (jumppedLines.includes(line)) {\n      let angle;\n      let diff;\n      let control1;\n      let control2;\n      if (jumpType === 'arc') {\n        // approximates semicircle with 2 curves\n        angle = -90;\n        // determine rotation of arc based on difference between points\n        diff = line.start.diff(line.end);\n        // make sure the arc always points up (or right)\n        const xAxisRotate = diff.x < 0 || diff.x === 0 && diff.y < 0;\n        if (xAxisRotate) {\n          angle += 180;\n        }\n        const center = line.getCenter();\n        const centerLine = new Line(center, line.end).rotate(angle, center);\n        let halfLine;\n        // first half\n        halfLine = new Line(line.start, center);\n        control1 = halfLine.pointAt(2 / 3).rotate(angle, line.start);\n        control2 = centerLine.pointAt(1 / 3).rotate(-angle, centerLine.end);\n        segment = Path.createSegment('C', control1, control2, centerLine.end);\n        path.appendSegment(segment);\n        // second half\n        halfLine = new Line(center, line.end);\n        control1 = centerLine.pointAt(1 / 3).rotate(angle, centerLine.end);\n        control2 = halfLine.pointAt(1 / 3).rotate(-angle, line.end);\n        segment = Path.createSegment('C', control1, control2, line.end);\n        path.appendSegment(segment);\n      } else if (jumpType === 'gap') {\n        segment = Path.createSegment('M', line.end);\n        path.appendSegment(segment);\n      } else if (jumpType === 'cubic') {\n        // approximates semicircle with 1 curve\n        angle = line.start.theta(line.end);\n        const xOffset = jumpSize * 0.6;\n        let yOffset = jumpSize * 1.35;\n        // determine rotation of arc based on difference between points\n        diff = line.start.diff(line.end);\n        // make sure the arc always points up (or right)\n        const xAxisRotate = diff.x < 0 || diff.x === 0 && diff.y < 0;\n        if (xAxisRotate) {\n          yOffset *= -1;\n        }\n        control1 = new Point(line.start.x + xOffset, line.start.y + yOffset).rotate(angle, line.start);\n        control2 = new Point(line.end.x - xOffset, line.end.y + yOffset).rotate(angle, line.end);\n        segment = Path.createSegment('C', control1, control2, line.end);\n        path.appendSegment(segment);\n      }\n    } else {\n      const nextLine = lines[index + 1];\n      if (radius === 0 || !nextLine || jumppedLines.includes(nextLine)) {\n        segment = Path.createSegment('L', line.end);\n        path.appendSegment(segment);\n      } else {\n        buildRoundedSegment(radius, path, line.end, line.start, nextLine.end);\n      }\n    }\n  });\n  return path;\n}\nfunction buildRoundedSegment(offset, path, curr, prev, next) {\n  const prevDistance = curr.distance(prev) / 2;\n  const nextDistance = curr.distance(next) / 2;\n  const startMove = -Math.min(offset, prevDistance);\n  const endMove = -Math.min(offset, nextDistance);\n  const roundedStart = curr.clone().move(prev, startMove).round();\n  const roundedEnd = curr.clone().move(next, endMove).round();\n  const control1 = new Point(F13 * roundedStart.x + F23 * curr.x, F23 * curr.y + F13 * roundedStart.y);\n  const control2 = new Point(F13 * roundedEnd.x + F23 * curr.x, F23 * curr.y + F13 * roundedEnd.y);\n  let segment;\n  segment = Path.createSegment('L', roundedStart);\n  path.appendSegment(segment);\n  segment = Path.createSegment('C', control1, control2, roundedEnd);\n  path.appendSegment(segment);\n}\nlet jumppedLines;\nlet skippedPoints;\nexport const jumpover = function (sourcePoint, targetPoint, routePoints, options = {}) {\n  jumppedLines = [];\n  skippedPoints = [];\n  setupUpdating(this);\n  const jumpSize = options.size || 5;\n  const jumpType = options.type || 'arc';\n  const radius = options.radius || 0;\n  // list of connector types not to jump over.\n  const ignoreConnectors = options.ignoreConnectors || ['smooth'];\n  const graph = this.graph;\n  const model = graph.model;\n  const allLinks = model.getEdges();\n  // there is just one link, draw it directly\n  if (allLinks.length === 1) {\n    return buildPath(createLines(sourcePoint, targetPoint, routePoints), jumpSize, jumpType, radius);\n  }\n  const edge = this.cell;\n  const thisIndex = allLinks.indexOf(edge);\n  const defaultConnector = graph.options.connecting.connector || {};\n  // not all links are meant to be jumped over.\n  const edges = allLinks.filter((link, idx) => {\n    const connector = link.getConnector() || defaultConnector;\n    // avoid jumping over links with connector type listed in `ignored connectors`.\n    if (ignoreConnectors.includes(connector.name)) {\n      return false;\n    }\n    // filter out links that are above this one and  have the same connector type\n    // otherwise there would double hoops for each intersection\n    if (idx > thisIndex) {\n      return connector.name !== 'jumpover';\n    }\n    return true;\n  });\n  // find views for all links\n  const linkViews = edges.map(edge => {\n    return graph.findViewByCell(edge);\n  });\n  // create lines for this link\n  const thisLines = createLines(sourcePoint, targetPoint, routePoints);\n  // create lines for all other links\n  const linkLines = linkViews.map(linkView => {\n    if (linkView == null) {\n      return [];\n    }\n    if (linkView === this) {\n      return thisLines;\n    }\n    return createLines(linkView.sourcePoint, linkView.targetPoint, linkView.routePoints);\n  });\n  // transform lines for this link by splitting with jump lines at\n  // points of intersection with other links\n  const jumpingLines = [];\n  thisLines.forEach(line => {\n    // iterate all links and grab the intersections with this line\n    // these are then sorted by distance so the line can be split more easily\n    const intersections = edges.reduce((memo, link, i) => {\n      // don't intersection with itself\n      if (link !== edge) {\n        const lineIntersections = findLineIntersections(line, linkLines[i]);\n        memo.push(...lineIntersections);\n      }\n      return memo;\n    }, []).sort((a, b) => getDistence(line.start, a) - getDistence(line.start, b));\n    if (intersections.length > 0) {\n      // split the line based on found intersection points\n      jumpingLines.push(...createJumps(line, intersections, jumpSize));\n    } else {\n      // without any intersection the line goes uninterrupted\n      jumpingLines.push(line);\n    }\n  });\n  const path = buildPath(jumpingLines, jumpSize, jumpType, radius);\n  jumppedLines = [];\n  skippedPoints = [];\n  return options.raw ? path : path.serialize();\n};","map":{"version":3,"names":["Point","Line","Path","CLOSE_PROXIMITY_PADDING","F13","F23","setupUpdating","view","updateList","graph","_jumpOverUpdateList","on","list","setTimeout","i","length","update","indexOf","push","clean","splice","cell","once","createLines","sourcePoint","targetPoint","route","points","lines","forEach","point","idx","next","findLineIntersections","line","crossCheckLines","intersections","crossCheckLine","intersection","intersectsWithLine","getDistence","p1","p2","squaredLength","createJumps","jumpSize","reduce","memo","skippedPoints","includes","lastLine","pop","jumpStart","create","move","start","jumpEnd","nextPoint","distance","endDistance","end","startDistance","jumpLine","jumppedLines","buildPath","jumpType","radius","path","segment","createSegment","appendSegment","index","angle","diff","control1","control2","xAxisRotate","x","y","center","getCenter","centerLine","rotate","halfLine","pointAt","theta","xOffset","yOffset","nextLine","buildRoundedSegment","offset","curr","prev","prevDistance","nextDistance","startMove","Math","min","endMove","roundedStart","clone","round","roundedEnd","jumpover","routePoints","options","size","type","ignoreConnectors","model","allLinks","getEdges","edge","thisIndex","defaultConnector","connecting","connector","edges","filter","link","getConnector","name","linkViews","map","findViewByCell","thisLines","linkLines","linkView","jumpingLines","lineIntersections","sort","a","b","raw","serialize"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/src/registry/connector/jumpover.ts"],"sourcesContent":["/* eslint-disable no-underscore-dangle */\n\nimport { Point, Line, Path } from '@antv/x6-geometry'\nimport { Edge } from '../../model'\nimport { EdgeView } from '../../view'\nimport { Connector } from './index'\n\n// takes care of math. error for case when jump is too close to end of line\nconst CLOSE_PROXIMITY_PADDING = 1\nconst F13 = 1 / 3\nconst F23 = 2 / 3\n\nfunction setupUpdating(view: EdgeView) {\n  let updateList = (view.graph as any)._jumpOverUpdateList\n\n  // first time setup for this paper\n  if (updateList == null) {\n    updateList = (view.graph as any)._jumpOverUpdateList = []\n\n    view.graph.on('cell:mouseup', () => {\n      const list = (view.graph as any)._jumpOverUpdateList\n      // add timeout to wait for the target node to be connected\n      // fix https://github.com/antvis/X6/issues/3387\n      setTimeout(() => {\n        for (let i = 0; i < list.length; i += 1) {\n          list[i].update()\n        }\n      })\n    })\n\n    view.graph.on('model:reseted', () => {\n      updateList = (view.graph as any)._jumpOverUpdateList = []\n    })\n  }\n\n  // add this link to a list so it can be updated when some other link is updated\n  if (updateList.indexOf(view) < 0) {\n    updateList.push(view)\n\n    // watch for change of connector type or removal of link itself\n    // to remove the link from a list of jump over connectors\n    const clean = () => updateList.splice(updateList.indexOf(view), 1)\n    view.cell.once('change:connector', clean)\n    view.cell.once('removed', clean)\n  }\n}\n\nfunction createLines(\n  sourcePoint: Point.PointLike,\n  targetPoint: Point.PointLike,\n  route: Point.PointLike[] = [],\n) {\n  const points = [sourcePoint, ...route, targetPoint]\n  const lines: Line[] = []\n\n  points.forEach((point, idx) => {\n    const next = points[idx + 1]\n    if (next != null) {\n      lines.push(new Line(point, next))\n    }\n  })\n\n  return lines\n}\n\nfunction findLineIntersections(line: Line, crossCheckLines: Line[]) {\n  const intersections: Point[] = []\n  crossCheckLines.forEach((crossCheckLine) => {\n    const intersection = line.intersectsWithLine(crossCheckLine)\n    if (intersection) {\n      intersections.push(intersection)\n    }\n  })\n  return intersections\n}\n\nfunction getDistence(p1: Point, p2: Point) {\n  return new Line(p1, p2).squaredLength()\n}\n\n/**\n * Split input line into multiple based on intersection points.\n */\nfunction createJumps(line: Line, intersections: Point[], jumpSize: number) {\n  return intersections.reduce<Line[]>((memo, point, idx) => {\n    // skipping points that were merged with the previous line\n    // to make bigger arc over multiple lines that are close to each other\n    if (skippedPoints.includes(point)) {\n      return memo\n    }\n\n    // always grab the last line from buffer and modify it\n    const lastLine = memo.pop() || line\n\n    // calculate start and end of jump by moving by a given size of jump\n    const jumpStart = Point.create(point).move(lastLine.start, -jumpSize)\n    let jumpEnd = Point.create(point).move(lastLine.start, +jumpSize)\n\n    // now try to look at the next intersection point\n    const nextPoint = intersections[idx + 1]\n    if (nextPoint != null) {\n      const distance = jumpEnd.distance(nextPoint)\n      if (distance <= jumpSize) {\n        // next point is close enough, move the jump end by this\n        // difference and mark the next point to be skipped\n        jumpEnd = nextPoint.move(lastLine.start, distance)\n        skippedPoints.push(nextPoint)\n      }\n    } else {\n      // this block is inside of `else` as an optimization so the distance is\n      // not calculated when we know there are no other intersection points\n      const endDistance = jumpStart.distance(lastLine.end)\n      // if the end is too close to possible jump, draw remaining line instead of a jump\n      if (endDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n        memo.push(lastLine)\n        return memo\n      }\n    }\n\n    const startDistance = jumpEnd.distance(lastLine.start)\n    if (startDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n      // if the start of line is too close to jump, draw that line instead of a jump\n      memo.push(lastLine)\n      return memo\n    }\n\n    // finally create a jump line\n    const jumpLine = new Line(jumpStart, jumpEnd)\n    // it's just simple line but with a `isJump` property\n    jumppedLines.push(jumpLine)\n\n    memo.push(\n      new Line(lastLine.start, jumpStart),\n      jumpLine,\n      new Line(jumpEnd, lastLine.end),\n    )\n\n    return memo\n  }, [])\n}\n\nfunction buildPath(\n  lines: Line[],\n  jumpSize: number,\n  jumpType: JumpType,\n  radius: number,\n) {\n  const path = new Path()\n  let segment\n\n  // first move to the start of a first line\n  segment = Path.createSegment('M', lines[0].start)\n  path.appendSegment(segment)\n\n  lines.forEach((line, index) => {\n    if (jumppedLines.includes(line)) {\n      let angle\n      let diff\n\n      let control1\n      let control2\n\n      if (jumpType === 'arc') {\n        // approximates semicircle with 2 curves\n        angle = -90\n        // determine rotation of arc based on difference between points\n        diff = line.start.diff(line.end)\n        // make sure the arc always points up (or right)\n        const xAxisRotate = diff.x < 0 || (diff.x === 0 && diff.y < 0)\n        if (xAxisRotate) {\n          angle += 180\n        }\n\n        const center = line.getCenter()\n        const centerLine = new Line(center, line.end).rotate(angle, center)\n\n        let halfLine\n\n        // first half\n        halfLine = new Line(line.start, center)\n        control1 = halfLine.pointAt(2 / 3).rotate(angle, line.start)\n        control2 = centerLine.pointAt(1 / 3).rotate(-angle, centerLine.end)\n\n        segment = Path.createSegment('C', control1, control2, centerLine.end)\n        path.appendSegment(segment)\n\n        // second half\n        halfLine = new Line(center, line.end)\n\n        control1 = centerLine.pointAt(1 / 3).rotate(angle, centerLine.end)\n        control2 = halfLine.pointAt(1 / 3).rotate(-angle, line.end)\n\n        segment = Path.createSegment('C', control1, control2, line.end)\n        path.appendSegment(segment)\n      } else if (jumpType === 'gap') {\n        segment = Path.createSegment('M', line.end)\n        path.appendSegment(segment)\n      } else if (jumpType === 'cubic') {\n        // approximates semicircle with 1 curve\n        angle = line.start.theta(line.end)\n\n        const xOffset = jumpSize * 0.6\n        let yOffset = jumpSize * 1.35\n\n        // determine rotation of arc based on difference between points\n        diff = line.start.diff(line.end)\n        // make sure the arc always points up (or right)\n        const xAxisRotate = diff.x < 0 || (diff.x === 0 && diff.y < 0)\n        if (xAxisRotate) {\n          yOffset *= -1\n        }\n\n        control1 = new Point(\n          line.start.x + xOffset,\n          line.start.y + yOffset,\n        ).rotate(angle, line.start)\n        control2 = new Point(line.end.x - xOffset, line.end.y + yOffset).rotate(\n          angle,\n          line.end,\n        )\n\n        segment = Path.createSegment('C', control1, control2, line.end)\n        path.appendSegment(segment)\n      }\n    } else {\n      const nextLine = lines[index + 1]\n      if (radius === 0 || !nextLine || jumppedLines.includes(nextLine)) {\n        segment = Path.createSegment('L', line.end)\n        path.appendSegment(segment)\n      } else {\n        buildRoundedSegment(radius, path, line.end, line.start, nextLine.end)\n      }\n    }\n  })\n\n  return path\n}\n\nfunction buildRoundedSegment(\n  offset: number,\n  path: Path,\n  curr: Point,\n  prev: Point,\n  next: Point,\n) {\n  const prevDistance = curr.distance(prev) / 2\n  const nextDistance = curr.distance(next) / 2\n\n  const startMove = -Math.min(offset, prevDistance)\n  const endMove = -Math.min(offset, nextDistance)\n\n  const roundedStart = curr.clone().move(prev, startMove).round()\n  const roundedEnd = curr.clone().move(next, endMove).round()\n\n  const control1 = new Point(\n    F13 * roundedStart.x + F23 * curr.x,\n    F23 * curr.y + F13 * roundedStart.y,\n  )\n  const control2 = new Point(\n    F13 * roundedEnd.x + F23 * curr.x,\n    F23 * curr.y + F13 * roundedEnd.y,\n  )\n\n  let segment\n  segment = Path.createSegment('L', roundedStart)\n  path.appendSegment(segment)\n\n  segment = Path.createSegment('C', control1, control2, roundedEnd)\n  path.appendSegment(segment)\n}\n\nexport type JumpType = 'arc' | 'gap' | 'cubic'\n\nexport interface JumpoverConnectorOptions extends Connector.BaseOptions {\n  size?: number\n  radius?: number\n  type?: JumpType\n  ignoreConnectors?: string[]\n}\n\nlet jumppedLines: Line[]\nlet skippedPoints: Point[]\n\nexport const jumpover: Connector.Definition<JumpoverConnectorOptions> =\n  function (sourcePoint, targetPoint, routePoints, options = {}) {\n    jumppedLines = []\n    skippedPoints = []\n\n    setupUpdating(this)\n\n    const jumpSize = options.size || 5\n    const jumpType = options.type || 'arc'\n    const radius = options.radius || 0\n    // list of connector types not to jump over.\n    const ignoreConnectors = options.ignoreConnectors || ['smooth']\n\n    const graph = this.graph\n    const model = graph.model\n    const allLinks = model.getEdges() as Edge[]\n\n    // there is just one link, draw it directly\n    if (allLinks.length === 1) {\n      return buildPath(\n        createLines(sourcePoint, targetPoint, routePoints),\n        jumpSize,\n        jumpType,\n        radius,\n      )\n    }\n\n    const edge = this.cell\n    const thisIndex = allLinks.indexOf(edge)\n    const defaultConnector = graph.options.connecting.connector || {}\n\n    // not all links are meant to be jumped over.\n    const edges = allLinks.filter((link, idx) => {\n      const connector = link.getConnector() || (defaultConnector as any)\n\n      // avoid jumping over links with connector type listed in `ignored connectors`.\n      if (ignoreConnectors.includes(connector.name)) {\n        return false\n      }\n      // filter out links that are above this one and  have the same connector type\n      // otherwise there would double hoops for each intersection\n      if (idx > thisIndex) {\n        return connector.name !== 'jumpover'\n      }\n      return true\n    })\n\n    // find views for all links\n    const linkViews = edges.map((edge) => {\n      return graph.findViewByCell(edge) as EdgeView\n    })\n\n    // create lines for this link\n    const thisLines = createLines(sourcePoint, targetPoint, routePoints)\n\n    // create lines for all other links\n    const linkLines = linkViews.map((linkView) => {\n      if (linkView == null) {\n        return []\n      }\n      if (linkView === this) {\n        return thisLines\n      }\n      return createLines(\n        linkView.sourcePoint,\n        linkView.targetPoint,\n        linkView.routePoints,\n      )\n    })\n\n    // transform lines for this link by splitting with jump lines at\n    // points of intersection with other links\n    const jumpingLines: Line[] = []\n\n    thisLines.forEach((line) => {\n      // iterate all links and grab the intersections with this line\n      // these are then sorted by distance so the line can be split more easily\n\n      const intersections = edges\n        .reduce<Point[]>((memo, link, i) => {\n          // don't intersection with itself\n          if (link !== edge) {\n            const lineIntersections = findLineIntersections(line, linkLines[i])\n            memo.push(...lineIntersections)\n          }\n          return memo\n        }, [])\n        .sort((a, b) => getDistence(line.start, a) - getDistence(line.start, b))\n\n      if (intersections.length > 0) {\n        // split the line based on found intersection points\n        jumpingLines.push(...createJumps(line, intersections, jumpSize))\n      } else {\n        // without any intersection the line goes uninterrupted\n        jumpingLines.push(line)\n      }\n    })\n\n    const path = buildPath(jumpingLines, jumpSize, jumpType, radius)\n\n    jumppedLines = []\n    skippedPoints = []\n\n    return options.raw ? path : path.serialize()\n  }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}