{"ast":null,"code":"import { Registry } from '../registry';\nimport * as anchors from './main';\nexport var NodeAnchor;\n(function (NodeAnchor) {\n  NodeAnchor.presets = anchors;\n  NodeAnchor.registry = Registry.create({\n    type: 'node endpoint'\n  });\n  NodeAnchor.registry.register(NodeAnchor.presets, true);\n})(NodeAnchor || (NodeAnchor = {}));","map":{"version":3,"names":["Registry","anchors","NodeAnchor","presets","registry","create","type","register"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/src/registry/node-anchor/index.ts"],"sourcesContent":["import { Point } from '@antv/x6-geometry'\nimport { KeyValue } from '@antv/x6-common'\nimport { Registry } from '../registry'\nimport { Edge } from '../../model'\nimport { EdgeView, NodeView } from '../../view'\nimport * as anchors from './main'\n\nexport namespace NodeAnchor {\n  export type Definition<T> = (\n    this: EdgeView,\n    /**\n     * The NodeView to which we are connecting.\n     */\n    nodeView: NodeView,\n    /**\n     * The SVGElement in our graph that contains the magnet\n     * (element/subelement/port) to which we are connecting.\n     */\n    magnet: SVGElement,\n    /**\n     * A reference to another component of the edge path that may be\n     * necessary to find this anchor point. If we are calling this method\n     * for a source anchor, it is the first vertex, or if there are no\n     * vertices the target anchor. If we are calling this method for a target\n     * anchor, it is the last vertex, or if there are no vertices the source\n     * anchor...\n     */\n    ref: Point | Point.PointLike | SVGElement,\n    args: T,\n    type: Edge.TerminalType,\n  ) => Point\n\n  export type CommonDefinition = Definition<KeyValue>\n\n  export type ResolvedDefinition<T> = (\n    this: EdgeView,\n    view: NodeView,\n    magnet: SVGElement,\n    refPoint: Point,\n    args: T,\n  ) => Point\n}\n\nexport namespace NodeAnchor {\n  export type Presets = (typeof NodeAnchor)['presets']\n\n  export type OptionsMap = {\n    readonly [K in keyof Presets]-?: Parameters<Presets[K]>[3]\n  }\n\n  export type NativeNames = keyof Presets\n\n  export interface NativeItem<T extends NativeNames = NativeNames> {\n    name: T\n    args?: OptionsMap[T]\n  }\n\n  export interface ManaualItem {\n    name: Exclude<string, NativeNames>\n    args?: KeyValue\n  }\n}\n\nexport namespace NodeAnchor {\n  export const presets = anchors\n  export const registry = Registry.create<CommonDefinition, Presets>({\n    type: 'node endpoint',\n  })\n\n  registry.register(presets, true)\n}\n"],"mappings":"AAEA,SAASA,QAAQ,QAAQ,aAAa;AAGtC,OAAO,KAAKC,OAAO,MAAM,QAAQ;AA0DjC,OAAM,IAAWC,UAAU;AAA3B,WAAiBA,UAAU;EACZA,UAAA,CAAAC,OAAO,GAAGF,OAAO;EACjBC,UAAA,CAAAE,QAAQ,GAAGJ,QAAQ,CAACK,MAAM,CAA4B;IACjEC,IAAI,EAAE;GACP,CAAC;EAEFJ,UAAA,CAAAE,QAAQ,CAACG,QAAQ,CAACL,UAAA,CAAAC,OAAO,EAAE,IAAI,CAAC;AAClC,CAAC,EAPgBD,UAAU,KAAVA,UAAU","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}