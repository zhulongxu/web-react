{"ast":null,"code":"var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { ArrayExt, Basecoat } from '@antv/x6-common';\nexport class Collection extends Basecoat {\n  constructor(cells, options = {}) {\n    super();\n    this.length = 0;\n    this.comparator = options.comparator || 'zIndex';\n    this.clean();\n    if (cells) {\n      this.reset(cells, {\n        silent: true\n      });\n    }\n  }\n  toJSON() {\n    return this.cells.map(cell => cell.toJSON());\n  }\n  add(cells, index, options) {\n    let localIndex;\n    let localOptions;\n    if (typeof index === 'number') {\n      localIndex = index;\n      localOptions = Object.assign({\n        merge: false\n      }, options);\n    } else {\n      localIndex = this.length;\n      localOptions = Object.assign({\n        merge: false\n      }, index);\n    }\n    if (localIndex > this.length) {\n      localIndex = this.length;\n    }\n    if (localIndex < 0) {\n      localIndex += this.length + 1;\n    }\n    const entities = Array.isArray(cells) ? cells : [cells];\n    const sortable = this.comparator && typeof index !== 'number' && localOptions.sort !== false;\n    const sortAttr = this.comparator || null;\n    let sort = false;\n    const added = [];\n    const merged = [];\n    entities.forEach(cell => {\n      const existing = this.get(cell);\n      if (existing) {\n        if (localOptions.merge && !cell.isSameStore(existing)) {\n          existing.setProp(cell.getProp(), options); // merge\n          merged.push(existing);\n          if (sortable && !sort) {\n            if (sortAttr == null || typeof sortAttr === 'function') {\n              sort = existing.hasChanged();\n            } else if (typeof sortAttr === 'string') {\n              sort = existing.hasChanged(sortAttr);\n            } else {\n              sort = sortAttr.some(key => existing.hasChanged(key));\n            }\n          }\n        }\n      } else {\n        added.push(cell);\n        this.reference(cell);\n      }\n    });\n    if (added.length) {\n      if (sortable) {\n        sort = true;\n      }\n      this.cells.splice(localIndex, 0, ...added);\n      this.length = this.cells.length;\n    }\n    if (sort) {\n      this.sort({\n        silent: true\n      });\n    }\n    if (!localOptions.silent) {\n      added.forEach((cell, i) => {\n        const args = {\n          cell,\n          index: localIndex + i,\n          options: localOptions\n        };\n        this.trigger('added', args);\n        if (!localOptions.dryrun) {\n          cell.notify('added', Object.assign({}, args));\n        }\n      });\n      if (sort) {\n        this.trigger('sorted');\n      }\n      if (added.length || merged.length) {\n        this.trigger('updated', {\n          added,\n          merged,\n          removed: [],\n          options: localOptions\n        });\n      }\n    }\n    return this;\n  }\n  remove(cells, options = {}) {\n    const arr = Array.isArray(cells) ? cells : [cells];\n    const removed = this.removeCells(arr, options);\n    if (!options.silent && removed.length > 0) {\n      this.trigger('updated', {\n        options,\n        removed,\n        added: [],\n        merged: []\n      });\n    }\n    return Array.isArray(cells) ? removed : removed[0];\n  }\n  removeCells(cells, options) {\n    const removed = [];\n    for (let i = 0; i < cells.length; i += 1) {\n      const cell = this.get(cells[i]);\n      if (cell == null) {\n        continue;\n      }\n      const index = this.cells.indexOf(cell);\n      this.cells.splice(index, 1);\n      this.length -= 1;\n      delete this.map[cell.id];\n      removed.push(cell);\n      this.unreference(cell);\n      if (!options.dryrun) {\n        cell.remove();\n      }\n      if (!options.silent) {\n        this.trigger('removed', {\n          cell,\n          index,\n          options\n        });\n        if (!options.dryrun) {\n          cell.notify('removed', {\n            cell,\n            index,\n            options\n          });\n        }\n      }\n    }\n    return removed;\n  }\n  reset(cells, options = {}) {\n    const previous = this.cells.slice();\n    previous.forEach(cell => this.unreference(cell));\n    this.clean();\n    this.add(cells, Object.assign({\n      silent: true\n    }, options));\n    if (!options.silent) {\n      const current = this.cells.slice();\n      this.trigger('reseted', {\n        options,\n        previous,\n        current\n      });\n      const added = [];\n      const removed = [];\n      current.forEach(a => {\n        const exist = previous.some(b => b.id === a.id);\n        if (!exist) {\n          added.push(a);\n        }\n      });\n      previous.forEach(a => {\n        const exist = current.some(b => b.id === a.id);\n        if (!exist) {\n          removed.push(a);\n        }\n      });\n      this.trigger('updated', {\n        options,\n        added,\n        removed,\n        merged: []\n      });\n    }\n    return this;\n  }\n  push(cell, options) {\n    return this.add(cell, this.length, options);\n  }\n  pop(options) {\n    const cell = this.at(this.length - 1);\n    return this.remove(cell, options);\n  }\n  unshift(cell, options) {\n    return this.add(cell, 0, options);\n  }\n  shift(options) {\n    const cell = this.at(0);\n    return this.remove(cell, options);\n  }\n  get(cell) {\n    if (cell == null) {\n      return null;\n    }\n    const id = typeof cell === 'string' || typeof cell === 'number' ? cell : cell.id;\n    return this.map[id] || null;\n  }\n  has(cell) {\n    return this.get(cell) != null;\n  }\n  at(index) {\n    if (index < 0) {\n      index += this.length; // eslint-disable-line\n    }\n    return this.cells[index] || null;\n  }\n  first() {\n    return this.at(0);\n  }\n  last() {\n    return this.at(-1);\n  }\n  indexOf(cell) {\n    return this.cells.indexOf(cell);\n  }\n  toArray() {\n    return this.cells.slice();\n  }\n  sort(options = {}) {\n    if (this.comparator != null) {\n      this.cells = ArrayExt.sortBy(this.cells, this.comparator);\n      if (!options.silent) {\n        this.trigger('sorted');\n      }\n    }\n    return this;\n  }\n  clone() {\n    const constructor = this.constructor;\n    return new constructor(this.cells.slice(), {\n      comparator: this.comparator\n    });\n  }\n  reference(cell) {\n    this.map[cell.id] = cell;\n    cell.on('*', this.notifyCellEvent, this);\n  }\n  unreference(cell) {\n    cell.off('*', this.notifyCellEvent, this);\n    delete this.map[cell.id];\n  }\n  notifyCellEvent(name, args) {\n    const cell = args.cell;\n    this.trigger(`cell:${name}`, args);\n    if (cell) {\n      if (cell.isNode()) {\n        this.trigger(`node:${name}`, Object.assign(Object.assign({}, args), {\n          node: cell\n        }));\n      } else if (cell.isEdge()) {\n        this.trigger(`edge:${name}`, Object.assign(Object.assign({}, args), {\n          edge: cell\n        }));\n      }\n    }\n  }\n  clean() {\n    this.length = 0;\n    this.cells = [];\n    this.map = {};\n  }\n  dispose() {\n    this.reset([]);\n  }\n}\n__decorate([Collection.dispose()], Collection.prototype, \"dispose\", null);","map":{"version":3,"names":["ArrayExt","Basecoat","Collection","constructor","cells","options","length","comparator","clean","reset","silent","toJSON","map","cell","add","index","localIndex","localOptions","Object","assign","merge","entities","Array","isArray","sortable","sort","sortAttr","added","merged","forEach","existing","get","isSameStore","setProp","getProp","push","hasChanged","some","key","reference","splice","i","args","trigger","dryrun","notify","removed","remove","arr","removeCells","indexOf","id","unreference","previous","slice","current","a","exist","b","pop","at","unshift","shift","has","first","last","toArray","sortBy","clone","on","notifyCellEvent","off","name","isNode","node","isEdge","edge","dispose","__decorate"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/src/model/collection.ts"],"sourcesContent":["import { ArrayExt, Basecoat } from '@antv/x6-common'\nimport { Cell } from './cell'\nimport { Node } from './node'\nimport { Edge } from './edge'\n\nexport class Collection extends Basecoat<Collection.EventArgs> {\n  public length = 0\n  public comparator: Collection.Comparator | null\n  private cells: Cell[]\n  private map: { [id: string]: Cell }\n\n  constructor(cells: Cell | Cell[], options: Collection.Options = {}) {\n    super()\n    this.comparator = options.comparator || 'zIndex'\n    this.clean()\n    if (cells) {\n      this.reset(cells, { silent: true })\n    }\n  }\n\n  toJSON() {\n    return this.cells.map((cell) => cell.toJSON())\n  }\n\n  add(cells: Cell | Cell[], options?: Collection.AddOptions): this\n  add(\n    cells: Cell | Cell[],\n    index: number,\n    options?: Collection.AddOptions,\n  ): this\n  add(\n    cells: Cell | Cell[],\n    index?: number | Collection.AddOptions,\n    options?: Collection.AddOptions,\n  ) {\n    let localIndex: number\n    let localOptions: Collection.AddOptions\n\n    if (typeof index === 'number') {\n      localIndex = index\n      localOptions = { merge: false, ...options }\n    } else {\n      localIndex = this.length\n      localOptions = { merge: false, ...index }\n    }\n\n    if (localIndex > this.length) {\n      localIndex = this.length\n    }\n    if (localIndex < 0) {\n      localIndex += this.length + 1\n    }\n\n    const entities = Array.isArray(cells) ? cells : [cells]\n    const sortable =\n      this.comparator &&\n      typeof index !== 'number' &&\n      localOptions.sort !== false\n    const sortAttr = this.comparator || null\n\n    let sort = false\n    const added: Cell[] = []\n    const merged: Cell[] = []\n\n    entities.forEach((cell) => {\n      const existing = this.get(cell)\n      if (existing) {\n        if (localOptions.merge && !cell.isSameStore(existing)) {\n          existing.setProp(cell.getProp(), options) // merge\n          merged.push(existing)\n          if (sortable && !sort) {\n            if (sortAttr == null || typeof sortAttr === 'function') {\n              sort = existing.hasChanged()\n            } else if (typeof sortAttr === 'string') {\n              sort = existing.hasChanged(sortAttr)\n            } else {\n              sort = sortAttr.some((key) => existing.hasChanged(key))\n            }\n          }\n        }\n      } else {\n        added.push(cell)\n        this.reference(cell)\n      }\n    })\n\n    if (added.length) {\n      if (sortable) {\n        sort = true\n      }\n      this.cells.splice(localIndex, 0, ...added)\n      this.length = this.cells.length\n    }\n\n    if (sort) {\n      this.sort({ silent: true })\n    }\n\n    if (!localOptions.silent) {\n      added.forEach((cell, i) => {\n        const args = {\n          cell,\n          index: localIndex + i,\n          options: localOptions,\n        }\n        this.trigger('added', args)\n        if (!localOptions.dryrun) {\n          cell.notify('added', { ...args })\n        }\n      })\n\n      if (sort) {\n        this.trigger('sorted')\n      }\n\n      if (added.length || merged.length) {\n        this.trigger('updated', {\n          added,\n          merged,\n          removed: [],\n          options: localOptions,\n        })\n      }\n    }\n\n    return this\n  }\n\n  remove(cell: Cell, options?: Collection.RemoveOptions): Cell\n  remove(cells: Cell[], options?: Collection.RemoveOptions): Cell[]\n  remove(cells: Cell | Cell[], options: Collection.RemoveOptions = {}) {\n    const arr = Array.isArray(cells) ? cells : [cells]\n    const removed = this.removeCells(arr, options)\n    if (!options.silent && removed.length > 0) {\n      this.trigger('updated', {\n        options,\n        removed,\n        added: [],\n        merged: [],\n      })\n    }\n    return Array.isArray(cells) ? removed : removed[0]\n  }\n\n  protected removeCells(cells: Cell[], options: Collection.RemoveOptions) {\n    const removed = []\n\n    for (let i = 0; i < cells.length; i += 1) {\n      const cell = this.get(cells[i])\n      if (cell == null) {\n        continue\n      }\n\n      const index = this.cells.indexOf(cell)\n      this.cells.splice(index, 1)\n      this.length -= 1\n      delete this.map[cell.id]\n      removed.push(cell)\n      this.unreference(cell)\n\n      if (!options.dryrun) {\n        cell.remove()\n      }\n\n      if (!options.silent) {\n        this.trigger('removed', { cell, index, options })\n\n        if (!options.dryrun) {\n          cell.notify('removed', { cell, index, options })\n        }\n      }\n    }\n\n    return removed\n  }\n\n  reset(cells: Cell | Cell[], options: Collection.SetOptions = {}) {\n    const previous = this.cells.slice()\n    previous.forEach((cell) => this.unreference(cell))\n    this.clean()\n    this.add(cells, { silent: true, ...options })\n    if (!options.silent) {\n      const current = this.cells.slice()\n      this.trigger('reseted', {\n        options,\n        previous,\n        current,\n      })\n\n      const added: Cell[] = []\n      const removed: Cell[] = []\n\n      current.forEach((a) => {\n        const exist = previous.some((b) => b.id === a.id)\n        if (!exist) {\n          added.push(a)\n        }\n      })\n\n      previous.forEach((a) => {\n        const exist = current.some((b) => b.id === a.id)\n        if (!exist) {\n          removed.push(a)\n        }\n      })\n\n      this.trigger('updated', { options, added, removed, merged: [] })\n    }\n\n    return this\n  }\n\n  push(cell: Cell, options?: Collection.SetOptions) {\n    return this.add(cell, this.length, options)\n  }\n\n  pop(options?: Collection.SetOptions) {\n    const cell = this.at(this.length - 1)!\n    return this.remove(cell, options)\n  }\n\n  unshift(cell: Cell, options?: Collection.SetOptions) {\n    return this.add(cell, 0, options)\n  }\n\n  shift(options?: Collection.SetOptions) {\n    const cell = this.at(0)!\n    return this.remove(cell, options)\n  }\n\n  get(cell?: string | number | Cell | null): Cell | null {\n    if (cell == null) {\n      return null\n    }\n\n    const id =\n      typeof cell === 'string' || typeof cell === 'number' ? cell : cell.id\n    return this.map[id] || null\n  }\n\n  has(cell: string | Cell): boolean {\n    return this.get(cell as any) != null\n  }\n\n  at(index: number): Cell | null {\n    if (index < 0) {\n      index += this.length // eslint-disable-line\n    }\n    return this.cells[index] || null\n  }\n\n  first() {\n    return this.at(0)\n  }\n\n  last() {\n    return this.at(-1)\n  }\n\n  indexOf(cell: Cell) {\n    return this.cells.indexOf(cell)\n  }\n\n  toArray() {\n    return this.cells.slice()\n  }\n\n  sort(options: Collection.SetOptions = {}) {\n    if (this.comparator != null) {\n      this.cells = ArrayExt.sortBy(this.cells, this.comparator)\n      if (!options.silent) {\n        this.trigger('sorted')\n      }\n    }\n\n    return this\n  }\n\n  clone() {\n    const constructor = this.constructor as any\n    return new constructor(this.cells.slice(), {\n      comparator: this.comparator,\n    }) as Collection\n  }\n\n  protected reference(cell: Cell) {\n    this.map[cell.id] = cell\n    cell.on('*', this.notifyCellEvent, this)\n  }\n\n  protected unreference(cell: Cell) {\n    cell.off('*', this.notifyCellEvent, this)\n    delete this.map[cell.id]\n  }\n\n  protected notifyCellEvent<K extends keyof Cell.EventArgs>(\n    name: K,\n    args: Cell.EventArgs[K],\n  ) {\n    const cell = args.cell\n    this.trigger(`cell:${name}`, args)\n    if (cell) {\n      if (cell.isNode()) {\n        this.trigger(`node:${name}`, { ...args, node: cell })\n      } else if (cell.isEdge()) {\n        this.trigger(`edge:${name}`, { ...args, edge: cell })\n      }\n    }\n  }\n\n  protected clean() {\n    this.length = 0\n    this.cells = []\n    this.map = {}\n  }\n\n  @Collection.dispose()\n  dispose() {\n    this.reset([])\n  }\n}\n\nexport namespace Collection {\n  export type Comparator = string | string[] | ((cell: Cell) => number)\n\n  export interface Options {\n    comparator?: Comparator\n  }\n\n  export interface SetOptions extends Cell.SetOptions {}\n\n  export interface RemoveOptions extends Cell.SetOptions {\n    /**\n     * The default is to remove all the associated links.\n     * Set `disconnectEdges` option to `true` to disconnect edges\n     * when a cell is removed.\n     */\n    disconnectEdges?: boolean\n\n    dryrun?: boolean\n  }\n\n  export interface AddOptions extends SetOptions {\n    sort?: boolean\n    merge?: boolean\n    dryrun?: boolean\n  }\n}\n\nexport namespace Collection {\n  export interface EventArgs\n    extends CellEventArgs,\n      NodeEventArgs,\n      EdgeEventArgs {\n    sorted?: null\n    reseted: {\n      current: Cell[]\n      previous: Cell[]\n      options: SetOptions\n    }\n    updated: {\n      added: Cell[]\n      merged: Cell[]\n      removed: Cell[]\n      options: SetOptions\n    }\n    added: {\n      cell: Cell\n      index: number\n      options: AddOptions\n    }\n    removed: {\n      cell: Cell\n      index: number\n      options: RemoveOptions\n    }\n  }\n\n  interface NodeEventCommonArgs {\n    node: Node\n  }\n\n  interface EdgeEventCommonArgs {\n    edge: Edge\n  }\n\n  export interface CellEventArgs {\n    'cell:transition:start': Cell.EventArgs['transition:start']\n    'cell:transition:progress': Cell.EventArgs['transition:progress']\n    'cell:transition:complete': Cell.EventArgs['transition:complete']\n    'cell:transition:stop': Cell.EventArgs['transition:stop']\n    'cell:transition:finish': Cell.EventArgs['transition:finish']\n\n    'cell:changed': Cell.EventArgs['changed']\n    'cell:added': Cell.EventArgs['added']\n    'cell:removed': Cell.EventArgs['removed']\n\n    'cell:change:*': Cell.EventArgs['change:*']\n    'cell:change:attrs': Cell.EventArgs['change:attrs']\n    'cell:change:zIndex': Cell.EventArgs['change:zIndex']\n    'cell:change:markup': Cell.EventArgs['change:markup']\n    'cell:change:visible': Cell.EventArgs['change:visible']\n    'cell:change:parent': Cell.EventArgs['change:parent']\n    'cell:change:children': Cell.EventArgs['change:children']\n    'cell:change:tools': Cell.EventArgs['change:tools']\n    'cell:change:view': Cell.EventArgs['change:view']\n    'cell:change:data': Cell.EventArgs['change:data']\n\n    'cell:change:size': Cell.EventArgs['change:size']\n    'cell:change:angle': Cell.EventArgs['change:angle']\n    'cell:change:position': Cell.EventArgs['change:position']\n    'cell:change:ports': Cell.EventArgs['change:ports']\n    'cell:change:portMarkup': Cell.EventArgs['change:portMarkup']\n    'cell:change:portLabelMarkup': Cell.EventArgs['change:portLabelMarkup']\n    'cell:change:portContainerMarkup': Cell.EventArgs['change:portContainerMarkup']\n    'cell:ports:added': Cell.EventArgs['ports:added']\n    'cell:ports:removed': Cell.EventArgs['ports:removed']\n\n    'cell:change:source': Cell.EventArgs['change:source']\n    'cell:change:target': Cell.EventArgs['change:target']\n    'cell:change:router': Cell.EventArgs['change:router']\n    'cell:change:connector': Cell.EventArgs['change:connector']\n    'cell:change:vertices': Cell.EventArgs['change:vertices']\n    'cell:change:labels': Cell.EventArgs['change:labels']\n    'cell:change:defaultLabel': Cell.EventArgs['change:defaultLabel']\n    'cell:vertexs:added': Cell.EventArgs['vertexs:added']\n    'cell:vertexs:removed': Cell.EventArgs['vertexs:removed']\n    'cell:labels:added': Cell.EventArgs['labels:added']\n    'cell:labels:removed': Cell.EventArgs['labels:removed']\n\n    'cell:batch:start': Cell.EventArgs['batch:start']\n    'cell:batch:stop': Cell.EventArgs['batch:stop']\n  }\n\n  export interface NodeEventArgs {\n    'node:transition:start': NodeEventCommonArgs &\n      Cell.EventArgs['transition:start']\n    'node:transition:progress': NodeEventCommonArgs &\n      Cell.EventArgs['transition:progress']\n    'node:transition:complete': NodeEventCommonArgs &\n      Cell.EventArgs['transition:complete']\n    'node:transition:stop': NodeEventCommonArgs &\n      Cell.EventArgs['transition:stop']\n    'node:transition:finish': NodeEventCommonArgs &\n      Cell.EventArgs['transition:finish']\n\n    'node:changed': NodeEventCommonArgs & CellEventArgs['cell:changed']\n    'node:added': NodeEventCommonArgs & CellEventArgs['cell:added']\n    'node:removed': NodeEventCommonArgs & CellEventArgs['cell:removed']\n\n    'node:change:*': NodeEventCommonArgs & Cell.EventArgs['change:*']\n    'node:change:attrs': NodeEventCommonArgs & Cell.EventArgs['change:attrs']\n    'node:change:zIndex': NodeEventCommonArgs & Cell.EventArgs['change:zIndex']\n    'node:change:markup': NodeEventCommonArgs & Cell.EventArgs['change:markup']\n    'node:change:visible': NodeEventCommonArgs &\n      Cell.EventArgs['change:visible']\n    'node:change:parent': NodeEventCommonArgs & Cell.EventArgs['change:parent']\n    'node:change:children': NodeEventCommonArgs &\n      Cell.EventArgs['change:children']\n    'node:change:tools': NodeEventCommonArgs & Cell.EventArgs['change:tools']\n    'node:change:view': NodeEventCommonArgs & Cell.EventArgs['change:view']\n    'node:change:data': NodeEventCommonArgs & Cell.EventArgs['change:data']\n\n    'node:change:size': NodeEventCommonArgs & Cell.EventArgs['change:size']\n    'node:change:position': NodeEventCommonArgs &\n      Cell.EventArgs['change:position']\n    'node:change:angle': NodeEventCommonArgs & Cell.EventArgs['change:angle']\n    'node:change:ports': NodeEventCommonArgs & Cell.EventArgs['change:ports']\n    'node:change:portMarkup': NodeEventCommonArgs &\n      Cell.EventArgs['change:portMarkup']\n    'node:change:portLabelMarkup': NodeEventCommonArgs &\n      Cell.EventArgs['change:portLabelMarkup']\n    'node:change:portContainerMarkup': NodeEventCommonArgs &\n      Cell.EventArgs['change:portContainerMarkup']\n    'node:ports:added': NodeEventCommonArgs & Cell.EventArgs['ports:added']\n    'node:ports:removed': NodeEventCommonArgs & Cell.EventArgs['ports:removed']\n\n    'node:batch:start': NodeEventCommonArgs & Cell.EventArgs['batch:start']\n    'node:batch:stop': NodeEventCommonArgs & Cell.EventArgs['batch:stop']\n\n    // 'node:translate': NodeEventCommonArgs\n    // 'node:translating': NodeEventCommonArgs\n    // 'node:translated': NodeEventCommonArgs\n    // 'node:resize': NodeEventCommonArgs\n    // 'node:resizing': NodeEventCommonArgs\n    // 'node:resized': NodeEventCommonArgs\n    // 'node:rotate': NodeEventCommonArgs\n    // 'node:rotating': NodeEventCommonArgs\n    // 'node:rotated': NodeEventCommonArgs\n  }\n\n  export interface EdgeEventArgs {\n    'edge:transition:start': EdgeEventCommonArgs &\n      Cell.EventArgs['transition:start']\n    'edge:transition:progress': EdgeEventCommonArgs &\n      Cell.EventArgs['transition:progress']\n    'edge:transition:complete': EdgeEventCommonArgs &\n      Cell.EventArgs['transition:complete']\n    'edge:transition:stop': EdgeEventCommonArgs &\n      Cell.EventArgs['transition:stop']\n    'edge:transition:finish': EdgeEventCommonArgs &\n      Cell.EventArgs['transition:finish']\n\n    'edge:changed': EdgeEventCommonArgs & CellEventArgs['cell:changed']\n    'edge:added': EdgeEventCommonArgs & CellEventArgs['cell:added']\n    'edge:removed': EdgeEventCommonArgs & CellEventArgs['cell:removed']\n\n    'edge:change:*': EdgeEventCommonArgs & Cell.EventArgs['change:*']\n    'edge:change:attrs': EdgeEventCommonArgs & Cell.EventArgs['change:attrs']\n    'edge:change:zIndex': EdgeEventCommonArgs & Cell.EventArgs['change:zIndex']\n    'edge:change:markup': EdgeEventCommonArgs & Cell.EventArgs['change:markup']\n    'edge:change:visible': EdgeEventCommonArgs &\n      Cell.EventArgs['change:visible']\n    'edge:change:parent': EdgeEventCommonArgs & Cell.EventArgs['change:parent']\n    'edge:change:children': EdgeEventCommonArgs &\n      Cell.EventArgs['change:children']\n    'edge:change:tools': EdgeEventCommonArgs & Cell.EventArgs['change:tools']\n    'edge:change:data': EdgeEventCommonArgs & Cell.EventArgs['change:data']\n\n    'edge:change:source': EdgeEventCommonArgs & Cell.EventArgs['change:source']\n    'edge:change:target': EdgeEventCommonArgs & Cell.EventArgs['change:target']\n    'edge:change:router': EdgeEventCommonArgs & Cell.EventArgs['change:router']\n    'edge:change:connector': EdgeEventCommonArgs &\n      Cell.EventArgs['change:connector']\n    'edge:change:vertices': EdgeEventCommonArgs &\n      Cell.EventArgs['change:vertices']\n    'edge:change:labels': EdgeEventCommonArgs & Cell.EventArgs['change:labels']\n    'edge:change:defaultLabel': EdgeEventCommonArgs &\n      Cell.EventArgs['change:defaultLabel']\n    'edge:vertexs:added': EdgeEventCommonArgs & Cell.EventArgs['vertexs:added']\n    'edge:vertexs:removed': EdgeEventCommonArgs &\n      Cell.EventArgs['vertexs:removed']\n    'edge:labels:added': EdgeEventCommonArgs & Cell.EventArgs['labels:added']\n    'edge:labels:removed': EdgeEventCommonArgs &\n      Cell.EventArgs['labels:removed']\n\n    'edge:batch:start': EdgeEventCommonArgs & Cell.EventArgs['batch:start']\n    'edge:batch:stop': EdgeEventCommonArgs & Cell.EventArgs['batch:stop']\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}