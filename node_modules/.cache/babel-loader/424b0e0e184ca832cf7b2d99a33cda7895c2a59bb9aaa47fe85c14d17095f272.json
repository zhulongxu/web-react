{"ast":null,"code":"import { FunctionExt } from '@antv/x6-common';\nimport { bbox } from './bbox';\nimport { offset, getStrokeWidth } from './util';\n/**\n * Places the connection point at the intersection between the\n * link path end segment and the element's unrotated bbox.\n */\nexport const rect = function (line, view, magnet, options, type) {\n  const cell = view.cell;\n  const angle = cell.isNode() ? cell.getAngle() : 0;\n  if (angle === 0) {\n    return FunctionExt.call(bbox, this, line, view, magnet, options, type);\n  }\n  const bboxRaw = view.getUnrotatedBBoxOfElement(magnet);\n  if (options.stroked) {\n    bboxRaw.inflate(getStrokeWidth(magnet) / 2);\n  }\n  const center = bboxRaw.getCenter();\n  const lineRaw = line.clone().rotate(angle, center);\n  const intersections = lineRaw.setLength(1e6).intersect(bboxRaw);\n  const p = intersections && intersections.length ? lineRaw.start.closest(intersections).rotate(-angle, center) : line.end;\n  return offset(p, line.start, options.offset);\n};","map":{"version":3,"names":["FunctionExt","bbox","offset","getStrokeWidth","rect","line","view","magnet","options","type","cell","angle","isNode","getAngle","call","bboxRaw","getUnrotatedBBoxOfElement","stroked","inflate","center","getCenter","lineRaw","clone","rotate","intersections","setLength","intersect","p","length","start","closest","end"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/src/registry/connection-point/rect.ts"],"sourcesContent":["import { FunctionExt } from '@antv/x6-common'\nimport { bbox } from './bbox'\nimport { offset, getStrokeWidth } from './util'\nimport { ConnectionPoint } from './index'\n\nexport interface RectangleOptions extends ConnectionPoint.StrokedOptions {}\n\n/**\n * Places the connection point at the intersection between the\n * link path end segment and the element's unrotated bbox.\n */\nexport const rect: ConnectionPoint.Definition<RectangleOptions> = function (\n  line,\n  view,\n  magnet,\n  options,\n  type,\n) {\n  const cell = view.cell\n  const angle = cell.isNode() ? cell.getAngle() : 0\n  if (angle === 0) {\n    return FunctionExt.call(bbox, this, line, view, magnet, options, type)\n  }\n\n  const bboxRaw = view.getUnrotatedBBoxOfElement(magnet)\n  if (options.stroked) {\n    bboxRaw.inflate(getStrokeWidth(magnet) / 2)\n  }\n  const center = bboxRaw.getCenter()\n  const lineRaw = line.clone().rotate(angle, center)\n  const intersections = lineRaw.setLength(1e6).intersect(bboxRaw)\n  const p =\n    intersections && intersections.length\n      ? lineRaw.start.closest(intersections)!.rotate(-angle, center)\n      : line.end\n  return offset(p, line.start, options.offset)\n}\n"],"mappings":"AAAA,SAASA,WAAW,QAAQ,iBAAiB;AAC7C,SAASC,IAAI,QAAQ,QAAQ;AAC7B,SAASC,MAAM,EAAEC,cAAc,QAAQ,QAAQ;AAK/C;;;;AAIA,OAAO,MAAMC,IAAI,GAAiD,SAAAA,CAChEC,IAAI,EACJC,IAAI,EACJC,MAAM,EACNC,OAAO,EACPC,IAAI;EAEJ,MAAMC,IAAI,GAAGJ,IAAI,CAACI,IAAI;EACtB,MAAMC,KAAK,GAAGD,IAAI,CAACE,MAAM,EAAE,GAAGF,IAAI,CAACG,QAAQ,EAAE,GAAG,CAAC;EACjD,IAAIF,KAAK,KAAK,CAAC,EAAE;IACf,OAAOX,WAAW,CAACc,IAAI,CAACb,IAAI,EAAE,IAAI,EAAEI,IAAI,EAAEC,IAAI,EAAEC,MAAM,EAAEC,OAAO,EAAEC,IAAI,CAAC;;EAGxE,MAAMM,OAAO,GAAGT,IAAI,CAACU,yBAAyB,CAACT,MAAM,CAAC;EACtD,IAAIC,OAAO,CAACS,OAAO,EAAE;IACnBF,OAAO,CAACG,OAAO,CAACf,cAAc,CAACI,MAAM,CAAC,GAAG,CAAC,CAAC;;EAE7C,MAAMY,MAAM,GAAGJ,OAAO,CAACK,SAAS,EAAE;EAClC,MAAMC,OAAO,GAAGhB,IAAI,CAACiB,KAAK,EAAE,CAACC,MAAM,CAACZ,KAAK,EAAEQ,MAAM,CAAC;EAClD,MAAMK,aAAa,GAAGH,OAAO,CAACI,SAAS,CAAC,GAAG,CAAC,CAACC,SAAS,CAACX,OAAO,CAAC;EAC/D,MAAMY,CAAC,GACLH,aAAa,IAAIA,aAAa,CAACI,MAAM,GACjCP,OAAO,CAACQ,KAAK,CAACC,OAAO,CAACN,aAAa,CAAE,CAACD,MAAM,CAAC,CAACZ,KAAK,EAAEQ,MAAM,CAAC,GAC5Dd,IAAI,CAAC0B,GAAG;EACd,OAAO7B,MAAM,CAACyB,CAAC,EAAEtB,IAAI,CAACwB,KAAK,EAAErB,OAAO,CAACN,MAAM,CAAC;AAC9C,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}