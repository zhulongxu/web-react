{"ast":null,"code":"var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { FunctionExt, Dijkstra, Basecoat } from '@antv/x6-common';\nimport { Rectangle } from '@antv/x6-geometry';\nimport { Cell } from './cell';\nimport { Edge } from './edge';\nimport { Node } from './node';\nimport { Collection } from './collection';\nexport class Model extends Basecoat {\n  get [Symbol.toStringTag]() {\n    return Model.toStringTag;\n  }\n  constructor(cells = []) {\n    super();\n    this.batches = {};\n    this.addings = new WeakMap();\n    this.nodes = {};\n    this.edges = {};\n    this.outgoings = {};\n    this.incomings = {};\n    this.collection = new Collection(cells);\n    this.setup();\n  }\n  notify(name, args) {\n    this.trigger(name, args);\n    const graph = this.graph;\n    if (graph) {\n      if (name === 'sorted' || name === 'reseted' || name === 'updated') {\n        graph.trigger(`model:${name}`, args);\n      } else {\n        graph.trigger(name, args);\n      }\n    }\n    return this;\n  }\n  setup() {\n    const collection = this.collection;\n    collection.on('sorted', () => this.notify('sorted', null));\n    collection.on('updated', args => this.notify('updated', args));\n    collection.on('cell:change:zIndex', () => this.sortOnChangeZ());\n    collection.on('added', ({\n      cell\n    }) => {\n      this.onCellAdded(cell);\n    });\n    collection.on('removed', args => {\n      const cell = args.cell;\n      this.onCellRemoved(cell, args.options);\n      // Should trigger remove-event manually after cell was removed.\n      this.notify('cell:removed', args);\n      if (cell.isNode()) {\n        this.notify('node:removed', Object.assign(Object.assign({}, args), {\n          node: cell\n        }));\n      } else if (cell.isEdge()) {\n        this.notify('edge:removed', Object.assign(Object.assign({}, args), {\n          edge: cell\n        }));\n      }\n    });\n    collection.on('reseted', args => {\n      this.onReset(args.current);\n      this.notify('reseted', args);\n    });\n    collection.on('edge:change:source', ({\n      edge\n    }) => this.onEdgeTerminalChanged(edge, 'source'));\n    collection.on('edge:change:target', ({\n      edge\n    }) => {\n      this.onEdgeTerminalChanged(edge, 'target');\n    });\n  }\n  sortOnChangeZ() {\n    this.collection.sort();\n  }\n  onCellAdded(cell) {\n    const cellId = cell.id;\n    if (cell.isEdge()) {\n      // Auto update edge's parent\n      cell.updateParent();\n      this.edges[cellId] = true;\n      this.onEdgeTerminalChanged(cell, 'source');\n      this.onEdgeTerminalChanged(cell, 'target');\n    } else {\n      this.nodes[cellId] = true;\n    }\n  }\n  onCellRemoved(cell, options) {\n    const cellId = cell.id;\n    if (cell.isEdge()) {\n      delete this.edges[cellId];\n      const source = cell.getSource();\n      const target = cell.getTarget();\n      if (source && source.cell) {\n        const cache = this.outgoings[source.cell];\n        const index = cache ? cache.indexOf(cellId) : -1;\n        if (index >= 0) {\n          cache.splice(index, 1);\n          if (cache.length === 0) {\n            delete this.outgoings[source.cell];\n          }\n        }\n      }\n      if (target && target.cell) {\n        const cache = this.incomings[target.cell];\n        const index = cache ? cache.indexOf(cellId) : -1;\n        if (index >= 0) {\n          cache.splice(index, 1);\n          if (cache.length === 0) {\n            delete this.incomings[target.cell];\n          }\n        }\n      }\n    } else {\n      delete this.nodes[cellId];\n    }\n    if (!options.clear) {\n      if (options.disconnectEdges) {\n        this.disconnectConnectedEdges(cell, options);\n      } else {\n        this.removeConnectedEdges(cell, options);\n      }\n    }\n    if (cell.model === this) {\n      cell.model = null;\n    }\n  }\n  onReset(cells) {\n    this.nodes = {};\n    this.edges = {};\n    this.outgoings = {};\n    this.incomings = {};\n    cells.forEach(cell => this.onCellAdded(cell));\n  }\n  onEdgeTerminalChanged(edge, type) {\n    const ref = type === 'source' ? this.outgoings : this.incomings;\n    const prev = edge.previous(type);\n    if (prev && prev.cell) {\n      const cellId = Cell.isCell(prev.cell) ? prev.cell.id : prev.cell;\n      const cache = ref[cellId];\n      const index = cache ? cache.indexOf(edge.id) : -1;\n      if (index >= 0) {\n        cache.splice(index, 1);\n        if (cache.length === 0) {\n          delete ref[cellId];\n        }\n      }\n    }\n    const terminal = edge.getTerminal(type);\n    if (terminal && terminal.cell) {\n      const terminalId = Cell.isCell(terminal.cell) ? terminal.cell.id : terminal.cell;\n      const cache = ref[terminalId] || [];\n      const index = cache.indexOf(edge.id);\n      if (index === -1) {\n        cache.push(edge.id);\n      }\n      ref[terminalId] = cache;\n    }\n  }\n  prepareCell(cell, options) {\n    if (!cell.model && (!options || !options.dryrun)) {\n      cell.model = this;\n    }\n    if (cell.zIndex == null) {\n      cell.setZIndex(this.getMaxZIndex() + 1, {\n        silent: true\n      });\n    }\n    return cell;\n  }\n  resetCells(cells, options = {}) {\n    // Do not update model at this time. Because if we just update the graph\n    // with the same json-data, the edge will reference to the old nodes.\n    cells.map(cell => this.prepareCell(cell, Object.assign(Object.assign({}, options), {\n      dryrun: true\n    })));\n    this.collection.reset(cells, options);\n    // Update model and trigger edge update it's references\n    cells.map(cell => this.prepareCell(cell, {\n      options\n    }));\n    return this;\n  }\n  clear(options = {}) {\n    const raw = this.getCells();\n    if (raw.length === 0) {\n      return this;\n    }\n    const localOptions = Object.assign(Object.assign({}, options), {\n      clear: true\n    });\n    this.batchUpdate('clear', () => {\n      // The nodes come after the edges.\n      const cells = raw.sort((a, b) => {\n        const v1 = a.isEdge() ? 1 : 2;\n        const v2 = b.isEdge() ? 1 : 2;\n        return v1 - v2;\n      });\n      while (cells.length > 0) {\n        // Note that all the edges are removed first, so it's safe to\n        // remove the nodes without removing the connected edges first.\n        const cell = cells.shift();\n        if (cell) {\n          cell.remove(localOptions);\n        }\n      }\n    }, localOptions);\n    return this;\n  }\n  addNode(metadata, options = {}) {\n    const node = Node.isNode(metadata) ? metadata : this.createNode(metadata);\n    this.addCell(node, options);\n    return node;\n  }\n  updateNode(metadata, options = {}) {\n    const node = this.createNode(metadata);\n    const prop = node.getProp();\n    node.dispose();\n    return this.updateCell(prop, options);\n  }\n  createNode(metadata) {\n    return Node.create(metadata);\n  }\n  addEdge(metadata, options = {}) {\n    const edge = Edge.isEdge(metadata) ? metadata : this.createEdge(metadata);\n    this.addCell(edge, options);\n    return edge;\n  }\n  createEdge(metadata) {\n    return Edge.create(metadata);\n  }\n  updateEdge(metadata, options = {}) {\n    const edge = this.createEdge(metadata);\n    const prop = edge.getProp();\n    edge.dispose();\n    return this.updateCell(prop, options);\n  }\n  addCell(cell, options = {}) {\n    if (Array.isArray(cell)) {\n      return this.addCells(cell, options);\n    }\n    if (!this.collection.has(cell) && !this.addings.has(cell)) {\n      this.addings.set(cell, true);\n      this.collection.add(this.prepareCell(cell, options), options);\n      cell.eachChild(child => this.addCell(child, options));\n      this.addings.delete(cell);\n    }\n    return this;\n  }\n  addCells(cells, options = {}) {\n    const count = cells.length;\n    if (count === 0) {\n      return this;\n    }\n    const localOptions = Object.assign(Object.assign({}, options), {\n      position: count - 1,\n      maxPosition: count - 1\n    });\n    this.startBatch('add', Object.assign(Object.assign({}, localOptions), {\n      cells\n    }));\n    cells.forEach(cell => {\n      this.addCell(cell, localOptions);\n      localOptions.position -= 1;\n    });\n    this.stopBatch('add', Object.assign(Object.assign({}, localOptions), {\n      cells\n    }));\n    return this;\n  }\n  updateCell(prop, options = {}) {\n    const existing = prop.id && this.getCell(prop.id);\n    if (existing) {\n      return this.batchUpdate('update', () => {\n        Object.entries(prop).forEach(([key, val]) => existing.setProp(key, val, options));\n        return true;\n      }, prop);\n    }\n    return false;\n  }\n  removeCell(obj, options = {}) {\n    const cell = typeof obj === 'string' ? this.getCell(obj) : obj;\n    if (cell && this.has(cell)) {\n      return this.collection.remove(cell, options);\n    }\n    return null;\n  }\n  updateCellId(cell, newId) {\n    if (cell.id === newId) return;\n    this.startBatch('update', {\n      id: newId\n    });\n    cell.prop('id', newId);\n    const newCell = cell.clone({\n      keepId: true\n    });\n    this.addCell(newCell);\n    // update connected edge terminal\n    const edges = this.getConnectedEdges(cell);\n    edges.forEach(edge => {\n      const sourceCell = edge.getSourceCell();\n      const targetCell = edge.getTargetCell();\n      if (sourceCell === cell) {\n        edge.setSource(Object.assign(Object.assign({}, edge.getSource()), {\n          cell: newId\n        }));\n      }\n      if (targetCell === cell) {\n        edge.setTarget(Object.assign(Object.assign({}, edge.getTarget()), {\n          cell: newId\n        }));\n      }\n    });\n    this.removeCell(cell);\n    this.stopBatch('update', {\n      id: newId\n    });\n    return newCell;\n  }\n  removeCells(cells, options = {}) {\n    if (cells.length) {\n      return this.batchUpdate('remove', () => {\n        return cells.map(cell => this.removeCell(cell, options));\n      });\n    }\n    return [];\n  }\n  removeConnectedEdges(cell, options = {}) {\n    const edges = this.getConnectedEdges(cell);\n    edges.forEach(edge => {\n      edge.remove(options);\n    });\n    return edges;\n  }\n  disconnectConnectedEdges(cell, options = {}) {\n    const cellId = typeof cell === 'string' ? cell : cell.id;\n    this.getConnectedEdges(cell).forEach(edge => {\n      const sourceCellId = edge.getSourceCellId();\n      const targetCellId = edge.getTargetCellId();\n      if (sourceCellId === cellId) {\n        edge.setSource({\n          x: 0,\n          y: 0\n        }, options);\n      }\n      if (targetCellId === cellId) {\n        edge.setTarget({\n          x: 0,\n          y: 0\n        }, options);\n      }\n    });\n  }\n  has(obj) {\n    return this.collection.has(obj);\n  }\n  total() {\n    return this.collection.length;\n  }\n  indexOf(cell) {\n    return this.collection.indexOf(cell);\n  }\n  /**\n   * Returns a cell from the graph by its id.\n   */\n  getCell(id) {\n    return this.collection.get(id);\n  }\n  /**\n   * Returns all the nodes and edges in the graph.\n   */\n  getCells() {\n    return this.collection.toArray();\n  }\n  /**\n   * Returns the first cell (node or edge) in the graph. The first cell is\n   * defined as the cell with the lowest `zIndex`.\n   */\n  getFirstCell() {\n    return this.collection.first();\n  }\n  /**\n   * Returns the last cell (node or edge) in the graph. The last cell is\n   * defined as the cell with the highest `zIndex`.\n   */\n  getLastCell() {\n    return this.collection.last();\n  }\n  /**\n   * Returns the lowest `zIndex` value in the graph.\n   */\n  getMinZIndex() {\n    const first = this.collection.first();\n    return first ? first.getZIndex() || 0 : 0;\n  }\n  /**\n   * Returns the highest `zIndex` value in the graph.\n   */\n  getMaxZIndex() {\n    const last = this.collection.last();\n    return last ? last.getZIndex() || 0 : 0;\n  }\n  getCellsFromCache(cache) {\n    return cache ? Object.keys(cache).map(id => this.getCell(id)).filter(cell => cell != null) : [];\n  }\n  /**\n   * Returns all the nodes in the graph.\n   */\n  getNodes() {\n    return this.getCellsFromCache(this.nodes);\n  }\n  /**\n   * Returns all the edges in the graph.\n   */\n  getEdges() {\n    return this.getCellsFromCache(this.edges);\n  }\n  /**\n   * Returns all outgoing edges for the node.\n   */\n  getOutgoingEdges(cell) {\n    const cellId = typeof cell === 'string' ? cell : cell.id;\n    const cellIds = this.outgoings[cellId];\n    return cellIds ? cellIds.map(id => this.getCell(id)).filter(cell => cell && cell.isEdge()) : null;\n  }\n  /**\n   * Returns all incoming edges for the node.\n   */\n  getIncomingEdges(cell) {\n    const cellId = typeof cell === 'string' ? cell : cell.id;\n    const cellIds = this.incomings[cellId];\n    return cellIds ? cellIds.map(id => this.getCell(id)).filter(cell => cell && cell.isEdge()) : null;\n  }\n  /**\n   * Returns edges connected with cell.\n   */\n  getConnectedEdges(cell, options = {}) {\n    const result = [];\n    const node = typeof cell === 'string' ? this.getCell(cell) : cell;\n    if (node == null) {\n      return result;\n    }\n    const cache = {};\n    const indirect = options.indirect;\n    let incoming = options.incoming;\n    let outgoing = options.outgoing;\n    if (incoming == null && outgoing == null) {\n      incoming = outgoing = true;\n    }\n    const collect = (cell, isOutgoing) => {\n      const edges = isOutgoing ? this.getOutgoingEdges(cell) : this.getIncomingEdges(cell);\n      if (edges != null) {\n        edges.forEach(edge => {\n          if (cache[edge.id]) {\n            return;\n          }\n          result.push(edge);\n          cache[edge.id] = true;\n          if (indirect) {\n            if (incoming) {\n              collect(edge, false);\n            }\n            if (outgoing) {\n              collect(edge, true);\n            }\n          }\n        });\n      }\n      if (indirect && cell.isEdge()) {\n        const terminal = isOutgoing ? cell.getTargetCell() : cell.getSourceCell();\n        if (terminal && terminal.isEdge()) {\n          if (!cache[terminal.id]) {\n            result.push(terminal);\n            collect(terminal, isOutgoing);\n          }\n        }\n      }\n    };\n    if (outgoing) {\n      collect(node, true);\n    }\n    if (incoming) {\n      collect(node, false);\n    }\n    if (options.deep) {\n      const descendants = node.getDescendants({\n        deep: true\n      });\n      const embedsCache = {};\n      descendants.forEach(cell => {\n        if (cell.isNode()) {\n          embedsCache[cell.id] = true;\n        }\n      });\n      const collectSub = (cell, isOutgoing) => {\n        const edges = isOutgoing ? this.getOutgoingEdges(cell.id) : this.getIncomingEdges(cell.id);\n        if (edges != null) {\n          edges.forEach(edge => {\n            if (!cache[edge.id]) {\n              const sourceCell = edge.getSourceCell();\n              const targetCell = edge.getTargetCell();\n              if (!options.enclosed && sourceCell && embedsCache[sourceCell.id] && targetCell && embedsCache[targetCell.id]) {\n                return;\n              }\n              result.push(edge);\n              cache[edge.id] = true;\n            }\n          });\n        }\n      };\n      descendants.forEach(cell => {\n        if (cell.isEdge()) {\n          return;\n        }\n        if (outgoing) {\n          collectSub(cell, true);\n        }\n        if (incoming) {\n          collectSub(cell, false);\n        }\n      });\n    }\n    return result;\n  }\n  isBoundary(cell, isOrigin) {\n    const node = typeof cell === 'string' ? this.getCell(cell) : cell;\n    const arr = isOrigin ? this.getIncomingEdges(node) : this.getOutgoingEdges(node);\n    return arr == null || arr.length === 0;\n  }\n  getBoundaryNodes(isOrigin) {\n    const result = [];\n    Object.keys(this.nodes).forEach(nodeId => {\n      if (this.isBoundary(nodeId, isOrigin)) {\n        const node = this.getCell(nodeId);\n        if (node) {\n          result.push(node);\n        }\n      }\n    });\n    return result;\n  }\n  /**\n   * Returns an array of all the roots of the graph.\n   */\n  getRoots() {\n    return this.getBoundaryNodes(true);\n  }\n  /**\n   * Returns an array of all the leafs of the graph.\n   */\n  getLeafs() {\n    return this.getBoundaryNodes(false);\n  }\n  /**\n   * Returns `true` if the node is a root node, i.e. there is no edges\n   * coming to the node.\n   */\n  isRoot(cell) {\n    return this.isBoundary(cell, true);\n  }\n  /**\n   * Returns `true` if the node is a leaf node, i.e. there is no edges\n   * going out from the node.\n   */\n  isLeaf(cell) {\n    return this.isBoundary(cell, false);\n  }\n  /**\n   * Returns all the neighbors of node in the graph. Neighbors are all\n   * the nodes connected to node via either incoming or outgoing edge.\n   */\n  getNeighbors(cell, options = {}) {\n    let incoming = options.incoming;\n    let outgoing = options.outgoing;\n    if (incoming == null && outgoing == null) {\n      incoming = outgoing = true;\n    }\n    const edges = this.getConnectedEdges(cell, options);\n    const map = edges.reduce((memo, edge) => {\n      const hasLoop = edge.hasLoop(options);\n      const sourceCell = edge.getSourceCell();\n      const targetCell = edge.getTargetCell();\n      if (incoming && sourceCell && sourceCell.isNode() && !memo[sourceCell.id]) {\n        if (hasLoop || sourceCell !== cell && (!options.deep || !sourceCell.isDescendantOf(cell))) {\n          memo[sourceCell.id] = sourceCell;\n        }\n      }\n      if (outgoing && targetCell && targetCell.isNode() && !memo[targetCell.id]) {\n        if (hasLoop || targetCell !== cell && (!options.deep || !targetCell.isDescendantOf(cell))) {\n          memo[targetCell.id] = targetCell;\n        }\n      }\n      return memo;\n    }, {});\n    if (cell.isEdge()) {\n      if (incoming) {\n        const sourceCell = cell.getSourceCell();\n        if (sourceCell && sourceCell.isNode() && !map[sourceCell.id]) {\n          map[sourceCell.id] = sourceCell;\n        }\n      }\n      if (outgoing) {\n        const targetCell = cell.getTargetCell();\n        if (targetCell && targetCell.isNode() && !map[targetCell.id]) {\n          map[targetCell.id] = targetCell;\n        }\n      }\n    }\n    return Object.keys(map).map(id => map[id]);\n  }\n  /**\n   * Returns `true` if `cell2` is a neighbor of `cell1`.\n   */\n  isNeighbor(cell1, cell2, options = {}) {\n    let incoming = options.incoming;\n    let outgoing = options.outgoing;\n    if (incoming == null && outgoing == null) {\n      incoming = outgoing = true;\n    }\n    return this.getConnectedEdges(cell1, options).some(edge => {\n      const sourceCell = edge.getSourceCell();\n      const targetCell = edge.getTargetCell();\n      if (incoming && sourceCell && sourceCell.id === cell2.id) {\n        return true;\n      }\n      if (outgoing && targetCell && targetCell.id === cell2.id) {\n        return true;\n      }\n      return false;\n    });\n  }\n  getSuccessors(cell, options = {}) {\n    const successors = [];\n    this.search(cell, (curr, distance) => {\n      if (curr !== cell && this.matchDistance(distance, options.distance)) {\n        successors.push(curr);\n      }\n    }, Object.assign(Object.assign({}, options), {\n      outgoing: true\n    }));\n    return successors;\n  }\n  /**\n   * Returns `true` if `cell2` is a successor of `cell1`.\n   */\n  isSuccessor(cell1, cell2, options = {}) {\n    let result = false;\n    this.search(cell1, (curr, distance) => {\n      if (curr === cell2 && curr !== cell1 && this.matchDistance(distance, options.distance)) {\n        result = true;\n        return false;\n      }\n    }, Object.assign(Object.assign({}, options), {\n      outgoing: true\n    }));\n    return result;\n  }\n  getPredecessors(cell, options = {}) {\n    const predecessors = [];\n    this.search(cell, (curr, distance) => {\n      if (curr !== cell && this.matchDistance(distance, options.distance)) {\n        predecessors.push(curr);\n      }\n    }, Object.assign(Object.assign({}, options), {\n      incoming: true\n    }));\n    return predecessors;\n  }\n  /**\n   * Returns `true` if `cell2` is a predecessor of `cell1`.\n   */\n  isPredecessor(cell1, cell2, options = {}) {\n    let result = false;\n    this.search(cell1, (curr, distance) => {\n      if (curr === cell2 && curr !== cell1 && this.matchDistance(distance, options.distance)) {\n        result = true;\n        return false;\n      }\n    }, Object.assign(Object.assign({}, options), {\n      incoming: true\n    }));\n    return result;\n  }\n  matchDistance(distance, preset) {\n    if (preset == null) {\n      return true;\n    }\n    if (typeof preset === 'function') {\n      return preset(distance);\n    }\n    if (Array.isArray(preset) && preset.includes(distance)) {\n      return true;\n    }\n    return distance === preset;\n  }\n  /**\n   * Returns the common ancestor of the passed cells.\n   */\n  getCommonAncestor(...cells) {\n    const arr = [];\n    cells.forEach(item => {\n      if (item) {\n        if (Array.isArray(item)) {\n          arr.push(...item);\n        } else {\n          arr.push(item);\n        }\n      }\n    });\n    return Cell.getCommonAncestor(...arr);\n  }\n  /**\n   * Returns an array of cells that result from finding nodes/edges that\n   * are connected to any of the cells in the cells array. This function\n   * loops over cells and if the current cell is a edge, it collects its\n   * source/target nodes; if it is an node, it collects its incoming and\n   * outgoing edges if both the edge terminal (source/target) are in the\n   * cells array.\n   */\n  getSubGraph(cells, options = {}) {\n    const subgraph = [];\n    const cache = {};\n    const nodes = [];\n    const edges = [];\n    const collect = cell => {\n      if (!cache[cell.id]) {\n        subgraph.push(cell);\n        cache[cell.id] = cell;\n        if (cell.isEdge()) {\n          edges.push(cell);\n        }\n        if (cell.isNode()) {\n          nodes.push(cell);\n        }\n      }\n    };\n    cells.forEach(cell => {\n      collect(cell);\n      if (options.deep) {\n        const descendants = cell.getDescendants({\n          deep: true\n        });\n        descendants.forEach(descendant => collect(descendant));\n      }\n    });\n    edges.forEach(edge => {\n      // For edges, include their source & target\n      const sourceCell = edge.getSourceCell();\n      const targetCell = edge.getTargetCell();\n      if (sourceCell && !cache[sourceCell.id]) {\n        subgraph.push(sourceCell);\n        cache[sourceCell.id] = sourceCell;\n        if (sourceCell.isNode()) {\n          nodes.push(sourceCell);\n        }\n      }\n      if (targetCell && !cache[targetCell.id]) {\n        subgraph.push(targetCell);\n        cache[targetCell.id] = targetCell;\n        if (targetCell.isNode()) {\n          nodes.push(targetCell);\n        }\n      }\n    });\n    nodes.forEach(node => {\n      // For nodes, include their connected edges if their source/target\n      // is in the subgraph.\n      const edges = this.getConnectedEdges(node, options);\n      edges.forEach(edge => {\n        const sourceCell = edge.getSourceCell();\n        const targetCell = edge.getTargetCell();\n        if (!cache[edge.id] && sourceCell && cache[sourceCell.id] && targetCell && cache[targetCell.id]) {\n          subgraph.push(edge);\n          cache[edge.id] = edge;\n        }\n      });\n    });\n    return subgraph;\n  }\n  /**\n   * Clones the whole subgraph (including all the connected links whose\n   * source/target is in the subgraph). If `options.deep` is `true`, also\n   * take into account all the embedded cells of all the subgraph cells.\n   *\n   * Returns a map of the form: { [original cell ID]: [clone] }.\n   */\n  cloneSubGraph(cells, options = {}) {\n    const subgraph = this.getSubGraph(cells, options);\n    return this.cloneCells(subgraph);\n  }\n  cloneCells(cells) {\n    return Cell.cloneCells(cells);\n  }\n  getNodesFromPoint(x, y) {\n    const p = typeof x === 'number' ? {\n      x,\n      y: y || 0\n    } : x;\n    return this.getNodes().filter(node => {\n      return node.getBBox().containsPoint(p);\n    });\n  }\n  getNodesInArea(x, y, w, h, options) {\n    const rect = typeof x === 'number' ? new Rectangle(x, y, w, h) : Rectangle.create(x);\n    const opts = typeof x === 'number' ? options : y;\n    const strict = opts && opts.strict;\n    return this.getNodes().filter(node => {\n      const bbox = node.getBBox();\n      return strict ? rect.containsRect(bbox) : rect.isIntersectWithRect(bbox);\n    });\n  }\n  getEdgesInArea(x, y, w, h, options) {\n    const rect = typeof x === 'number' ? new Rectangle(x, y, w, h) : Rectangle.create(x);\n    const opts = typeof x === 'number' ? options : y;\n    const strict = opts && opts.strict;\n    return this.getEdges().filter(edge => {\n      const bbox = edge.getBBox();\n      if (bbox.width === 0) {\n        bbox.inflate(1, 0);\n      } else if (bbox.height === 0) {\n        bbox.inflate(0, 1);\n      }\n      return strict ? rect.containsRect(bbox) : rect.isIntersectWithRect(bbox);\n    });\n  }\n  getNodesUnderNode(node, options = {}) {\n    const bbox = node.getBBox();\n    const nodes = options.by == null || options.by === 'bbox' ? this.getNodesInArea(bbox) : this.getNodesFromPoint(bbox[options.by]);\n    return nodes.filter(curr => node.id !== curr.id && !curr.isDescendantOf(node));\n  }\n  /**\n   * Returns the bounding box that surrounds all cells in the graph.\n   */\n  getAllCellsBBox() {\n    return this.getCellsBBox(this.getCells());\n  }\n  /**\n   * Returns the bounding box that surrounds all the given cells.\n   */\n  getCellsBBox(cells, options = {}) {\n    return Cell.getCellsBBox(cells, options);\n  }\n  // #region search\n  search(cell, iterator, options = {}) {\n    if (options.breadthFirst) {\n      this.breadthFirstSearch(cell, iterator, options);\n    } else {\n      this.depthFirstSearch(cell, iterator, options);\n    }\n  }\n  breadthFirstSearch(cell, iterator, options = {}) {\n    const queue = [];\n    const visited = {};\n    const distance = {};\n    queue.push(cell);\n    distance[cell.id] = 0;\n    while (queue.length > 0) {\n      const next = queue.shift();\n      if (next == null || visited[next.id]) {\n        continue;\n      }\n      visited[next.id] = true;\n      if (FunctionExt.call(iterator, this, next, distance[next.id]) === false) {\n        continue;\n      }\n      const neighbors = this.getNeighbors(next, options);\n      neighbors.forEach(neighbor => {\n        distance[neighbor.id] = distance[next.id] + 1;\n        queue.push(neighbor);\n      });\n    }\n  }\n  depthFirstSearch(cell, iterator, options = {}) {\n    const queue = [];\n    const visited = {};\n    const distance = {};\n    queue.push(cell);\n    distance[cell.id] = 0;\n    while (queue.length > 0) {\n      const next = queue.pop();\n      if (next == null || visited[next.id]) {\n        continue;\n      }\n      visited[next.id] = true;\n      if (FunctionExt.call(iterator, this, next, distance[next.id]) === false) {\n        continue;\n      }\n      const neighbors = this.getNeighbors(next, options);\n      const lastIndex = queue.length;\n      neighbors.forEach(neighbor => {\n        distance[neighbor.id] = distance[next.id] + 1;\n        queue.splice(lastIndex, 0, neighbor);\n      });\n    }\n  }\n  // #endregion\n  // #region shortest path\n  /** *\n   * Returns an array of IDs of nodes on the shortest\n   * path between source and target.\n   */\n  getShortestPath(source, target, options = {}) {\n    const adjacencyList = {};\n    this.getEdges().forEach(edge => {\n      const sourceId = edge.getSourceCellId();\n      const targetId = edge.getTargetCellId();\n      if (sourceId && targetId) {\n        if (!adjacencyList[sourceId]) {\n          adjacencyList[sourceId] = [];\n        }\n        if (!adjacencyList[targetId]) {\n          adjacencyList[targetId] = [];\n        }\n        adjacencyList[sourceId].push(targetId);\n        if (!options.directed) {\n          adjacencyList[targetId].push(sourceId);\n        }\n      }\n    });\n    const sourceId = typeof source === 'string' ? source : source.id;\n    const previous = Dijkstra.run(adjacencyList, sourceId, options.weight);\n    const path = [];\n    let targetId = typeof target === 'string' ? target : target.id;\n    if (previous[targetId]) {\n      path.push(targetId);\n    }\n    while (targetId = previous[targetId]) {\n      path.unshift(targetId);\n    }\n    return path;\n  }\n  // #endregion\n  // #region transform\n  /**\n   * Translate all cells in the graph by `tx` and `ty` pixels.\n   */\n  translate(tx, ty, options) {\n    this.getCells().filter(cell => !cell.hasParent()).forEach(cell => cell.translate(tx, ty, options));\n    return this;\n  }\n  resize(width, height, options) {\n    return this.resizeCells(width, height, this.getCells(), options);\n  }\n  resizeCells(width, height, cells, options = {}) {\n    const bbox = this.getCellsBBox(cells);\n    if (bbox) {\n      const sx = Math.max(width / bbox.width, 0);\n      const sy = Math.max(height / bbox.height, 0);\n      const origin = bbox.getOrigin();\n      cells.forEach(cell => cell.scale(sx, sy, origin, options));\n    }\n    return this;\n  }\n  // #endregion\n  // #region serialize/deserialize\n  toJSON(options = {}) {\n    return Model.toJSON(this.getCells(), options);\n  }\n  parseJSON(data) {\n    return Model.fromJSON(data);\n  }\n  fromJSON(data, options = {}) {\n    const cells = this.parseJSON(data);\n    this.resetCells(cells, options);\n    return this;\n  }\n  // #endregion\n  // #region batch\n  startBatch(name, data = {}) {\n    this.batches[name] = (this.batches[name] || 0) + 1;\n    this.notify('batch:start', {\n      name,\n      data\n    });\n    return this;\n  }\n  stopBatch(name, data = {}) {\n    this.batches[name] = (this.batches[name] || 0) - 1;\n    this.notify('batch:stop', {\n      name,\n      data\n    });\n    return this;\n  }\n  batchUpdate(name, execute, data = {}) {\n    this.startBatch(name, data);\n    const result = execute();\n    this.stopBatch(name, data);\n    return result;\n  }\n  hasActiveBatch(name = Object.keys(this.batches)) {\n    const names = Array.isArray(name) ? name : [name];\n    return names.some(batch => this.batches[batch] > 0);\n  }\n  // #endregion\n  dispose() {\n    this.collection.dispose();\n  }\n}\n__decorate([Model.dispose()], Model.prototype, \"dispose\", null);\n(function (Model) {\n  Model.toStringTag = `X6.${Model.name}`;\n  function isModel(instance) {\n    if (instance == null) {\n      return false;\n    }\n    if (instance instanceof Model) {\n      return true;\n    }\n    const tag = instance[Symbol.toStringTag];\n    const model = instance;\n    if ((tag == null || tag === Model.toStringTag) && typeof model.addNode === 'function' && typeof model.addEdge === 'function' && model.collection != null) {\n      return true;\n    }\n    return false;\n  }\n  Model.isModel = isModel;\n})(Model || (Model = {}));\n(function (Model) {\n  function toJSON(cells, options = {}) {\n    return {\n      cells: cells.map(cell => cell.toJSON(options))\n    };\n  }\n  Model.toJSON = toJSON;\n  function fromJSON(data) {\n    const cells = [];\n    if (Array.isArray(data)) {\n      cells.push(...data);\n    } else {\n      if (data.cells) {\n        cells.push(...data.cells);\n      }\n      if (data.nodes) {\n        data.nodes.forEach(node => {\n          if (node.shape == null) {\n            node.shape = 'rect';\n          }\n          cells.push(node);\n        });\n      }\n      if (data.edges) {\n        data.edges.forEach(edge => {\n          if (edge.shape == null) {\n            edge.shape = 'edge';\n          }\n          cells.push(edge);\n        });\n      }\n    }\n    return cells.map(cell => {\n      const type = cell.shape;\n      if (type) {\n        if (Node.registry.exist(type)) {\n          return Node.create(cell);\n        }\n        if (Edge.registry.exist(type)) {\n          return Edge.create(cell);\n        }\n      }\n      throw new Error('The `shape` should be specified when creating a node/edge instance');\n    });\n  }\n  Model.fromJSON = fromJSON;\n})(Model || (Model = {}));","map":{"version":3,"names":["FunctionExt","Dijkstra","Basecoat","Rectangle","Cell","Edge","Node","Collection","Model","Symbol","toStringTag","constructor","cells","batches","addings","WeakMap","nodes","edges","outgoings","incomings","collection","setup","notify","name","args","trigger","graph","on","sortOnChangeZ","cell","onCellAdded","onCellRemoved","options","isNode","Object","assign","node","isEdge","edge","onReset","current","onEdgeTerminalChanged","sort","cellId","id","updateParent","source","getSource","target","getTarget","cache","index","indexOf","splice","length","clear","disconnectEdges","disconnectConnectedEdges","removeConnectedEdges","model","forEach","type","ref","prev","previous","isCell","terminal","getTerminal","terminalId","push","prepareCell","dryrun","zIndex","setZIndex","getMaxZIndex","silent","resetCells","map","reset","raw","getCells","localOptions","batchUpdate","a","b","v1","v2","shift","remove","addNode","metadata","createNode","addCell","updateNode","prop","getProp","dispose","updateCell","create","addEdge","createEdge","updateEdge","Array","isArray","addCells","has","set","add","eachChild","child","delete","count","position","maxPosition","startBatch","stopBatch","existing","getCell","entries","key","val","setProp","removeCell","obj","updateCellId","newId","newCell","clone","keepId","getConnectedEdges","sourceCell","getSourceCell","targetCell","getTargetCell","setSource","setTarget","removeCells","sourceCellId","getSourceCellId","targetCellId","getTargetCellId","x","y","total","get","toArray","getFirstCell","first","getLastCell","last","getMinZIndex","getZIndex","getCellsFromCache","keys","filter","getNodes","getEdges","getOutgoingEdges","cellIds","getIncomingEdges","result","indirect","incoming","outgoing","collect","isOutgoing","deep","descendants","getDescendants","embedsCache","collectSub","enclosed","isBoundary","isOrigin","arr","getBoundaryNodes","nodeId","getRoots","getLeafs","isRoot","isLeaf","getNeighbors","reduce","memo","hasLoop","isDescendantOf","isNeighbor","cell1","cell2","some","getSuccessors","successors","search","curr","distance","matchDistance","isSuccessor","getPredecessors","predecessors","isPredecessor","preset","includes","getCommonAncestor","item","getSubGraph","subgraph","descendant","cloneSubGraph","cloneCells","getNodesFromPoint","p","getBBox","containsPoint","getNodesInArea","w","h","rect","opts","strict","bbox","containsRect","isIntersectWithRect","getEdgesInArea","width","inflate","height","getNodesUnderNode","by","getAllCellsBBox","getCellsBBox","iterator","breadthFirst","breadthFirstSearch","depthFirstSearch","queue","visited","next","call","neighbors","neighbor","pop","lastIndex","getShortestPath","adjacencyList","sourceId","targetId","directed","run","weight","path","unshift","translate","tx","ty","hasParent","resize","resizeCells","sx","Math","max","sy","origin","getOrigin","scale","toJSON","parseJSON","data","fromJSON","execute","hasActiveBatch","names","batch","__decorate","isModel","instance","tag","shape","registry","exist","Error"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/src/model/model.ts"],"sourcesContent":["import { FunctionExt, Dijkstra, KeyValue, Basecoat } from '@antv/x6-common'\nimport { Point, Rectangle } from '@antv/x6-geometry'\nimport { Cell } from './cell'\nimport { Edge } from './edge'\nimport { Node } from './node'\nimport { Collection } from './collection'\nimport { Graph } from '../graph'\n\nexport class Model extends Basecoat<Model.EventArgs> {\n  public readonly collection: Collection\n  protected readonly batches: KeyValue<number> = {}\n  protected readonly addings: WeakMap<Cell, boolean> = new WeakMap()\n  public graph: Graph\n  protected nodes: KeyValue<boolean> = {}\n  protected edges: KeyValue<boolean> = {}\n  protected outgoings: KeyValue<string[]> = {}\n  protected incomings: KeyValue<string[]> = {}\n\n  protected get [Symbol.toStringTag]() {\n    return Model.toStringTag\n  }\n\n  constructor(cells: Cell[] = []) {\n    super()\n    this.collection = new Collection(cells)\n    this.setup()\n  }\n\n  notify<Key extends keyof Model.EventArgs>(\n    name: Key,\n    args: Model.EventArgs[Key],\n  ): this\n  notify(name: Exclude<string, keyof Model.EventArgs>, args: any): this\n  notify<Key extends keyof Model.EventArgs>(\n    name: Key,\n    args: Model.EventArgs[Key],\n  ) {\n    this.trigger(name, args)\n    const graph = this.graph\n    if (graph) {\n      if (name === 'sorted' || name === 'reseted' || name === 'updated') {\n        graph.trigger(`model:${name}`, args)\n      } else {\n        graph.trigger(name, args)\n      }\n    }\n    return this\n  }\n\n  protected setup() {\n    const collection = this.collection\n\n    collection.on('sorted', () => this.notify('sorted', null))\n    collection.on('updated', (args) => this.notify('updated', args))\n    collection.on('cell:change:zIndex', () => this.sortOnChangeZ())\n\n    collection.on('added', ({ cell }) => {\n      this.onCellAdded(cell)\n    })\n\n    collection.on('removed', (args) => {\n      const cell = args.cell\n      this.onCellRemoved(cell, args.options)\n\n      // Should trigger remove-event manually after cell was removed.\n      this.notify('cell:removed', args)\n      if (cell.isNode()) {\n        this.notify('node:removed', { ...args, node: cell })\n      } else if (cell.isEdge()) {\n        this.notify('edge:removed', { ...args, edge: cell })\n      }\n    })\n\n    collection.on('reseted', (args) => {\n      this.onReset(args.current)\n      this.notify('reseted', args)\n    })\n\n    collection.on('edge:change:source', ({ edge }) =>\n      this.onEdgeTerminalChanged(edge, 'source'),\n    )\n\n    collection.on('edge:change:target', ({ edge }) => {\n      this.onEdgeTerminalChanged(edge, 'target')\n    })\n  }\n\n  protected sortOnChangeZ() {\n    this.collection.sort()\n  }\n\n  protected onCellAdded(cell: Cell) {\n    const cellId = cell.id\n    if (cell.isEdge()) {\n      // Auto update edge's parent\n      cell.updateParent()\n      this.edges[cellId] = true\n      this.onEdgeTerminalChanged(cell, 'source')\n      this.onEdgeTerminalChanged(cell, 'target')\n    } else {\n      this.nodes[cellId] = true\n    }\n  }\n\n  protected onCellRemoved(cell: Cell, options: Collection.RemoveOptions) {\n    const cellId = cell.id\n    if (cell.isEdge()) {\n      delete this.edges[cellId]\n\n      const source = cell.getSource() as Edge.TerminalCellData\n      const target = cell.getTarget() as Edge.TerminalCellData\n      if (source && source.cell) {\n        const cache = this.outgoings[source.cell]\n        const index = cache ? cache.indexOf(cellId) : -1\n        if (index >= 0) {\n          cache.splice(index, 1)\n          if (cache.length === 0) {\n            delete this.outgoings[source.cell]\n          }\n        }\n      }\n\n      if (target && target.cell) {\n        const cache = this.incomings[target.cell]\n        const index = cache ? cache.indexOf(cellId) : -1\n        if (index >= 0) {\n          cache.splice(index, 1)\n          if (cache.length === 0) {\n            delete this.incomings[target.cell]\n          }\n        }\n      }\n    } else {\n      delete this.nodes[cellId]\n    }\n\n    if (!options.clear) {\n      if (options.disconnectEdges) {\n        this.disconnectConnectedEdges(cell, options)\n      } else {\n        this.removeConnectedEdges(cell, options)\n      }\n    }\n\n    if (cell.model === this) {\n      cell.model = null\n    }\n  }\n\n  protected onReset(cells: Cell[]) {\n    this.nodes = {}\n    this.edges = {}\n    this.outgoings = {}\n    this.incomings = {}\n    cells.forEach((cell) => this.onCellAdded(cell))\n  }\n\n  protected onEdgeTerminalChanged(edge: Edge, type: Edge.TerminalType) {\n    const ref = type === 'source' ? this.outgoings : this.incomings\n    const prev = edge.previous<Edge.TerminalCellLooseData>(type)\n\n    if (prev && prev.cell) {\n      const cellId = Cell.isCell(prev.cell) ? prev.cell.id : prev.cell\n      const cache = ref[cellId]\n      const index = cache ? cache.indexOf(edge.id) : -1\n      if (index >= 0) {\n        cache.splice(index, 1)\n        if (cache.length === 0) {\n          delete ref[cellId]\n        }\n      }\n    }\n\n    const terminal = edge.getTerminal(type) as Edge.TerminalCellLooseData\n    if (terminal && terminal.cell) {\n      const terminalId = Cell.isCell(terminal.cell)\n        ? terminal.cell.id\n        : terminal.cell\n      const cache = ref[terminalId] || []\n      const index = cache.indexOf(edge.id)\n      if (index === -1) {\n        cache.push(edge.id)\n      }\n      ref[terminalId] = cache\n    }\n  }\n\n  protected prepareCell(cell: Cell, options: Collection.AddOptions) {\n    if (!cell.model && (!options || !options.dryrun)) {\n      cell.model = this\n    }\n\n    if (cell.zIndex == null) {\n      cell.setZIndex(this.getMaxZIndex() + 1, { silent: true })\n    }\n\n    return cell\n  }\n\n  resetCells(cells: Cell[], options: Collection.SetOptions = {}) {\n    // Do not update model at this time. Because if we just update the graph\n    // with the same json-data, the edge will reference to the old nodes.\n    cells.map((cell) => this.prepareCell(cell, { ...options, dryrun: true }))\n    this.collection.reset(cells, options)\n    // Update model and trigger edge update it's references\n    cells.map((cell) => this.prepareCell(cell, { options }))\n    return this\n  }\n\n  clear(options: Cell.SetOptions = {}) {\n    const raw = this.getCells()\n    if (raw.length === 0) {\n      return this\n    }\n    const localOptions = { ...options, clear: true }\n    this.batchUpdate(\n      'clear',\n      () => {\n        // The nodes come after the edges.\n        const cells = raw.sort((a, b) => {\n          const v1 = a.isEdge() ? 1 : 2\n          const v2 = b.isEdge() ? 1 : 2\n          return v1 - v2\n        })\n\n        while (cells.length > 0) {\n          // Note that all the edges are removed first, so it's safe to\n          // remove the nodes without removing the connected edges first.\n          const cell = cells.shift()\n          if (cell) {\n            cell.remove(localOptions)\n          }\n        }\n      },\n      localOptions,\n    )\n\n    return this\n  }\n\n  addNode(metadata: Node | Node.Metadata, options: Model.AddOptions = {}) {\n    const node = Node.isNode(metadata) ? metadata : this.createNode(metadata)\n    this.addCell(node, options)\n    return node\n  }\n\n  updateNode(metadata: Node.Metadata, options: Model.SetOptions = {}) {\n    const node = this.createNode(metadata)\n    const prop = node.getProp()\n    node.dispose()\n    return this.updateCell(prop, options)\n  }\n\n  createNode(metadata: Node.Metadata) {\n    return Node.create(metadata)\n  }\n\n  addEdge(metadata: Edge.Metadata | Edge, options: Model.AddOptions = {}) {\n    const edge = Edge.isEdge(metadata) ? metadata : this.createEdge(metadata)\n    this.addCell(edge, options)\n    return edge\n  }\n\n  createEdge(metadata: Edge.Metadata) {\n    return Edge.create(metadata)\n  }\n\n  updateEdge(metadata: Edge.Metadata, options: Model.SetOptions = {}) {\n    const edge = this.createEdge(metadata)\n    const prop = edge.getProp()\n    edge.dispose()\n    return this.updateCell(prop, options)\n  }\n\n  addCell(cell: Cell | Cell[], options: Model.AddOptions = {}) {\n    if (Array.isArray(cell)) {\n      return this.addCells(cell, options)\n    }\n\n    if (!this.collection.has(cell) && !this.addings.has(cell)) {\n      this.addings.set(cell, true)\n      this.collection.add(this.prepareCell(cell, options), options)\n      cell.eachChild((child) => this.addCell(child, options))\n      this.addings.delete(cell)\n    }\n\n    return this\n  }\n\n  addCells(cells: Cell[], options: Model.AddOptions = {}) {\n    const count = cells.length\n    if (count === 0) {\n      return this\n    }\n\n    const localOptions = {\n      ...options,\n      position: count - 1,\n      maxPosition: count - 1,\n    }\n\n    this.startBatch('add', { ...localOptions, cells })\n    cells.forEach((cell) => {\n      this.addCell(cell, localOptions)\n      localOptions.position -= 1\n    })\n    this.stopBatch('add', { ...localOptions, cells })\n\n    return this\n  }\n\n  updateCell(prop: Cell.Properties, options: Model.SetOptions = {}): boolean {\n    const existing = prop.id && this.getCell(prop.id)\n    if (existing) {\n      return this.batchUpdate(\n        'update',\n        () => {\n          Object.entries(prop).forEach(([key, val]) =>\n            existing.setProp(key, val, options),\n          )\n          return true\n        },\n        prop,\n      )\n    }\n    return false\n  }\n\n  removeCell(cellId: string, options?: Collection.RemoveOptions): Cell | null\n  removeCell(cell: Cell, options?: Collection.RemoveOptions): Cell | null\n  removeCell(\n    obj: Cell | string,\n    options: Collection.RemoveOptions = {},\n  ): Cell | null {\n    const cell = typeof obj === 'string' ? this.getCell(obj) : obj\n    if (cell && this.has(cell)) {\n      return this.collection.remove(cell, options)\n    }\n    return null\n  }\n\n  updateCellId(cell: Cell, newId: string) {\n    if (cell.id === newId) return\n    this.startBatch('update', { id: newId })\n    cell.prop('id', newId)\n    const newCell = cell.clone({ keepId: true })\n    this.addCell(newCell)\n\n    // update connected edge terminal\n    const edges = this.getConnectedEdges(cell)\n    edges.forEach((edge) => {\n      const sourceCell = edge.getSourceCell()\n      const targetCell = edge.getTargetCell()\n      if (sourceCell === cell) {\n        edge.setSource({\n          ...edge.getSource(),\n          cell: newId,\n        })\n      }\n      if (targetCell === cell) {\n        edge.setTarget({\n          ...edge.getTarget(),\n          cell: newId,\n        })\n      }\n    })\n\n    this.removeCell(cell)\n    this.stopBatch('update', { id: newId })\n    return newCell\n  }\n\n  removeCells(cells: (Cell | string)[], options: Cell.RemoveOptions = {}) {\n    if (cells.length) {\n      return this.batchUpdate('remove', () => {\n        return cells.map((cell) => this.removeCell(cell as Cell, options))\n      })\n    }\n    return []\n  }\n\n  removeConnectedEdges(cell: Cell | string, options: Cell.RemoveOptions = {}) {\n    const edges = this.getConnectedEdges(cell)\n    edges.forEach((edge) => {\n      edge.remove(options)\n    })\n    return edges\n  }\n\n  disconnectConnectedEdges(cell: Cell | string, options: Edge.SetOptions = {}) {\n    const cellId = typeof cell === 'string' ? cell : cell.id\n    this.getConnectedEdges(cell).forEach((edge) => {\n      const sourceCellId = edge.getSourceCellId()\n      const targetCellId = edge.getTargetCellId()\n\n      if (sourceCellId === cellId) {\n        edge.setSource({ x: 0, y: 0 }, options)\n      }\n\n      if (targetCellId === cellId) {\n        edge.setTarget({ x: 0, y: 0 }, options)\n      }\n    })\n  }\n\n  has(id: string): boolean\n  has(cell: Cell): boolean\n  has(obj: string | Cell): boolean {\n    return this.collection.has(obj)\n  }\n\n  total() {\n    return this.collection.length\n  }\n\n  indexOf(cell: Cell) {\n    return this.collection.indexOf(cell)\n  }\n\n  /**\n   * Returns a cell from the graph by its id.\n   */\n  getCell<T extends Cell = Cell>(id: string) {\n    return this.collection.get(id) as T\n  }\n\n  /**\n   * Returns all the nodes and edges in the graph.\n   */\n  getCells() {\n    return this.collection.toArray()\n  }\n\n  /**\n   * Returns the first cell (node or edge) in the graph. The first cell is\n   * defined as the cell with the lowest `zIndex`.\n   */\n  getFirstCell() {\n    return this.collection.first()\n  }\n\n  /**\n   * Returns the last cell (node or edge) in the graph. The last cell is\n   * defined as the cell with the highest `zIndex`.\n   */\n  getLastCell() {\n    return this.collection.last()\n  }\n\n  /**\n   * Returns the lowest `zIndex` value in the graph.\n   */\n  getMinZIndex() {\n    const first = this.collection.first()\n    return first ? first.getZIndex() || 0 : 0\n  }\n\n  /**\n   * Returns the highest `zIndex` value in the graph.\n   */\n  getMaxZIndex() {\n    const last = this.collection.last()\n    return last ? last.getZIndex() || 0 : 0\n  }\n\n  protected getCellsFromCache<T extends Cell = Cell>(cache: {\n    [key: string]: boolean\n  }) {\n    return cache\n      ? Object.keys(cache)\n          .map((id) => this.getCell<T>(id))\n          .filter((cell) => cell != null)\n      : []\n  }\n\n  /**\n   * Returns all the nodes in the graph.\n   */\n  getNodes() {\n    return this.getCellsFromCache<Node>(this.nodes)\n  }\n\n  /**\n   * Returns all the edges in the graph.\n   */\n  getEdges() {\n    return this.getCellsFromCache<Edge>(this.edges)\n  }\n\n  /**\n   * Returns all outgoing edges for the node.\n   */\n  getOutgoingEdges(cell: Cell | string) {\n    const cellId = typeof cell === 'string' ? cell : cell.id\n    const cellIds = this.outgoings[cellId]\n    return cellIds\n      ? cellIds\n          .map((id) => this.getCell(id) as Edge)\n          .filter((cell) => cell && cell.isEdge())\n      : null\n  }\n\n  /**\n   * Returns all incoming edges for the node.\n   */\n  getIncomingEdges(cell: Cell | string) {\n    const cellId = typeof cell === 'string' ? cell : cell.id\n    const cellIds = this.incomings[cellId]\n    return cellIds\n      ? cellIds\n          .map((id) => this.getCell(id) as Edge)\n          .filter((cell) => cell && cell.isEdge())\n      : null\n  }\n\n  /**\n   * Returns edges connected with cell.\n   */\n  getConnectedEdges(\n    cell: Cell | string,\n    options: Model.GetConnectedEdgesOptions = {},\n  ) {\n    const result: Edge[] = []\n    const node = typeof cell === 'string' ? this.getCell(cell) : cell\n    if (node == null) {\n      return result\n    }\n\n    const cache: { [id: string]: boolean } = {}\n    const indirect = options.indirect\n    let incoming = options.incoming\n    let outgoing = options.outgoing\n    if (incoming == null && outgoing == null) {\n      incoming = outgoing = true\n    }\n\n    const collect = (cell: Cell, isOutgoing: boolean) => {\n      const edges = isOutgoing\n        ? this.getOutgoingEdges(cell)\n        : this.getIncomingEdges(cell)\n\n      if (edges != null) {\n        edges.forEach((edge) => {\n          if (cache[edge.id]) {\n            return\n          }\n\n          result.push(edge)\n          cache[edge.id] = true\n\n          if (indirect) {\n            if (incoming) {\n              collect(edge, false)\n            }\n\n            if (outgoing) {\n              collect(edge, true)\n            }\n          }\n        })\n      }\n\n      if (indirect && cell.isEdge()) {\n        const terminal = isOutgoing\n          ? cell.getTargetCell()\n          : cell.getSourceCell()\n        if (terminal && terminal.isEdge()) {\n          if (!cache[terminal.id]) {\n            result.push(terminal)\n            collect(terminal, isOutgoing)\n          }\n        }\n      }\n    }\n\n    if (outgoing) {\n      collect(node, true)\n    }\n\n    if (incoming) {\n      collect(node, false)\n    }\n\n    if (options.deep) {\n      const descendants = node.getDescendants({ deep: true })\n      const embedsCache: KeyValue<boolean> = {}\n      descendants.forEach((cell) => {\n        if (cell.isNode()) {\n          embedsCache[cell.id] = true\n        }\n      })\n\n      const collectSub = (cell: Cell, isOutgoing: boolean) => {\n        const edges = isOutgoing\n          ? this.getOutgoingEdges(cell.id)\n          : this.getIncomingEdges(cell.id)\n\n        if (edges != null) {\n          edges.forEach((edge) => {\n            if (!cache[edge.id]) {\n              const sourceCell = edge.getSourceCell()\n              const targetCell = edge.getTargetCell()\n\n              if (\n                !options.enclosed &&\n                sourceCell &&\n                embedsCache[sourceCell.id] &&\n                targetCell &&\n                embedsCache[targetCell.id]\n              ) {\n                return\n              }\n\n              result.push(edge)\n              cache[edge.id] = true\n            }\n          })\n        }\n      }\n\n      descendants.forEach((cell) => {\n        if (cell.isEdge()) {\n          return\n        }\n\n        if (outgoing) {\n          collectSub(cell, true)\n        }\n\n        if (incoming) {\n          collectSub(cell, false)\n        }\n      })\n    }\n\n    return result\n  }\n\n  protected isBoundary(cell: Cell | string, isOrigin: boolean) {\n    const node = typeof cell === 'string' ? this.getCell(cell) : cell\n    const arr = isOrigin\n      ? this.getIncomingEdges(node)\n      : this.getOutgoingEdges(node)\n    return arr == null || arr.length === 0\n  }\n\n  protected getBoundaryNodes(isOrigin: boolean) {\n    const result: Node[] = []\n    Object.keys(this.nodes).forEach((nodeId) => {\n      if (this.isBoundary(nodeId, isOrigin)) {\n        const node = this.getCell<Node>(nodeId)\n        if (node) {\n          result.push(node)\n        }\n      }\n    })\n    return result\n  }\n\n  /**\n   * Returns an array of all the roots of the graph.\n   */\n  getRoots() {\n    return this.getBoundaryNodes(true)\n  }\n\n  /**\n   * Returns an array of all the leafs of the graph.\n   */\n  getLeafs() {\n    return this.getBoundaryNodes(false)\n  }\n\n  /**\n   * Returns `true` if the node is a root node, i.e. there is no edges\n   * coming to the node.\n   */\n  isRoot(cell: Cell | string) {\n    return this.isBoundary(cell, true)\n  }\n\n  /**\n   * Returns `true` if the node is a leaf node, i.e. there is no edges\n   * going out from the node.\n   */\n  isLeaf(cell: Cell | string) {\n    return this.isBoundary(cell, false)\n  }\n\n  /**\n   * Returns all the neighbors of node in the graph. Neighbors are all\n   * the nodes connected to node via either incoming or outgoing edge.\n   */\n  getNeighbors(cell: Cell, options: Model.GetNeighborsOptions = {}) {\n    let incoming = options.incoming\n    let outgoing = options.outgoing\n    if (incoming == null && outgoing == null) {\n      incoming = outgoing = true\n    }\n\n    const edges = this.getConnectedEdges(cell, options)\n    const map = edges.reduce<KeyValue<Cell>>((memo, edge) => {\n      const hasLoop = edge.hasLoop(options)\n      const sourceCell = edge.getSourceCell()\n      const targetCell = edge.getTargetCell()\n\n      if (\n        incoming &&\n        sourceCell &&\n        sourceCell.isNode() &&\n        !memo[sourceCell.id]\n      ) {\n        if (\n          hasLoop ||\n          (sourceCell !== cell &&\n            (!options.deep || !sourceCell.isDescendantOf(cell)))\n        ) {\n          memo[sourceCell.id] = sourceCell\n        }\n      }\n\n      if (\n        outgoing &&\n        targetCell &&\n        targetCell.isNode() &&\n        !memo[targetCell.id]\n      ) {\n        if (\n          hasLoop ||\n          (targetCell !== cell &&\n            (!options.deep || !targetCell.isDescendantOf(cell)))\n        ) {\n          memo[targetCell.id] = targetCell\n        }\n      }\n\n      return memo\n    }, {})\n\n    if (cell.isEdge()) {\n      if (incoming) {\n        const sourceCell = cell.getSourceCell()\n        if (sourceCell && sourceCell.isNode() && !map[sourceCell.id]) {\n          map[sourceCell.id] = sourceCell\n        }\n      }\n      if (outgoing) {\n        const targetCell = cell.getTargetCell()\n        if (targetCell && targetCell.isNode() && !map[targetCell.id]) {\n          map[targetCell.id] = targetCell\n        }\n      }\n    }\n\n    return Object.keys(map).map((id) => map[id])\n  }\n\n  /**\n   * Returns `true` if `cell2` is a neighbor of `cell1`.\n   */\n  isNeighbor(\n    cell1: Cell,\n    cell2: Cell,\n    options: Model.GetNeighborsOptions = {},\n  ) {\n    let incoming = options.incoming\n    let outgoing = options.outgoing\n    if (incoming == null && outgoing == null) {\n      incoming = outgoing = true\n    }\n\n    return this.getConnectedEdges(cell1, options).some((edge) => {\n      const sourceCell = edge.getSourceCell()\n      const targetCell = edge.getTargetCell()\n\n      if (incoming && sourceCell && sourceCell.id === cell2.id) {\n        return true\n      }\n\n      if (outgoing && targetCell && targetCell.id === cell2.id) {\n        return true\n      }\n\n      return false\n    })\n  }\n\n  getSuccessors(cell: Cell, options: Model.GetPredecessorsOptions = {}) {\n    const successors: Cell[] = []\n    this.search(\n      cell,\n      (curr, distance) => {\n        if (curr !== cell && this.matchDistance(distance, options.distance)) {\n          successors.push(curr)\n        }\n      },\n      { ...options, outgoing: true },\n    )\n    return successors\n  }\n\n  /**\n   * Returns `true` if `cell2` is a successor of `cell1`.\n   */\n  isSuccessor(\n    cell1: Cell,\n    cell2: Cell,\n    options: Model.GetPredecessorsOptions = {},\n  ) {\n    let result = false\n    this.search(\n      cell1,\n      (curr, distance) => {\n        if (\n          curr === cell2 &&\n          curr !== cell1 &&\n          this.matchDistance(distance, options.distance)\n        ) {\n          result = true\n          return false\n        }\n      },\n      { ...options, outgoing: true },\n    )\n    return result\n  }\n\n  getPredecessors(cell: Cell, options: Model.GetPredecessorsOptions = {}) {\n    const predecessors: Cell[] = []\n    this.search(\n      cell,\n      (curr, distance) => {\n        if (curr !== cell && this.matchDistance(distance, options.distance)) {\n          predecessors.push(curr)\n        }\n      },\n      { ...options, incoming: true },\n    )\n    return predecessors\n  }\n\n  /**\n   * Returns `true` if `cell2` is a predecessor of `cell1`.\n   */\n  isPredecessor(\n    cell1: Cell,\n    cell2: Cell,\n    options: Model.GetPredecessorsOptions = {},\n  ) {\n    let result = false\n    this.search(\n      cell1,\n      (curr, distance) => {\n        if (\n          curr === cell2 &&\n          curr !== cell1 &&\n          this.matchDistance(distance, options.distance)\n        ) {\n          result = true\n          return false\n        }\n      },\n      { ...options, incoming: true },\n    )\n    return result\n  }\n\n  protected matchDistance(\n    distance: number,\n    preset?: number | number[] | ((d: number) => boolean),\n  ) {\n    if (preset == null) {\n      return true\n    }\n\n    if (typeof preset === 'function') {\n      return preset(distance)\n    }\n\n    if (Array.isArray(preset) && preset.includes(distance)) {\n      return true\n    }\n\n    return distance === preset\n  }\n\n  /**\n   * Returns the common ancestor of the passed cells.\n   */\n  getCommonAncestor(...cells: (Cell | Cell[] | null | undefined)[]) {\n    const arr: Cell[] = []\n    cells.forEach((item) => {\n      if (item) {\n        if (Array.isArray(item)) {\n          arr.push(...item)\n        } else {\n          arr.push(item)\n        }\n      }\n    })\n    return Cell.getCommonAncestor(...arr)\n  }\n\n  /**\n   * Returns an array of cells that result from finding nodes/edges that\n   * are connected to any of the cells in the cells array. This function\n   * loops over cells and if the current cell is a edge, it collects its\n   * source/target nodes; if it is an node, it collects its incoming and\n   * outgoing edges if both the edge terminal (source/target) are in the\n   * cells array.\n   */\n  getSubGraph(cells: Cell[], options: Model.GetSubgraphOptions = {}) {\n    const subgraph: Cell[] = []\n    const cache: KeyValue<Cell> = {}\n    const nodes: Node[] = []\n    const edges: Edge[] = []\n    const collect = (cell: Cell) => {\n      if (!cache[cell.id]) {\n        subgraph.push(cell)\n        cache[cell.id] = cell\n        if (cell.isEdge()) {\n          edges.push(cell)\n        }\n\n        if (cell.isNode()) {\n          nodes.push(cell)\n        }\n      }\n    }\n\n    cells.forEach((cell) => {\n      collect(cell)\n      if (options.deep) {\n        const descendants = cell.getDescendants({ deep: true })\n        descendants.forEach((descendant) => collect(descendant))\n      }\n    })\n\n    edges.forEach((edge) => {\n      // For edges, include their source & target\n      const sourceCell = edge.getSourceCell()\n      const targetCell = edge.getTargetCell()\n      if (sourceCell && !cache[sourceCell.id]) {\n        subgraph.push(sourceCell)\n        cache[sourceCell.id] = sourceCell\n        if (sourceCell.isNode()) {\n          nodes.push(sourceCell)\n        }\n      }\n      if (targetCell && !cache[targetCell.id]) {\n        subgraph.push(targetCell)\n        cache[targetCell.id] = targetCell\n        if (targetCell.isNode()) {\n          nodes.push(targetCell)\n        }\n      }\n    })\n\n    nodes.forEach((node) => {\n      // For nodes, include their connected edges if their source/target\n      // is in the subgraph.\n      const edges = this.getConnectedEdges(node, options)\n      edges.forEach((edge) => {\n        const sourceCell = edge.getSourceCell()\n        const targetCell = edge.getTargetCell()\n        if (\n          !cache[edge.id] &&\n          sourceCell &&\n          cache[sourceCell.id] &&\n          targetCell &&\n          cache[targetCell.id]\n        ) {\n          subgraph.push(edge)\n          cache[edge.id] = edge\n        }\n      })\n    })\n\n    return subgraph\n  }\n\n  /**\n   * Clones the whole subgraph (including all the connected links whose\n   * source/target is in the subgraph). If `options.deep` is `true`, also\n   * take into account all the embedded cells of all the subgraph cells.\n   *\n   * Returns a map of the form: { [original cell ID]: [clone] }.\n   */\n  cloneSubGraph(cells: Cell[], options: Model.GetSubgraphOptions = {}) {\n    const subgraph = this.getSubGraph(cells, options)\n    return this.cloneCells(subgraph)\n  }\n\n  cloneCells(cells: Cell[]) {\n    return Cell.cloneCells(cells)\n  }\n\n  /**\n   * Returns an array of nodes whose bounding box contains point.\n   * Note that there can be more then one node as nodes might overlap.\n   */\n  getNodesFromPoint(x: number, y: number): Node[]\n  getNodesFromPoint(p: Point.PointLike): Node[]\n  getNodesFromPoint(x: number | Point.PointLike, y?: number) {\n    const p = typeof x === 'number' ? { x, y: y || 0 } : x\n    return this.getNodes().filter((node) => {\n      return node.getBBox().containsPoint(p)\n    })\n  }\n\n  /**\n   * Returns an array of nodes whose bounding box top/left coordinate\n   * falls into the rectangle.\n   */\n  getNodesInArea(\n    x: number,\n    y: number,\n    w: number,\n    h: number,\n    options?: Model.GetCellsInAreaOptions,\n  ): Node[]\n  getNodesInArea(\n    rect: Rectangle.RectangleLike,\n    options?: Model.GetCellsInAreaOptions,\n  ): Node[]\n  getNodesInArea(\n    x: number | Rectangle.RectangleLike,\n    y?: number | Model.GetCellsInAreaOptions,\n    w?: number,\n    h?: number,\n    options?: Model.GetCellsInAreaOptions,\n  ): Node[] {\n    const rect =\n      typeof x === 'number'\n        ? new Rectangle(x, y as number, w as number, h as number)\n        : Rectangle.create(x)\n    const opts =\n      typeof x === 'number' ? options : (y as Model.GetCellsInAreaOptions)\n    const strict = opts && opts.strict\n    return this.getNodes().filter((node) => {\n      const bbox = node.getBBox()\n      return strict ? rect.containsRect(bbox) : rect.isIntersectWithRect(bbox)\n    })\n  }\n\n  /**\n   * Returns an array of edges whose bounding box top/left coordinate\n   * falls into the rectangle.\n   */\n  getEdgesInArea(\n    x: number,\n    y: number,\n    w: number,\n    h: number,\n    options?: Model.GetCellsInAreaOptions,\n  ): Edge[]\n  getEdgesInArea(\n    rect: Rectangle.RectangleLike,\n    options?: Model.GetCellsInAreaOptions,\n  ): Edge[]\n  getEdgesInArea(\n    x: number | Rectangle.RectangleLike,\n    y?: number | Model.GetCellsInAreaOptions,\n    w?: number,\n    h?: number,\n    options?: Model.GetCellsInAreaOptions,\n  ): Edge[] {\n    const rect =\n      typeof x === 'number'\n        ? new Rectangle(x, y as number, w as number, h as number)\n        : Rectangle.create(x)\n    const opts =\n      typeof x === 'number' ? options : (y as Model.GetCellsInAreaOptions)\n    const strict = opts && opts.strict\n    return this.getEdges().filter((edge) => {\n      const bbox = edge.getBBox()\n      if (bbox.width === 0) {\n        bbox.inflate(1, 0)\n      } else if (bbox.height === 0) {\n        bbox.inflate(0, 1)\n      }\n      return strict ? rect.containsRect(bbox) : rect.isIntersectWithRect(bbox)\n    })\n  }\n\n  getNodesUnderNode(\n    node: Node,\n    options: {\n      by?: 'bbox' | Rectangle.KeyPoint\n    } = {},\n  ) {\n    const bbox = node.getBBox()\n    const nodes =\n      options.by == null || options.by === 'bbox'\n        ? this.getNodesInArea(bbox)\n        : this.getNodesFromPoint(bbox[options.by])\n\n    return nodes.filter(\n      (curr) => node.id !== curr.id && !curr.isDescendantOf(node),\n    )\n  }\n\n  /**\n   * Returns the bounding box that surrounds all cells in the graph.\n   */\n  getAllCellsBBox() {\n    return this.getCellsBBox(this.getCells())\n  }\n\n  /**\n   * Returns the bounding box that surrounds all the given cells.\n   */\n  getCellsBBox(cells: Cell[], options: Cell.GetCellsBBoxOptions = {}) {\n    return Cell.getCellsBBox(cells, options)\n  }\n\n  // #region search\n\n  search(\n    cell: Cell,\n    iterator: Model.SearchIterator,\n    options: Model.SearchOptions = {},\n  ) {\n    if (options.breadthFirst) {\n      this.breadthFirstSearch(cell, iterator, options)\n    } else {\n      this.depthFirstSearch(cell, iterator, options)\n    }\n  }\n\n  breadthFirstSearch(\n    cell: Cell,\n    iterator: Model.SearchIterator,\n    options: Model.GetNeighborsOptions = {},\n  ) {\n    const queue: Cell[] = []\n    const visited: KeyValue<boolean> = {}\n    const distance: KeyValue<number> = {}\n\n    queue.push(cell)\n    distance[cell.id] = 0\n\n    while (queue.length > 0) {\n      const next = queue.shift()\n      if (next == null || visited[next.id]) {\n        continue\n      }\n      visited[next.id] = true\n      if (FunctionExt.call(iterator, this, next, distance[next.id]) === false) {\n        continue\n      }\n      const neighbors = this.getNeighbors(next, options)\n      neighbors.forEach((neighbor) => {\n        distance[neighbor.id] = distance[next.id] + 1\n        queue.push(neighbor)\n      })\n    }\n  }\n\n  depthFirstSearch(\n    cell: Cell,\n    iterator: Model.SearchIterator,\n    options: Model.GetNeighborsOptions = {},\n  ) {\n    const queue: Cell[] = []\n    const visited: KeyValue<boolean> = {}\n    const distance: KeyValue<number> = {}\n\n    queue.push(cell)\n    distance[cell.id] = 0\n\n    while (queue.length > 0) {\n      const next = queue.pop()\n      if (next == null || visited[next.id]) {\n        continue\n      }\n      visited[next.id] = true\n\n      if (FunctionExt.call(iterator, this, next, distance[next.id]) === false) {\n        continue\n      }\n\n      const neighbors = this.getNeighbors(next, options)\n      const lastIndex = queue.length\n      neighbors.forEach((neighbor) => {\n        distance[neighbor.id] = distance[next.id] + 1\n        queue.splice(lastIndex, 0, neighbor)\n      })\n    }\n  }\n\n  // #endregion\n\n  // #region shortest path\n\n  /** *\n   * Returns an array of IDs of nodes on the shortest\n   * path between source and target.\n   */\n  getShortestPath(\n    source: Cell | string,\n    target: Cell | string,\n    options: Model.GetShortestPathOptions = {},\n  ) {\n    const adjacencyList: Dijkstra.AdjacencyList = {}\n    this.getEdges().forEach((edge) => {\n      const sourceId = edge.getSourceCellId()\n      const targetId = edge.getTargetCellId()\n      if (sourceId && targetId) {\n        if (!adjacencyList[sourceId]) {\n          adjacencyList[sourceId] = []\n        }\n        if (!adjacencyList[targetId]) {\n          adjacencyList[targetId] = []\n        }\n\n        adjacencyList[sourceId].push(targetId)\n        if (!options.directed) {\n          adjacencyList[targetId].push(sourceId)\n        }\n      }\n    })\n\n    const sourceId = typeof source === 'string' ? source : source.id\n    const previous = Dijkstra.run(adjacencyList, sourceId, options.weight)\n\n    const path = []\n    let targetId = typeof target === 'string' ? target : target.id\n    if (previous[targetId]) {\n      path.push(targetId)\n    }\n\n    while ((targetId = previous[targetId])) {\n      path.unshift(targetId)\n    }\n    return path\n  }\n\n  // #endregion\n\n  // #region transform\n\n  /**\n   * Translate all cells in the graph by `tx` and `ty` pixels.\n   */\n  translate(tx: number, ty: number, options: Cell.TranslateOptions) {\n    this.getCells()\n      .filter((cell) => !cell.hasParent())\n      .forEach((cell) => cell.translate(tx, ty, options))\n\n    return this\n  }\n\n  resize(width: number, height: number, options: Cell.SetOptions) {\n    return this.resizeCells(width, height, this.getCells(), options)\n  }\n\n  resizeCells(\n    width: number,\n    height: number,\n    cells: Cell[],\n    options: Cell.SetOptions = {},\n  ) {\n    const bbox = this.getCellsBBox(cells)\n    if (bbox) {\n      const sx = Math.max(width / bbox.width, 0)\n      const sy = Math.max(height / bbox.height, 0)\n      const origin = bbox.getOrigin()\n      cells.forEach((cell) => cell.scale(sx, sy, origin, options))\n    }\n\n    return this\n  }\n\n  // #endregion\n\n  // #region serialize/deserialize\n\n  toJSON(options: Model.ToJSONOptions = {}) {\n    return Model.toJSON(this.getCells(), options)\n  }\n\n  parseJSON(data: Model.FromJSONData) {\n    return Model.fromJSON(data)\n  }\n\n  fromJSON(data: Model.FromJSONData, options: Model.FromJSONOptions = {}) {\n    const cells = this.parseJSON(data)\n    this.resetCells(cells, options)\n    return this\n  }\n\n  // #endregion\n\n  // #region batch\n\n  startBatch(name: Model.BatchName, data: KeyValue = {}) {\n    this.batches[name] = (this.batches[name] || 0) + 1\n    this.notify('batch:start', { name, data })\n    return this\n  }\n\n  stopBatch(name: Model.BatchName, data: KeyValue = {}) {\n    this.batches[name] = (this.batches[name] || 0) - 1\n    this.notify('batch:stop', { name, data })\n    return this\n  }\n\n  batchUpdate<T>(name: Model.BatchName, execute: () => T, data: KeyValue = {}) {\n    this.startBatch(name, data)\n    const result = execute()\n    this.stopBatch(name, data)\n    return result\n  }\n\n  hasActiveBatch(\n    name: Model.BatchName | Model.BatchName[] = Object.keys(\n      this.batches,\n    ) as Model.BatchName[],\n  ) {\n    const names = Array.isArray(name) ? name : [name]\n    return names.some((batch) => this.batches[batch] > 0)\n  }\n\n  // #endregion\n\n  @Model.dispose()\n  dispose() {\n    this.collection.dispose()\n  }\n}\n\nexport namespace Model {\n  export const toStringTag = `X6.${Model.name}`\n\n  export function isModel(instance: any): instance is Model {\n    if (instance == null) {\n      return false\n    }\n\n    if (instance instanceof Model) {\n      return true\n    }\n\n    const tag = instance[Symbol.toStringTag]\n    const model = instance as Model\n\n    if (\n      (tag == null || tag === toStringTag) &&\n      typeof model.addNode === 'function' &&\n      typeof model.addEdge === 'function' &&\n      model.collection != null\n    ) {\n      return true\n    }\n\n    return false\n  }\n}\nexport namespace Model {\n  export interface SetOptions extends Collection.SetOptions {}\n  export interface AddOptions extends Collection.AddOptions {}\n  export interface RemoveOptions extends Collection.RemoveOptions {}\n  export interface FromJSONOptions extends Collection.SetOptions {}\n\n  export type FromJSONData =\n    | (Node.Metadata | Edge.Metadata)[]\n    | (Partial<ReturnType<typeof toJSON>> & {\n        nodes?: Node.Metadata[]\n        edges?: Edge.Metadata[]\n      })\n  export type ToJSONData = {\n    cells: Cell.Properties[]\n  }\n\n  export interface GetCellsInAreaOptions {\n    strict?: boolean\n  }\n\n  export interface SearchOptions extends GetNeighborsOptions {\n    breadthFirst?: boolean\n  }\n\n  export type SearchIterator = (\n    this: Model,\n    cell: Cell,\n    distance: number,\n  ) => any\n\n  export interface GetNeighborsOptions {\n    deep?: boolean\n    incoming?: boolean\n    outgoing?: boolean\n    indirect?: boolean\n  }\n\n  export interface GetConnectedEdgesOptions extends GetNeighborsOptions {\n    enclosed?: boolean\n  }\n\n  export interface GetSubgraphOptions {\n    deep?: boolean\n  }\n\n  export interface GetShortestPathOptions {\n    directed?: boolean\n    weight?: Dijkstra.Weight\n  }\n\n  export interface GetPredecessorsOptions extends Cell.GetDescendantsOptions {\n    distance?: number | number[] | ((distance: number) => boolean)\n  }\n}\n\nexport namespace Model {\n  export interface EventArgs\n    extends Collection.CellEventArgs,\n      Collection.NodeEventArgs,\n      Collection.EdgeEventArgs {\n    'batch:start': {\n      name: BatchName | string\n      data: KeyValue\n    }\n    'batch:stop': {\n      name: BatchName | string\n      data: KeyValue\n    }\n\n    sorted: null\n    reseted: {\n      current: Cell[]\n      previous: Cell[]\n      options: Collection.SetOptions\n    }\n    updated: {\n      added: Cell[]\n      merged: Cell[]\n      removed: Cell[]\n      options: Collection.SetOptions\n    }\n  }\n\n  export type BatchName =\n    | 'update'\n    | 'add'\n    | 'remove'\n    | 'clear'\n    | 'to-back'\n    | 'to-front'\n    | 'scale'\n    | 'resize'\n    | 'rotate'\n    | 'translate'\n    | 'mouse'\n    | 'layout'\n    | 'add-edge'\n    | 'fit-embeds'\n    | 'dnd'\n    | 'halo'\n    | 'cut'\n    | 'paste'\n    | 'knob'\n    | 'add-vertex'\n    | 'move-anchor'\n    | 'move-vertex'\n    | 'move-segment'\n    | 'move-arrowhead'\n    | 'move-selection'\n}\n\nexport namespace Model {\n  export interface ToJSONOptions extends Cell.ToJSONOptions {}\n\n  export function toJSON(cells: Cell[], options: ToJSONOptions = {}) {\n    return {\n      cells: cells.map((cell) => cell.toJSON(options)),\n    }\n  }\n\n  export function fromJSON(data: FromJSONData) {\n    const cells: Cell.Metadata[] = []\n    if (Array.isArray(data)) {\n      cells.push(...data)\n    } else {\n      if (data.cells) {\n        cells.push(...data.cells)\n      }\n\n      if (data.nodes) {\n        data.nodes.forEach((node) => {\n          if (node.shape == null) {\n            node.shape = 'rect'\n          }\n          cells.push(node)\n        })\n      }\n\n      if (data.edges) {\n        data.edges.forEach((edge) => {\n          if (edge.shape == null) {\n            edge.shape = 'edge'\n          }\n          cells.push(edge)\n        })\n      }\n    }\n\n    return cells.map((cell) => {\n      const type = cell.shape\n      if (type) {\n        if (Node.registry.exist(type)) {\n          return Node.create(cell)\n        }\n        if (Edge.registry.exist(type)) {\n          return Edge.create(cell)\n        }\n      }\n      throw new Error(\n        'The `shape` should be specified when creating a node/edge instance',\n      )\n    })\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}