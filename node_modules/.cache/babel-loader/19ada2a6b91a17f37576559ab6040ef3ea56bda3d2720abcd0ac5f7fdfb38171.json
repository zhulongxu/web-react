{"ast":null,"code":"/**\n * An implementation of the Priority Queue abstract data type.\n *\n * @see: http://en.wikipedia.org/wiki/Priority_queue\n *\n * It is like a normal stack or queue, but where each item has assigned a\n * priority (a number). Items with higher priority are served before items\n * with lower priority. This implementation uses binary heap as an internal\n * representation of the queue. The time complexity of all the methods is as\n * follows:\n *\n * - create: `O(n)`\n * - insert: `O(log n)`\n * - remove: `O(log n)`\n * - peek: `O(1)`\n * - isEmpty: `O(1)`\n * - peekPriority: `O(1)`\n */\nexport class PriorityQueue {\n  constructor(options = {}) {\n    this.comparator = options.comparator || PriorityQueue.defaultComparator;\n    this.index = {};\n    this.data = options.data || [];\n    this.heapify();\n  }\n  /**\n   * Returns `true` if the priority queue is empty, `false` otherwise.\n   */\n  isEmpty() {\n    return this.data.length === 0;\n  }\n  /**\n   * Inserts a value with priority to the queue. Optionally pass a unique\n   * id of this item. Passing unique IDs for each item you insert allows\n   * you to use the `updatePriority()` operation.\n   * @param priority\n   * @param value\n   * @param id\n   */\n  insert(priority, value, id) {\n    const item = {\n      priority,\n      value\n    };\n    const index = this.data.length;\n    if (id) {\n      item.id = id;\n      this.index[id] = index;\n    }\n    this.data.push(item);\n    this.bubbleUp(index);\n    return this;\n  }\n  /**\n   * Returns the value of an item with the highest priority.\n   */\n  peek() {\n    return this.data[0] ? this.data[0].value : null;\n  }\n  /**\n   * Returns the highest priority in the queue.\n   */\n  peekPriority() {\n    return this.data[0] ? this.data[0].priority : null;\n  }\n  updatePriority(id, priority) {\n    const index = this.index[id];\n    if (typeof index === 'undefined') {\n      throw new Error(`Node with id '${id}' was not found in the heap.`);\n    }\n    const data = this.data;\n    const oldPriority = data[index].priority;\n    const comp = this.comparator(priority, oldPriority);\n    if (comp < 0) {\n      data[index].priority = priority;\n      this.bubbleUp(index);\n    } else if (comp > 0) {\n      data[index].priority = priority;\n      this.bubbleDown(index);\n    }\n  }\n  /**\n   * Removes the item with the highest priority from the queue\n   *\n   * @returns The value of the removed item.\n   */\n  remove() {\n    const data = this.data;\n    const peek = data[0];\n    const last = data.pop();\n    if (peek.id) {\n      delete this.index[peek.id];\n    }\n    if (data.length > 0) {\n      data[0] = last;\n      if (last.id) {\n        this.index[last.id] = 0;\n      }\n      this.bubbleDown(0);\n    }\n    return peek ? peek.value : null;\n  }\n  heapify() {\n    for (let i = 0; i < this.data.length; i += 1) {\n      this.bubbleUp(i);\n    }\n  }\n  bubbleUp(index) {\n    const data = this.data;\n    let tmp;\n    let parent;\n    let current = index;\n    while (current > 0) {\n      parent = current - 1 >>> 1;\n      if (this.comparator(data[current].priority, data[parent].priority) < 0) {\n        tmp = data[parent];\n        data[parent] = data[current];\n        let id = data[current].id;\n        if (id != null) {\n          this.index[id] = parent;\n        }\n        data[current] = tmp;\n        id = data[current].id;\n        if (id != null) {\n          this.index[id] = current;\n        }\n        current = parent;\n      } else {\n        break;\n      }\n    }\n  }\n  bubbleDown(index) {\n    const data = this.data;\n    const last = data.length - 1;\n    let current = index;\n    // eslint-disable-next-line\n    while (true) {\n      const left = (current << 1) + 1;\n      const right = left + 1;\n      let minIndex = current;\n      if (left <= last && this.comparator(data[left].priority, data[minIndex].priority) < 0) {\n        minIndex = left;\n      }\n      if (right <= last && this.comparator(data[right].priority, data[minIndex].priority) < 0) {\n        minIndex = right;\n      }\n      if (minIndex !== current) {\n        const tmp = data[minIndex];\n        data[minIndex] = data[current];\n        let id = data[current].id;\n        if (id != null) {\n          this.index[id] = minIndex;\n        }\n        data[current] = tmp;\n        id = data[current].id;\n        if (id != null) {\n          this.index[id] = current;\n        }\n        current = minIndex;\n      } else {\n        break;\n      }\n    }\n  }\n}\n(function (PriorityQueue) {\n  PriorityQueue.defaultComparator = (a, b) => a - b;\n})(PriorityQueue || (PriorityQueue = {}));","map":{"version":3,"names":["PriorityQueue","constructor","options","comparator","defaultComparator","index","data","heapify","isEmpty","length","insert","priority","value","id","item","push","bubbleUp","peek","peekPriority","updatePriority","Error","oldPriority","comp","bubbleDown","remove","last","pop","i","tmp","parent","current","left","right","minIndex","a","b"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/src/algorithm/priorityqueue.ts"],"sourcesContent":["/**\n * An implementation of the Priority Queue abstract data type.\n *\n * @see: http://en.wikipedia.org/wiki/Priority_queue\n *\n * It is like a normal stack or queue, but where each item has assigned a\n * priority (a number). Items with higher priority are served before items\n * with lower priority. This implementation uses binary heap as an internal\n * representation of the queue. The time complexity of all the methods is as\n * follows:\n *\n * - create: `O(n)`\n * - insert: `O(log n)`\n * - remove: `O(log n)`\n * - peek: `O(1)`\n * - isEmpty: `O(1)`\n * - peekPriority: `O(1)`\n */\nexport class PriorityQueue<T> {\n  protected readonly comparator: PriorityQueue.Comparator\n  protected index: { [key: string]: number }\n  protected data: PriorityQueue.Data<T>\n\n  constructor(options: PriorityQueue.Options<T> = {}) {\n    this.comparator = options.comparator || PriorityQueue.defaultComparator\n    this.index = {}\n    this.data = options.data || []\n    this.heapify()\n  }\n\n  /**\n   * Returns `true` if the priority queue is empty, `false` otherwise.\n   */\n  isEmpty() {\n    return this.data.length === 0\n  }\n\n  /**\n   * Inserts a value with priority to the queue. Optionally pass a unique\n   * id of this item. Passing unique IDs for each item you insert allows\n   * you to use the `updatePriority()` operation.\n   * @param priority\n   * @param value\n   * @param id\n   */\n  insert(priority: number, value: T, id?: string) {\n    const item: PriorityQueue.DataItem<T> = { priority, value }\n    const index = this.data.length\n    if (id) {\n      item.id = id\n      this.index[id] = index\n    }\n    this.data.push(item)\n    this.bubbleUp(index)\n    return this\n  }\n\n  /**\n   * Returns the value of an item with the highest priority.\n   */\n  peek() {\n    return this.data[0] ? this.data[0].value : null\n  }\n\n  /**\n   * Returns the highest priority in the queue.\n   */\n  peekPriority() {\n    return this.data[0] ? this.data[0].priority : null\n  }\n\n  updatePriority(id: string, priority: number) {\n    const index = this.index[id]\n    if (typeof index === 'undefined') {\n      throw new Error(`Node with id '${id}' was not found in the heap.`)\n    }\n\n    const data = this.data\n    const oldPriority = data[index].priority\n    const comp = this.comparator(priority, oldPriority)\n    if (comp < 0) {\n      data[index].priority = priority\n      this.bubbleUp(index)\n    } else if (comp > 0) {\n      data[index].priority = priority\n      this.bubbleDown(index)\n    }\n  }\n\n  /**\n   * Removes the item with the highest priority from the queue\n   *\n   * @returns The value of the removed item.\n   */\n  remove() {\n    const data = this.data\n    const peek = data[0]\n    const last = data.pop()!\n    if (peek.id) {\n      delete this.index[peek.id]\n    }\n\n    if (data.length > 0) {\n      data[0] = last\n      if (last.id) {\n        this.index[last.id] = 0\n      }\n      this.bubbleDown(0)\n    }\n\n    return peek ? peek.value : null\n  }\n\n  protected heapify() {\n    for (let i = 0; i < this.data.length; i += 1) {\n      this.bubbleUp(i)\n    }\n  }\n\n  protected bubbleUp(index: number) {\n    const data = this.data\n    let tmp\n    let parent: number\n    let current = index\n\n    while (current > 0) {\n      parent = (current - 1) >>> 1\n      if (this.comparator(data[current].priority, data[parent].priority) < 0) {\n        tmp = data[parent]\n        data[parent] = data[current]\n        let id = data[current].id\n        if (id != null) {\n          this.index[id] = parent\n        }\n        data[current] = tmp\n        id = data[current].id\n        if (id != null) {\n          this.index[id] = current\n        }\n        current = parent\n      } else {\n        break\n      }\n    }\n  }\n\n  protected bubbleDown(index: number) {\n    const data = this.data\n    const last = data.length - 1\n    let current = index\n\n    // eslint-disable-next-line\n    while (true) {\n      const left = (current << 1) + 1\n      const right = left + 1\n      let minIndex = current\n\n      if (\n        left <= last &&\n        this.comparator(data[left].priority, data[minIndex].priority) < 0\n      ) {\n        minIndex = left\n      }\n      if (\n        right <= last &&\n        this.comparator(data[right].priority, data[minIndex].priority) < 0\n      ) {\n        minIndex = right\n      }\n\n      if (minIndex !== current) {\n        const tmp = data[minIndex]\n        data[minIndex] = data[current]\n        let id = data[current].id\n        if (id != null) {\n          this.index[id] = minIndex\n        }\n        data[current] = tmp\n        id = data[current].id\n        if (id != null) {\n          this.index[id] = current\n        }\n        current = minIndex\n      } else {\n        break\n      }\n    }\n  }\n}\n\nexport namespace PriorityQueue {\n  export interface Options<T> {\n    comparator?: Comparator\n    data?: Data<T>\n  }\n\n  export type Data<T> = DataItem<T>[]\n\n  export interface DataItem<T> {\n    priority: number\n    value: T\n    id?: string\n  }\n\n  export type Comparator = (a: number, b: number) => number\n}\nexport namespace PriorityQueue {\n  export const defaultComparator: Comparator = (a, b) => a - b\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;AAkBA,OAAM,MAAOA,aAAa;EAKxBC,YAAYC,OAAA,GAAoC,EAAE;IAChD,IAAI,CAACC,UAAU,GAAGD,OAAO,CAACC,UAAU,IAAIH,aAAa,CAACI,iBAAiB;IACvE,IAAI,CAACC,KAAK,GAAG,EAAE;IACf,IAAI,CAACC,IAAI,GAAGJ,OAAO,CAACI,IAAI,IAAI,EAAE;IAC9B,IAAI,CAACC,OAAO,EAAE;EAChB;EAEA;;;EAGAC,OAAOA,CAAA;IACL,OAAO,IAAI,CAACF,IAAI,CAACG,MAAM,KAAK,CAAC;EAC/B;EAEA;;;;;;;;EAQAC,MAAMA,CAACC,QAAgB,EAAEC,KAAQ,EAAEC,EAAW;IAC5C,MAAMC,IAAI,GAA8B;MAAEH,QAAQ;MAAEC;IAAK,CAAE;IAC3D,MAAMP,KAAK,GAAG,IAAI,CAACC,IAAI,CAACG,MAAM;IAC9B,IAAII,EAAE,EAAE;MACNC,IAAI,CAACD,EAAE,GAAGA,EAAE;MACZ,IAAI,CAACR,KAAK,CAACQ,EAAE,CAAC,GAAGR,KAAK;;IAExB,IAAI,CAACC,IAAI,CAACS,IAAI,CAACD,IAAI,CAAC;IACpB,IAAI,CAACE,QAAQ,CAACX,KAAK,CAAC;IACpB,OAAO,IAAI;EACb;EAEA;;;EAGAY,IAAIA,CAAA;IACF,OAAO,IAAI,CAACX,IAAI,CAAC,CAAC,CAAC,GAAG,IAAI,CAACA,IAAI,CAAC,CAAC,CAAC,CAACM,KAAK,GAAG,IAAI;EACjD;EAEA;;;EAGAM,YAAYA,CAAA;IACV,OAAO,IAAI,CAACZ,IAAI,CAAC,CAAC,CAAC,GAAG,IAAI,CAACA,IAAI,CAAC,CAAC,CAAC,CAACK,QAAQ,GAAG,IAAI;EACpD;EAEAQ,cAAcA,CAACN,EAAU,EAAEF,QAAgB;IACzC,MAAMN,KAAK,GAAG,IAAI,CAACA,KAAK,CAACQ,EAAE,CAAC;IAC5B,IAAI,OAAOR,KAAK,KAAK,WAAW,EAAE;MAChC,MAAM,IAAIe,KAAK,CAAC,iBAAiBP,EAAE,8BAA8B,CAAC;;IAGpE,MAAMP,IAAI,GAAG,IAAI,CAACA,IAAI;IACtB,MAAMe,WAAW,GAAGf,IAAI,CAACD,KAAK,CAAC,CAACM,QAAQ;IACxC,MAAMW,IAAI,GAAG,IAAI,CAACnB,UAAU,CAACQ,QAAQ,EAAEU,WAAW,CAAC;IACnD,IAAIC,IAAI,GAAG,CAAC,EAAE;MACZhB,IAAI,CAACD,KAAK,CAAC,CAACM,QAAQ,GAAGA,QAAQ;MAC/B,IAAI,CAACK,QAAQ,CAACX,KAAK,CAAC;KACrB,MAAM,IAAIiB,IAAI,GAAG,CAAC,EAAE;MACnBhB,IAAI,CAACD,KAAK,CAAC,CAACM,QAAQ,GAAGA,QAAQ;MAC/B,IAAI,CAACY,UAAU,CAAClB,KAAK,CAAC;;EAE1B;EAEA;;;;;EAKAmB,MAAMA,CAAA;IACJ,MAAMlB,IAAI,GAAG,IAAI,CAACA,IAAI;IACtB,MAAMW,IAAI,GAAGX,IAAI,CAAC,CAAC,CAAC;IACpB,MAAMmB,IAAI,GAAGnB,IAAI,CAACoB,GAAG,EAAG;IACxB,IAAIT,IAAI,CAACJ,EAAE,EAAE;MACX,OAAO,IAAI,CAACR,KAAK,CAACY,IAAI,CAACJ,EAAE,CAAC;;IAG5B,IAAIP,IAAI,CAACG,MAAM,GAAG,CAAC,EAAE;MACnBH,IAAI,CAAC,CAAC,CAAC,GAAGmB,IAAI;MACd,IAAIA,IAAI,CAACZ,EAAE,EAAE;QACX,IAAI,CAACR,KAAK,CAACoB,IAAI,CAACZ,EAAE,CAAC,GAAG,CAAC;;MAEzB,IAAI,CAACU,UAAU,CAAC,CAAC,CAAC;;IAGpB,OAAON,IAAI,GAAGA,IAAI,CAACL,KAAK,GAAG,IAAI;EACjC;EAEUL,OAAOA,CAAA;IACf,KAAK,IAAIoB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACrB,IAAI,CAACG,MAAM,EAAEkB,CAAC,IAAI,CAAC,EAAE;MAC5C,IAAI,CAACX,QAAQ,CAACW,CAAC,CAAC;;EAEpB;EAEUX,QAAQA,CAACX,KAAa;IAC9B,MAAMC,IAAI,GAAG,IAAI,CAACA,IAAI;IACtB,IAAIsB,GAAG;IACP,IAAIC,MAAc;IAClB,IAAIC,OAAO,GAAGzB,KAAK;IAEnB,OAAOyB,OAAO,GAAG,CAAC,EAAE;MAClBD,MAAM,GAAIC,OAAO,GAAG,CAAC,KAAM,CAAC;MAC5B,IAAI,IAAI,CAAC3B,UAAU,CAACG,IAAI,CAACwB,OAAO,CAAC,CAACnB,QAAQ,EAAEL,IAAI,CAACuB,MAAM,CAAC,CAAClB,QAAQ,CAAC,GAAG,CAAC,EAAE;QACtEiB,GAAG,GAAGtB,IAAI,CAACuB,MAAM,CAAC;QAClBvB,IAAI,CAACuB,MAAM,CAAC,GAAGvB,IAAI,CAACwB,OAAO,CAAC;QAC5B,IAAIjB,EAAE,GAAGP,IAAI,CAACwB,OAAO,CAAC,CAACjB,EAAE;QACzB,IAAIA,EAAE,IAAI,IAAI,EAAE;UACd,IAAI,CAACR,KAAK,CAACQ,EAAE,CAAC,GAAGgB,MAAM;;QAEzBvB,IAAI,CAACwB,OAAO,CAAC,GAAGF,GAAG;QACnBf,EAAE,GAAGP,IAAI,CAACwB,OAAO,CAAC,CAACjB,EAAE;QACrB,IAAIA,EAAE,IAAI,IAAI,EAAE;UACd,IAAI,CAACR,KAAK,CAACQ,EAAE,CAAC,GAAGiB,OAAO;;QAE1BA,OAAO,GAAGD,MAAM;OACjB,MAAM;QACL;;;EAGN;EAEUN,UAAUA,CAAClB,KAAa;IAChC,MAAMC,IAAI,GAAG,IAAI,CAACA,IAAI;IACtB,MAAMmB,IAAI,GAAGnB,IAAI,CAACG,MAAM,GAAG,CAAC;IAC5B,IAAIqB,OAAO,GAAGzB,KAAK;IAEnB;IACA,OAAO,IAAI,EAAE;MACX,MAAM0B,IAAI,GAAG,CAACD,OAAO,IAAI,CAAC,IAAI,CAAC;MAC/B,MAAME,KAAK,GAAGD,IAAI,GAAG,CAAC;MACtB,IAAIE,QAAQ,GAAGH,OAAO;MAEtB,IACEC,IAAI,IAAIN,IAAI,IACZ,IAAI,CAACtB,UAAU,CAACG,IAAI,CAACyB,IAAI,CAAC,CAACpB,QAAQ,EAAEL,IAAI,CAAC2B,QAAQ,CAAC,CAACtB,QAAQ,CAAC,GAAG,CAAC,EACjE;QACAsB,QAAQ,GAAGF,IAAI;;MAEjB,IACEC,KAAK,IAAIP,IAAI,IACb,IAAI,CAACtB,UAAU,CAACG,IAAI,CAAC0B,KAAK,CAAC,CAACrB,QAAQ,EAAEL,IAAI,CAAC2B,QAAQ,CAAC,CAACtB,QAAQ,CAAC,GAAG,CAAC,EAClE;QACAsB,QAAQ,GAAGD,KAAK;;MAGlB,IAAIC,QAAQ,KAAKH,OAAO,EAAE;QACxB,MAAMF,GAAG,GAAGtB,IAAI,CAAC2B,QAAQ,CAAC;QAC1B3B,IAAI,CAAC2B,QAAQ,CAAC,GAAG3B,IAAI,CAACwB,OAAO,CAAC;QAC9B,IAAIjB,EAAE,GAAGP,IAAI,CAACwB,OAAO,CAAC,CAACjB,EAAE;QACzB,IAAIA,EAAE,IAAI,IAAI,EAAE;UACd,IAAI,CAACR,KAAK,CAACQ,EAAE,CAAC,GAAGoB,QAAQ;;QAE3B3B,IAAI,CAACwB,OAAO,CAAC,GAAGF,GAAG;QACnBf,EAAE,GAAGP,IAAI,CAACwB,OAAO,CAAC,CAACjB,EAAE;QACrB,IAAIA,EAAE,IAAI,IAAI,EAAE;UACd,IAAI,CAACR,KAAK,CAACQ,EAAE,CAAC,GAAGiB,OAAO;;QAE1BA,OAAO,GAAGG,QAAQ;OACnB,MAAM;QACL;;;EAGN;;AAmBF,WAAiBjC,aAAa;EACfA,aAAA,CAAAI,iBAAiB,GAAe,CAAC8B,CAAC,EAAEC,CAAC,KAAKD,CAAC,GAAGC,CAAC;AAC9D,CAAC,EAFgBnC,aAAa,KAAbA,aAAa","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}