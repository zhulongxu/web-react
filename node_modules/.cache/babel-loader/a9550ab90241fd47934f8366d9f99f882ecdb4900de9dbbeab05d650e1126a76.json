{"ast":null,"code":"import { GeometryUtil } from './util';\nimport { Angle } from './angle';\nimport { Line } from './line';\nimport { Point } from './point';\nimport { Geometry } from './geometry';\nexport class Rectangle extends Geometry {\n  get left() {\n    return this.x;\n  }\n  get top() {\n    return this.y;\n  }\n  get right() {\n    return this.x + this.width;\n  }\n  get bottom() {\n    return this.y + this.height;\n  }\n  get origin() {\n    return new Point(this.x, this.y);\n  }\n  get topLeft() {\n    return new Point(this.x, this.y);\n  }\n  get topCenter() {\n    return new Point(this.x + this.width / 2, this.y);\n  }\n  get topRight() {\n    return new Point(this.x + this.width, this.y);\n  }\n  get center() {\n    return new Point(this.x + this.width / 2, this.y + this.height / 2);\n  }\n  get bottomLeft() {\n    return new Point(this.x, this.y + this.height);\n  }\n  get bottomCenter() {\n    return new Point(this.x + this.width / 2, this.y + this.height);\n  }\n  get bottomRight() {\n    return new Point(this.x + this.width, this.y + this.height);\n  }\n  get corner() {\n    return new Point(this.x + this.width, this.y + this.height);\n  }\n  get rightMiddle() {\n    return new Point(this.x + this.width, this.y + this.height / 2);\n  }\n  get leftMiddle() {\n    return new Point(this.x, this.y + this.height / 2);\n  }\n  get topLine() {\n    return new Line(this.topLeft, this.topRight);\n  }\n  get rightLine() {\n    return new Line(this.topRight, this.bottomRight);\n  }\n  get bottomLine() {\n    return new Line(this.bottomLeft, this.bottomRight);\n  }\n  get leftLine() {\n    return new Line(this.topLeft, this.bottomLeft);\n  }\n  constructor(x, y, width, height) {\n    super();\n    this.x = x == null ? 0 : x;\n    this.y = y == null ? 0 : y;\n    this.width = width == null ? 0 : width;\n    this.height = height == null ? 0 : height;\n  }\n  getOrigin() {\n    return this.origin;\n  }\n  getTopLeft() {\n    return this.topLeft;\n  }\n  getTopCenter() {\n    return this.topCenter;\n  }\n  getTopRight() {\n    return this.topRight;\n  }\n  getCenter() {\n    return this.center;\n  }\n  getCenterX() {\n    return this.x + this.width / 2;\n  }\n  getCenterY() {\n    return this.y + this.height / 2;\n  }\n  getBottomLeft() {\n    return this.bottomLeft;\n  }\n  getBottomCenter() {\n    return this.bottomCenter;\n  }\n  getBottomRight() {\n    return this.bottomRight;\n  }\n  getCorner() {\n    return this.corner;\n  }\n  getRightMiddle() {\n    return this.rightMiddle;\n  }\n  getLeftMiddle() {\n    return this.leftMiddle;\n  }\n  getTopLine() {\n    return this.topLine;\n  }\n  getRightLine() {\n    return this.rightLine;\n  }\n  getBottomLine() {\n    return this.bottomLine;\n  }\n  getLeftLine() {\n    return this.leftLine;\n  }\n  /**\n   * Returns a rectangle that is the bounding box of the rectangle.\n   *\n   * If `angle` is specified, the bounding box calculation will take into\n   * account the rotation of the rectangle by angle degrees around its center.\n   */\n  bbox(angle) {\n    if (!angle) {\n      return this.clone();\n    }\n    const rad = Angle.toRad(angle);\n    const st = Math.abs(Math.sin(rad));\n    const ct = Math.abs(Math.cos(rad));\n    const w = this.width * ct + this.height * st;\n    const h = this.width * st + this.height * ct;\n    return new Rectangle(this.x + (this.width - w) / 2, this.y + (this.height - h) / 2, w, h);\n  }\n  round(precision = 0) {\n    this.x = GeometryUtil.round(this.x, precision);\n    this.y = GeometryUtil.round(this.y, precision);\n    this.width = GeometryUtil.round(this.width, precision);\n    this.height = GeometryUtil.round(this.height, precision);\n    return this;\n  }\n  add(x, y, width, height) {\n    const rect = Rectangle.create(x, y, width, height);\n    const minX = Math.min(this.x, rect.x);\n    const minY = Math.min(this.y, rect.y);\n    const maxX = Math.max(this.x + this.width, rect.x + rect.width);\n    const maxY = Math.max(this.y + this.height, rect.y + rect.height);\n    this.x = minX;\n    this.y = minY;\n    this.width = maxX - minX;\n    this.height = maxY - minY;\n    return this;\n  }\n  update(x, y, width, height) {\n    const rect = Rectangle.create(x, y, width, height);\n    this.x = rect.x;\n    this.y = rect.y;\n    this.width = rect.width;\n    this.height = rect.height;\n    return this;\n  }\n  inflate(dx, dy) {\n    const w = dx;\n    const h = dy != null ? dy : dx;\n    this.x -= w;\n    this.y -= h;\n    this.width += 2 * w;\n    this.height += 2 * h;\n    return this;\n  }\n  snapToGrid(gx, gy) {\n    const origin = this.origin.snapToGrid(gx, gy);\n    const corner = this.corner.snapToGrid(gx, gy);\n    this.x = origin.x;\n    this.y = origin.y;\n    this.width = corner.x - origin.x;\n    this.height = corner.y - origin.y;\n    return this;\n  }\n  translate(tx, ty) {\n    const p = Point.create(tx, ty);\n    this.x += p.x;\n    this.y += p.y;\n    return this;\n  }\n  scale(sx, sy, origin = new Point()) {\n    const pos = this.origin.scale(sx, sy, origin);\n    this.x = pos.x;\n    this.y = pos.y;\n    this.width *= sx;\n    this.height *= sy;\n    return this;\n  }\n  rotate(degree, center = this.getCenter()) {\n    if (degree !== 0) {\n      const rad = Angle.toRad(degree);\n      const cos = Math.cos(rad);\n      const sin = Math.sin(rad);\n      let p1 = this.getOrigin();\n      let p2 = this.getTopRight();\n      let p3 = this.getBottomRight();\n      let p4 = this.getBottomLeft();\n      p1 = Point.rotateEx(p1, cos, sin, center);\n      p2 = Point.rotateEx(p2, cos, sin, center);\n      p3 = Point.rotateEx(p3, cos, sin, center);\n      p4 = Point.rotateEx(p4, cos, sin, center);\n      const rect = new Rectangle(p1.x, p1.y, 0, 0);\n      rect.add(p2.x, p2.y, 0, 0);\n      rect.add(p3.x, p3.y, 0, 0);\n      rect.add(p4.x, p4.y, 0, 0);\n      this.update(rect);\n    }\n    return this;\n  }\n  rotate90() {\n    const t = (this.width - this.height) / 2;\n    this.x += t;\n    this.y -= t;\n    const tmp = this.width;\n    this.width = this.height;\n    this.height = tmp;\n    return this;\n  }\n  /**\n   * Translates the rectangle by `rect.x` and `rect.y` and expand it by\n   * `rect.width` and `rect.height`.\n   */\n  moveAndExpand(rect) {\n    const ref = Rectangle.clone(rect);\n    this.x += ref.x || 0;\n    this.y += ref.y || 0;\n    this.width += ref.width || 0;\n    this.height += ref.height || 0;\n    return this;\n  }\n  /**\n   * Returns an object where `sx` and `sy` give the maximum scaling that can be\n   * applied to the rectangle so that it would still fit into `limit`. If\n   * `origin` is specified, the rectangle is scaled around it; otherwise, it is\n   * scaled around its center.\n   */\n  getMaxScaleToFit(limit, origin = this.center) {\n    const rect = Rectangle.clone(limit);\n    const ox = origin.x;\n    const oy = origin.y;\n    // Find the maximal possible scale for all corners, so when the scale\n    // is applied the point is still inside the rectangle.\n    let sx1 = Infinity;\n    let sx2 = Infinity;\n    let sx3 = Infinity;\n    let sx4 = Infinity;\n    let sy1 = Infinity;\n    let sy2 = Infinity;\n    let sy3 = Infinity;\n    let sy4 = Infinity;\n    // Top Left\n    const p1 = rect.topLeft;\n    if (p1.x < ox) {\n      sx1 = (this.x - ox) / (p1.x - ox);\n    }\n    if (p1.y < oy) {\n      sy1 = (this.y - oy) / (p1.y - oy);\n    }\n    // Bottom Right\n    const p2 = rect.bottomRight;\n    if (p2.x > ox) {\n      sx2 = (this.x + this.width - ox) / (p2.x - ox);\n    }\n    if (p2.y > oy) {\n      sy2 = (this.y + this.height - oy) / (p2.y - oy);\n    }\n    // Top Right\n    const p3 = rect.topRight;\n    if (p3.x > ox) {\n      sx3 = (this.x + this.width - ox) / (p3.x - ox);\n    }\n    if (p3.y < oy) {\n      sy3 = (this.y - oy) / (p3.y - oy);\n    }\n    // Bottom Left\n    const p4 = rect.bottomLeft;\n    if (p4.x < ox) {\n      sx4 = (this.x - ox) / (p4.x - ox);\n    }\n    if (p4.y > oy) {\n      sy4 = (this.y + this.height - oy) / (p4.y - oy);\n    }\n    return {\n      sx: Math.min(sx1, sx2, sx3, sx4),\n      sy: Math.min(sy1, sy2, sy3, sy4)\n    };\n  }\n  /**\n   * Returns a number that specifies the maximum scaling that can be applied to\n   * the rectangle along both axes so that it would still fit into `limit`. If\n   * `origin` is specified, the rectangle is scaled around it; otherwise, it is\n   * scaled around its center.\n   */\n  getMaxUniformScaleToFit(limit, origin = this.center) {\n    const scale = this.getMaxScaleToFit(limit, origin);\n    return Math.min(scale.sx, scale.sy);\n  }\n  containsPoint(x, y) {\n    return GeometryUtil.containsPoint(this, Point.create(x, y));\n  }\n  containsRect(x, y, width, height) {\n    const b = Rectangle.create(x, y, width, height);\n    const x1 = this.x;\n    const y1 = this.y;\n    const w1 = this.width;\n    const h1 = this.height;\n    const x2 = b.x;\n    const y2 = b.y;\n    const w2 = b.width;\n    const h2 = b.height;\n    // one of the dimensions is 0\n    if (w1 === 0 || h1 === 0 || w2 === 0 || h2 === 0) {\n      return false;\n    }\n    return x2 >= x1 && y2 >= y1 && x2 + w2 <= x1 + w1 && y2 + h2 <= y1 + h1;\n  }\n  /**\n   * Returns an array of the intersection points of the rectangle and the line.\n   * Return `null` if no intersection exists.\n   */\n  intersectsWithLine(line) {\n    const rectLines = [this.topLine, this.rightLine, this.bottomLine, this.leftLine];\n    const points = [];\n    const dedupeArr = [];\n    rectLines.forEach(l => {\n      const p = line.intersectsWithLine(l);\n      if (p !== null && dedupeArr.indexOf(p.toString()) < 0) {\n        points.push(p);\n        dedupeArr.push(p.toString());\n      }\n    });\n    return points.length > 0 ? points : null;\n  }\n  /**\n   * Returns the point on the boundary of the rectangle that is the intersection\n   * of the rectangle with a line starting in the center the rectangle ending in\n   * the point `p`.\n   *\n   * If `angle` is specified, the intersection will take into account the\n   * rotation of the rectangle by `angle` degrees around its center.\n   */\n  intersectsWithLineFromCenterToPoint(p, angle) {\n    const ref = Point.clone(p);\n    const center = this.center;\n    let result = null;\n    if (angle != null && angle !== 0) {\n      ref.rotate(angle, center);\n    }\n    const sides = [this.topLine, this.rightLine, this.bottomLine, this.leftLine];\n    const connector = new Line(center, ref);\n    for (let i = sides.length - 1; i >= 0; i -= 1) {\n      const intersection = sides[i].intersectsWithLine(connector);\n      if (intersection !== null) {\n        result = intersection;\n        break;\n      }\n    }\n    if (result && angle != null && angle !== 0) {\n      result.rotate(-angle, center);\n    }\n    return result;\n  }\n  intersectsWithRect(x, y, width, height) {\n    const ref = Rectangle.create(x, y, width, height);\n    // no intersection\n    if (!this.isIntersectWithRect(ref)) {\n      return null;\n    }\n    const myOrigin = this.origin;\n    const myCorner = this.corner;\n    const rOrigin = ref.origin;\n    const rCorner = ref.corner;\n    const xx = Math.max(myOrigin.x, rOrigin.x);\n    const yy = Math.max(myOrigin.y, rOrigin.y);\n    return new Rectangle(xx, yy, Math.min(myCorner.x, rCorner.x) - xx, Math.min(myCorner.y, rCorner.y) - yy);\n  }\n  isIntersectWithRect(x, y, width, height) {\n    const ref = Rectangle.create(x, y, width, height);\n    const myOrigin = this.origin;\n    const myCorner = this.corner;\n    const rOrigin = ref.origin;\n    const rCorner = ref.corner;\n    if (rCorner.x <= myOrigin.x || rCorner.y <= myOrigin.y || rOrigin.x >= myCorner.x || rOrigin.y >= myCorner.y) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Normalize the rectangle, i.e. make it so that it has non-negative\n   * width and height. If width is less than `0`, the function swaps left and\n   * right corners and if height is less than `0`, the top and bottom corners\n   * are swapped.\n   */\n  normalize() {\n    let newx = this.x;\n    let newy = this.y;\n    let newwidth = this.width;\n    let newheight = this.height;\n    if (this.width < 0) {\n      newx = this.x + this.width;\n      newwidth = -this.width;\n    }\n    if (this.height < 0) {\n      newy = this.y + this.height;\n      newheight = -this.height;\n    }\n    this.x = newx;\n    this.y = newy;\n    this.width = newwidth;\n    this.height = newheight;\n    return this;\n  }\n  /**\n   * Returns a rectangle that is a union of this rectangle and rectangle `rect`.\n   */\n  union(rect) {\n    const ref = Rectangle.clone(rect);\n    const myOrigin = this.origin;\n    const myCorner = this.corner;\n    const rOrigin = ref.origin;\n    const rCorner = ref.corner;\n    const originX = Math.min(myOrigin.x, rOrigin.x);\n    const originY = Math.min(myOrigin.y, rOrigin.y);\n    const cornerX = Math.max(myCorner.x, rCorner.x);\n    const cornerY = Math.max(myCorner.y, rCorner.y);\n    return new Rectangle(originX, originY, cornerX - originX, cornerY - originY);\n  }\n  /**\n   * Returns a string (\"top\", \"left\", \"right\" or \"bottom\") denoting the side of\n   * the rectangle which is nearest to the point `p`.\n   */\n  getNearestSideToPoint(p) {\n    const ref = Point.clone(p);\n    const distLeft = ref.x - this.x;\n    const distRight = this.x + this.width - ref.x;\n    const distTop = ref.y - this.y;\n    const distBottom = this.y + this.height - ref.y;\n    let closest = distLeft;\n    let side = 'left';\n    if (distRight < closest) {\n      closest = distRight;\n      side = 'right';\n    }\n    if (distTop < closest) {\n      closest = distTop;\n      side = 'top';\n    }\n    if (distBottom < closest) {\n      side = 'bottom';\n    }\n    return side;\n  }\n  /**\n   * Returns a point on the boundary of the rectangle nearest to the point `p`.\n   */\n  getNearestPointToPoint(p) {\n    const ref = Point.clone(p);\n    if (this.containsPoint(ref)) {\n      const side = this.getNearestSideToPoint(ref);\n      if (side === 'left') {\n        return new Point(this.x, ref.y);\n      }\n      if (side === 'top') {\n        return new Point(ref.x, this.y);\n      }\n      if (side === 'right') {\n        return new Point(this.x + this.width, ref.y);\n      }\n      if (side === 'bottom') {\n        return new Point(ref.x, this.y + this.height);\n      }\n    }\n    return ref.adhereToRect(this);\n  }\n  equals(rect) {\n    return rect != null && rect.x === this.x && rect.y === this.y && rect.width === this.width && rect.height === this.height;\n  }\n  clone() {\n    return new Rectangle(this.x, this.y, this.width, this.height);\n  }\n  toJSON() {\n    return {\n      x: this.x,\n      y: this.y,\n      width: this.width,\n      height: this.height\n    };\n  }\n  serialize() {\n    return `${this.x} ${this.y} ${this.width} ${this.height}`;\n  }\n}\n(function (Rectangle) {\n  function isRectangle(instance) {\n    return instance != null && instance instanceof Rectangle;\n  }\n  Rectangle.isRectangle = isRectangle;\n})(Rectangle || (Rectangle = {}));\n(function (Rectangle) {\n  function isRectangleLike(o) {\n    return o != null && typeof o === 'object' && typeof o.x === 'number' && typeof o.y === 'number' && typeof o.width === 'number' && typeof o.height === 'number';\n  }\n  Rectangle.isRectangleLike = isRectangleLike;\n})(Rectangle || (Rectangle = {}));\n(function (Rectangle) {\n  function create(x, y, width, height) {\n    if (x == null || typeof x === 'number') {\n      return new Rectangle(x, y, width, height);\n    }\n    return clone(x);\n  }\n  Rectangle.create = create;\n  function clone(rect) {\n    if (Rectangle.isRectangle(rect)) {\n      return rect.clone();\n    }\n    if (Array.isArray(rect)) {\n      return new Rectangle(rect[0], rect[1], rect[2], rect[3]);\n    }\n    return new Rectangle(rect.x, rect.y, rect.width, rect.height);\n  }\n  Rectangle.clone = clone;\n  /**\n   * Returns a new rectangle from the given ellipse.\n   */\n  function fromEllipse(ellipse) {\n    return new Rectangle(ellipse.x - ellipse.a, ellipse.y - ellipse.b, 2 * ellipse.a, 2 * ellipse.b);\n  }\n  Rectangle.fromEllipse = fromEllipse;\n  function fromSize(size) {\n    return new Rectangle(0, 0, size.width, size.height);\n  }\n  Rectangle.fromSize = fromSize;\n  function fromPositionAndSize(pos, size) {\n    return new Rectangle(pos.x, pos.y, size.width, size.height);\n  }\n  Rectangle.fromPositionAndSize = fromPositionAndSize;\n})(Rectangle || (Rectangle = {}));","map":{"version":3,"names":["GeometryUtil","Angle","Line","Point","Geometry","Rectangle","left","x","top","y","right","width","bottom","height","origin","topLeft","topCenter","topRight","center","bottomLeft","bottomCenter","bottomRight","corner","rightMiddle","leftMiddle","topLine","rightLine","bottomLine","leftLine","constructor","getOrigin","getTopLeft","getTopCenter","getTopRight","getCenter","getCenterX","getCenterY","getBottomLeft","getBottomCenter","getBottomRight","getCorner","getRightMiddle","getLeftMiddle","getTopLine","getRightLine","getBottomLine","getLeftLine","bbox","angle","clone","rad","toRad","st","Math","abs","sin","ct","cos","w","h","round","precision","add","rect","create","minX","min","minY","maxX","max","maxY","update","inflate","dx","dy","snapToGrid","gx","gy","translate","tx","ty","p","scale","sx","sy","pos","rotate","degree","p1","p2","p3","p4","rotateEx","rotate90","t","tmp","moveAndExpand","ref","getMaxScaleToFit","limit","ox","oy","sx1","Infinity","sx2","sx3","sx4","sy1","sy2","sy3","sy4","getMaxUniformScaleToFit","containsPoint","containsRect","b","x1","y1","w1","h1","x2","y2","w2","h2","intersectsWithLine","line","rectLines","points","dedupeArr","forEach","l","indexOf","toString","push","length","intersectsWithLineFromCenterToPoint","result","sides","connector","i","intersection","intersectsWithRect","isIntersectWithRect","myOrigin","myCorner","rOrigin","rCorner","xx","yy","normalize","newx","newy","newwidth","newheight","union","originX","originY","cornerX","cornerY","getNearestSideToPoint","distLeft","distRight","distTop","distBottom","closest","side","getNearestPointToPoint","adhereToRect","equals","toJSON","serialize","isRectangle","instance","isRectangleLike","o","Array","isArray","fromEllipse","ellipse","a","fromSize","size","fromPositionAndSize"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6-geometry@2.0.5/node_modules/@antv/x6-geometry/src/rectangle.ts"],"sourcesContent":["import { GeometryUtil } from './util'\nimport { Angle } from './angle'\nimport { Line } from './line'\nimport { Point } from './point'\nimport { Geometry } from './geometry'\nimport { Ellipse } from './ellipse'\n\nexport class Rectangle extends Geometry implements Rectangle.RectangleLike {\n  public x: number\n  public y: number\n  public width: number\n  public height: number\n\n  public get left() {\n    return this.x\n  }\n\n  public get top() {\n    return this.y\n  }\n\n  public get right() {\n    return this.x + this.width\n  }\n\n  public get bottom() {\n    return this.y + this.height\n  }\n\n  public get origin() {\n    return new Point(this.x, this.y)\n  }\n\n  public get topLeft() {\n    return new Point(this.x, this.y)\n  }\n\n  public get topCenter() {\n    return new Point(this.x + this.width / 2, this.y)\n  }\n\n  public get topRight() {\n    return new Point(this.x + this.width, this.y)\n  }\n\n  public get center() {\n    return new Point(this.x + this.width / 2, this.y + this.height / 2)\n  }\n\n  public get bottomLeft() {\n    return new Point(this.x, this.y + this.height)\n  }\n\n  public get bottomCenter() {\n    return new Point(this.x + this.width / 2, this.y + this.height)\n  }\n\n  public get bottomRight() {\n    return new Point(this.x + this.width, this.y + this.height)\n  }\n\n  public get corner() {\n    return new Point(this.x + this.width, this.y + this.height)\n  }\n\n  public get rightMiddle() {\n    return new Point(this.x + this.width, this.y + this.height / 2)\n  }\n\n  public get leftMiddle() {\n    return new Point(this.x, this.y + this.height / 2)\n  }\n\n  public get topLine() {\n    return new Line(this.topLeft, this.topRight)\n  }\n\n  public get rightLine() {\n    return new Line(this.topRight, this.bottomRight)\n  }\n\n  public get bottomLine() {\n    return new Line(this.bottomLeft, this.bottomRight)\n  }\n\n  public get leftLine() {\n    return new Line(this.topLeft, this.bottomLeft)\n  }\n\n  constructor(x?: number, y?: number, width?: number, height?: number) {\n    super()\n    this.x = x == null ? 0 : x\n    this.y = y == null ? 0 : y\n    this.width = width == null ? 0 : width\n    this.height = height == null ? 0 : height\n  }\n\n  getOrigin() {\n    return this.origin\n  }\n\n  getTopLeft() {\n    return this.topLeft\n  }\n\n  getTopCenter() {\n    return this.topCenter\n  }\n\n  getTopRight() {\n    return this.topRight\n  }\n\n  getCenter() {\n    return this.center\n  }\n\n  getCenterX() {\n    return this.x + this.width / 2\n  }\n\n  getCenterY() {\n    return this.y + this.height / 2\n  }\n\n  getBottomLeft() {\n    return this.bottomLeft\n  }\n\n  getBottomCenter() {\n    return this.bottomCenter\n  }\n\n  getBottomRight() {\n    return this.bottomRight\n  }\n\n  getCorner() {\n    return this.corner\n  }\n\n  getRightMiddle() {\n    return this.rightMiddle\n  }\n\n  getLeftMiddle() {\n    return this.leftMiddle\n  }\n\n  getTopLine() {\n    return this.topLine\n  }\n\n  getRightLine() {\n    return this.rightLine\n  }\n\n  getBottomLine() {\n    return this.bottomLine\n  }\n\n  getLeftLine() {\n    return this.leftLine\n  }\n\n  /**\n   * Returns a rectangle that is the bounding box of the rectangle.\n   *\n   * If `angle` is specified, the bounding box calculation will take into\n   * account the rotation of the rectangle by angle degrees around its center.\n   */\n  bbox(angle?: number) {\n    if (!angle) {\n      return this.clone()\n    }\n\n    const rad = Angle.toRad(angle)\n    const st = Math.abs(Math.sin(rad))\n    const ct = Math.abs(Math.cos(rad))\n    const w = this.width * ct + this.height * st\n    const h = this.width * st + this.height * ct\n    return new Rectangle(\n      this.x + (this.width - w) / 2,\n      this.y + (this.height - h) / 2,\n      w,\n      h,\n    )\n  }\n\n  round(precision = 0) {\n    this.x = GeometryUtil.round(this.x, precision)\n    this.y = GeometryUtil.round(this.y, precision)\n    this.width = GeometryUtil.round(this.width, precision)\n    this.height = GeometryUtil.round(this.height, precision)\n    return this\n  }\n\n  add(x: number, y: number, width: number, height: number): this\n  add(rect: Rectangle.RectangleLike | Rectangle.RectangleData): this\n  add(\n    x: number | Rectangle.RectangleLike | Rectangle.RectangleData,\n    y?: number,\n    width?: number,\n    height?: number,\n  ): this {\n    const rect = Rectangle.create(x, y, width, height)\n    const minX = Math.min(this.x, rect.x)\n    const minY = Math.min(this.y, rect.y)\n    const maxX = Math.max(this.x + this.width, rect.x + rect.width)\n    const maxY = Math.max(this.y + this.height, rect.y + rect.height)\n\n    this.x = minX\n    this.y = minY\n    this.width = maxX - minX\n    this.height = maxY - minY\n\n    return this\n  }\n\n  update(x: number, y: number, width: number, height: number): this\n  update(rect: Rectangle.RectangleLike | Rectangle.RectangleData): this\n  update(\n    x: number | Rectangle.RectangleLike | Rectangle.RectangleData,\n    y?: number,\n    width?: number,\n    height?: number,\n  ): this {\n    const rect = Rectangle.create(x, y, width, height)\n    this.x = rect.x\n    this.y = rect.y\n    this.width = rect.width\n    this.height = rect.height\n    return this\n  }\n\n  inflate(amount: number): this\n  /**\n   * Returns a rectangle inflated in axis-x by `2*dx` and in axis-y by `2*dy`.\n   */\n  inflate(dx: number, dy: number): this\n  inflate(dx: number, dy?: number): this {\n    const w = dx\n    const h = dy != null ? dy : dx\n    this.x -= w\n    this.y -= h\n    this.width += 2 * w\n    this.height += 2 * h\n\n    return this\n  }\n\n  /**\n   * Adjust the position and dimensions of the rectangle such that its edges\n   * are on the nearest increment of `gx` on the x-axis and `gy` on the y-axis.\n   */\n  snapToGrid(gridSize: number): this\n  snapToGrid(gx: number, gy: number): this\n  snapToGrid(gx: number, gy?: number): this\n  snapToGrid(gx: number, gy?: number): this {\n    const origin = this.origin.snapToGrid(gx, gy)\n    const corner = this.corner.snapToGrid(gx, gy)\n    this.x = origin.x\n    this.y = origin.y\n    this.width = corner.x - origin.x\n    this.height = corner.y - origin.y\n    return this\n  }\n\n  translate(tx: number, ty: number): this\n  translate(p: Point.PointLike | Point.PointData): this\n  translate(tx: number | Point.PointLike | Point.PointData, ty?: number): this {\n    const p = Point.create(tx, ty)\n    this.x += p.x\n    this.y += p.y\n    return this\n  }\n\n  scale(\n    sx: number,\n    sy: number,\n    origin: Point.PointLike | Point.PointData = new Point(),\n  ) {\n    const pos = this.origin.scale(sx, sy, origin)\n    this.x = pos.x\n    this.y = pos.y\n    this.width *= sx\n    this.height *= sy\n    return this\n  }\n\n  rotate(\n    degree: number,\n    center: Point.PointLike | Point.PointData = this.getCenter(),\n  ) {\n    if (degree !== 0) {\n      const rad = Angle.toRad(degree)\n      const cos = Math.cos(rad)\n      const sin = Math.sin(rad)\n\n      let p1 = this.getOrigin()\n      let p2 = this.getTopRight()\n      let p3 = this.getBottomRight()\n      let p4 = this.getBottomLeft()\n\n      p1 = Point.rotateEx(p1, cos, sin, center)\n      p2 = Point.rotateEx(p2, cos, sin, center)\n      p3 = Point.rotateEx(p3, cos, sin, center)\n      p4 = Point.rotateEx(p4, cos, sin, center)\n\n      const rect = new Rectangle(p1.x, p1.y, 0, 0)\n      rect.add(p2.x, p2.y, 0, 0)\n      rect.add(p3.x, p3.y, 0, 0)\n      rect.add(p4.x, p4.y, 0, 0)\n\n      this.update(rect)\n    }\n    return this\n  }\n\n  rotate90() {\n    const t = (this.width - this.height) / 2\n    this.x += t\n    this.y -= t\n    const tmp = this.width\n    this.width = this.height\n    this.height = tmp\n\n    return this\n  }\n\n  /**\n   * Translates the rectangle by `rect.x` and `rect.y` and expand it by\n   * `rect.width` and `rect.height`.\n   */\n  moveAndExpand(rect: Rectangle.RectangleLike | Rectangle.RectangleData) {\n    const ref = Rectangle.clone(rect)\n    this.x += ref.x || 0\n    this.y += ref.y || 0\n    this.width += ref.width || 0\n    this.height += ref.height || 0\n    return this\n  }\n\n  /**\n   * Returns an object where `sx` and `sy` give the maximum scaling that can be\n   * applied to the rectangle so that it would still fit into `limit`. If\n   * `origin` is specified, the rectangle is scaled around it; otherwise, it is\n   * scaled around its center.\n   */\n  getMaxScaleToFit(\n    limit: Rectangle.RectangleLike | Rectangle.RectangleData,\n    origin: Point = this.center,\n  ) {\n    const rect = Rectangle.clone(limit)\n    const ox = origin.x\n    const oy = origin.y\n\n    // Find the maximal possible scale for all corners, so when the scale\n    // is applied the point is still inside the rectangle.\n    let sx1 = Infinity\n    let sx2 = Infinity\n    let sx3 = Infinity\n    let sx4 = Infinity\n    let sy1 = Infinity\n    let sy2 = Infinity\n    let sy3 = Infinity\n    let sy4 = Infinity\n\n    // Top Left\n    const p1 = rect.topLeft\n    if (p1.x < ox) {\n      sx1 = (this.x - ox) / (p1.x - ox)\n    }\n    if (p1.y < oy) {\n      sy1 = (this.y - oy) / (p1.y - oy)\n    }\n\n    // Bottom Right\n    const p2 = rect.bottomRight\n    if (p2.x > ox) {\n      sx2 = (this.x + this.width - ox) / (p2.x - ox)\n    }\n    if (p2.y > oy) {\n      sy2 = (this.y + this.height - oy) / (p2.y - oy)\n    }\n\n    // Top Right\n    const p3 = rect.topRight\n    if (p3.x > ox) {\n      sx3 = (this.x + this.width - ox) / (p3.x - ox)\n    }\n    if (p3.y < oy) {\n      sy3 = (this.y - oy) / (p3.y - oy)\n    }\n\n    // Bottom Left\n    const p4 = rect.bottomLeft\n    if (p4.x < ox) {\n      sx4 = (this.x - ox) / (p4.x - ox)\n    }\n    if (p4.y > oy) {\n      sy4 = (this.y + this.height - oy) / (p4.y - oy)\n    }\n\n    return {\n      sx: Math.min(sx1, sx2, sx3, sx4),\n      sy: Math.min(sy1, sy2, sy3, sy4),\n    }\n  }\n\n  /**\n   * Returns a number that specifies the maximum scaling that can be applied to\n   * the rectangle along both axes so that it would still fit into `limit`. If\n   * `origin` is specified, the rectangle is scaled around it; otherwise, it is\n   * scaled around its center.\n   */\n  getMaxUniformScaleToFit(\n    limit: Rectangle.RectangleLike | Rectangle.RectangleData,\n    origin: Point = this.center,\n  ) {\n    const scale = this.getMaxScaleToFit(limit, origin)\n    return Math.min(scale.sx, scale.sy)\n  }\n\n  /**\n   * Returns `true` if the point is inside the rectangle (inclusive).\n   * Returns `false` otherwise.\n   */\n  containsPoint(x: number, y: number): boolean\n  containsPoint(point: Point.PointLike | Point.PointData): boolean\n  containsPoint(\n    x: number | Point.PointLike | Point.PointData,\n    y?: number,\n  ): boolean {\n    return GeometryUtil.containsPoint(this, Point.create(x, y))\n  }\n\n  /**\n   * Returns `true` if the rectangle is (completely) inside the\n   * rectangle (inclusive). Returns `false` otherwise.\n   */\n  containsRect(x: number, y: number, w: number, h: number): boolean\n  containsRect(rect: Rectangle.RectangleLike | Rectangle.RectangleData): boolean\n  containsRect(\n    x: number | Rectangle.RectangleLike | Rectangle.RectangleData,\n    y?: number,\n    width?: number,\n    height?: number,\n  ) {\n    const b = Rectangle.create(x, y, width, height)\n    const x1 = this.x\n    const y1 = this.y\n    const w1 = this.width\n    const h1 = this.height\n\n    const x2 = b.x\n    const y2 = b.y\n    const w2 = b.width\n    const h2 = b.height\n\n    // one of the dimensions is 0\n    if (w1 === 0 || h1 === 0 || w2 === 0 || h2 === 0) {\n      return false\n    }\n\n    return x2 >= x1 && y2 >= y1 && x2 + w2 <= x1 + w1 && y2 + h2 <= y1 + h1\n  }\n\n  /**\n   * Returns an array of the intersection points of the rectangle and the line.\n   * Return `null` if no intersection exists.\n   */\n  intersectsWithLine(line: Line) {\n    const rectLines = [\n      this.topLine,\n      this.rightLine,\n      this.bottomLine,\n      this.leftLine,\n    ]\n    const points: Point[] = []\n    const dedupeArr: string[] = []\n    rectLines.forEach((l) => {\n      const p = line.intersectsWithLine(l)\n      if (p !== null && dedupeArr.indexOf(p.toString()) < 0) {\n        points.push(p)\n        dedupeArr.push(p.toString())\n      }\n    })\n\n    return points.length > 0 ? points : null\n  }\n\n  /**\n   * Returns the point on the boundary of the rectangle that is the intersection\n   * of the rectangle with a line starting in the center the rectangle ending in\n   * the point `p`.\n   *\n   * If `angle` is specified, the intersection will take into account the\n   * rotation of the rectangle by `angle` degrees around its center.\n   */\n  intersectsWithLineFromCenterToPoint(\n    p: Point.PointLike | Point.PointData,\n    angle?: number,\n  ) {\n    const ref = Point.clone(p)\n    const center = this.center\n    let result: Point | null = null\n\n    if (angle != null && angle !== 0) {\n      ref.rotate(angle, center)\n    }\n\n    const sides = [this.topLine, this.rightLine, this.bottomLine, this.leftLine]\n    const connector = new Line(center, ref)\n\n    for (let i = sides.length - 1; i >= 0; i -= 1) {\n      const intersection = sides[i].intersectsWithLine(connector)\n      if (intersection !== null) {\n        result = intersection\n        break\n      }\n    }\n    if (result && angle != null && angle !== 0) {\n      result.rotate(-angle, center)\n    }\n\n    return result\n  }\n\n  /**\n   * Returns a rectangle that is a subtraction of the two rectangles if such an\n   * object exists (the two rectangles intersect). Returns `null` otherwise.\n   */\n  intersectsWithRect(\n    x: number,\n    y: number,\n    w: number,\n    h: number,\n  ): Rectangle | null\n  intersectsWithRect(\n    rect: Rectangle.RectangleLike | Rectangle.RectangleData,\n  ): Rectangle | null\n  intersectsWithRect(\n    x: number | Rectangle.RectangleLike | Rectangle.RectangleData,\n    y?: number,\n    width?: number,\n    height?: number,\n  ) {\n    const ref = Rectangle.create(x, y, width, height)\n\n    // no intersection\n    if (!this.isIntersectWithRect(ref)) {\n      return null\n    }\n\n    const myOrigin = this.origin\n    const myCorner = this.corner\n    const rOrigin = ref.origin\n    const rCorner = ref.corner\n\n    const xx = Math.max(myOrigin.x, rOrigin.x)\n    const yy = Math.max(myOrigin.y, rOrigin.y)\n\n    return new Rectangle(\n      xx,\n      yy,\n      Math.min(myCorner.x, rCorner.x) - xx,\n      Math.min(myCorner.y, rCorner.y) - yy,\n    )\n  }\n\n  isIntersectWithRect(x: number, y: number, w: number, h: number): boolean\n  isIntersectWithRect(\n    rect: Rectangle.RectangleLike | Rectangle.RectangleData,\n  ): boolean\n  isIntersectWithRect(\n    x: number | Rectangle.RectangleLike | Rectangle.RectangleData,\n    y?: number,\n    width?: number,\n    height?: number,\n  ) {\n    const ref = Rectangle.create(x, y, width, height)\n    const myOrigin = this.origin\n    const myCorner = this.corner\n    const rOrigin = ref.origin\n    const rCorner = ref.corner\n\n    if (\n      rCorner.x <= myOrigin.x ||\n      rCorner.y <= myOrigin.y ||\n      rOrigin.x >= myCorner.x ||\n      rOrigin.y >= myCorner.y\n    ) {\n      return false\n    }\n    return true\n  }\n\n  /**\n   * Normalize the rectangle, i.e. make it so that it has non-negative\n   * width and height. If width is less than `0`, the function swaps left and\n   * right corners and if height is less than `0`, the top and bottom corners\n   * are swapped.\n   */\n  normalize() {\n    let newx = this.x\n    let newy = this.y\n    let newwidth = this.width\n    let newheight = this.height\n    if (this.width < 0) {\n      newx = this.x + this.width\n      newwidth = -this.width\n    }\n    if (this.height < 0) {\n      newy = this.y + this.height\n      newheight = -this.height\n    }\n    this.x = newx\n    this.y = newy\n    this.width = newwidth\n    this.height = newheight\n    return this\n  }\n\n  /**\n   * Returns a rectangle that is a union of this rectangle and rectangle `rect`.\n   */\n  union(rect: Rectangle.RectangleLike | Rectangle.RectangleData) {\n    const ref = Rectangle.clone(rect)\n    const myOrigin = this.origin\n    const myCorner = this.corner\n    const rOrigin = ref.origin\n    const rCorner = ref.corner\n\n    const originX = Math.min(myOrigin.x, rOrigin.x)\n    const originY = Math.min(myOrigin.y, rOrigin.y)\n    const cornerX = Math.max(myCorner.x, rCorner.x)\n    const cornerY = Math.max(myCorner.y, rCorner.y)\n\n    return new Rectangle(originX, originY, cornerX - originX, cornerY - originY)\n  }\n\n  /**\n   * Returns a string (\"top\", \"left\", \"right\" or \"bottom\") denoting the side of\n   * the rectangle which is nearest to the point `p`.\n   */\n  getNearestSideToPoint(p: Point.PointLike | Point.PointData): Rectangle.Side {\n    const ref = Point.clone(p)\n    const distLeft = ref.x - this.x\n    const distRight = this.x + this.width - ref.x\n    const distTop = ref.y - this.y\n    const distBottom = this.y + this.height - ref.y\n    let closest = distLeft\n    let side: Rectangle.Side = 'left'\n\n    if (distRight < closest) {\n      closest = distRight\n      side = 'right'\n    }\n\n    if (distTop < closest) {\n      closest = distTop\n      side = 'top'\n    }\n\n    if (distBottom < closest) {\n      side = 'bottom'\n    }\n\n    return side\n  }\n\n  /**\n   * Returns a point on the boundary of the rectangle nearest to the point `p`.\n   */\n  getNearestPointToPoint(p: Point.PointLike | Point.PointData) {\n    const ref = Point.clone(p)\n    if (this.containsPoint(ref)) {\n      const side = this.getNearestSideToPoint(ref)\n      if (side === 'left') {\n        return new Point(this.x, ref.y)\n      }\n\n      if (side === 'top') {\n        return new Point(ref.x, this.y)\n      }\n\n      if (side === 'right') {\n        return new Point(this.x + this.width, ref.y)\n      }\n\n      if (side === 'bottom') {\n        return new Point(ref.x, this.y + this.height)\n      }\n    }\n\n    return ref.adhereToRect(this)\n  }\n\n  equals(rect: Rectangle.RectangleLike) {\n    return (\n      rect != null &&\n      rect.x === this.x &&\n      rect.y === this.y &&\n      rect.width === this.width &&\n      rect.height === this.height\n    )\n  }\n\n  clone() {\n    return new Rectangle(this.x, this.y, this.width, this.height)\n  }\n\n  toJSON() {\n    return { x: this.x, y: this.y, width: this.width, height: this.height }\n  }\n\n  serialize() {\n    return `${this.x} ${this.y} ${this.width} ${this.height}`\n  }\n}\n\nexport namespace Rectangle {\n  export function isRectangle(instance: any): instance is Rectangle {\n    return instance != null && instance instanceof Rectangle\n  }\n}\n\nexport namespace Rectangle {\n  export type RectangleData = [number, number, number, number]\n\n  export interface RectangleLike extends Point.PointLike {\n    x: number\n    y: number\n    width: number\n    height: number\n  }\n\n  export function isRectangleLike(o: any): o is RectangleLike {\n    return (\n      o != null &&\n      typeof o === 'object' &&\n      typeof o.x === 'number' &&\n      typeof o.y === 'number' &&\n      typeof o.width === 'number' &&\n      typeof o.height === 'number'\n    )\n  }\n\n  export type Side = 'left' | 'right' | 'top' | 'bottom'\n\n  export type KeyPoint =\n    | 'center'\n    | 'origin'\n    | 'corner'\n    | 'topLeft'\n    | 'topCenter'\n    | 'topRight'\n    | 'bottomLeft'\n    | 'bottomCenter'\n    | 'bottomRight'\n    | 'rightMiddle'\n    | 'leftMiddle'\n}\n\nexport namespace Rectangle {\n  export function create(rect: RectangleLike | RectangleData): Rectangle\n  export function create(\n    x?: number,\n    y?: number,\n    width?: number,\n    height?: number,\n  ): Rectangle\n  export function create(\n    x?: number | RectangleLike | RectangleData,\n    y?: number,\n    width?: number,\n    height?: number,\n  ): Rectangle\n  export function create(\n    x?: number | RectangleLike | RectangleData,\n    y?: number,\n    width?: number,\n    height?: number,\n  ): Rectangle {\n    if (x == null || typeof x === 'number') {\n      return new Rectangle(x, y, width, height)\n    }\n\n    return clone(x)\n  }\n\n  export function clone(rect: RectangleLike | RectangleData) {\n    if (Rectangle.isRectangle(rect)) {\n      return rect.clone()\n    }\n\n    if (Array.isArray(rect)) {\n      return new Rectangle(rect[0], rect[1], rect[2], rect[3])\n    }\n\n    return new Rectangle(rect.x, rect.y, rect.width, rect.height)\n  }\n\n  /**\n   * Returns a new rectangle from the given ellipse.\n   */\n  export function fromEllipse(ellipse: Ellipse) {\n    return new Rectangle(\n      ellipse.x - ellipse.a,\n      ellipse.y - ellipse.b,\n      2 * ellipse.a,\n      2 * ellipse.b,\n    )\n  }\n\n  interface Size {\n    width: number\n    height: number\n  }\n\n  export function fromSize(size: Size) {\n    return new Rectangle(0, 0, size.width, size.height)\n  }\n\n  export function fromPositionAndSize(pos: Point.PointLike, size: Size) {\n    return new Rectangle(pos.x, pos.y, size.width, size.height)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}