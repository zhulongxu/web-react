{"ast":null,"code":"import { resolve } from './util';\nconst middleSide = function (view, magnet, refPoint, options) {\n  let bbox;\n  let angle = 0;\n  let center;\n  const node = view.cell;\n  if (options.rotate) {\n    bbox = view.getUnrotatedBBoxOfElement(magnet);\n    center = node.getBBox().getCenter();\n    angle = node.getAngle();\n  } else {\n    bbox = view.getBBoxOfElement(magnet);\n  }\n  const padding = options.padding;\n  if (padding != null && Number.isFinite(padding)) {\n    bbox.inflate(padding);\n  }\n  if (options.rotate) {\n    refPoint.rotate(angle, center);\n  }\n  const side = bbox.getNearestSideToPoint(refPoint);\n  let result;\n  switch (side) {\n    case 'left':\n      result = bbox.getLeftMiddle();\n      break;\n    case 'right':\n      result = bbox.getRightMiddle();\n      break;\n    case 'top':\n      result = bbox.getTopCenter();\n      break;\n    case 'bottom':\n      result = bbox.getBottomCenter();\n      break;\n    default:\n      break;\n  }\n  const direction = options.direction;\n  if (direction === 'H') {\n    if (side === 'top' || side === 'bottom') {\n      if (refPoint.x <= bbox.x + bbox.width) {\n        result = bbox.getLeftMiddle();\n      } else {\n        result = bbox.getRightMiddle();\n      }\n    }\n  } else if (direction === 'V') {\n    if (refPoint.y <= bbox.y + bbox.height) {\n      result = bbox.getTopCenter();\n    } else {\n      result = bbox.getBottomCenter();\n    }\n  }\n  return options.rotate ? result.rotate(-angle, center) : result;\n};\n/**\n * Places the anchor of the edge in the middle of the side of view bbox\n * closest to the other endpoint.\n */\nexport const midSide = resolve(middleSide);","map":{"version":3,"names":["resolve","middleSide","view","magnet","refPoint","options","bbox","angle","center","node","cell","rotate","getUnrotatedBBoxOfElement","getBBox","getCenter","getAngle","getBBoxOfElement","padding","Number","isFinite","inflate","side","getNearestSideToPoint","result","getLeftMiddle","getRightMiddle","getTopCenter","getBottomCenter","direction","x","width","y","height","midSide"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/src/registry/node-anchor/middle-side.ts"],"sourcesContent":["import { Point } from '@antv/x6-geometry'\nimport { ResolveOptions, resolve } from './util'\nimport { NodeAnchor } from './index'\n\nexport interface MiddleSideEndpointOptions extends ResolveOptions {\n  rotate?: boolean\n  padding?: number\n  direction?: 'H' | 'V'\n}\n\nconst middleSide: NodeAnchor.ResolvedDefinition<MiddleSideEndpointOptions> =\n  function (view, magnet, refPoint, options) {\n    let bbox\n    let angle = 0\n    let center\n\n    const node = view.cell\n    if (options.rotate) {\n      bbox = view.getUnrotatedBBoxOfElement(magnet)\n      center = node.getBBox().getCenter()\n      angle = node.getAngle()\n    } else {\n      bbox = view.getBBoxOfElement(magnet)\n    }\n\n    const padding = options.padding\n    if (padding != null && Number.isFinite(padding)) {\n      bbox.inflate(padding)\n    }\n\n    if (options.rotate) {\n      refPoint.rotate(angle, center)\n    }\n\n    const side = bbox.getNearestSideToPoint(refPoint)\n    let result: Point\n    switch (side) {\n      case 'left':\n        result = bbox.getLeftMiddle()\n        break\n      case 'right':\n        result = bbox.getRightMiddle()\n        break\n      case 'top':\n        result = bbox.getTopCenter()\n        break\n      case 'bottom':\n        result = bbox.getBottomCenter()\n        break\n      default:\n        break\n    }\n\n    const direction = options.direction\n    if (direction === 'H') {\n      if (side === 'top' || side === 'bottom') {\n        if (refPoint.x <= bbox.x + bbox.width) {\n          result = bbox.getLeftMiddle()\n        } else {\n          result = bbox.getRightMiddle()\n        }\n      }\n    } else if (direction === 'V') {\n      if (refPoint.y <= bbox.y + bbox.height) {\n        result = bbox.getTopCenter()\n      } else {\n        result = bbox.getBottomCenter()\n      }\n    }\n\n    return options.rotate ? result!.rotate(-angle, center) : result!\n  }\n\n/**\n * Places the anchor of the edge in the middle of the side of view bbox\n * closest to the other endpoint.\n */\nexport const midSide = resolve<\n  NodeAnchor.ResolvedDefinition<ResolveOptions>,\n  NodeAnchor.Definition<ResolveOptions>\n>(middleSide)\n"],"mappings":"AACA,SAAyBA,OAAO,QAAQ,QAAQ;AAShD,MAAMC,UAAU,GACd,SAAAA,CAAUC,IAAI,EAAEC,MAAM,EAAEC,QAAQ,EAAEC,OAAO;EACvC,IAAIC,IAAI;EACR,IAAIC,KAAK,GAAG,CAAC;EACb,IAAIC,MAAM;EAEV,MAAMC,IAAI,GAAGP,IAAI,CAACQ,IAAI;EACtB,IAAIL,OAAO,CAACM,MAAM,EAAE;IAClBL,IAAI,GAAGJ,IAAI,CAACU,yBAAyB,CAACT,MAAM,CAAC;IAC7CK,MAAM,GAAGC,IAAI,CAACI,OAAO,EAAE,CAACC,SAAS,EAAE;IACnCP,KAAK,GAAGE,IAAI,CAACM,QAAQ,EAAE;GACxB,MAAM;IACLT,IAAI,GAAGJ,IAAI,CAACc,gBAAgB,CAACb,MAAM,CAAC;;EAGtC,MAAMc,OAAO,GAAGZ,OAAO,CAACY,OAAO;EAC/B,IAAIA,OAAO,IAAI,IAAI,IAAIC,MAAM,CAACC,QAAQ,CAACF,OAAO,CAAC,EAAE;IAC/CX,IAAI,CAACc,OAAO,CAACH,OAAO,CAAC;;EAGvB,IAAIZ,OAAO,CAACM,MAAM,EAAE;IAClBP,QAAQ,CAACO,MAAM,CAACJ,KAAK,EAAEC,MAAM,CAAC;;EAGhC,MAAMa,IAAI,GAAGf,IAAI,CAACgB,qBAAqB,CAAClB,QAAQ,CAAC;EACjD,IAAImB,MAAa;EACjB,QAAQF,IAAI;IACV,KAAK,MAAM;MACTE,MAAM,GAAGjB,IAAI,CAACkB,aAAa,EAAE;MAC7B;IACF,KAAK,OAAO;MACVD,MAAM,GAAGjB,IAAI,CAACmB,cAAc,EAAE;MAC9B;IACF,KAAK,KAAK;MACRF,MAAM,GAAGjB,IAAI,CAACoB,YAAY,EAAE;MAC5B;IACF,KAAK,QAAQ;MACXH,MAAM,GAAGjB,IAAI,CAACqB,eAAe,EAAE;MAC/B;IACF;MACE;;EAGJ,MAAMC,SAAS,GAAGvB,OAAO,CAACuB,SAAS;EACnC,IAAIA,SAAS,KAAK,GAAG,EAAE;IACrB,IAAIP,IAAI,KAAK,KAAK,IAAIA,IAAI,KAAK,QAAQ,EAAE;MACvC,IAAIjB,QAAQ,CAACyB,CAAC,IAAIvB,IAAI,CAACuB,CAAC,GAAGvB,IAAI,CAACwB,KAAK,EAAE;QACrCP,MAAM,GAAGjB,IAAI,CAACkB,aAAa,EAAE;OAC9B,MAAM;QACLD,MAAM,GAAGjB,IAAI,CAACmB,cAAc,EAAE;;;GAGnC,MAAM,IAAIG,SAAS,KAAK,GAAG,EAAE;IAC5B,IAAIxB,QAAQ,CAAC2B,CAAC,IAAIzB,IAAI,CAACyB,CAAC,GAAGzB,IAAI,CAAC0B,MAAM,EAAE;MACtCT,MAAM,GAAGjB,IAAI,CAACoB,YAAY,EAAE;KAC7B,MAAM;MACLH,MAAM,GAAGjB,IAAI,CAACqB,eAAe,EAAE;;;EAInC,OAAOtB,OAAO,CAACM,MAAM,GAAGY,MAAO,CAACZ,MAAM,CAAC,CAACJ,KAAK,EAAEC,MAAM,CAAC,GAAGe,MAAO;AAClE,CAAC;AAEH;;;;AAIA,OAAO,MAAMU,OAAO,GAAGjC,OAAO,CAG5BC,UAAU,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}