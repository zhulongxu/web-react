{"ast":null,"code":"export var DataUri;\n(function (DataUri) {\n  function isDataUrl(url) {\n    const prefix = 'data:';\n    return url.substr(0, prefix.length) === prefix;\n  }\n  DataUri.isDataUrl = isDataUrl;\n  /**\n   * Converts an image at `url` to base64-encoded data uri.\n   * The mime type of the image is inferred from the `url` file extension.\n   */\n  function imageToDataUri(url, callback) {\n    // No need to convert to data uri if it is already in data uri.\n    if (!url || isDataUrl(url)) {\n      // Keep the async nature of the function.\n      setTimeout(() => callback(null, url));\n      return;\n    }\n    const onError = () => {\n      callback(new Error(`Failed to load image: ${url}`));\n    };\n    const onLoad = window.FileReader ?\n    // chrome, IE10+\n    xhr => {\n      if (xhr.status === 200) {\n        const reader = new FileReader();\n        reader.onload = evt => {\n          const dataUri = evt.target.result;\n          callback(null, dataUri);\n        };\n        reader.onerror = onError;\n        reader.readAsDataURL(xhr.response);\n      } else {\n        onError();\n      }\n    } : xhr => {\n      const toString = u8a => {\n        const CHUNK_SZ = 0x8000;\n        const c = [];\n        for (let i = 0; i < u8a.length; i += CHUNK_SZ) {\n          c.push(String.fromCharCode.apply(null, u8a.subarray(i, i + CHUNK_SZ)));\n        }\n        return c.join('');\n      };\n      if (xhr.status === 200) {\n        let suffix = url.split('.').pop() || 'png';\n        if (suffix === 'svg') {\n          suffix = 'svg+xml';\n        }\n        const meta = `data:image/${suffix};base64,`;\n        const bytes = new Uint8Array(xhr.response);\n        const base64 = meta + btoa(toString(bytes));\n        callback(null, base64);\n      } else {\n        onError();\n      }\n    };\n    const xhr = new XMLHttpRequest();\n    xhr.responseType = window.FileReader ? 'blob' : 'arraybuffer';\n    xhr.open('GET', url, true);\n    xhr.addEventListener('error', onError);\n    xhr.addEventListener('load', () => onLoad(xhr));\n    xhr.send();\n  }\n  DataUri.imageToDataUri = imageToDataUri;\n  function dataUriToBlob(dataUrl) {\n    let uri = dataUrl.replace(/\\s/g, '');\n    uri = decodeURIComponent(uri);\n    const index = uri.indexOf(',');\n    const dataType = uri.slice(0, index); // e.g. 'data:image/jpeg;base64'\n    const mime = dataType.split(':')[1].split(';')[0]; // e.g. 'image/jpeg'\n    const data = uri.slice(index + 1);\n    let decodedString;\n    if (dataType.indexOf('base64') >= 0) {\n      // data may be encoded in base64\n      decodedString = atob(data);\n    } else {\n      // convert the decoded string to UTF-8\n      decodedString = unescape(encodeURIComponent(data));\n    }\n    // write the bytes of the string to a typed array\n    const ia = new Uint8Array(decodedString.length);\n    for (let i = 0; i < decodedString.length; i += 1) {\n      ia[i] = decodedString.charCodeAt(i);\n    }\n    return new Blob([ia], {\n      type: mime\n    });\n  }\n  DataUri.dataUriToBlob = dataUriToBlob;\n  function downloadBlob(blob, fileName) {\n    const msSaveBlob = window.navigator.msSaveBlob;\n    if (msSaveBlob) {\n      // requires IE 10+\n      // pulls up a save dialog\n      msSaveBlob(blob, fileName);\n    } else {\n      // other browsers\n      // downloads directly in Chrome and Safari\n      // presents a save/open dialog in Firefox\n      // Firefox bug: `from` field in save dialog always shows `from:blob:`\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1053327\n      const url = window.URL.createObjectURL(blob);\n      const link = document.createElement('a');\n      link.href = url;\n      link.download = fileName;\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n      // mark the url for garbage collection\n      window.URL.revokeObjectURL(url);\n    }\n  }\n  DataUri.downloadBlob = downloadBlob;\n  function downloadDataUri(dataUrl, fileName) {\n    const blob = dataUriToBlob(dataUrl);\n    downloadBlob(blob, fileName);\n  }\n  DataUri.downloadDataUri = downloadDataUri;\n  function parseViewBox(svg) {\n    const matches = svg.match(/<svg[^>]*viewBox\\s*=\\s*([\"']?)(.+?)\\1[^>]*>/i);\n    if (matches && matches[2]) {\n      return matches[2].replace(/\\s+/, ' ').split(' ');\n    }\n    return null;\n  }\n  function getNumber(str) {\n    const ret = parseFloat(str);\n    return Number.isNaN(ret) ? null : ret;\n  }\n  function svgToDataUrl(svg, options = {}) {\n    let viewBox = null;\n    const getNumberFromViewBox = index => {\n      if (viewBox == null) {\n        viewBox = parseViewBox(svg);\n      }\n      if (viewBox != null) {\n        return getNumber(viewBox[index]);\n      }\n      return null;\n    };\n    const getNumberFromMatches = reg => {\n      const matches = svg.match(reg);\n      if (matches && matches[2]) {\n        return getNumber(matches[2]);\n      }\n      return null;\n    };\n    let w = options.width;\n    if (w == null) {\n      w = getNumberFromMatches(/<svg[^>]*width\\s*=\\s*([\"']?)(.+?)\\1[^>]*>/i);\n    }\n    if (w == null) {\n      w = getNumberFromViewBox(2);\n    }\n    if (w == null) {\n      throw new Error('Can not parse width from svg string');\n    }\n    let h = options.height;\n    if (h == null) {\n      h = getNumberFromMatches(/<svg[^>]*height\\s*=\\s*([\"']?)(.+?)\\1[^>]*>/i);\n    }\n    if (h == null) {\n      h = getNumberFromViewBox(3);\n    }\n    if (h == null) {\n      throw new Error('Can not parse height from svg string');\n    }\n    const decoded = encodeURIComponent(svg).replace(/'/g, '%27').replace(/\"/g, '%22');\n    const header = 'data:image/svg+xml';\n    const dataUrl = `${header},${decoded}`;\n    return dataUrl;\n  }\n  DataUri.svgToDataUrl = svgToDataUrl;\n})(DataUri || (DataUri = {}));","map":{"version":3,"names":["DataUri","isDataUrl","url","prefix","substr","length","imageToDataUri","callback","setTimeout","onError","Error","onLoad","window","FileReader","xhr","status","reader","onload","evt","dataUri","target","result","onerror","readAsDataURL","response","toString","u8a","CHUNK_SZ","c","i","push","String","fromCharCode","apply","subarray","join","suffix","split","pop","meta","bytes","Uint8Array","base64","btoa","XMLHttpRequest","responseType","open","addEventListener","send","dataUriToBlob","dataUrl","uri","replace","decodeURIComponent","index","indexOf","dataType","slice","mime","data","decodedString","atob","unescape","encodeURIComponent","ia","charCodeAt","Blob","type","downloadBlob","blob","fileName","msSaveBlob","navigator","URL","createObjectURL","link","document","createElement","href","download","body","appendChild","click","removeChild","revokeObjectURL","downloadDataUri","parseViewBox","svg","matches","match","getNumber","str","ret","parseFloat","Number","isNaN","svgToDataUrl","options","viewBox","getNumberFromViewBox","getNumberFromMatches","reg","w","width","h","height","decoded","header"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/src/datauri/index.ts"],"sourcesContent":["export namespace DataUri {\n  export function isDataUrl(url: string) {\n    const prefix = 'data:'\n    return url.substr(0, prefix.length) === prefix\n  }\n\n  /**\n   * Converts an image at `url` to base64-encoded data uri.\n   * The mime type of the image is inferred from the `url` file extension.\n   */\n  export function imageToDataUri(\n    url: string,\n    callback: (err: Error | null, dataUri?: string) => any,\n  ) {\n    // No need to convert to data uri if it is already in data uri.\n    if (!url || isDataUrl(url)) {\n      // Keep the async nature of the function.\n      setTimeout(() => callback(null, url))\n      return\n    }\n\n    const onError = () => {\n      callback(new Error(`Failed to load image: ${url}`))\n    }\n\n    const onLoad = window.FileReader\n      ? // chrome, IE10+\n        (xhr: XMLHttpRequest) => {\n          if (xhr.status === 200) {\n            const reader = new FileReader()\n            reader.onload = (evt) => {\n              const dataUri = evt.target!.result as string\n              callback(null, dataUri)\n            }\n\n            reader.onerror = onError\n            reader.readAsDataURL(xhr.response)\n          } else {\n            onError()\n          }\n        }\n      : (xhr: XMLHttpRequest) => {\n          const toString = (u8a: Uint8Array) => {\n            const CHUNK_SZ = 0x8000\n            const c = []\n            for (let i = 0; i < u8a.length; i += CHUNK_SZ) {\n              c.push(\n                String.fromCharCode.apply(null, u8a.subarray(i, i + CHUNK_SZ)),\n              )\n            }\n            return c.join('')\n          }\n\n          if (xhr.status === 200) {\n            let suffix = url.split('.').pop() || 'png'\n            if (suffix === 'svg') {\n              suffix = 'svg+xml'\n            }\n            const meta = `data:image/${suffix};base64,`\n            const bytes = new Uint8Array(xhr.response)\n            const base64 = meta + btoa(toString(bytes))\n            callback(null, base64)\n          } else {\n            onError()\n          }\n        }\n\n    const xhr = new XMLHttpRequest()\n    xhr.responseType = window.FileReader ? 'blob' : 'arraybuffer'\n    xhr.open('GET', url, true)\n    xhr.addEventListener('error', onError)\n    xhr.addEventListener('load', () => onLoad(xhr))\n    xhr.send()\n  }\n\n  export function dataUriToBlob(dataUrl: string) {\n    let uri = dataUrl.replace(/\\s/g, '')\n    uri = decodeURIComponent(uri)\n\n    const index = uri.indexOf(',')\n    const dataType = uri.slice(0, index) // e.g. 'data:image/jpeg;base64'\n    const mime = dataType.split(':')[1].split(';')[0] // e.g. 'image/jpeg'\n\n    const data = uri.slice(index + 1)\n    let decodedString: string\n    if (dataType.indexOf('base64') >= 0) {\n      // data may be encoded in base64\n      decodedString = atob(data)\n    } else {\n      // convert the decoded string to UTF-8\n      decodedString = unescape(encodeURIComponent(data))\n    }\n\n    // write the bytes of the string to a typed array\n    const ia = new Uint8Array(decodedString.length)\n    for (let i = 0; i < decodedString.length; i += 1) {\n      ia[i] = decodedString.charCodeAt(i)\n    }\n\n    return new Blob([ia], { type: mime })\n  }\n\n  export function downloadBlob(blob: Blob, fileName: string) {\n    const msSaveBlob = (window.navigator as any).msSaveBlob\n    if (msSaveBlob) {\n      // requires IE 10+\n      // pulls up a save dialog\n      msSaveBlob(blob, fileName)\n    } else {\n      // other browsers\n      // downloads directly in Chrome and Safari\n\n      // presents a save/open dialog in Firefox\n      // Firefox bug: `from` field in save dialog always shows `from:blob:`\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1053327\n\n      const url = window.URL.createObjectURL(blob)\n      const link = document.createElement('a')\n\n      link.href = url\n      link.download = fileName\n      document.body.appendChild(link)\n\n      link.click()\n\n      document.body.removeChild(link)\n      // mark the url for garbage collection\n      window.URL.revokeObjectURL(url)\n    }\n  }\n\n  export function downloadDataUri(dataUrl: string, fileName: string) {\n    const blob = dataUriToBlob(dataUrl)\n    downloadBlob(blob, fileName)\n  }\n\n  function parseViewBox(svg: string) {\n    const matches = svg.match(/<svg[^>]*viewBox\\s*=\\s*([\"']?)(.+?)\\1[^>]*>/i)\n    if (matches && matches[2]) {\n      return matches[2].replace(/\\s+/, ' ').split(' ')\n    }\n    return null\n  }\n\n  function getNumber(str: string) {\n    const ret = parseFloat(str)\n    return Number.isNaN(ret) ? null : ret\n  }\n\n  export function svgToDataUrl(\n    svg: string,\n    options: {\n      width?: number | null\n      height?: number | null\n    } = {},\n  ) {\n    let viewBox: string[] | null = null\n\n    const getNumberFromViewBox = (index: number) => {\n      if (viewBox == null) {\n        viewBox = parseViewBox(svg)\n      }\n      if (viewBox != null) {\n        return getNumber(viewBox[index])\n      }\n      return null\n    }\n\n    const getNumberFromMatches = (reg: RegExp) => {\n      const matches = svg.match(reg)\n      if (matches && matches[2]) {\n        return getNumber(matches[2])\n      }\n      return null\n    }\n\n    let w = options.width\n    if (w == null) {\n      w = getNumberFromMatches(/<svg[^>]*width\\s*=\\s*([\"']?)(.+?)\\1[^>]*>/i)\n    }\n\n    if (w == null) {\n      w = getNumberFromViewBox(2)\n    }\n\n    if (w == null) {\n      throw new Error('Can not parse width from svg string')\n    }\n\n    let h = options.height\n    if (h == null) {\n      h = getNumberFromMatches(/<svg[^>]*height\\s*=\\s*([\"']?)(.+?)\\1[^>]*>/i)\n    }\n\n    if (h == null) {\n      h = getNumberFromViewBox(3)\n    }\n\n    if (h == null) {\n      throw new Error('Can not parse height from svg string')\n    }\n\n    const decoded = encodeURIComponent(svg)\n      .replace(/'/g, '%27')\n      .replace(/\"/g, '%22')\n\n    const header = 'data:image/svg+xml'\n    const dataUrl = `${header},${decoded}`\n\n    return dataUrl\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}