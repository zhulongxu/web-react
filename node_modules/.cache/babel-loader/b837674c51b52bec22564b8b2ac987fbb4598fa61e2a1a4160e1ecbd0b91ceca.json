{"ast":null,"code":"/* eslint-disable no-control-regex */\nimport { StringExt } from '../string';\nimport { Text } from '../text';\nimport { attr } from './attr';\nimport { Vector } from '../vector';\nimport { createSvgElement, empty } from './elem';\nfunction createTextPathNode(attrs, elem) {\n  const vel = Vector.create(elem);\n  const textPath = Vector.create('textPath');\n  const d = attrs.d;\n  if (d && attrs['xlink:href'] === undefined) {\n    const path = Vector.create('path').attr('d', d).appendTo(vel.defs());\n    textPath.attr('xlink:href', `#${path.id}`);\n  }\n  if (typeof attrs === 'object') {\n    textPath.attr(attrs);\n  }\n  return textPath.node;\n}\nfunction annotateTextLine(lineNode, lineAnnotations, options) {\n  const eol = options.eol;\n  const baseSize = options.baseSize;\n  const lineHeight = options.lineHeight;\n  let maxFontSize = 0;\n  let tspanNode;\n  const fontMetrics = {};\n  const lastJ = lineAnnotations.length - 1;\n  for (let j = 0; j <= lastJ; j += 1) {\n    let annotation = lineAnnotations[j];\n    let fontSize = null;\n    if (typeof annotation === 'object') {\n      const annotationAttrs = annotation.attrs;\n      const vTSpan = Vector.create('tspan', annotationAttrs);\n      tspanNode = vTSpan.node;\n      let t = annotation.t;\n      if (eol && j === lastJ) {\n        t += eol;\n      }\n      tspanNode.textContent = t;\n      // Per annotation className\n      const annotationClass = annotationAttrs.class;\n      if (annotationClass) {\n        vTSpan.addClass(annotationClass);\n      }\n      // set the list of indices of all the applied annotations\n      // in the `annotations` attribute. This list is a comma\n      // separated list of indices.\n      if (options.includeAnnotationIndices) {\n        vTSpan.attr('annotations', annotation.annotations.join(','));\n      }\n      // Check for max font size\n      fontSize = parseFloat(annotationAttrs['font-size']);\n      if (fontSize === undefined) fontSize = baseSize;\n      if (fontSize && fontSize > maxFontSize) maxFontSize = fontSize;\n    } else {\n      if (eol && j === lastJ) {\n        annotation += eol;\n      }\n      tspanNode = document.createTextNode(annotation || ' ');\n      if (baseSize && baseSize > maxFontSize) {\n        maxFontSize = baseSize;\n      }\n    }\n    lineNode.appendChild(tspanNode);\n  }\n  if (maxFontSize) {\n    fontMetrics.maxFontSize = maxFontSize;\n  }\n  if (lineHeight) {\n    fontMetrics.lineHeight = lineHeight;\n  } else if (maxFontSize) {\n    fontMetrics.lineHeight = maxFontSize * 1.2;\n  }\n  return fontMetrics;\n}\nconst emRegex = /em$/;\nfunction emToPx(em, fontSize) {\n  const numerical = parseFloat(em);\n  if (emRegex.test(em)) {\n    return numerical * fontSize;\n  }\n  return numerical;\n}\nfunction calculateDY(alignment, linesMetrics, baseSizePx, lineHeight) {\n  if (!Array.isArray(linesMetrics)) {\n    return 0;\n  }\n  const n = linesMetrics.length;\n  if (!n) return 0;\n  let lineMetrics = linesMetrics[0];\n  const flMaxFont = emToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;\n  let rLineHeights = 0;\n  const lineHeightPx = emToPx(lineHeight, baseSizePx);\n  for (let i = 1; i < n; i += 1) {\n    lineMetrics = linesMetrics[i];\n    const iLineHeight = emToPx(lineMetrics.lineHeight, baseSizePx) || lineHeightPx;\n    rLineHeights += iLineHeight;\n  }\n  const llMaxFont = emToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;\n  let dy;\n  switch (alignment) {\n    case 'middle':\n      dy = flMaxFont / 2 - 0.15 * llMaxFont - rLineHeights / 2;\n      break;\n    case 'bottom':\n      dy = -(0.25 * llMaxFont) - rLineHeights;\n      break;\n    case 'top':\n    default:\n      dy = 0.8 * flMaxFont;\n      break;\n  }\n  return dy;\n}\nexport function text(elem, content, options = {}) {\n  content = Text.sanitize(content); // eslint-disable-line\n  const eol = options.eol;\n  let textPath = options.textPath;\n  const verticalAnchor = options.textVerticalAnchor;\n  const namedVerticalAnchor = verticalAnchor === 'middle' || verticalAnchor === 'bottom' || verticalAnchor === 'top';\n  // Horizontal shift applied to all the lines but the first.\n  let x = options.x;\n  if (x === undefined) {\n    x = elem.getAttribute('x') || 0;\n  }\n  // Annotations\n  const iai = options.includeAnnotationIndices;\n  let annotations = options.annotations;\n  if (annotations && !Array.isArray(annotations)) {\n    annotations = [annotations];\n  }\n  // Shift all the <tspan> but first by one line (`1em`)\n  const defaultLineHeight = options.lineHeight;\n  const autoLineHeight = defaultLineHeight === 'auto';\n  const lineHeight = autoLineHeight ? '1.5em' : defaultLineHeight || '1em';\n  let needEmpty = true;\n  const childNodes = elem.childNodes;\n  if (childNodes.length === 1) {\n    const node = childNodes[0];\n    if (node && node.tagName.toUpperCase() === 'TITLE') {\n      needEmpty = false;\n    }\n  }\n  if (needEmpty) {\n    empty(elem);\n  }\n  attr(elem, {\n    // Preserve spaces, do not consecutive spaces to get collapsed to one.\n    'xml:space': 'preserve',\n    // An empty text gets rendered into the DOM in webkit-based browsers.\n    // In order to unify this behaviour across all browsers\n    // we rather hide the text element when it's empty.\n    display: content || options.displayEmpty ? null : 'none'\n  });\n  // Set default font-size if none\n  const strFontSize = attr(elem, 'font-size');\n  let fontSize = parseFloat(strFontSize);\n  if (!fontSize) {\n    fontSize = 16;\n    if ((namedVerticalAnchor || annotations) && !strFontSize) {\n      attr(elem, 'font-size', `${fontSize}`);\n    }\n  }\n  let containerNode;\n  if (textPath) {\n    // Now all the `<tspan>`s will be inside the `<textPath>`.\n    if (typeof textPath === 'string') {\n      textPath = {\n        d: textPath\n      };\n    }\n    containerNode = createTextPathNode(textPath, elem);\n  } else {\n    containerNode = document.createDocumentFragment();\n  }\n  let dy;\n  let offset = 0;\n  let annotatedY;\n  const lines = content.split('\\n');\n  const linesMetrics = [];\n  const lastI = lines.length - 1;\n  for (let i = 0; i <= lastI; i += 1) {\n    dy = lineHeight;\n    let lineClassName = 'v-line';\n    const lineNode = createSvgElement('tspan');\n    let lineMetrics;\n    let line = lines[i];\n    if (line) {\n      if (annotations) {\n        // Find the *compacted* annotations for this line.\n        const lineAnnotations = Text.annotate(line, annotations, {\n          offset: -offset,\n          includeAnnotationIndices: iai\n        });\n        lineMetrics = annotateTextLine(lineNode, lineAnnotations, {\n          eol: i !== lastI && eol,\n          baseSize: fontSize,\n          lineHeight: autoLineHeight ? null : lineHeight,\n          includeAnnotationIndices: iai\n        });\n        // Get the line height based on the biggest font size\n        // in the annotations for this line.\n        const iLineHeight = lineMetrics.lineHeight;\n        if (iLineHeight && autoLineHeight && i !== 0) {\n          dy = iLineHeight;\n        }\n        if (i === 0) {\n          annotatedY = lineMetrics.maxFontSize * 0.8;\n        }\n      } else {\n        if (eol && i !== lastI) {\n          line += eol;\n        }\n        lineNode.textContent = line;\n      }\n    } else {\n      // Make sure the textContent is never empty. If it is, add a dummy\n      // character and make it invisible, making the following lines correctly\n      // relatively positioned. `dy=1em` won't work with empty lines otherwise.\n      lineNode.textContent = '-';\n      lineClassName += ' v-empty-line';\n      const lineNodeStyle = lineNode.style;\n      lineNodeStyle.fillOpacity = 0;\n      lineNodeStyle.strokeOpacity = 0;\n      if (annotations) {\n        lineMetrics = {};\n      }\n    }\n    if (lineMetrics) {\n      linesMetrics.push(lineMetrics);\n    }\n    if (i > 0) {\n      lineNode.setAttribute('dy', dy);\n    }\n    // Firefox requires 'x' to be set on the first line\n    if (i > 0 || textPath) {\n      lineNode.setAttribute('x', x);\n    }\n    lineNode.className.baseVal = lineClassName;\n    containerNode.appendChild(lineNode);\n    offset += line.length + 1; // + 1 = newline character.\n  }\n  // Y Alignment calculation\n  if (namedVerticalAnchor) {\n    if (annotations) {\n      dy = calculateDY(verticalAnchor, linesMetrics, fontSize, lineHeight);\n    } else if (verticalAnchor === 'top') {\n      // A shortcut for top alignment. It does not depend on font-size nor line-height\n      dy = '0.8em';\n    } else {\n      let rh; // remaining height\n      if (lastI > 0) {\n        rh = parseFloat(lineHeight) || 1;\n        rh *= lastI;\n        if (!emRegex.test(lineHeight)) rh /= fontSize;\n      } else {\n        // Single-line text\n        rh = 0;\n      }\n      switch (verticalAnchor) {\n        case 'middle':\n          dy = `${0.3 - rh / 2}em`;\n          break;\n        case 'bottom':\n          dy = `${-rh - 0.3}em`;\n          break;\n        default:\n          break;\n      }\n    }\n  } else if (verticalAnchor === 0) {\n    dy = '0em';\n  } else if (verticalAnchor) {\n    dy = verticalAnchor;\n  } else {\n    // No vertical anchor is defined\n    dy = 0;\n    // Backwards compatibility - we change the `y` attribute instead of `dy`.\n    if (elem.getAttribute('y') == null) {\n      elem.setAttribute('y', `${annotatedY || '0.8em'}`);\n    }\n  }\n  const firstLine = containerNode.firstChild;\n  firstLine.setAttribute('dy', dy);\n  elem.appendChild(containerNode);\n}\nexport function measureText(text, styles = {}) {\n  const canvasContext = document.createElement('canvas').getContext('2d');\n  if (!text) {\n    return {\n      width: 0\n    };\n  }\n  const font = [];\n  const fontSize = styles['font-size'] ? `${parseFloat(styles['font-size'])}px` : '14px';\n  font.push(styles['font-style'] || 'normal');\n  font.push(styles['font-variant'] || 'normal');\n  font.push(styles['font-weight'] || 400);\n  font.push(fontSize);\n  font.push(styles['font-family'] || 'sans-serif');\n  canvasContext.font = font.join(' ');\n  return canvasContext.measureText(text);\n}\nexport function splitTextByLength(text, splitWidth, totalWidth, style = {}) {\n  if (splitWidth >= totalWidth) {\n    return [text, ''];\n  }\n  const length = text.length;\n  const caches = {};\n  let index = Math.round(splitWidth / totalWidth * length - 1);\n  if (index < 0) {\n    index = 0;\n  }\n  // eslint-disable-next-line\n  while (index >= 0 && index < length) {\n    const frontText = text.slice(0, index);\n    const frontWidth = caches[frontText] || measureText(frontText, style).width;\n    const behindText = text.slice(0, index + 1);\n    const behindWidth = caches[behindText] || measureText(behindText, style).width;\n    caches[frontText] = frontWidth;\n    caches[behindText] = behindWidth;\n    if (frontWidth > splitWidth) {\n      index -= 1;\n    } else if (behindWidth <= splitWidth) {\n      index += 1;\n    } else {\n      break;\n    }\n  }\n  return [text.slice(0, index), text.slice(index)];\n}\nexport function breakText(text, size, styles = {}, options = {}) {\n  const width = size.width;\n  const height = size.height;\n  const eol = options.eol || '\\n';\n  const fontSize = styles.fontSize || 14;\n  const lineHeight = styles.lineHeight ? parseFloat(styles.lineHeight) : Math.ceil(fontSize * 1.4);\n  const maxLines = Math.floor(height / lineHeight);\n  if (text.indexOf(eol) > -1) {\n    const delimiter = StringExt.uuid();\n    const splitText = [];\n    text.split(eol).map(line => {\n      const part = breakText(line, Object.assign(Object.assign({}, size), {\n        height: Number.MAX_SAFE_INTEGER\n      }), styles, Object.assign(Object.assign({}, options), {\n        eol: delimiter\n      }));\n      if (part) {\n        splitText.push(...part.split(delimiter));\n      }\n    });\n    return splitText.slice(0, maxLines).join(eol);\n  }\n  const {\n    width: textWidth\n  } = measureText(text, styles);\n  if (textWidth < width) {\n    return text;\n  }\n  const lines = [];\n  let remainText = text;\n  let remainWidth = textWidth;\n  let ellipsis = options.ellipsis;\n  let ellipsisWidth = 0;\n  if (ellipsis) {\n    if (typeof ellipsis !== 'string') {\n      ellipsis = '\\u2026';\n    }\n    ellipsisWidth = measureText(ellipsis, styles).width;\n  }\n  for (let i = 0; i < maxLines; i += 1) {\n    if (remainWidth > width) {\n      const isLast = i === maxLines - 1;\n      if (isLast) {\n        const [front] = splitTextByLength(remainText, width - ellipsisWidth, remainWidth, styles);\n        lines.push(ellipsis ? `${front}${ellipsis}` : front);\n      } else {\n        const [front, behind] = splitTextByLength(remainText, width, remainWidth, styles);\n        lines.push(front);\n        remainText = behind;\n        remainWidth = measureText(remainText, styles).width;\n      }\n    } else {\n      lines.push(remainText);\n      break;\n    }\n  }\n  return lines.join(eol);\n}","map":{"version":3,"names":["StringExt","Text","attr","Vector","createSvgElement","empty","createTextPathNode","attrs","elem","vel","create","textPath","d","undefined","path","appendTo","defs","id","node","annotateTextLine","lineNode","lineAnnotations","options","eol","baseSize","lineHeight","maxFontSize","tspanNode","fontMetrics","lastJ","length","j","annotation","fontSize","annotationAttrs","vTSpan","t","textContent","annotationClass","class","addClass","includeAnnotationIndices","annotations","join","parseFloat","document","createTextNode","appendChild","emRegex","emToPx","em","numerical","test","calculateDY","alignment","linesMetrics","baseSizePx","Array","isArray","n","lineMetrics","flMaxFont","rLineHeights","lineHeightPx","i","iLineHeight","llMaxFont","dy","text","content","sanitize","verticalAnchor","textVerticalAnchor","namedVerticalAnchor","x","getAttribute","iai","defaultLineHeight","autoLineHeight","needEmpty","childNodes","tagName","toUpperCase","display","displayEmpty","strFontSize","containerNode","createDocumentFragment","offset","annotatedY","lines","split","lastI","lineClassName","line","annotate","lineNodeStyle","style","fillOpacity","strokeOpacity","push","setAttribute","className","baseVal","rh","firstLine","firstChild","measureText","styles","canvasContext","createElement","getContext","width","font","splitTextByLength","splitWidth","totalWidth","caches","index","Math","round","frontText","slice","frontWidth","behindText","behindWidth","breakText","size","height","ceil","maxLines","floor","indexOf","delimiter","uuid","splitText","map","part","Object","assign","Number","MAX_SAFE_INTEGER","textWidth","remainText","remainWidth","ellipsis","ellipsisWidth","isLast","front","behind"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/src/dom/text.ts"],"sourcesContent":["/* eslint-disable no-control-regex */\n\nimport { Size } from '../types'\nimport { StringExt } from '../string'\nimport { Text } from '../text'\nimport { attr } from './attr'\nimport { Vector } from '../vector'\nimport { createSvgElement, empty } from './elem'\n\nfunction createTextPathNode(\n  attrs: { d?: string; 'xlink:href'?: string },\n  elem: SVGElement,\n) {\n  const vel = Vector.create(elem)\n  const textPath = Vector.create('textPath')\n  const d = attrs.d\n  if (d && attrs['xlink:href'] === undefined) {\n    const path = Vector.create('path').attr('d', d).appendTo(vel.defs())\n    textPath.attr('xlink:href', `#${path.id}`)\n  }\n\n  if (typeof attrs === 'object') {\n    textPath.attr(attrs as any)\n  }\n\n  return textPath.node\n}\n\nfunction annotateTextLine(\n  lineNode: SVGTSpanElement,\n  lineAnnotations: (string | Text.AnnotatedItem)[],\n  options: {\n    includeAnnotationIndices?: boolean\n    eol?: boolean | string\n    lineHeight: string | null\n    baseSize: number\n  },\n) {\n  const eol = options.eol\n  const baseSize = options.baseSize\n  const lineHeight = options.lineHeight\n\n  let maxFontSize = 0\n  let tspanNode\n  const fontMetrics: any = {}\n  const lastJ = lineAnnotations.length - 1\n\n  for (let j = 0; j <= lastJ; j += 1) {\n    let annotation = lineAnnotations[j]\n    let fontSize = null\n    if (typeof annotation === 'object') {\n      const annotationAttrs = annotation.attrs\n      const vTSpan = Vector.create('tspan', annotationAttrs)\n      tspanNode = vTSpan.node\n\n      let t = annotation.t\n      if (eol && j === lastJ) {\n        t += eol\n      }\n\n      tspanNode.textContent = t\n      // Per annotation className\n      const annotationClass = annotationAttrs.class as string\n      if (annotationClass) {\n        vTSpan.addClass(annotationClass)\n      }\n\n      // set the list of indices of all the applied annotations\n      // in the `annotations` attribute. This list is a comma\n      // separated list of indices.\n      if (options.includeAnnotationIndices) {\n        vTSpan.attr('annotations', annotation.annotations!.join(','))\n      }\n      // Check for max font size\n      fontSize = parseFloat(annotationAttrs['font-size'] as string)\n      if (fontSize === undefined) fontSize = baseSize\n      if (fontSize && fontSize > maxFontSize) maxFontSize = fontSize\n    } else {\n      if (eol && j === lastJ) {\n        annotation += eol\n      }\n      tspanNode = document.createTextNode(annotation || ' ')\n      if (baseSize && baseSize > maxFontSize) {\n        maxFontSize = baseSize\n      }\n    }\n\n    lineNode.appendChild(tspanNode)\n  }\n\n  if (maxFontSize) {\n    fontMetrics.maxFontSize = maxFontSize\n  }\n\n  if (lineHeight) {\n    fontMetrics.lineHeight = lineHeight\n  } else if (maxFontSize) {\n    fontMetrics.lineHeight = maxFontSize * 1.2\n  }\n\n  return fontMetrics\n}\n\nconst emRegex = /em$/\n\nfunction emToPx(em: string, fontSize: number) {\n  const numerical = parseFloat(em)\n  if (emRegex.test(em)) {\n    return numerical * fontSize\n  }\n\n  return numerical\n}\n\nfunction calculateDY(\n  alignment: string,\n  linesMetrics: any[],\n  baseSizePx: number,\n  lineHeight: string,\n) {\n  if (!Array.isArray(linesMetrics)) {\n    return 0\n  }\n\n  const n = linesMetrics.length\n  if (!n) return 0\n  let lineMetrics = linesMetrics[0]\n  const flMaxFont = emToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx\n  let rLineHeights = 0\n  const lineHeightPx = emToPx(lineHeight, baseSizePx)\n  for (let i = 1; i < n; i += 1) {\n    lineMetrics = linesMetrics[i]\n    const iLineHeight =\n      emToPx(lineMetrics.lineHeight, baseSizePx) || lineHeightPx\n    rLineHeights += iLineHeight\n  }\n  const llMaxFont = emToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx\n  let dy\n  switch (alignment) {\n    case 'middle':\n      dy = flMaxFont / 2 - 0.15 * llMaxFont - rLineHeights / 2\n      break\n    case 'bottom':\n      dy = -(0.25 * llMaxFont) - rLineHeights\n      break\n    case 'top':\n    default:\n      dy = 0.8 * flMaxFont\n      break\n  }\n  return dy\n}\n\nexport interface TextOptions {\n  /** Should we allow the text to be selected? */\n  displayEmpty?: boolean\n  /** End of Line character */\n  eol?: string\n  textPath?: string | { d?: string; 'xlink:href'?: string }\n  textVerticalAnchor?: 'middle' | 'bottom' | 'top' | number\n  x?: number | string\n  /** auto, 1.25em */\n  lineHeight?: string\n  includeAnnotationIndices?: boolean\n  annotations?: Text.Annotation | Text.Annotation[]\n}\n\nexport function text(\n  elem: SVGElement,\n  content: string,\n  options: TextOptions = {},\n) {\n  content = Text.sanitize(content) // eslint-disable-line\n  const eol = options.eol\n  let textPath = options.textPath\n  const verticalAnchor = options.textVerticalAnchor\n  const namedVerticalAnchor =\n    verticalAnchor === 'middle' ||\n    verticalAnchor === 'bottom' ||\n    verticalAnchor === 'top'\n\n  // Horizontal shift applied to all the lines but the first.\n  let x = options.x\n  if (x === undefined) {\n    x = elem.getAttribute('x') || 0\n  }\n\n  // Annotations\n  const iai = options.includeAnnotationIndices\n  let annotations = options.annotations\n  if (annotations && !Array.isArray(annotations)) {\n    annotations = [annotations]\n  }\n\n  // Shift all the <tspan> but first by one line (`1em`)\n  const defaultLineHeight = options.lineHeight\n  const autoLineHeight = defaultLineHeight === 'auto'\n  const lineHeight = autoLineHeight ? '1.5em' : defaultLineHeight || '1em'\n\n  let needEmpty = true\n  const childNodes = elem.childNodes\n  if (childNodes.length === 1) {\n    const node = childNodes[0] as any\n    if (node && node.tagName.toUpperCase() === 'TITLE') {\n      needEmpty = false\n    }\n  }\n\n  if (needEmpty) {\n    empty(elem)\n  }\n\n  attr(elem, {\n    // Preserve spaces, do not consecutive spaces to get collapsed to one.\n    'xml:space': 'preserve',\n    // An empty text gets rendered into the DOM in webkit-based browsers.\n    // In order to unify this behaviour across all browsers\n    // we rather hide the text element when it's empty.\n    display: content || options.displayEmpty ? null : 'none',\n  })\n\n  // Set default font-size if none\n  const strFontSize = attr(elem, 'font-size')\n  let fontSize = parseFloat(strFontSize)\n  if (!fontSize) {\n    fontSize = 16\n    if ((namedVerticalAnchor || annotations) && !strFontSize) {\n      attr(elem, 'font-size', `${fontSize}`)\n    }\n  }\n\n  let containerNode\n  if (textPath) {\n    // Now all the `<tspan>`s will be inside the `<textPath>`.\n    if (typeof textPath === 'string') {\n      textPath = { d: textPath }\n    }\n    containerNode = createTextPathNode(textPath as any, elem)\n  } else {\n    containerNode = document.createDocumentFragment()\n  }\n\n  let dy\n  let offset = 0\n  let annotatedY\n  const lines = content.split('\\n')\n  const linesMetrics = []\n  const lastI = lines.length - 1\n\n  for (let i = 0; i <= lastI; i += 1) {\n    dy = lineHeight\n    let lineClassName = 'v-line'\n    const lineNode = createSvgElement('tspan') as SVGTSpanElement\n\n    let lineMetrics\n    let line = lines[i]\n    if (line) {\n      if (annotations) {\n        // Find the *compacted* annotations for this line.\n        const lineAnnotations = Text.annotate(line, annotations, {\n          offset: -offset,\n          includeAnnotationIndices: iai,\n        })\n\n        lineMetrics = annotateTextLine(lineNode, lineAnnotations, {\n          eol: i !== lastI && eol,\n          baseSize: fontSize,\n          lineHeight: autoLineHeight ? null : lineHeight,\n          includeAnnotationIndices: iai,\n        })\n\n        // Get the line height based on the biggest font size\n        // in the annotations for this line.\n        const iLineHeight = lineMetrics.lineHeight\n        if (iLineHeight && autoLineHeight && i !== 0) {\n          dy = iLineHeight\n        }\n\n        if (i === 0) {\n          annotatedY = lineMetrics.maxFontSize * 0.8\n        }\n      } else {\n        if (eol && i !== lastI) {\n          line += eol\n        }\n\n        lineNode.textContent = line\n      }\n    } else {\n      // Make sure the textContent is never empty. If it is, add a dummy\n      // character and make it invisible, making the following lines correctly\n      // relatively positioned. `dy=1em` won't work with empty lines otherwise.\n      lineNode.textContent = '-'\n      lineClassName += ' v-empty-line'\n\n      const lineNodeStyle = lineNode.style as any\n      lineNodeStyle.fillOpacity = 0\n      lineNodeStyle.strokeOpacity = 0\n\n      if (annotations) {\n        lineMetrics = {}\n      }\n    }\n\n    if (lineMetrics) {\n      linesMetrics.push(lineMetrics)\n    }\n\n    if (i > 0) {\n      lineNode.setAttribute('dy', dy)\n    }\n\n    // Firefox requires 'x' to be set on the first line\n    if (i > 0 || textPath) {\n      lineNode.setAttribute('x', x as string)\n    }\n\n    lineNode.className.baseVal = lineClassName\n    containerNode.appendChild(lineNode)\n    offset += line.length + 1 // + 1 = newline character.\n  }\n\n  // Y Alignment calculation\n  if (namedVerticalAnchor) {\n    if (annotations) {\n      dy = calculateDY(\n        verticalAnchor as string,\n        linesMetrics,\n        fontSize,\n        lineHeight,\n      )\n    } else if (verticalAnchor === 'top') {\n      // A shortcut for top alignment. It does not depend on font-size nor line-height\n      dy = '0.8em'\n    } else {\n      let rh // remaining height\n      if (lastI > 0) {\n        rh = parseFloat(lineHeight) || 1\n        rh *= lastI\n        if (!emRegex.test(lineHeight)) rh /= fontSize\n      } else {\n        // Single-line text\n        rh = 0\n      }\n      switch (verticalAnchor) {\n        case 'middle':\n          dy = `${0.3 - rh / 2}em`\n          break\n        case 'bottom':\n          dy = `${-rh - 0.3}em`\n          break\n        default:\n          break\n      }\n    }\n  } else if (verticalAnchor === 0) {\n    dy = '0em'\n  } else if (verticalAnchor) {\n    dy = verticalAnchor\n  } else {\n    // No vertical anchor is defined\n    dy = 0\n    // Backwards compatibility - we change the `y` attribute instead of `dy`.\n    if (elem.getAttribute('y') == null) {\n      elem.setAttribute('y', `${annotatedY || '0.8em'}`)\n    }\n  }\n\n  const firstLine = containerNode.firstChild as SVGElement\n  firstLine.setAttribute('dy', dy)\n  elem.appendChild(containerNode)\n}\n\nexport function measureText(text: string, styles: any = {}) {\n  const canvasContext = document.createElement('canvas').getContext('2d')!\n  if (!text) {\n    return { width: 0 }\n  }\n  const font = []\n  const fontSize = styles['font-size']\n    ? `${parseFloat(styles['font-size'])}px`\n    : '14px'\n  font.push(styles['font-style'] || 'normal')\n  font.push(styles['font-variant'] || 'normal')\n  font.push(styles['font-weight'] || 400)\n  font.push(fontSize)\n  font.push(styles['font-family'] || 'sans-serif')\n\n  canvasContext.font = font.join(' ')\n\n  return canvasContext.measureText(text)\n}\n\nexport function splitTextByLength(\n  text: string,\n  splitWidth: number,\n  totalWidth: number,\n  style: any = {},\n) {\n  if (splitWidth >= totalWidth) {\n    return [text, '']\n  }\n  const length = text.length\n  const caches: Record<string, number> = {}\n  let index = Math.round((splitWidth / totalWidth) * length - 1)\n  if (index < 0) {\n    index = 0\n  }\n\n  // eslint-disable-next-line\n  while (index >= 0 && index < length) {\n    const frontText = text.slice(0, index)\n    const frontWidth = caches[frontText] || measureText(frontText, style).width\n    const behindText = text.slice(0, index + 1)\n    const behindWidth =\n      caches[behindText] || measureText(behindText, style).width\n\n    caches[frontText] = frontWidth\n    caches[behindText] = behindWidth\n\n    if (frontWidth > splitWidth) {\n      index -= 1\n    } else if (behindWidth <= splitWidth) {\n      index += 1\n    } else {\n      break\n    }\n  }\n\n  return [text.slice(0, index), text.slice(index)]\n}\n\nexport function breakText(\n  text: string,\n  size: Size,\n  styles: any = {},\n  options: {\n    ellipsis?: string\n    eol?: string\n  } = {},\n) {\n  const width = size.width\n  const height = size.height\n  const eol = options.eol || '\\n'\n  const fontSize = styles.fontSize || 14\n  const lineHeight = styles.lineHeight\n    ? parseFloat(styles.lineHeight)\n    : Math.ceil(fontSize * 1.4)\n  const maxLines = Math.floor(height / lineHeight)\n\n  if (text.indexOf(eol) > -1) {\n    const delimiter = StringExt.uuid()\n    const splitText: string[] = []\n\n    text.split(eol).map((line) => {\n      const part = breakText(line, { ...size, height: Number.MAX_SAFE_INTEGER }, styles, { ...options, eol: delimiter })\n\n      if (part) {\n        splitText.push(...part.split(delimiter))\n      }\n    })\n\n    return splitText.slice(0, maxLines).join(eol)\n  }\n\n  const { width: textWidth } = measureText(text, styles)\n\n  if (textWidth < width) {\n    return text\n  }\n\n  const lines = []\n\n  let remainText = text\n  let remainWidth = textWidth\n  let ellipsis = options.ellipsis\n  let ellipsisWidth = 0\n\n  if (ellipsis) {\n    if (typeof ellipsis !== 'string') {\n      ellipsis = '\\u2026'\n    }\n    ellipsisWidth = measureText(ellipsis, styles).width\n  }\n\n  for (let i = 0; i < maxLines; i += 1) {\n    if (remainWidth > width) {\n      const isLast = i === maxLines - 1\n      if (isLast) {\n        const [front] = splitTextByLength(\n          remainText,\n          width - ellipsisWidth,\n          remainWidth,\n          styles,\n        )\n        lines.push(ellipsis ? `${front}${ellipsis}` : front)\n      } else {\n        const [front, behind] = splitTextByLength(\n          remainText,\n          width,\n          remainWidth,\n          styles,\n        )\n        lines.push(front)\n        remainText = behind\n        remainWidth = measureText(remainText, styles).width\n      }\n    } else {\n      lines.push(remainText)\n      break\n    }\n  }\n\n  return lines.join(eol)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}