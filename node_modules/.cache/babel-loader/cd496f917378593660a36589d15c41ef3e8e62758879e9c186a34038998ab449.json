{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { Util } from './util';\nimport { EventHook } from './hook';\nimport { Store } from './store';\nimport { EventObject } from './object';\nimport './special';\nexport var Core;\n(function (Core) {\n  let triggered;\n  function on(elem, types, handler, data, selector) {\n    if (!Util.isValidTarget(elem)) {\n      return;\n    }\n    // Caller can pass in an object of custom data in lieu of the handler\n    let handlerData;\n    if (typeof handler !== 'function') {\n      const {\n          handler: h,\n          selector: s\n        } = handler,\n        others = __rest(handler, [\"handler\", \"selector\"]);\n      handler = h; // eslint-disable-line\n      selector = s; // eslint-disable-line\n      handlerData = others;\n    }\n    // Ensure that invalid selectors throw exceptions at attach time\n    // if (!Util.isValidSelector(elem, selector)) {\n    //   throw new Error('Delegate event with invalid selector.')\n    // }\n    const store = Store.ensure(elem);\n    // Ensure the main handle\n    let mainHandler = store.handler;\n    if (mainHandler == null) {\n      mainHandler = store.handler = function (e, ...args) {\n        return triggered !== e.type ? dispatch(elem, e, ...args) : undefined;\n      };\n    }\n    // Make sure that the handler has a unique ID, used to find/remove it later\n    const guid = Util.ensureHandlerId(handler);\n    // Handle multiple events separated by a space\n    Util.splitType(types).forEach(item => {\n      const {\n        originType,\n        namespaces\n      } = Util.normalizeType(item);\n      // There *must* be a type, no attaching namespace-only handlers\n      if (!originType) {\n        return;\n      }\n      let type = originType;\n      let hook = EventHook.get(type);\n      // If selector defined, determine special event type, otherwise given type\n      type = (selector ? hook.delegateType : hook.bindType) || type;\n      // Update hook based on newly reset type\n      hook = EventHook.get(type);\n      // handleObj is passed to all event handlers\n      const handleObj = Object.assign({\n        type,\n        originType,\n        data,\n        selector,\n        guid,\n        handler: handler,\n        namespace: namespaces.join('.')\n      }, handlerData);\n      // Init the event handler queue if we're the first\n      const events = store.events;\n      let bag = events[type];\n      if (!bag) {\n        bag = events[type] = {\n          handlers: [],\n          delegateCount: 0\n        };\n        // Only use addEventListener if the `hook.steup` returns false\n        if (!hook.setup || hook.setup(elem, data, namespaces, mainHandler) === false) {\n          Util.addEventListener(elem, type, mainHandler);\n        }\n      }\n      if (hook.add) {\n        Util.removeHandlerId(handleObj.handler);\n        hook.add(elem, handleObj);\n        Util.setHandlerId(handleObj.handler, guid);\n      }\n      // Add to the element's handler list, delegates in front\n      if (selector) {\n        bag.handlers.splice(bag.delegateCount, 0, handleObj);\n        bag.delegateCount += 1;\n      } else {\n        bag.handlers.push(handleObj);\n      }\n    });\n  }\n  Core.on = on;\n  function off(elem, types, handler, selector, mappedTypes) {\n    const store = Store.get(elem);\n    if (!store) {\n      return;\n    }\n    const events = store.events;\n    if (!events) {\n      return;\n    }\n    // Once for each type.namespace in types; type may be omitted\n    Util.splitType(types).forEach(item => {\n      const {\n        originType,\n        namespaces\n      } = Util.normalizeType(item);\n      // Unbind all events (on this namespace, if provided) for the element\n      if (!originType) {\n        Object.keys(events).forEach(key => {\n          off(elem, key + item, handler, selector, true);\n        });\n        return;\n      }\n      let type = originType;\n      const hook = EventHook.get(type);\n      type = (selector ? hook.delegateType : hook.bindType) || type;\n      const bag = events[type];\n      if (!bag) {\n        return;\n      }\n      const rns = namespaces.length > 0 ? new RegExp(`(^|\\\\.)${namespaces.join('\\\\.(?:.*\\\\.|)')}(\\\\.|$)`) : null;\n      // Remove matching events\n      const originHandlerCount = bag.handlers.length;\n      for (let i = bag.handlers.length - 1; i >= 0; i -= 1) {\n        const handleObj = bag.handlers[i];\n        if ((mappedTypes || originType === handleObj.originType) && (!handler || Util.getHandlerId(handler) === handleObj.guid) && (rns == null || handleObj.namespace && rns.test(handleObj.namespace)) && (selector == null || selector === handleObj.selector || selector === '**' && handleObj.selector)) {\n          bag.handlers.splice(i, 1);\n          if (handleObj.selector) {\n            bag.delegateCount -= 1;\n          }\n          if (hook.remove) {\n            hook.remove(elem, handleObj);\n          }\n        }\n      }\n      if (originHandlerCount && bag.handlers.length === 0) {\n        if (!hook.teardown || hook.teardown(elem, namespaces, store.handler) === false) {\n          Util.removeEventListener(elem, type, store.handler);\n        }\n        delete events[type];\n      }\n    });\n    // Remove data and the expando if it's no longer used\n    if (Object.keys(events).length === 0) {\n      Store.remove(elem);\n    }\n  }\n  Core.off = off;\n  function dispatch(elem, evt, ...args) {\n    const event = EventObject.create(evt);\n    event.delegateTarget = elem;\n    const hook = EventHook.get(event.type);\n    if (hook.preDispatch && hook.preDispatch(elem, event) === false) {\n      return;\n    }\n    const handlerQueue = Util.getHandlerQueue(elem, event);\n    // Run delegates first; they may want to stop propagation beneath us\n    for (let i = 0, l = handlerQueue.length; i < l && !event.isPropagationStopped(); i += 1) {\n      const matched = handlerQueue[i];\n      event.currentTarget = matched.elem;\n      for (let j = 0, k = matched.handlers.length; j < k && !event.isImmediatePropagationStopped(); j += 1) {\n        const handleObj = matched.handlers[j];\n        // If event is namespaced, then each handler is only invoked if it is\n        // specially universal or its namespaces are a superset of the event's.\n        if (event.rnamespace == null || handleObj.namespace && event.rnamespace.test(handleObj.namespace)) {\n          event.handleObj = handleObj;\n          event.data = handleObj.data;\n          const hookHandle = EventHook.get(handleObj.originType).handle;\n          const result = hookHandle ? hookHandle(matched.elem, event, ...args) : handleObj.handler.call(matched.elem, event, ...args);\n          if (result !== undefined) {\n            event.result = result;\n            if (result === false) {\n              event.preventDefault();\n              event.stopPropagation();\n            }\n          }\n        }\n      }\n    }\n    // Call the postDispatch hook for the mapped type\n    if (hook.postDispatch) {\n      hook.postDispatch(elem, event);\n    }\n    return event.result;\n  }\n  Core.dispatch = dispatch;\n  function trigger(event, eventArgs, elem, onlyHandlers) {\n    let eventObj = event;\n    let type = typeof event === 'string' ? event : event.type;\n    let namespaces = typeof event === 'string' || eventObj.namespace == null ? [] : eventObj.namespace.split('.');\n    const node = elem;\n    // Don't do events on text and comment nodes\n    if (node.nodeType === 3 || node.nodeType === 8) {\n      return;\n    }\n    if (type.indexOf('.') > -1) {\n      // Namespaced trigger; create a regexp to match event type in handle()\n      namespaces = type.split('.');\n      type = namespaces.shift();\n      namespaces.sort();\n    }\n    const ontype = type.indexOf(':') < 0 && `on${type}`;\n    // Caller can pass in a EventObject, Object, or just an event type string\n    eventObj = event instanceof EventObject ? event : new EventObject(type, typeof event === 'object' ? event : null);\n    eventObj.namespace = namespaces.join('.');\n    eventObj.rnamespace = eventObj.namespace ? new RegExp(`(^|\\\\.)${namespaces.join('\\\\.(?:.*\\\\.|)')}(\\\\.|$)`) : null;\n    // Clean up the event in case it is being reused\n    eventObj.result = undefined;\n    if (!eventObj.target) {\n      eventObj.target = node;\n    }\n    const args = [eventObj];\n    if (Array.isArray(eventArgs)) {\n      args.push(...eventArgs);\n    } else {\n      args.push(eventArgs);\n    }\n    const hook = EventHook.get(type);\n    if (!onlyHandlers && hook.trigger && hook.trigger(node, eventObj, eventArgs) === false) {\n      return;\n    }\n    let bubbleType;\n    // Determine event propagation path in advance, per W3C events spec.\n    // Bubble up to document, then to window; watch for a global ownerDocument\n    const eventPath = [node];\n    if (!onlyHandlers && !hook.noBubble && !Util.isWindow(node)) {\n      bubbleType = hook.delegateType || type;\n      let last = node;\n      let curr = node.parentNode;\n      while (curr != null) {\n        eventPath.push(curr);\n        last = curr;\n        curr = curr.parentNode;\n      }\n      // Only add window if we got to document\n      const doc = node.ownerDocument || document;\n      if (last === doc) {\n        const win = last.defaultView || last.parentWindow || window;\n        eventPath.push(win);\n      }\n    }\n    let lastElement = node;\n    // Fire handlers on the event path\n    for (let i = 0, l = eventPath.length; i < l && !eventObj.isPropagationStopped(); i += 1) {\n      const currElement = eventPath[i];\n      lastElement = currElement;\n      eventObj.type = i > 1 ? bubbleType : hook.bindType || type;\n      // Custom handler\n      const store = Store.get(currElement);\n      if (store) {\n        if (store.events[eventObj.type] && store.handler) {\n          store.handler.call(currElement, ...args);\n        }\n      }\n      // Native handler\n      const handle = ontype && currElement[ontype] || null;\n      if (handle && Util.isValidTarget(currElement)) {\n        eventObj.result = handle.call(currElement, ...args);\n        if (eventObj.result === false) {\n          eventObj.preventDefault();\n        }\n      }\n    }\n    eventObj.type = type;\n    // If nobody prevented the default action, do it now\n    if (!onlyHandlers && !eventObj.isDefaultPrevented()) {\n      const preventDefault = hook.preventDefault;\n      if ((preventDefault == null || preventDefault(eventPath.pop(), eventObj, eventArgs) === false) && Util.isValidTarget(node)) {\n        // Call a native DOM method on the target with the same name as the\n        // event. Don't do default actions on window.\n        if (ontype && typeof node[type] === 'function' && !Util.isWindow(node)) {\n          // Don't re-trigger an onFOO event when we call its FOO() method\n          const tmp = node[ontype];\n          if (tmp) {\n            node[ontype] = null;\n          }\n          // Prevent re-triggering of the same event, since we already bubbled it above\n          triggered = type;\n          if (eventObj.isPropagationStopped()) {\n            lastElement.addEventListener(type, Util.stopPropagationCallback);\n          }\n          node[type]();\n          if (eventObj.isPropagationStopped()) {\n            lastElement.removeEventListener(type, Util.stopPropagationCallback);\n          }\n          triggered = undefined;\n          if (tmp) {\n            node[ontype] = tmp;\n          }\n        }\n      }\n    }\n    return eventObj.result;\n  }\n  Core.trigger = trigger;\n})(Core || (Core = {}));","map":{"version":3,"names":["Util","EventHook","Store","EventObject","Core","triggered","on","elem","types","handler","data","selector","isValidTarget","handlerData","h","s","others","__rest","store","ensure","mainHandler","e","args","type","dispatch","undefined","guid","ensureHandlerId","splitType","forEach","item","originType","namespaces","normalizeType","hook","get","delegateType","bindType","handleObj","Object","assign","namespace","join","events","bag","handlers","delegateCount","setup","addEventListener","add","removeHandlerId","setHandlerId","splice","push","off","mappedTypes","keys","key","rns","length","RegExp","originHandlerCount","i","getHandlerId","test","remove","teardown","removeEventListener","evt","event","create","delegateTarget","preDispatch","handlerQueue","getHandlerQueue","l","isPropagationStopped","matched","currentTarget","j","k","isImmediatePropagationStopped","rnamespace","hookHandle","handle","result","call","preventDefault","stopPropagation","postDispatch","trigger","eventArgs","onlyHandlers","eventObj","split","node","nodeType","indexOf","shift","sort","ontype","target","Array","isArray","bubbleType","eventPath","noBubble","isWindow","last","curr","parentNode","doc","ownerDocument","document","win","defaultView","parentWindow","window","lastElement","currElement","isDefaultPrevented","pop","tmp","stopPropagationCallback"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/src/dom/event/core.ts"],"sourcesContent":["import { Util } from './util'\nimport { EventHook } from './hook'\nimport { Store } from './store'\nimport { EventObject } from './object'\nimport { EventHandler } from './types'\nimport './special'\n\nexport namespace Core {\n  let triggered: string | undefined\n\n  export function on(\n    elem: Store.EventTarget,\n    types: string,\n    handler:\n      | EventHandler<any, any>\n      | ({\n          handler: EventHandler<any, any>\n          selector?: string\n        } & Partial<Store.HandlerObject>),\n    data?: any,\n    selector?: string,\n  ) {\n    if (!Util.isValidTarget(elem)) {\n      return\n    }\n\n    // Caller can pass in an object of custom data in lieu of the handler\n    let handlerData: any\n    if (typeof handler !== 'function') {\n      const { handler: h, selector: s, ...others } = handler\n      handler = h // eslint-disable-line\n      selector = s // eslint-disable-line\n      handlerData = others\n    }\n\n    // Ensure that invalid selectors throw exceptions at attach time\n    // if (!Util.isValidSelector(elem, selector)) {\n    //   throw new Error('Delegate event with invalid selector.')\n    // }\n\n    const store = Store.ensure(elem)\n\n    // Ensure the main handle\n    let mainHandler = store.handler\n    if (mainHandler == null) {\n      mainHandler = store.handler = function (e, ...args: any[]) {\n        return triggered !== e.type ? dispatch(elem, e, ...args) : undefined\n      }\n    }\n\n    // Make sure that the handler has a unique ID, used to find/remove it later\n    const guid = Util.ensureHandlerId(handler)\n\n    // Handle multiple events separated by a space\n    Util.splitType(types).forEach((item) => {\n      const { originType, namespaces } = Util.normalizeType(item)\n\n      // There *must* be a type, no attaching namespace-only handlers\n      if (!originType) {\n        return\n      }\n\n      let type = originType\n      let hook = EventHook.get(type)\n\n      // If selector defined, determine special event type, otherwise given type\n      type = (selector ? hook.delegateType : hook.bindType) || type\n\n      // Update hook based on newly reset type\n      hook = EventHook.get(type)\n\n      // handleObj is passed to all event handlers\n      const handleObj: Store.HandlerObject = {\n        type,\n        originType,\n        data,\n        selector,\n        guid,\n        handler: handler as EventHandler<any, any>,\n        namespace: namespaces.join('.'),\n        ...handlerData,\n      }\n\n      // Init the event handler queue if we're the first\n      const events = store.events\n      let bag = events[type]\n      if (!bag) {\n        bag = events[type] = { handlers: [], delegateCount: 0 }\n\n        // Only use addEventListener if the `hook.steup` returns false\n        if (\n          !hook.setup ||\n          hook.setup(elem, data, namespaces, mainHandler!) === false\n        ) {\n          Util.addEventListener(\n            elem as Element,\n            type,\n            mainHandler as any as EventListener,\n          )\n        }\n      }\n\n      if (hook.add) {\n        Util.removeHandlerId(handleObj.handler)\n        hook.add(elem, handleObj)\n        Util.setHandlerId(handleObj.handler, guid)\n      }\n\n      // Add to the element's handler list, delegates in front\n      if (selector) {\n        bag.handlers.splice(bag.delegateCount, 0, handleObj)\n        bag.delegateCount += 1\n      } else {\n        bag.handlers.push(handleObj)\n      }\n    })\n  }\n\n  export function off(\n    elem: Store.EventTarget,\n    types: string,\n    handler?: EventHandler<any, any>,\n    selector?: string,\n    mappedTypes?: boolean,\n  ) {\n    const store = Store.get(elem)\n    if (!store) {\n      return\n    }\n\n    const events = store.events\n    if (!events) {\n      return\n    }\n\n    // Once for each type.namespace in types; type may be omitted\n    Util.splitType(types).forEach((item) => {\n      const { originType, namespaces } = Util.normalizeType(item)\n\n      // Unbind all events (on this namespace, if provided) for the element\n      if (!originType) {\n        Object.keys(events).forEach((key) => {\n          off(elem, key + item, handler, selector, true)\n        })\n        return\n      }\n\n      let type = originType\n      const hook = EventHook.get(type)\n      type = (selector ? hook.delegateType : hook.bindType) || type\n      const bag = events[type]\n      if (!bag) {\n        return\n      }\n      const rns =\n        namespaces.length > 0\n          ? new RegExp(`(^|\\\\.)${namespaces.join('\\\\.(?:.*\\\\.|)')}(\\\\.|$)`)\n          : null\n\n      // Remove matching events\n      const originHandlerCount = bag.handlers.length\n      for (let i = bag.handlers.length - 1; i >= 0; i -= 1) {\n        const handleObj = bag.handlers[i]\n        if (\n          (mappedTypes || originType === handleObj.originType) &&\n          (!handler || Util.getHandlerId(handler) === handleObj.guid) &&\n          (rns == null ||\n            (handleObj.namespace && rns.test(handleObj.namespace))) &&\n          (selector == null ||\n            selector === handleObj.selector ||\n            (selector === '**' && handleObj.selector))\n        ) {\n          bag.handlers.splice(i, 1)\n\n          if (handleObj.selector) {\n            bag.delegateCount -= 1\n          }\n\n          if (hook.remove) {\n            hook.remove(elem, handleObj)\n          }\n        }\n      }\n\n      if (originHandlerCount && bag.handlers.length === 0) {\n        if (\n          !hook.teardown ||\n          hook.teardown(elem, namespaces, store.handler!) === false\n        ) {\n          Util.removeEventListener(\n            elem as Element,\n            type,\n            store.handler as any as EventListener,\n          )\n        }\n\n        delete events[type]\n      }\n    })\n\n    // Remove data and the expando if it's no longer used\n    if (Object.keys(events).length === 0) {\n      Store.remove(elem)\n    }\n  }\n\n  export function dispatch(\n    elem: Store.EventTarget,\n    evt: Event | EventObject | string,\n    ...args: any[]\n  ) {\n    const event = EventObject.create(evt)\n    event.delegateTarget = elem as Element\n\n    const hook = EventHook.get(event.type)\n    if (hook.preDispatch && hook.preDispatch(elem, event) === false) {\n      return\n    }\n\n    const handlerQueue = Util.getHandlerQueue(elem, event)\n\n    // Run delegates first; they may want to stop propagation beneath us\n    for (\n      let i = 0, l = handlerQueue.length;\n      i < l && !event.isPropagationStopped();\n      i += 1\n    ) {\n      const matched = handlerQueue[i]\n      event.currentTarget = matched.elem\n\n      for (\n        let j = 0, k = matched.handlers.length;\n        j < k && !event.isImmediatePropagationStopped();\n        j += 1\n      ) {\n        const handleObj = matched.handlers[j]\n        // If event is namespaced, then each handler is only invoked if it is\n        // specially universal or its namespaces are a superset of the event's.\n        if (\n          event.rnamespace == null ||\n          (handleObj.namespace && event.rnamespace.test(handleObj.namespace))\n        ) {\n          event.handleObj = handleObj\n          event.data = handleObj.data\n\n          const hookHandle = EventHook.get(handleObj.originType).handle\n\n          const result = hookHandle\n            ? hookHandle(matched.elem as Store.EventTarget, event, ...args)\n            : handleObj.handler.call(matched.elem, event, ...args)\n          if (result !== undefined) {\n            event.result = result\n            if (result === false) {\n              event.preventDefault()\n              event.stopPropagation()\n            }\n          }\n        }\n      }\n    }\n\n    // Call the postDispatch hook for the mapped type\n    if (hook.postDispatch) {\n      hook.postDispatch(elem, event)\n    }\n\n    return event.result\n  }\n\n  export function trigger(\n    event:\n      | (Partial<EventObject.Event> & { type: string })\n      | EventObject\n      | string,\n    eventArgs: any,\n    elem: Store.EventTarget,\n    onlyHandlers?: boolean,\n  ) {\n    let eventObj = event as EventObject\n    let type = typeof event === 'string' ? event : event.type\n    let namespaces =\n      typeof event === 'string' || eventObj.namespace == null\n        ? []\n        : eventObj.namespace.split('.')\n\n    const node = elem as HTMLElement\n\n    // Don't do events on text and comment nodes\n    if (node.nodeType === 3 || node.nodeType === 8) {\n      return\n    }\n\n    if (type.indexOf('.') > -1) {\n      // Namespaced trigger; create a regexp to match event type in handle()\n      namespaces = type.split('.')\n      type = namespaces.shift()!\n      namespaces.sort()\n    }\n    const ontype = type.indexOf(':') < 0 && (`on${type}` as 'onclick')\n\n    // Caller can pass in a EventObject, Object, or just an event type string\n    eventObj =\n      event instanceof EventObject\n        ? event\n        : new EventObject(type, typeof event === 'object' ? event : null)\n\n    eventObj.namespace = namespaces.join('.')\n    eventObj.rnamespace = eventObj.namespace\n      ? new RegExp(`(^|\\\\.)${namespaces.join('\\\\.(?:.*\\\\.|)')}(\\\\.|$)`)\n      : null\n\n    // Clean up the event in case it is being reused\n    eventObj.result = undefined\n    if (!eventObj.target) {\n      eventObj.target = node\n    }\n\n    const args: [EventObject, ...any[]] = [eventObj]\n    if (Array.isArray(eventArgs)) {\n      args.push(...eventArgs)\n    } else {\n      args.push(eventArgs)\n    }\n\n    const hook = EventHook.get(type)\n    if (\n      !onlyHandlers &&\n      hook.trigger &&\n      hook.trigger(node, eventObj, eventArgs) === false\n    ) {\n      return\n    }\n\n    let bubbleType\n\n    // Determine event propagation path in advance, per W3C events spec.\n    // Bubble up to document, then to window; watch for a global ownerDocument\n    const eventPath = [node]\n    if (!onlyHandlers && !hook.noBubble && !Util.isWindow(node)) {\n      bubbleType = hook.delegateType || type\n\n      let last: Document | HTMLElement = node\n      let curr = node.parentNode as HTMLElement\n\n      while (curr != null) {\n        eventPath.push(curr)\n        last = curr\n        curr = curr.parentNode as HTMLElement\n      }\n\n      // Only add window if we got to document\n      const doc = node.ownerDocument || document\n      if ((last as any) === doc) {\n        const win =\n          (last as any).defaultView || (last as any).parentWindow || window\n        eventPath.push(win)\n      }\n    }\n\n    let lastElement = node\n    // Fire handlers on the event path\n    for (\n      let i = 0, l = eventPath.length;\n      i < l && !eventObj.isPropagationStopped();\n      i += 1\n    ) {\n      const currElement = eventPath[i]\n      lastElement = currElement\n\n      eventObj.type = i > 1 ? (bubbleType as string) : hook.bindType || type\n\n      // Custom handler\n      const store = Store.get(currElement as Element)\n      if (store) {\n        if (store.events[eventObj.type] && store.handler) {\n          store.handler.call(currElement, ...args)\n        }\n      }\n\n      // Native handler\n      const handle = (ontype && currElement[ontype]) || null\n      if (handle && Util.isValidTarget(currElement)) {\n        eventObj.result = handle.call(currElement, ...args)\n        if (eventObj.result === false) {\n          eventObj.preventDefault()\n        }\n      }\n    }\n\n    eventObj.type = type\n\n    // If nobody prevented the default action, do it now\n    if (!onlyHandlers && !eventObj.isDefaultPrevented()) {\n      const preventDefault = hook.preventDefault\n      if (\n        (preventDefault == null ||\n          preventDefault(eventPath.pop()!, eventObj, eventArgs) === false) &&\n        Util.isValidTarget(node)\n      ) {\n        // Call a native DOM method on the target with the same name as the\n        // event. Don't do default actions on window.\n        if (\n          ontype &&\n          typeof node[type as 'click'] === 'function' &&\n          !Util.isWindow(node)\n        ) {\n          // Don't re-trigger an onFOO event when we call its FOO() method\n          const tmp = node[ontype]\n          if (tmp) {\n            node[ontype] = null\n          }\n\n          // Prevent re-triggering of the same event, since we already bubbled it above\n          triggered = type\n\n          if (eventObj.isPropagationStopped()) {\n            lastElement.addEventListener(type, Util.stopPropagationCallback)\n          }\n\n          node[type as 'click']()\n\n          if (eventObj.isPropagationStopped()) {\n            lastElement.removeEventListener(type, Util.stopPropagationCallback)\n          }\n\n          triggered = undefined\n\n          if (tmp) {\n            node[ontype] = tmp\n          }\n        }\n      }\n    }\n\n    return eventObj.result\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}