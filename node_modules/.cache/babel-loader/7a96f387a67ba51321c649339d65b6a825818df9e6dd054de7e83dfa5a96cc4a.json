{"ast":null,"code":"import { Line } from './line';\nimport { Point } from './point';\nimport { Polyline } from './polyline';\nimport { Rectangle } from './rectangle';\nimport { Geometry } from './geometry';\nexport class Curve extends Geometry {\n  constructor(start, controlPoint1, controlPoint2, end) {\n    super();\n    this.PRECISION = 3;\n    this.start = Point.create(start);\n    this.controlPoint1 = Point.create(controlPoint1);\n    this.controlPoint2 = Point.create(controlPoint2);\n    this.end = Point.create(end);\n  }\n  bbox() {\n    const start = this.start;\n    const controlPoint1 = this.controlPoint1;\n    const controlPoint2 = this.controlPoint2;\n    const end = this.end;\n    const x0 = start.x;\n    const y0 = start.y;\n    const x1 = controlPoint1.x;\n    const y1 = controlPoint1.y;\n    const x2 = controlPoint2.x;\n    const y2 = controlPoint2.y;\n    const x3 = end.x;\n    const y3 = end.y;\n    const points = []; // local extremes\n    const tvalues = []; // t values of local extremes\n    const bounds = [[], []];\n    let a;\n    let b;\n    let c;\n    let t;\n    let t1;\n    let t2;\n    let b2ac;\n    let sqrtb2ac;\n    for (let i = 0; i < 2; i += 1) {\n      if (i === 0) {\n        b = 6 * x0 - 12 * x1 + 6 * x2;\n        a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n        c = 3 * x1 - 3 * x0;\n      } else {\n        b = 6 * y0 - 12 * y1 + 6 * y2;\n        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n        c = 3 * y1 - 3 * y0;\n      }\n      if (Math.abs(a) < 1e-12) {\n        if (Math.abs(b) < 1e-12) {\n          continue;\n        }\n        t = -c / b;\n        if (t > 0 && t < 1) tvalues.push(t);\n        continue;\n      }\n      b2ac = b * b - 4 * c * a;\n      sqrtb2ac = Math.sqrt(b2ac);\n      if (b2ac < 0) continue;\n      t1 = (-b + sqrtb2ac) / (2 * a);\n      if (t1 > 0 && t1 < 1) tvalues.push(t1);\n      t2 = (-b - sqrtb2ac) / (2 * a);\n      if (t2 > 0 && t2 < 1) tvalues.push(t2);\n    }\n    let x;\n    let y;\n    let mt;\n    let j = tvalues.length;\n    const jlen = j;\n    while (j) {\n      j -= 1;\n      t = tvalues[j];\n      mt = 1 - t;\n      x = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;\n      bounds[0][j] = x;\n      y = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;\n      bounds[1][j] = y;\n      points[j] = {\n        X: x,\n        Y: y\n      };\n    }\n    tvalues[jlen] = 0;\n    tvalues[jlen + 1] = 1;\n    points[jlen] = {\n      X: x0,\n      Y: y0\n    };\n    points[jlen + 1] = {\n      X: x3,\n      Y: y3\n    };\n    bounds[0][jlen] = x0;\n    bounds[1][jlen] = y0;\n    bounds[0][jlen + 1] = x3;\n    bounds[1][jlen + 1] = y3;\n    tvalues.length = jlen + 2;\n    bounds[0].length = jlen + 2;\n    bounds[1].length = jlen + 2;\n    points.length = jlen + 2;\n    const left = Math.min.apply(null, bounds[0]);\n    const top = Math.min.apply(null, bounds[1]);\n    const right = Math.max.apply(null, bounds[0]);\n    const bottom = Math.max.apply(null, bounds[1]);\n    return new Rectangle(left, top, right - left, bottom - top);\n  }\n  closestPoint(p, options = {}) {\n    return this.pointAtT(this.closestPointT(p, options));\n  }\n  closestPointLength(p, options = {}) {\n    const opts = this.getOptions(options);\n    return this.lengthAtT(this.closestPointT(p, opts), opts);\n  }\n  closestPointNormalizedLength(p, options = {}) {\n    const opts = this.getOptions(options);\n    const cpLength = this.closestPointLength(p, opts);\n    if (!cpLength) {\n      return 0;\n    }\n    const length = this.length(opts);\n    if (length === 0) {\n      return 0;\n    }\n    return cpLength / length;\n  }\n  closestPointT(p, options = {}) {\n    const precision = this.getPrecision(options);\n    const subdivisions = this.getDivisions(options);\n    const precisionRatio = Math.pow(10, -precision); // eslint-disable-line\n    let investigatedSubdivision = null;\n    let investigatedSubdivisionStartT = 0;\n    let investigatedSubdivisionEndT = 0;\n    let distFromStart = 0;\n    let distFromEnd = 0;\n    let chordLength = 0;\n    let minSumDist = null;\n    const count = subdivisions.length;\n    let piece = count > 0 ? 1 / count : 0;\n    subdivisions.forEach((division, i) => {\n      const startDist = division.start.distance(p);\n      const endDist = division.end.distance(p);\n      const sumDist = startDist + endDist;\n      if (minSumDist == null || sumDist < minSumDist) {\n        investigatedSubdivision = division;\n        investigatedSubdivisionStartT = i * piece;\n        investigatedSubdivisionEndT = (i + 1) * piece;\n        distFromStart = startDist;\n        distFromEnd = endDist;\n        minSumDist = sumDist;\n        chordLength = division.endpointDistance();\n      }\n    });\n    // Recursively divide investigated subdivision, until distance between\n    // baselinePoint and closest path endpoint is within `10^(-precision)`,\n    // then return the closest endpoint of that final subdivision.\n    // eslint-disable-next-line\n    while (true) {\n      // check if we have reached at least one required observed precision\n      // - calculated as: the difference in distances from point to start and end divided by the distance\n      // - note that this function is not monotonic = it doesn't converge stably but has \"teeth\"\n      // - the function decreases while one of the endpoints is fixed but \"jumps\" whenever we switch\n      // - this criterion works well for points lying far away from the curve\n      const startPrecisionRatio = distFromStart ? Math.abs(distFromStart - distFromEnd) / distFromStart : 0;\n      const endPrecisionRatio = distFromEnd != null ? Math.abs(distFromStart - distFromEnd) / distFromEnd : 0;\n      const hasRequiredPrecision = startPrecisionRatio < precisionRatio || endPrecisionRatio < precisionRatio;\n      // check if we have reached at least one required minimal distance\n      // - calculated as: the subdivision chord length multiplied by precisionRatio\n      // - calculation is relative so it will work for arbitrarily large/small curves and their subdivisions\n      // - this is a backup criterion that works well for points lying \"almost at\" the curve\n      const hasMiniStartDistance = distFromStart ? distFromStart < chordLength * precisionRatio : true;\n      const hasMiniEndDistance = distFromEnd ? distFromEnd < chordLength * precisionRatio : true;\n      const hasMiniDistance = hasMiniStartDistance || hasMiniEndDistance;\n      if (hasRequiredPrecision || hasMiniDistance) {\n        return distFromStart <= distFromEnd ? investigatedSubdivisionStartT : investigatedSubdivisionEndT;\n      }\n      // otherwise, set up for next iteration\n      const divided = investigatedSubdivision.divide(0.5);\n      piece /= 2;\n      const startDist1 = divided[0].start.distance(p);\n      const endDist1 = divided[0].end.distance(p);\n      const sumDist1 = startDist1 + endDist1;\n      const startDist2 = divided[1].start.distance(p);\n      const endDist2 = divided[1].end.distance(p);\n      const sumDist2 = startDist2 + endDist2;\n      if (sumDist1 <= sumDist2) {\n        investigatedSubdivision = divided[0];\n        investigatedSubdivisionEndT -= piece;\n        distFromStart = startDist1;\n        distFromEnd = endDist1;\n      } else {\n        investigatedSubdivision = divided[1];\n        investigatedSubdivisionStartT += piece;\n        distFromStart = startDist2;\n        distFromEnd = endDist2;\n      }\n    }\n  }\n  closestPointTangent(p, options = {}) {\n    return this.tangentAtT(this.closestPointT(p, options));\n  }\n  containsPoint(p, options = {}) {\n    const polyline = this.toPolyline(options);\n    return polyline.containsPoint(p);\n  }\n  divideAt(ratio, options = {}) {\n    if (ratio <= 0) {\n      return this.divideAtT(0);\n    }\n    if (ratio >= 1) {\n      return this.divideAtT(1);\n    }\n    const t = this.tAt(ratio, options);\n    return this.divideAtT(t);\n  }\n  divideAtLength(length, options = {}) {\n    const t = this.tAtLength(length, options);\n    return this.divideAtT(t);\n  }\n  divide(t) {\n    return this.divideAtT(t);\n  }\n  divideAtT(t) {\n    const start = this.start;\n    const controlPoint1 = this.controlPoint1;\n    const controlPoint2 = this.controlPoint2;\n    const end = this.end;\n    if (t <= 0) {\n      return [new Curve(start, start, start, start), new Curve(start, controlPoint1, controlPoint2, end)];\n    }\n    if (t >= 1) {\n      return [new Curve(start, controlPoint1, controlPoint2, end), new Curve(end, end, end, end)];\n    }\n    const dividerPoints = this.getSkeletonPoints(t);\n    const startControl1 = dividerPoints.startControlPoint1;\n    const startControl2 = dividerPoints.startControlPoint2;\n    const divider = dividerPoints.divider;\n    const dividerControl1 = dividerPoints.dividerControlPoint1;\n    const dividerControl2 = dividerPoints.dividerControlPoint2;\n    return [new Curve(start, startControl1, startControl2, divider), new Curve(divider, dividerControl1, dividerControl2, end)];\n  }\n  endpointDistance() {\n    return this.start.distance(this.end);\n  }\n  getSkeletonPoints(t) {\n    const start = this.start;\n    const control1 = this.controlPoint1;\n    const control2 = this.controlPoint2;\n    const end = this.end;\n    // shortcuts for `t` values that are out of range\n    if (t <= 0) {\n      return {\n        startControlPoint1: start.clone(),\n        startControlPoint2: start.clone(),\n        divider: start.clone(),\n        dividerControlPoint1: control1.clone(),\n        dividerControlPoint2: control2.clone()\n      };\n    }\n    if (t >= 1) {\n      return {\n        startControlPoint1: control1.clone(),\n        startControlPoint2: control2.clone(),\n        divider: end.clone(),\n        dividerControlPoint1: end.clone(),\n        dividerControlPoint2: end.clone()\n      };\n    }\n    const midpoint1 = new Line(start, control1).pointAt(t);\n    const midpoint2 = new Line(control1, control2).pointAt(t);\n    const midpoint3 = new Line(control2, end).pointAt(t);\n    const subControl1 = new Line(midpoint1, midpoint2).pointAt(t);\n    const subControl2 = new Line(midpoint2, midpoint3).pointAt(t);\n    const divideLine = new Line(subControl1, subControl2).pointAt(t);\n    return {\n      startControlPoint1: midpoint1,\n      startControlPoint2: subControl1,\n      divider: divideLine,\n      dividerControlPoint1: subControl2,\n      dividerControlPoint2: midpoint3\n    };\n  }\n  getSubdivisions(options = {}) {\n    const precision = this.getPrecision(options);\n    let subdivisions = [new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end)];\n    if (precision === 0) {\n      return subdivisions;\n    }\n    let previousLength = this.endpointDistance();\n    const precisionRatio = Math.pow(10, -precision); // eslint-disable-line\n    // Recursively divide curve at `t = 0.5`, until the difference between\n    // observed length at subsequent iterations is lower than precision.\n    let iteration = 0;\n    // eslint-disable-next-line\n    while (true) {\n      iteration += 1;\n      const divisions = [];\n      subdivisions.forEach(c => {\n        // dividing at t = 0.5 (not at middle length!)\n        const divided = c.divide(0.5);\n        divisions.push(divided[0], divided[1]);\n      });\n      // measure new length\n      const length = divisions.reduce((memo, c) => memo + c.endpointDistance(), 0);\n      // check if we have reached required observed precision\n      // sine-like curves may have the same observed length in iteration 0 and 1 - skip iteration 1\n      // not a problem for further iterations because cubic curves cannot have more than two local extrema\n      // (i.e. cubic curves cannot intersect the baseline more than once)\n      // therefore two subsequent iterations cannot produce sampling with equal length\n      const ratio = length !== 0 ? (length - previousLength) / length : 0;\n      if (iteration > 1 && ratio < precisionRatio) {\n        return divisions;\n      }\n      subdivisions = divisions;\n      previousLength = length;\n    }\n  }\n  length(options = {}) {\n    const divisions = this.getDivisions(options);\n    return divisions.reduce((memo, c) => {\n      return memo + c.endpointDistance();\n    }, 0);\n  }\n  lengthAtT(t, options = {}) {\n    if (t <= 0) {\n      return 0;\n    }\n    const precision = options.precision === undefined ? this.PRECISION : options.precision;\n    const subCurve = this.divide(t)[0];\n    return subCurve.length({\n      precision\n    });\n  }\n  pointAt(ratio, options = {}) {\n    if (ratio <= 0) {\n      return this.start.clone();\n    }\n    if (ratio >= 1) {\n      return this.end.clone();\n    }\n    const t = this.tAt(ratio, options);\n    return this.pointAtT(t);\n  }\n  pointAtLength(length, options = {}) {\n    const t = this.tAtLength(length, options);\n    return this.pointAtT(t);\n  }\n  pointAtT(t) {\n    if (t <= 0) {\n      return this.start.clone();\n    }\n    if (t >= 1) {\n      return this.end.clone();\n    }\n    return this.getSkeletonPoints(t).divider;\n  }\n  isDifferentiable() {\n    const start = this.start;\n    const control1 = this.controlPoint1;\n    const control2 = this.controlPoint2;\n    const end = this.end;\n    return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));\n  }\n  tangentAt(ratio, options = {}) {\n    if (!this.isDifferentiable()) return null;\n    if (ratio < 0) {\n      ratio = 0; // eslint-disable-line\n    } else if (ratio > 1) {\n      ratio = 1; // eslint-disable-line\n    }\n    const t = this.tAt(ratio, options);\n    return this.tangentAtT(t);\n  }\n  tangentAtLength(length, options = {}) {\n    if (!this.isDifferentiable()) {\n      return null;\n    }\n    const t = this.tAtLength(length, options);\n    return this.tangentAtT(t);\n  }\n  tangentAtT(t) {\n    if (!this.isDifferentiable()) {\n      return null;\n    }\n    if (t < 0) {\n      t = 0; // eslint-disable-line\n    }\n    if (t > 1) {\n      t = 1; // eslint-disable-line\n    }\n    const skeletonPoints = this.getSkeletonPoints(t);\n    const p1 = skeletonPoints.startControlPoint2;\n    const p2 = skeletonPoints.dividerControlPoint1;\n    const tangentStart = skeletonPoints.divider;\n    const tangentLine = new Line(p1, p2);\n    // move so that tangent line starts at the point requested\n    tangentLine.translate(tangentStart.x - p1.x, tangentStart.y - p1.y);\n    return tangentLine;\n  }\n  getPrecision(options = {}) {\n    return options.precision == null ? this.PRECISION : options.precision;\n  }\n  getDivisions(options = {}) {\n    if (options.subdivisions != null) {\n      return options.subdivisions;\n    }\n    const precision = this.getPrecision(options);\n    return this.getSubdivisions({\n      precision\n    });\n  }\n  getOptions(options = {}) {\n    const precision = this.getPrecision(options);\n    const subdivisions = this.getDivisions(options);\n    return {\n      precision,\n      subdivisions\n    };\n  }\n  tAt(ratio, options = {}) {\n    if (ratio <= 0) {\n      return 0;\n    }\n    if (ratio >= 1) {\n      return 1;\n    }\n    const opts = this.getOptions(options);\n    const total = this.length(opts);\n    const length = total * ratio;\n    return this.tAtLength(length, opts);\n  }\n  tAtLength(length, options = {}) {\n    let fromStart = true;\n    if (length < 0) {\n      fromStart = false;\n      length = -length; // eslint-disable-line\n    }\n    const precision = this.getPrecision(options);\n    const subdivisions = this.getDivisions(options);\n    const opts = {\n      precision,\n      subdivisions\n    };\n    let investigatedSubdivision = null;\n    let investigatedSubdivisionStartT;\n    let investigatedSubdivisionEndT;\n    let baselinePointDistFromStart = 0;\n    let baselinePointDistFromEnd = 0;\n    let memo = 0;\n    const count = subdivisions.length;\n    let piece = count > 0 ? 1 / count : 0;\n    for (let i = 0; i < count; i += 1) {\n      const index = fromStart ? i : count - 1 - i;\n      const division = subdivisions[i];\n      const dist = division.endpointDistance();\n      if (length <= memo + dist) {\n        investigatedSubdivision = division;\n        investigatedSubdivisionStartT = index * piece;\n        investigatedSubdivisionEndT = (index + 1) * piece;\n        baselinePointDistFromStart = fromStart ? length - memo : dist + memo - length;\n        baselinePointDistFromEnd = fromStart ? dist + memo - length : length - memo;\n        break;\n      }\n      memo += dist;\n    }\n    if (investigatedSubdivision == null) {\n      return fromStart ? 1 : 0;\n    }\n    // note that precision affects what length is recorded\n    // (imprecise measurements underestimate length by up to 10^(-precision) of the precise length)\n    // e.g. at precision 1, the length may be underestimated by up to 10% and cause this function to return 1\n    const total = this.length(opts);\n    const precisionRatio = Math.pow(10, -precision); // eslint-disable-line\n    // recursively divide investigated subdivision:\n    // until distance between baselinePoint and closest path endpoint is within 10^(-precision)\n    // then return the closest endpoint of that final subdivision\n    // eslint-disable-next-line\n    while (true) {\n      let ratio;\n      ratio = total !== 0 ? baselinePointDistFromStart / total : 0;\n      if (ratio < precisionRatio) {\n        return investigatedSubdivisionStartT;\n      }\n      ratio = total !== 0 ? baselinePointDistFromEnd / total : 0;\n      if (ratio < precisionRatio) {\n        return investigatedSubdivisionEndT;\n      }\n      // otherwise, set up for next iteration\n      let newBaselinePointDistFromStart;\n      let newBaselinePointDistFromEnd;\n      const divided = investigatedSubdivision.divide(0.5);\n      piece /= 2;\n      const baseline1Length = divided[0].endpointDistance();\n      const baseline2Length = divided[1].endpointDistance();\n      if (baselinePointDistFromStart <= baseline1Length) {\n        investigatedSubdivision = divided[0];\n        investigatedSubdivisionEndT -= piece;\n        newBaselinePointDistFromStart = baselinePointDistFromStart;\n        newBaselinePointDistFromEnd = baseline1Length - newBaselinePointDistFromStart;\n      } else {\n        investigatedSubdivision = divided[1];\n        investigatedSubdivisionStartT += piece;\n        newBaselinePointDistFromStart = baselinePointDistFromStart - baseline1Length;\n        newBaselinePointDistFromEnd = baseline2Length - newBaselinePointDistFromStart;\n      }\n      baselinePointDistFromStart = newBaselinePointDistFromStart;\n      baselinePointDistFromEnd = newBaselinePointDistFromEnd;\n    }\n  }\n  toPoints(options = {}) {\n    const subdivisions = this.getDivisions(options);\n    const points = [subdivisions[0].start.clone()];\n    subdivisions.forEach(c => points.push(c.end.clone()));\n    return points;\n  }\n  toPolyline(options = {}) {\n    return new Polyline(this.toPoints(options));\n  }\n  scale(sx, sy, origin) {\n    this.start.scale(sx, sy, origin);\n    this.controlPoint1.scale(sx, sy, origin);\n    this.controlPoint2.scale(sx, sy, origin);\n    this.end.scale(sx, sy, origin);\n    return this;\n  }\n  rotate(angle, origin) {\n    this.start.rotate(angle, origin);\n    this.controlPoint1.rotate(angle, origin);\n    this.controlPoint2.rotate(angle, origin);\n    this.end.rotate(angle, origin);\n    return this;\n  }\n  translate(tx, ty) {\n    if (typeof tx === 'number') {\n      this.start.translate(tx, ty);\n      this.controlPoint1.translate(tx, ty);\n      this.controlPoint2.translate(tx, ty);\n      this.end.translate(tx, ty);\n    } else {\n      this.start.translate(tx);\n      this.controlPoint1.translate(tx);\n      this.controlPoint2.translate(tx);\n      this.end.translate(tx);\n    }\n    return this;\n  }\n  equals(c) {\n    return c != null && this.start.equals(c.start) && this.controlPoint1.equals(c.controlPoint1) && this.controlPoint2.equals(c.controlPoint2) && this.end.equals(c.end);\n  }\n  clone() {\n    return new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n  }\n  toJSON() {\n    return {\n      start: this.start.toJSON(),\n      controlPoint1: this.controlPoint1.toJSON(),\n      controlPoint2: this.controlPoint2.toJSON(),\n      end: this.end.toJSON()\n    };\n  }\n  serialize() {\n    return [this.start.serialize(), this.controlPoint1.serialize(), this.controlPoint2.serialize(), this.end.serialize()].join(' ');\n  }\n}\n(function (Curve) {\n  function isCurve(instance) {\n    return instance != null && instance instanceof Curve;\n  }\n  Curve.isCurve = isCurve;\n})(Curve || (Curve = {}));\n(function (Curve) {\n  function getFirstControlPoints(rhs) {\n    const n = rhs.length;\n    const x = []; // `x` is a solution vector.\n    const tmp = [];\n    let b = 2.0;\n    x[0] = rhs[0] / b;\n    // Decomposition and forward substitution.\n    for (let i = 1; i < n; i += 1) {\n      tmp[i] = 1 / b;\n      b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];\n      x[i] = (rhs[i] - x[i - 1]) / b;\n    }\n    for (let i = 1; i < n; i += 1) {\n      // Backsubstitution.\n      x[n - i - 1] -= tmp[n - i] * x[n - i];\n    }\n    return x;\n  }\n  function getCurveControlPoints(points) {\n    const knots = points.map(p => Point.clone(p));\n    const firstControlPoints = [];\n    const secondControlPoints = [];\n    const n = knots.length - 1;\n    // Special case: Bezier curve should be a straight line.\n    if (n === 1) {\n      // 3P1 = 2P0 + P3\n      firstControlPoints[0] = new Point((2 * knots[0].x + knots[1].x) / 3, (2 * knots[0].y + knots[1].y) / 3);\n      // P2 = 2P1 â€“ P0\n      secondControlPoints[0] = new Point(2 * firstControlPoints[0].x - knots[0].x, 2 * firstControlPoints[0].y - knots[0].y);\n      return [firstControlPoints, secondControlPoints];\n    }\n    // Calculate first Bezier control points.\n    // Right hand side vector.\n    const rhs = [];\n    // Set right hand side X values.\n    for (let i = 1; i < n - 1; i += 1) {\n      rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n    }\n    rhs[0] = knots[0].x + 2 * knots[1].x;\n    rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0;\n    // Get first control points X-values.\n    const x = getFirstControlPoints(rhs);\n    // Set right hand side Y values.\n    for (let i = 1; i < n - 1; i += 1) {\n      rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\n    }\n    rhs[0] = knots[0].y + 2 * knots[1].y;\n    rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0;\n    // Get first control points Y-values.\n    const y = getFirstControlPoints(rhs);\n    // Fill output arrays.\n    for (let i = 0; i < n; i += 1) {\n      // First control point.\n      firstControlPoints.push(new Point(x[i], y[i]));\n      // Second control point.\n      if (i < n - 1) {\n        secondControlPoints.push(new Point(2 * knots[i + 1].x - x[i + 1], 2 * knots[i + 1].y - y[i + 1]));\n      } else {\n        secondControlPoints.push(new Point((knots[n].x + x[n - 1]) / 2, (knots[n].y + y[n - 1]) / 2));\n      }\n    }\n    return [firstControlPoints, secondControlPoints];\n  }\n  function throughPoints(points) {\n    if (points == null || Array.isArray(points) && points.length < 2) {\n      throw new Error('At least 2 points are required');\n    }\n    const controlPoints = getCurveControlPoints(points);\n    const curves = [];\n    for (let i = 0, ii = controlPoints[0].length; i < ii; i += 1) {\n      const controlPoint1 = new Point(controlPoints[0][i].x, controlPoints[0][i].y);\n      const controlPoint2 = new Point(controlPoints[1][i].x, controlPoints[1][i].y);\n      curves.push(new Curve(points[i], controlPoint1, controlPoint2, points[i + 1]));\n    }\n    return curves;\n  }\n  Curve.throughPoints = throughPoints;\n})(Curve || (Curve = {}));","map":{"version":3,"names":["Line","Point","Polyline","Rectangle","Geometry","Curve","constructor","start","controlPoint1","controlPoint2","end","PRECISION","create","bbox","x0","x","y0","y","x1","y1","x2","y2","x3","y3","points","tvalues","bounds","a","b","c","t","t1","t2","b2ac","sqrtb2ac","i","Math","abs","push","sqrt","mt","j","length","jlen","X","Y","left","min","apply","top","right","max","bottom","closestPoint","p","options","pointAtT","closestPointT","closestPointLength","opts","getOptions","lengthAtT","closestPointNormalizedLength","cpLength","precision","getPrecision","subdivisions","getDivisions","precisionRatio","pow","investigatedSubdivision","investigatedSubdivisionStartT","investigatedSubdivisionEndT","distFromStart","distFromEnd","chordLength","minSumDist","count","piece","forEach","division","startDist","distance","endDist","sumDist","endpointDistance","startPrecisionRatio","endPrecisionRatio","hasRequiredPrecision","hasMiniStartDistance","hasMiniEndDistance","hasMiniDistance","divided","divide","startDist1","endDist1","sumDist1","startDist2","endDist2","sumDist2","closestPointTangent","tangentAtT","containsPoint","polyline","toPolyline","divideAt","ratio","divideAtT","tAt","divideAtLength","tAtLength","dividerPoints","getSkeletonPoints","startControl1","startControlPoint1","startControl2","startControlPoint2","divider","dividerControl1","dividerControlPoint1","dividerControl2","dividerControlPoint2","control1","control2","clone","midpoint1","pointAt","midpoint2","midpoint3","subControl1","subControl2","divideLine","getSubdivisions","previousLength","iteration","divisions","reduce","memo","undefined","subCurve","pointAtLength","isDifferentiable","equals","tangentAt","tangentAtLength","skeletonPoints","p1","p2","tangentStart","tangentLine","translate","total","fromStart","baselinePointDistFromStart","baselinePointDistFromEnd","index","dist","newBaselinePointDistFromStart","newBaselinePointDistFromEnd","baseline1Length","baseline2Length","toPoints","scale","sx","sy","origin","rotate","angle","tx","ty","toJSON","serialize","join","isCurve","instance","getFirstControlPoints","rhs","n","tmp","getCurveControlPoints","knots","map","firstControlPoints","secondControlPoints","throughPoints","Array","isArray","Error","controlPoints","curves","ii"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6-geometry@2.0.5/node_modules/@antv/x6-geometry/src/curve.ts"],"sourcesContent":["import { Line } from './line'\nimport { Point } from './point'\nimport { Polyline } from './polyline'\nimport { Rectangle } from './rectangle'\nimport { Geometry } from './geometry'\n\nexport class Curve extends Geometry {\n  public start: Point\n  public end: Point\n  public controlPoint1: Point\n  public controlPoint2: Point\n\n  public PRECISION = 3\n\n  constructor(\n    start: Point.PointLike | Point.PointData,\n    controlPoint1: Point.PointLike | Point.PointData,\n    controlPoint2: Point.PointLike | Point.PointData,\n    end: Point.PointLike | Point.PointData,\n  ) {\n    super()\n    this.start = Point.create(start)\n    this.controlPoint1 = Point.create(controlPoint1)\n    this.controlPoint2 = Point.create(controlPoint2)\n    this.end = Point.create(end)\n  }\n\n  bbox() {\n    const start = this.start\n    const controlPoint1 = this.controlPoint1\n    const controlPoint2 = this.controlPoint2\n    const end = this.end\n\n    const x0 = start.x\n    const y0 = start.y\n    const x1 = controlPoint1.x\n    const y1 = controlPoint1.y\n    const x2 = controlPoint2.x\n    const y2 = controlPoint2.y\n    const x3 = end.x\n    const y3 = end.y\n\n    const points = [] // local extremes\n    const tvalues = [] // t values of local extremes\n    const bounds: [number[], number[]] = [[], []]\n\n    let a\n    let b\n    let c\n    let t\n    let t1\n    let t2\n    let b2ac\n    let sqrtb2ac\n\n    for (let i = 0; i < 2; i += 1) {\n      if (i === 0) {\n        b = 6 * x0 - 12 * x1 + 6 * x2\n        a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3\n        c = 3 * x1 - 3 * x0\n      } else {\n        b = 6 * y0 - 12 * y1 + 6 * y2\n        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3\n        c = 3 * y1 - 3 * y0\n      }\n\n      if (Math.abs(a) < 1e-12) {\n        if (Math.abs(b) < 1e-12) {\n          continue\n        }\n\n        t = -c / b\n        if (t > 0 && t < 1) tvalues.push(t)\n\n        continue\n      }\n\n      b2ac = b * b - 4 * c * a\n      sqrtb2ac = Math.sqrt(b2ac)\n\n      if (b2ac < 0) continue\n\n      t1 = (-b + sqrtb2ac) / (2 * a)\n      if (t1 > 0 && t1 < 1) tvalues.push(t1)\n\n      t2 = (-b - sqrtb2ac) / (2 * a)\n      if (t2 > 0 && t2 < 1) tvalues.push(t2)\n    }\n\n    let x\n    let y\n    let mt\n    let j = tvalues.length\n    const jlen = j\n\n    while (j) {\n      j -= 1\n      t = tvalues[j]\n      mt = 1 - t\n\n      x =\n        mt * mt * mt * x0 +\n        3 * mt * mt * t * x1 +\n        3 * mt * t * t * x2 +\n        t * t * t * x3\n      bounds[0][j] = x\n\n      y =\n        mt * mt * mt * y0 +\n        3 * mt * mt * t * y1 +\n        3 * mt * t * t * y2 +\n        t * t * t * y3\n\n      bounds[1][j] = y\n      points[j] = { X: x, Y: y }\n    }\n\n    tvalues[jlen] = 0\n    tvalues[jlen + 1] = 1\n\n    points[jlen] = { X: x0, Y: y0 }\n    points[jlen + 1] = { X: x3, Y: y3 }\n\n    bounds[0][jlen] = x0\n    bounds[1][jlen] = y0\n\n    bounds[0][jlen + 1] = x3\n    bounds[1][jlen + 1] = y3\n\n    tvalues.length = jlen + 2\n    bounds[0].length = jlen + 2\n    bounds[1].length = jlen + 2\n    points.length = jlen + 2\n\n    const left = Math.min.apply(null, bounds[0])\n    const top = Math.min.apply(null, bounds[1])\n    const right = Math.max.apply(null, bounds[0])\n    const bottom = Math.max.apply(null, bounds[1])\n\n    return new Rectangle(left, top, right - left, bottom - top)\n  }\n\n  closestPoint(\n    p: Point.PointLike | Point.PointData,\n    options: Curve.Options = {},\n  ) {\n    return this.pointAtT(this.closestPointT(p, options))\n  }\n\n  closestPointLength(\n    p: Point.PointLike | Point.PointData,\n    options: Curve.Options = {},\n  ) {\n    const opts = this.getOptions(options)\n    return this.lengthAtT(this.closestPointT(p, opts), opts)\n  }\n\n  closestPointNormalizedLength(\n    p: Point.PointLike | Point.PointData,\n    options: Curve.Options = {},\n  ) {\n    const opts = this.getOptions(options)\n    const cpLength = this.closestPointLength(p, opts)\n    if (!cpLength) {\n      return 0\n    }\n\n    const length = this.length(opts)\n    if (length === 0) {\n      return 0\n    }\n\n    return cpLength / length\n  }\n\n  closestPointT(\n    p: Point.PointLike | Point.PointData,\n    options: Curve.Options = {},\n  ) {\n    const precision = this.getPrecision(options)\n    const subdivisions = this.getDivisions(options)\n    const precisionRatio = Math.pow(10, -precision) // eslint-disable-line\n\n    let investigatedSubdivision: Curve | null = null\n    let investigatedSubdivisionStartT = 0\n    let investigatedSubdivisionEndT = 0\n    let distFromStart = 0\n    let distFromEnd = 0\n    let chordLength = 0\n    let minSumDist: number | null = null\n\n    const count = subdivisions.length\n    let piece = count > 0 ? 1 / count : 0\n\n    subdivisions.forEach((division, i) => {\n      const startDist = division.start.distance(p)\n      const endDist = division.end.distance(p)\n      const sumDist = startDist + endDist\n      if (minSumDist == null || sumDist < minSumDist) {\n        investigatedSubdivision = division\n        investigatedSubdivisionStartT = i * piece\n        investigatedSubdivisionEndT = (i + 1) * piece\n\n        distFromStart = startDist\n        distFromEnd = endDist\n        minSumDist = sumDist\n        chordLength = division.endpointDistance()\n      }\n    })\n\n    // Recursively divide investigated subdivision, until distance between\n    // baselinePoint and closest path endpoint is within `10^(-precision)`,\n    // then return the closest endpoint of that final subdivision.\n    // eslint-disable-next-line\n    while (true) {\n      // check if we have reached at least one required observed precision\n      // - calculated as: the difference in distances from point to start and end divided by the distance\n      // - note that this function is not monotonic = it doesn't converge stably but has \"teeth\"\n      // - the function decreases while one of the endpoints is fixed but \"jumps\" whenever we switch\n      // - this criterion works well for points lying far away from the curve\n      const startPrecisionRatio = distFromStart\n        ? Math.abs(distFromStart - distFromEnd!) / distFromStart\n        : 0\n\n      const endPrecisionRatio =\n        distFromEnd != null\n          ? Math.abs(distFromStart! - distFromEnd) / distFromEnd\n          : 0\n\n      const hasRequiredPrecision =\n        startPrecisionRatio < precisionRatio ||\n        endPrecisionRatio < precisionRatio\n\n      // check if we have reached at least one required minimal distance\n      // - calculated as: the subdivision chord length multiplied by precisionRatio\n      // - calculation is relative so it will work for arbitrarily large/small curves and their subdivisions\n      // - this is a backup criterion that works well for points lying \"almost at\" the curve\n      const hasMiniStartDistance = distFromStart\n        ? distFromStart < chordLength * precisionRatio\n        : true\n      const hasMiniEndDistance = distFromEnd\n        ? distFromEnd < chordLength * precisionRatio\n        : true\n      const hasMiniDistance = hasMiniStartDistance || hasMiniEndDistance\n\n      if (hasRequiredPrecision || hasMiniDistance) {\n        return distFromStart <= distFromEnd\n          ? investigatedSubdivisionStartT\n          : investigatedSubdivisionEndT\n      }\n\n      // otherwise, set up for next iteration\n      const divided: [Curve, Curve] = investigatedSubdivision!.divide(0.5)\n      piece /= 2\n\n      const startDist1 = divided[0].start.distance(p)\n      const endDist1 = divided[0].end.distance(p)\n      const sumDist1 = startDist1 + endDist1\n\n      const startDist2 = divided[1].start.distance(p)\n      const endDist2 = divided[1].end.distance(p)\n      const sumDist2 = startDist2 + endDist2\n\n      if (sumDist1 <= sumDist2) {\n        investigatedSubdivision = divided[0]\n        investigatedSubdivisionEndT -= piece\n        distFromStart = startDist1\n        distFromEnd = endDist1\n      } else {\n        investigatedSubdivision = divided[1]\n        investigatedSubdivisionStartT += piece\n        distFromStart = startDist2\n        distFromEnd = endDist2\n      }\n    }\n  }\n\n  closestPointTangent(\n    p: Point.PointLike | Point.PointData,\n    options: Curve.Options = {},\n  ) {\n    return this.tangentAtT(this.closestPointT(p, options))\n  }\n\n  containsPoint(\n    p: Point.PointLike | Point.PointData,\n    options: Curve.Options = {},\n  ) {\n    const polyline = this.toPolyline(options)\n    return polyline.containsPoint(p)\n  }\n\n  divideAt(ratio: number, options: Curve.Options = {}): [Curve, Curve] {\n    if (ratio <= 0) {\n      return this.divideAtT(0)\n    }\n\n    if (ratio >= 1) {\n      return this.divideAtT(1)\n    }\n\n    const t = this.tAt(ratio, options)\n    return this.divideAtT(t)\n  }\n\n  divideAtLength(length: number, options: Curve.Options = {}): [Curve, Curve] {\n    const t = this.tAtLength(length, options)\n    return this.divideAtT(t)\n  }\n\n  divide(t: number) {\n    return this.divideAtT(t)\n  }\n\n  divideAtT(t: number): [Curve, Curve] {\n    const start = this.start\n    const controlPoint1 = this.controlPoint1\n    const controlPoint2 = this.controlPoint2\n    const end = this.end\n\n    if (t <= 0) {\n      return [\n        new Curve(start, start, start, start),\n        new Curve(start, controlPoint1, controlPoint2, end),\n      ]\n    }\n\n    if (t >= 1) {\n      return [\n        new Curve(start, controlPoint1, controlPoint2, end),\n        new Curve(end, end, end, end),\n      ]\n    }\n\n    const dividerPoints = this.getSkeletonPoints(t)\n    const startControl1 = dividerPoints.startControlPoint1\n    const startControl2 = dividerPoints.startControlPoint2\n    const divider = dividerPoints.divider\n    const dividerControl1 = dividerPoints.dividerControlPoint1\n    const dividerControl2 = dividerPoints.dividerControlPoint2\n\n    return [\n      new Curve(start, startControl1, startControl2, divider),\n      new Curve(divider, dividerControl1, dividerControl2, end),\n    ]\n  }\n\n  endpointDistance() {\n    return this.start.distance(this.end)\n  }\n\n  getSkeletonPoints(t: number) {\n    const start = this.start\n    const control1 = this.controlPoint1\n    const control2 = this.controlPoint2\n    const end = this.end\n\n    // shortcuts for `t` values that are out of range\n    if (t <= 0) {\n      return {\n        startControlPoint1: start.clone(),\n        startControlPoint2: start.clone(),\n        divider: start.clone(),\n        dividerControlPoint1: control1.clone(),\n        dividerControlPoint2: control2.clone(),\n      }\n    }\n\n    if (t >= 1) {\n      return {\n        startControlPoint1: control1.clone(),\n        startControlPoint2: control2.clone(),\n        divider: end.clone(),\n        dividerControlPoint1: end.clone(),\n        dividerControlPoint2: end.clone(),\n      }\n    }\n\n    const midpoint1 = new Line(start, control1).pointAt(t)\n    const midpoint2 = new Line(control1, control2).pointAt(t)\n    const midpoint3 = new Line(control2, end).pointAt(t)\n\n    const subControl1 = new Line(midpoint1, midpoint2).pointAt(t)\n    const subControl2 = new Line(midpoint2, midpoint3).pointAt(t)\n\n    const divideLine = new Line(subControl1, subControl2).pointAt(t)\n\n    return {\n      startControlPoint1: midpoint1,\n      startControlPoint2: subControl1,\n      divider: divideLine,\n      dividerControlPoint1: subControl2,\n      dividerControlPoint2: midpoint3,\n    }\n  }\n\n  getSubdivisions(options: Curve.Options = {}): Curve[] {\n    const precision = this.getPrecision(options)\n    let subdivisions = [\n      new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end),\n    ]\n\n    if (precision === 0) {\n      return subdivisions\n    }\n\n    let previousLength = this.endpointDistance()\n    const precisionRatio = Math.pow(10, -precision) // eslint-disable-line\n\n    // Recursively divide curve at `t = 0.5`, until the difference between\n    // observed length at subsequent iterations is lower than precision.\n    let iteration = 0\n    // eslint-disable-next-line\n    while (true) {\n      iteration += 1\n\n      const divisions: Curve[] = []\n      subdivisions.forEach((c) => {\n        // dividing at t = 0.5 (not at middle length!)\n        const divided = c.divide(0.5)\n        divisions.push(divided[0], divided[1])\n      })\n\n      // measure new length\n      const length = divisions.reduce(\n        (memo, c) => memo + c.endpointDistance(),\n        0,\n      )\n\n      // check if we have reached required observed precision\n      // sine-like curves may have the same observed length in iteration 0 and 1 - skip iteration 1\n      // not a problem for further iterations because cubic curves cannot have more than two local extrema\n      // (i.e. cubic curves cannot intersect the baseline more than once)\n      // therefore two subsequent iterations cannot produce sampling with equal length\n      const ratio = length !== 0 ? (length - previousLength) / length : 0\n      if (iteration > 1 && ratio < precisionRatio) {\n        return divisions\n      }\n\n      subdivisions = divisions\n      previousLength = length\n    }\n  }\n\n  length(options: Curve.Options = {}) {\n    const divisions = this.getDivisions(options)\n    return divisions.reduce((memo, c) => {\n      return memo + c.endpointDistance()\n    }, 0)\n  }\n\n  lengthAtT(t: number, options: Curve.Options = {}) {\n    if (t <= 0) {\n      return 0\n    }\n\n    const precision =\n      options.precision === undefined ? this.PRECISION : options.precision\n    const subCurve = this.divide(t)[0]\n    return subCurve.length({ precision })\n  }\n\n  pointAt(ratio: number, options: Curve.Options = {}) {\n    if (ratio <= 0) {\n      return this.start.clone()\n    }\n\n    if (ratio >= 1) {\n      return this.end.clone()\n    }\n\n    const t = this.tAt(ratio, options)\n    return this.pointAtT(t)\n  }\n\n  pointAtLength(length: number, options: Curve.Options = {}) {\n    const t = this.tAtLength(length, options)\n    return this.pointAtT(t)\n  }\n\n  pointAtT(t: number) {\n    if (t <= 0) {\n      return this.start.clone()\n    }\n\n    if (t >= 1) {\n      return this.end.clone()\n    }\n\n    return this.getSkeletonPoints(t).divider\n  }\n\n  isDifferentiable() {\n    const start = this.start\n    const control1 = this.controlPoint1\n    const control2 = this.controlPoint2\n    const end = this.end\n\n    return !(\n      start.equals(control1) &&\n      control1.equals(control2) &&\n      control2.equals(end)\n    )\n  }\n\n  tangentAt(ratio: number, options: Curve.Options = {}) {\n    if (!this.isDifferentiable()) return null\n\n    if (ratio < 0) {\n      ratio = 0 // eslint-disable-line\n    } else if (ratio > 1) {\n      ratio = 1 // eslint-disable-line\n    }\n\n    const t = this.tAt(ratio, options)\n    return this.tangentAtT(t)\n  }\n\n  tangentAtLength(length: number, options: Curve.Options = {}) {\n    if (!this.isDifferentiable()) {\n      return null\n    }\n\n    const t = this.tAtLength(length, options)\n    return this.tangentAtT(t)\n  }\n\n  tangentAtT(t: number) {\n    if (!this.isDifferentiable()) {\n      return null\n    }\n\n    if (t < 0) {\n      t = 0 // eslint-disable-line\n    }\n\n    if (t > 1) {\n      t = 1 // eslint-disable-line\n    }\n\n    const skeletonPoints = this.getSkeletonPoints(t)\n    const p1 = skeletonPoints.startControlPoint2\n    const p2 = skeletonPoints.dividerControlPoint1\n\n    const tangentStart = skeletonPoints.divider\n    const tangentLine = new Line(p1, p2)\n    // move so that tangent line starts at the point requested\n    tangentLine.translate(tangentStart.x - p1.x, tangentStart.y - p1.y)\n    return tangentLine\n  }\n\n  protected getPrecision(options: Curve.Options = {}) {\n    return options.precision == null ? this.PRECISION : options.precision\n  }\n\n  protected getDivisions(options: Curve.Options = {}) {\n    if (options.subdivisions != null) {\n      return options.subdivisions\n    }\n\n    const precision = this.getPrecision(options)\n    return this.getSubdivisions({ precision })\n  }\n\n  protected getOptions(options: Curve.Options = {}): Curve.Options {\n    const precision = this.getPrecision(options)\n    const subdivisions = this.getDivisions(options)\n    return { precision, subdivisions }\n  }\n\n  protected tAt(ratio: number, options: Curve.Options = {}) {\n    if (ratio <= 0) {\n      return 0\n    }\n    if (ratio >= 1) {\n      return 1\n    }\n\n    const opts = this.getOptions(options)\n    const total = this.length(opts)\n    const length = total * ratio\n    return this.tAtLength(length, opts)\n  }\n\n  protected tAtLength(length: number, options: Curve.Options = {}) {\n    let fromStart = true\n    if (length < 0) {\n      fromStart = false\n      length = -length // eslint-disable-line\n    }\n\n    const precision = this.getPrecision(options)\n    const subdivisions = this.getDivisions(options)\n    const opts = { precision, subdivisions }\n\n    let investigatedSubdivision: Curve | null = null\n    let investigatedSubdivisionStartT: number\n    let investigatedSubdivisionEndT: number\n    let baselinePointDistFromStart = 0\n    let baselinePointDistFromEnd = 0\n    let memo = 0\n\n    const count = subdivisions.length\n    let piece = count > 0 ? 1 / count : 0\n\n    for (let i = 0; i < count; i += 1) {\n      const index = fromStart ? i : count - 1 - i\n      const division = subdivisions[i]\n      const dist = division.endpointDistance()\n\n      if (length <= memo + dist) {\n        investigatedSubdivision = division\n        investigatedSubdivisionStartT = index * piece\n        investigatedSubdivisionEndT = (index + 1) * piece\n\n        baselinePointDistFromStart = fromStart\n          ? length - memo\n          : dist + memo - length\n        baselinePointDistFromEnd = fromStart\n          ? dist + memo - length\n          : length - memo\n\n        break\n      }\n\n      memo += dist\n    }\n\n    if (investigatedSubdivision == null) {\n      return fromStart ? 1 : 0\n    }\n\n    // note that precision affects what length is recorded\n    // (imprecise measurements underestimate length by up to 10^(-precision) of the precise length)\n    // e.g. at precision 1, the length may be underestimated by up to 10% and cause this function to return 1\n\n    const total = this.length(opts)\n    const precisionRatio = Math.pow(10, -precision) // eslint-disable-line\n\n    // recursively divide investigated subdivision:\n    // until distance between baselinePoint and closest path endpoint is within 10^(-precision)\n    // then return the closest endpoint of that final subdivision\n    // eslint-disable-next-line\n    while (true) {\n      let ratio\n\n      ratio = total !== 0 ? baselinePointDistFromStart / total : 0\n      if (ratio < precisionRatio) {\n        return investigatedSubdivisionStartT!\n      }\n\n      ratio = total !== 0 ? baselinePointDistFromEnd / total : 0\n      if (ratio < precisionRatio) {\n        return investigatedSubdivisionEndT!\n      }\n\n      // otherwise, set up for next iteration\n      let newBaselinePointDistFromStart\n      let newBaselinePointDistFromEnd\n\n      const divided: [Curve, Curve] = investigatedSubdivision.divide(0.5)\n      piece /= 2\n\n      const baseline1Length = divided[0].endpointDistance()\n      const baseline2Length = divided[1].endpointDistance()\n\n      if (baselinePointDistFromStart <= baseline1Length) {\n        investigatedSubdivision = divided[0]\n        investigatedSubdivisionEndT! -= piece\n\n        newBaselinePointDistFromStart = baselinePointDistFromStart\n        newBaselinePointDistFromEnd =\n          baseline1Length - newBaselinePointDistFromStart\n      } else {\n        investigatedSubdivision = divided[1]\n        investigatedSubdivisionStartT! += piece\n\n        newBaselinePointDistFromStart =\n          baselinePointDistFromStart - baseline1Length\n        newBaselinePointDistFromEnd =\n          baseline2Length - newBaselinePointDistFromStart\n      }\n\n      baselinePointDistFromStart = newBaselinePointDistFromStart\n      baselinePointDistFromEnd = newBaselinePointDistFromEnd\n    }\n  }\n\n  toPoints(options: Curve.Options = {}) {\n    const subdivisions = this.getDivisions(options)\n    const points = [subdivisions[0].start.clone()]\n    subdivisions.forEach((c) => points.push(c.end.clone()))\n    return points\n  }\n\n  toPolyline(options: Curve.Options = {}) {\n    return new Polyline(this.toPoints(options))\n  }\n\n  scale(sx: number, sy: number, origin?: Point.PointLike | Point.PointData) {\n    this.start.scale(sx, sy, origin)\n    this.controlPoint1.scale(sx, sy, origin)\n    this.controlPoint2.scale(sx, sy, origin)\n    this.end.scale(sx, sy, origin)\n    return this\n  }\n\n  rotate(angle: number, origin?: Point.PointLike | Point.PointData) {\n    this.start.rotate(angle, origin)\n    this.controlPoint1.rotate(angle, origin)\n    this.controlPoint2.rotate(angle, origin)\n    this.end.rotate(angle, origin)\n    return this\n  }\n\n  translate(tx: number, ty: number): this\n  translate(p: Point.PointLike | Point.PointData): this\n  translate(tx: number | Point.PointLike | Point.PointData, ty?: number) {\n    if (typeof tx === 'number') {\n      this.start.translate(tx, ty as number)\n      this.controlPoint1.translate(tx, ty as number)\n      this.controlPoint2.translate(tx, ty as number)\n      this.end.translate(tx, ty as number)\n    } else {\n      this.start.translate(tx)\n      this.controlPoint1.translate(tx)\n      this.controlPoint2.translate(tx)\n      this.end.translate(tx)\n    }\n\n    return this\n  }\n\n  equals(c: Curve) {\n    return (\n      c != null &&\n      this.start.equals(c.start) &&\n      this.controlPoint1.equals(c.controlPoint1) &&\n      this.controlPoint2.equals(c.controlPoint2) &&\n      this.end.equals(c.end)\n    )\n  }\n\n  clone() {\n    return new Curve(\n      this.start,\n      this.controlPoint1,\n      this.controlPoint2,\n      this.end,\n    )\n  }\n\n  toJSON() {\n    return {\n      start: this.start.toJSON(),\n      controlPoint1: this.controlPoint1.toJSON(),\n      controlPoint2: this.controlPoint2.toJSON(),\n      end: this.end.toJSON(),\n    }\n  }\n\n  serialize() {\n    return [\n      this.start.serialize(),\n      this.controlPoint1.serialize(),\n      this.controlPoint2.serialize(),\n      this.end.serialize(),\n    ].join(' ')\n  }\n}\n\nexport namespace Curve {\n  export function isCurve(instance: any): instance is Curve {\n    return instance != null && instance instanceof Curve\n  }\n}\n\nexport namespace Curve {\n  export interface Options {\n    precision?: number\n    subdivisions?: Curve[]\n  }\n}\nexport namespace Curve {\n  function getFirstControlPoints(rhs: number[]) {\n    const n = rhs.length\n    const x = [] // `x` is a solution vector.\n    const tmp = []\n    let b = 2.0\n\n    x[0] = rhs[0] / b\n\n    // Decomposition and forward substitution.\n    for (let i = 1; i < n; i += 1) {\n      tmp[i] = 1 / b\n      b = (i < n - 1 ? 4.0 : 3.5) - tmp[i]\n      x[i] = (rhs[i] - x[i - 1]) / b\n    }\n\n    for (let i = 1; i < n; i += 1) {\n      // Backsubstitution.\n      x[n - i - 1] -= tmp[n - i] * x[n - i]\n    }\n\n    return x\n  }\n\n  function getCurveControlPoints(\n    points: (Point.PointLike | Point.PointData)[],\n  ) {\n    const knots = points.map((p) => Point.clone(p))\n    const firstControlPoints = []\n    const secondControlPoints = []\n    const n = knots.length - 1\n\n    // Special case: Bezier curve should be a straight line.\n    if (n === 1) {\n      // 3P1 = 2P0 + P3\n      firstControlPoints[0] = new Point(\n        (2 * knots[0].x + knots[1].x) / 3,\n        (2 * knots[0].y + knots[1].y) / 3,\n      )\n\n      // P2 = 2P1 â€“ P0\n      secondControlPoints[0] = new Point(\n        2 * firstControlPoints[0].x - knots[0].x,\n        2 * firstControlPoints[0].y - knots[0].y,\n      )\n\n      return [firstControlPoints, secondControlPoints]\n    }\n\n    // Calculate first Bezier control points.\n    // Right hand side vector.\n    const rhs = []\n\n    // Set right hand side X values.\n    for (let i = 1; i < n - 1; i += 1) {\n      rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x\n    }\n\n    rhs[0] = knots[0].x + 2 * knots[1].x\n    rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0\n\n    // Get first control points X-values.\n    const x = getFirstControlPoints(rhs)\n\n    // Set right hand side Y values.\n    for (let i = 1; i < n - 1; i += 1) {\n      rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y\n    }\n\n    rhs[0] = knots[0].y + 2 * knots[1].y\n    rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0\n\n    // Get first control points Y-values.\n    const y = getFirstControlPoints(rhs)\n\n    // Fill output arrays.\n    for (let i = 0; i < n; i += 1) {\n      // First control point.\n      firstControlPoints.push(new Point(x[i], y[i]))\n\n      // Second control point.\n      if (i < n - 1) {\n        secondControlPoints.push(\n          new Point(\n            2 * knots[i + 1].x - x[i + 1],\n            2 * knots[i + 1].y - y[i + 1],\n          ),\n        )\n      } else {\n        secondControlPoints.push(\n          new Point((knots[n].x + x[n - 1]) / 2, (knots[n].y + y[n - 1]) / 2),\n        )\n      }\n    }\n\n    return [firstControlPoints, secondControlPoints]\n  }\n\n  export function throughPoints(points: (Point.PointLike | Point.PointData)[]) {\n    if (points == null || (Array.isArray(points) && points.length < 2)) {\n      throw new Error('At least 2 points are required')\n    }\n\n    const controlPoints = getCurveControlPoints(points)\n\n    const curves = []\n    for (let i = 0, ii = controlPoints[0].length; i < ii; i += 1) {\n      const controlPoint1 = new Point(\n        controlPoints[0][i].x,\n        controlPoints[0][i].y,\n      )\n      const controlPoint2 = new Point(\n        controlPoints[1][i].x,\n        controlPoints[1][i].y,\n      )\n\n      curves.push(\n        new Curve(points[i], controlPoint1, controlPoint2, points[i + 1]),\n      )\n    }\n\n    return curves\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}