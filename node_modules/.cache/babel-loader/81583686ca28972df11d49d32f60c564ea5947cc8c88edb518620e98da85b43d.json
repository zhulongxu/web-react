{"ast":null,"code":"import { GeometryUtil } from './util';\nimport { Angle } from './angle';\nimport { Geometry } from './geometry';\nexport class Point extends Geometry {\n  constructor(x, y) {\n    super();\n    this.x = x == null ? 0 : x;\n    this.y = y == null ? 0 : y;\n  }\n  /**\n   * Rounds the point to the given precision.\n   */\n  round(precision = 0) {\n    this.x = GeometryUtil.round(this.x, precision);\n    this.y = GeometryUtil.round(this.y, precision);\n    return this;\n  }\n  add(x, y) {\n    const p = Point.create(x, y);\n    this.x += p.x;\n    this.y += p.y;\n    return this;\n  }\n  update(x, y) {\n    const p = Point.create(x, y);\n    this.x = p.x;\n    this.y = p.y;\n    return this;\n  }\n  translate(dx, dy) {\n    const t = Point.create(dx, dy);\n    this.x += t.x;\n    this.y += t.y;\n    return this;\n  }\n  /**\n   * Rotate the point by `degree` around `center`.\n   */\n  rotate(degree, center) {\n    const p = Point.rotate(this, degree, center);\n    this.x = p.x;\n    this.y = p.y;\n    return this;\n  }\n  /**\n   * Scale point by `sx` and `sy` around the given `origin`. If origin is\n   * not specified, the point is scaled around `0, 0`.\n   */\n  scale(sx, sy, origin = new Point()) {\n    const ref = Point.create(origin);\n    this.x = ref.x + sx * (this.x - ref.x);\n    this.y = ref.y + sy * (this.y - ref.y);\n    return this;\n  }\n  /**\n   * Chooses the point closest to this point from among `points`. If `points`\n   * is an empty array, `null` is returned.\n   */\n  closest(points) {\n    if (points.length === 1) {\n      return Point.create(points[0]);\n    }\n    let ret = null;\n    let min = Infinity;\n    points.forEach(p => {\n      const dist = this.squaredDistance(p);\n      if (dist < min) {\n        ret = p;\n        min = dist;\n      }\n    });\n    return ret ? Point.create(ret) : null;\n  }\n  /**\n   * Returns the distance between the point and another point `p`.\n   */\n  distance(p) {\n    return Math.sqrt(this.squaredDistance(p));\n  }\n  /**\n   * Returns the squared distance between the point and another point `p`.\n   *\n   * Useful for distance comparisons in which real distance is not necessary\n   * (saves one `Math.sqrt()` operation).\n   */\n  squaredDistance(p) {\n    const ref = Point.create(p);\n    const dx = this.x - ref.x;\n    const dy = this.y - ref.y;\n    return dx * dx + dy * dy;\n  }\n  manhattanDistance(p) {\n    const ref = Point.create(p);\n    return Math.abs(ref.x - this.x) + Math.abs(ref.y - this.y);\n  }\n  /**\n   * Returns the magnitude of the point vector.\n   *\n   * @see http://en.wikipedia.org/wiki/Magnitude_(mathematics)\n   */\n  magnitude() {\n    return Math.sqrt(this.x * this.x + this.y * this.y) || 0.01;\n  }\n  /**\n   * Returns the angle(in degrees) between vector from this point to `p` and\n   * the x-axis.\n   */\n  theta(p = new Point()) {\n    const ref = Point.create(p);\n    const y = -(ref.y - this.y); // invert the y-axis.\n    const x = ref.x - this.x;\n    let rad = Math.atan2(y, x);\n    // Correction for III. and IV. quadrant.\n    if (rad < 0) {\n      rad = 2 * Math.PI + rad;\n    }\n    return 180 * rad / Math.PI;\n  }\n  /**\n   * Returns the angle(in degrees) between vector from this point to `p1` and\n   * the vector from this point to `p2`.\n   *\n   * The ordering of points `p1` and `p2` is important.\n   *\n   * The function returns a value between `0` and `180` when the angle (in the\n   * direction from `p1` to `p2`) is clockwise, and a value between `180` and\n   * `360` when the angle is counterclockwise.\n   *\n   * Returns `NaN` if either of the points `p1` and `p2` is equal with this point.\n   */\n  angleBetween(p1, p2) {\n    if (this.equals(p1) || this.equals(p2)) {\n      return NaN;\n    }\n    let angle = this.theta(p2) - this.theta(p1);\n    if (angle < 0) {\n      angle += 360;\n    }\n    return angle;\n  }\n  /**\n   * Returns the angle(in degrees) between the line from `(0,0)` and this point\n   * and the line from `(0,0)` to `p`.\n   *\n   * The function returns a value between `0` and `180` when the angle (in the\n   * direction from this point to `p`) is clockwise, and a value between `180`\n   * and `360` when the angle is counterclockwise. Returns `NaN` if called from\n   * point `(0,0)` or if `p` is `(0,0)`.\n   */\n  vectorAngle(p) {\n    const zero = new Point(0, 0);\n    return zero.angleBetween(this, p);\n  }\n  /**\n   * Converts rectangular to polar coordinates.\n   */\n  toPolar(origin) {\n    this.update(Point.toPolar(this, origin));\n    return this;\n  }\n  /**\n   * Returns the change in angle(in degrees) that is the result of moving the\n   * point from its previous position to its current position.\n   *\n   * More specifically, this function computes the angle between the line from\n   * the ref point to the previous position of this point(i.e. current position\n   * `-dx`, `-dy`) and the line from the `ref` point to the current position of\n   * this point.\n   *\n   * The function returns a positive value between `0` and `180` when the angle\n   * (in the direction from previous position of this point to its current\n   * position) is clockwise, and a negative value between `0` and `-180` when\n   * the angle is counterclockwise.\n   *\n   * The function returns `0` if the previous and current positions of this\n   * point are the same (i.e. both `dx` and `dy` are `0`).\n   */\n  changeInAngle(dx, dy, ref = new Point()) {\n    // Revert the translation and measure the change in angle around x-axis.\n    return this.clone().translate(-dx, -dy).theta(ref) - this.theta(ref);\n  }\n  /**\n   * If the point lies outside the rectangle `rect`, adjust the point so that\n   * it becomes the nearest point on the boundary of `rect`.\n   */\n  adhereToRect(rect) {\n    if (!GeometryUtil.containsPoint(rect, this)) {\n      this.x = Math.min(Math.max(this.x, rect.x), rect.x + rect.width);\n      this.y = Math.min(Math.max(this.y, rect.y), rect.y + rect.height);\n    }\n    return this;\n  }\n  /**\n   * Returns the bearing(cardinal direction) between me and the given point.\n   *\n   * @see https://en.wikipedia.org/wiki/Cardinal_direction\n   */\n  bearing(p) {\n    const ref = Point.create(p);\n    const lat1 = Angle.toRad(this.y);\n    const lat2 = Angle.toRad(ref.y);\n    const lon1 = this.x;\n    const lon2 = ref.x;\n    const dLon = Angle.toRad(lon2 - lon1);\n    const y = Math.sin(dLon) * Math.cos(lat2);\n    const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);\n    const brng = Angle.toDeg(Math.atan2(y, x));\n    const bearings = ['NE', 'E', 'SE', 'S', 'SW', 'W', 'NW', 'N'];\n    let index = brng - 22.5;\n    if (index < 0) {\n      index += 360;\n    }\n    index = parseInt(index / 45, 10);\n    return bearings[index];\n  }\n  /**\n   * Returns the cross product of the vector from me to `p1` and the vector\n   * from me to `p2`.\n   *\n   * The left-hand rule is used because the coordinate system is left-handed.\n   */\n  cross(p1, p2) {\n    if (p1 != null && p2 != null) {\n      const a = Point.create(p1);\n      const b = Point.create(p2);\n      return (b.x - this.x) * (a.y - this.y) - (b.y - this.y) * (a.x - this.x);\n    }\n    return NaN;\n  }\n  /**\n   * Returns the dot product of this point with given other point.\n   */\n  dot(p) {\n    const ref = Point.create(p);\n    return this.x * ref.x + this.y * ref.y;\n  }\n  diff(dx, dy) {\n    if (typeof dx === 'number') {\n      return new Point(this.x - dx, this.y - dy);\n    }\n    const p = Point.create(dx);\n    return new Point(this.x - p.x, this.y - p.y);\n  }\n  /**\n   * Returns an interpolation between me and point `p` for a parametert in\n   * the closed interval `[0, 1]`.\n   */\n  lerp(p, t) {\n    const ref = Point.create(p);\n    return new Point((1 - t) * this.x + t * ref.x, (1 - t) * this.y + t * ref.y);\n  }\n  /**\n   * Normalize the point vector, scale the line segment between `(0, 0)`\n   * and the point in order for it to have the given length. If length is\n   * not specified, it is considered to be `1`; in that case, a unit vector\n   * is computed.\n   */\n  normalize(length = 1) {\n    const scale = length / this.magnitude();\n    return this.scale(scale, scale);\n  }\n  /**\n   * Moves this point along the line starting from `ref` to this point by a\n   * certain `distance`.\n   */\n  move(ref, distance) {\n    const p = Point.create(ref);\n    const rad = Angle.toRad(p.theta(this));\n    return this.translate(Math.cos(rad) * distance, -Math.sin(rad) * distance);\n  }\n  /**\n   * Returns a point that is the reflection of me with the center of inversion\n   * in `ref` point.\n   */\n  reflection(ref) {\n    return Point.create(ref).move(this, this.distance(ref));\n  }\n  snapToGrid(gx, gy) {\n    this.x = GeometryUtil.snapToGrid(this.x, gx);\n    this.y = GeometryUtil.snapToGrid(this.y, gy == null ? gx : gy);\n    return this;\n  }\n  equals(p) {\n    const ref = Point.create(p);\n    return ref != null && ref.x === this.x && ref.y === this.y;\n  }\n  clone() {\n    return Point.clone(this);\n  }\n  /**\n   * Returns the point as a simple JSON object. For example: `{ x: 0, y: 0 }`.\n   */\n  toJSON() {\n    return Point.toJSON(this);\n  }\n  serialize() {\n    return `${this.x} ${this.y}`;\n  }\n}\n(function (Point) {\n  function isPoint(instance) {\n    return instance != null && instance instanceof Point;\n  }\n  Point.isPoint = isPoint;\n})(Point || (Point = {}));\n(function (Point) {\n  function isPointLike(p) {\n    return p != null && typeof p === 'object' && typeof p.x === 'number' && typeof p.y === 'number';\n  }\n  Point.isPointLike = isPointLike;\n  function isPointData(p) {\n    return p != null && Array.isArray(p) && p.length === 2 && typeof p[0] === 'number' && typeof p[1] === 'number';\n  }\n  Point.isPointData = isPointData;\n})(Point || (Point = {}));\n(function (Point) {\n  function create(x, y) {\n    if (x == null || typeof x === 'number') {\n      return new Point(x, y);\n    }\n    return clone(x);\n  }\n  Point.create = create;\n  function clone(p) {\n    if (Point.isPoint(p)) {\n      return new Point(p.x, p.y);\n    }\n    if (Array.isArray(p)) {\n      return new Point(p[0], p[1]);\n    }\n    return new Point(p.x, p.y);\n  }\n  Point.clone = clone;\n  function toJSON(p) {\n    if (Point.isPoint(p)) {\n      return {\n        x: p.x,\n        y: p.y\n      };\n    }\n    if (Array.isArray(p)) {\n      return {\n        x: p[0],\n        y: p[1]\n      };\n    }\n    return {\n      x: p.x,\n      y: p.y\n    };\n  }\n  Point.toJSON = toJSON;\n  /**\n   * Returns a new Point object from the given polar coordinates.\n   * @see http://en.wikipedia.org/wiki/Polar_coordinate_system\n   */\n  function fromPolar(r, rad, origin = new Point()) {\n    let x = Math.abs(r * Math.cos(rad));\n    let y = Math.abs(r * Math.sin(rad));\n    const org = clone(origin);\n    const deg = Angle.normalize(Angle.toDeg(rad));\n    if (deg < 90) {\n      y = -y;\n    } else if (deg < 180) {\n      x = -x;\n      y = -y;\n    } else if (deg < 270) {\n      x = -x;\n    }\n    return new Point(org.x + x, org.y + y);\n  }\n  Point.fromPolar = fromPolar;\n  /**\n   * Converts rectangular to polar coordinates.\n   */\n  function toPolar(point, origin = new Point()) {\n    const p = clone(point);\n    const o = clone(origin);\n    const dx = p.x - o.x;\n    const dy = p.y - o.y;\n    return new Point(Math.sqrt(dx * dx + dy * dy),\n    // r\n    Angle.toRad(o.theta(p)));\n  }\n  Point.toPolar = toPolar;\n  function equals(p1, p2) {\n    if (p1 === p2) {\n      return true;\n    }\n    if (p1 != null && p2 != null) {\n      return p1.x === p2.x && p1.y === p2.y;\n    }\n    return false;\n  }\n  Point.equals = equals;\n  function equalPoints(p1, p2) {\n    if (p1 == null && p2 != null || p1 != null && p2 == null || p1 != null && p2 != null && p1.length !== p2.length) {\n      return false;\n    }\n    if (p1 != null && p2 != null) {\n      for (let i = 0, ii = p1.length; i < ii; i += 1) {\n        if (!equals(p1[i], p2[i])) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  Point.equalPoints = equalPoints;\n  /**\n   * Returns a point with random coordinates that fall within the range\n   * `[x1, x2]` and `[y1, y2]`.\n   */\n  function random(x1, x2, y1, y2) {\n    return new Point(GeometryUtil.random(x1, x2), GeometryUtil.random(y1, y2));\n  }\n  Point.random = random;\n  function rotate(point, angle, center) {\n    const rad = Angle.toRad(Angle.normalize(-angle));\n    const sin = Math.sin(rad);\n    const cos = Math.cos(rad);\n    return rotateEx(point, cos, sin, center);\n  }\n  Point.rotate = rotate;\n  function rotateEx(point, cos, sin, center = new Point()) {\n    const source = clone(point);\n    const origin = clone(center);\n    const dx = source.x - origin.x;\n    const dy = source.y - origin.y;\n    const x1 = dx * cos - dy * sin;\n    const y1 = dy * cos + dx * sin;\n    return new Point(x1 + origin.x, y1 + origin.y);\n  }\n  Point.rotateEx = rotateEx;\n})(Point || (Point = {}));","map":{"version":3,"names":["GeometryUtil","Angle","Geometry","Point","constructor","x","y","round","precision","add","p","create","update","translate","dx","dy","t","rotate","degree","center","scale","sx","sy","origin","ref","closest","points","length","ret","min","Infinity","forEach","dist","squaredDistance","distance","Math","sqrt","manhattanDistance","abs","magnitude","theta","rad","atan2","PI","angleBetween","p1","p2","equals","NaN","angle","vectorAngle","zero","toPolar","changeInAngle","clone","adhereToRect","rect","containsPoint","max","width","height","bearing","lat1","toRad","lat2","lon1","lon2","dLon","sin","cos","brng","toDeg","bearings","index","parseInt","cross","a","b","dot","diff","lerp","normalize","move","reflection","snapToGrid","gx","gy","toJSON","serialize","isPoint","instance","isPointLike","isPointData","Array","isArray","fromPolar","r","org","deg","point","o","equalPoints","i","ii","random","x1","x2","y1","y2","rotateEx","source"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6-geometry@2.0.5/node_modules/@antv/x6-geometry/src/point.ts"],"sourcesContent":["import { Rectangle } from './rectangle'\nimport { GeometryUtil } from './util'\nimport { Angle } from './angle'\nimport { Geometry } from './geometry'\n\nexport class Point extends Geometry implements Point.PointLike {\n  public x: number\n  public y: number\n\n  constructor()\n  constructor(x?: number, y?: number)\n  constructor(x?: number, y?: number) {\n    super()\n    this.x = x == null ? 0 : x\n    this.y = y == null ? 0 : y\n  }\n\n  /**\n   * Rounds the point to the given precision.\n   */\n  round(precision = 0) {\n    this.x = GeometryUtil.round(this.x, precision)\n    this.y = GeometryUtil.round(this.y, precision)\n    return this\n  }\n\n  add(x: number, y: number): this\n  add(p: Point.PointLike | Point.PointData): this\n  add(x: number | Point.PointLike | Point.PointData, y?: number): this {\n    const p = Point.create(x, y)\n    this.x += p.x\n    this.y += p.y\n    return this\n  }\n\n  update(x: number, y: number): this\n  update(p: Point.PointLike | Point.PointData): this\n  update(x: number | Point.PointLike | Point.PointData, y?: number): this {\n    const p = Point.create(x, y)\n    this.x = p.x\n    this.y = p.y\n    return this\n  }\n\n  translate(dx: number, dy: number): this\n  translate(p: Point.PointLike | Point.PointData): this\n  translate(dx: number | Point.PointLike | Point.PointData, dy?: number): this {\n    const t = Point.create(dx, dy)\n    this.x += t.x\n    this.y += t.y\n    return this\n  }\n\n  /**\n   * Rotate the point by `degree` around `center`.\n   */\n  rotate(degree: number, center?: Point.PointLike | Point.PointData): this {\n    const p = Point.rotate(this, degree, center)\n    this.x = p.x\n    this.y = p.y\n    return this\n  }\n\n  /**\n   * Scale point by `sx` and `sy` around the given `origin`. If origin is\n   * not specified, the point is scaled around `0, 0`.\n   */\n  scale(\n    sx: number,\n    sy: number,\n    origin: Point.PointLike | Point.PointData = new Point(),\n  ) {\n    const ref = Point.create(origin)\n    this.x = ref.x + sx * (this.x - ref.x)\n    this.y = ref.y + sy * (this.y - ref.y)\n    return this\n  }\n\n  /**\n   * Chooses the point closest to this point from among `points`. If `points`\n   * is an empty array, `null` is returned.\n   */\n  closest(points: (Point.PointLike | Point.PointData)[]) {\n    if (points.length === 1) {\n      return Point.create(points[0])\n    }\n\n    let ret: Point.PointLike | Point.PointData | null = null\n    let min = Infinity\n    points.forEach((p) => {\n      const dist = this.squaredDistance(p)\n      if (dist < min) {\n        ret = p\n        min = dist\n      }\n    })\n\n    return ret ? Point.create(ret) : null\n  }\n\n  /**\n   * Returns the distance between the point and another point `p`.\n   */\n  distance(p: Point.PointLike | Point.PointData) {\n    return Math.sqrt(this.squaredDistance(p))\n  }\n\n  /**\n   * Returns the squared distance between the point and another point `p`.\n   *\n   * Useful for distance comparisons in which real distance is not necessary\n   * (saves one `Math.sqrt()` operation).\n   */\n  squaredDistance(p: Point.PointLike | Point.PointData) {\n    const ref = Point.create(p)\n    const dx = this.x - ref.x\n    const dy = this.y - ref.y\n    return dx * dx + dy * dy\n  }\n\n  manhattanDistance(p: Point.PointLike | Point.PointData) {\n    const ref = Point.create(p)\n    return Math.abs(ref.x - this.x) + Math.abs(ref.y - this.y)\n  }\n\n  /**\n   * Returns the magnitude of the point vector.\n   *\n   * @see http://en.wikipedia.org/wiki/Magnitude_(mathematics)\n   */\n  magnitude() {\n    return Math.sqrt(this.x * this.x + this.y * this.y) || 0.01\n  }\n\n  /**\n   * Returns the angle(in degrees) between vector from this point to `p` and\n   * the x-axis.\n   */\n  theta(p: Point.PointLike | Point.PointData = new Point()): number {\n    const ref = Point.create(p)\n    const y = -(ref.y - this.y) // invert the y-axis.\n    const x = ref.x - this.x\n    let rad = Math.atan2(y, x)\n\n    // Correction for III. and IV. quadrant.\n    if (rad < 0) {\n      rad = 2 * Math.PI + rad\n    }\n\n    return (180 * rad) / Math.PI\n  }\n\n  /**\n   * Returns the angle(in degrees) between vector from this point to `p1` and\n   * the vector from this point to `p2`.\n   *\n   * The ordering of points `p1` and `p2` is important.\n   *\n   * The function returns a value between `0` and `180` when the angle (in the\n   * direction from `p1` to `p2`) is clockwise, and a value between `180` and\n   * `360` when the angle is counterclockwise.\n   *\n   * Returns `NaN` if either of the points `p1` and `p2` is equal with this point.\n   */\n  angleBetween(\n    p1: Point.PointLike | Point.PointData,\n    p2: Point.PointLike | Point.PointData,\n  ) {\n    if (this.equals(p1) || this.equals(p2)) {\n      return NaN\n    }\n\n    let angle = this.theta(p2) - this.theta(p1)\n    if (angle < 0) {\n      angle += 360\n    }\n\n    return angle\n  }\n\n  /**\n   * Returns the angle(in degrees) between the line from `(0,0)` and this point\n   * and the line from `(0,0)` to `p`.\n   *\n   * The function returns a value between `0` and `180` when the angle (in the\n   * direction from this point to `p`) is clockwise, and a value between `180`\n   * and `360` when the angle is counterclockwise. Returns `NaN` if called from\n   * point `(0,0)` or if `p` is `(0,0)`.\n   */\n  vectorAngle(p: Point.PointLike | Point.PointData) {\n    const zero = new Point(0, 0)\n    return zero.angleBetween(this, p)\n  }\n\n  /**\n   * Converts rectangular to polar coordinates.\n   */\n  toPolar(origin?: Point.PointLike | Point.PointData) {\n    this.update(Point.toPolar(this, origin))\n    return this\n  }\n\n  /**\n   * Returns the change in angle(in degrees) that is the result of moving the\n   * point from its previous position to its current position.\n   *\n   * More specifically, this function computes the angle between the line from\n   * the ref point to the previous position of this point(i.e. current position\n   * `-dx`, `-dy`) and the line from the `ref` point to the current position of\n   * this point.\n   *\n   * The function returns a positive value between `0` and `180` when the angle\n   * (in the direction from previous position of this point to its current\n   * position) is clockwise, and a negative value between `0` and `-180` when\n   * the angle is counterclockwise.\n   *\n   * The function returns `0` if the previous and current positions of this\n   * point are the same (i.e. both `dx` and `dy` are `0`).\n   */\n  changeInAngle(\n    dx: number,\n    dy: number,\n    ref: Point.PointLike | Point.PointData = new Point(),\n  ) {\n    // Revert the translation and measure the change in angle around x-axis.\n    return this.clone().translate(-dx, -dy).theta(ref) - this.theta(ref)\n  }\n\n  /**\n   * If the point lies outside the rectangle `rect`, adjust the point so that\n   * it becomes the nearest point on the boundary of `rect`.\n   */\n  adhereToRect(rect: Rectangle.RectangleLike) {\n    if (!GeometryUtil.containsPoint(rect, this)) {\n      this.x = Math.min(Math.max(this.x, rect.x), rect.x + rect.width)\n      this.y = Math.min(Math.max(this.y, rect.y), rect.y + rect.height)\n    }\n    return this\n  }\n\n  /**\n   * Returns the bearing(cardinal direction) between me and the given point.\n   *\n   * @see https://en.wikipedia.org/wiki/Cardinal_direction\n   */\n  bearing(p: Point.PointLike | Point.PointData) {\n    const ref = Point.create(p)\n    const lat1 = Angle.toRad(this.y)\n    const lat2 = Angle.toRad(ref.y)\n    const lon1 = this.x\n    const lon2 = ref.x\n    const dLon = Angle.toRad(lon2 - lon1)\n    const y = Math.sin(dLon) * Math.cos(lat2)\n    const x =\n      Math.cos(lat1) * Math.sin(lat2) -\n      Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon)\n\n    const brng = Angle.toDeg(Math.atan2(y, x))\n    const bearings = ['NE', 'E', 'SE', 'S', 'SW', 'W', 'NW', 'N']\n\n    let index = brng - 22.5\n    if (index < 0) {\n      index += 360\n    }\n    index = parseInt((index / 45) as any, 10)\n    return bearings[index] as Point.Bearing\n  }\n\n  /**\n   * Returns the cross product of the vector from me to `p1` and the vector\n   * from me to `p2`.\n   *\n   * The left-hand rule is used because the coordinate system is left-handed.\n   */\n  cross(\n    p1: Point.PointLike | Point.PointData,\n    p2: Point.PointLike | Point.PointData,\n  ) {\n    if (p1 != null && p2 != null) {\n      const a = Point.create(p1)\n      const b = Point.create(p2)\n      return (b.x - this.x) * (a.y - this.y) - (b.y - this.y) * (a.x - this.x)\n    }\n\n    return NaN\n  }\n\n  /**\n   * Returns the dot product of this point with given other point.\n   */\n  dot(p: Point.PointLike | Point.PointData) {\n    const ref = Point.create(p)\n    return this.x * ref.x + this.y * ref.y\n  }\n\n  /**\n   * Returns a point that has coordinates computed as a difference between the\n   * point and another point with coordinates `dx` and `dy`.\n   *\n   * If only `dx` is specified and is a number, `dy` is considered to be zero.\n   * If only `dx` is specified and is an object, it is considered to be another\n   * point or an object in the form `{ x: [number], y: [number] }`\n   */\n  diff(dx: number, dy: number): Point\n  diff(p: Point.PointLike | Point.PointData): Point\n  diff(dx: number | Point.PointLike | Point.PointData, dy?: number): Point {\n    if (typeof dx === 'number') {\n      return new Point(this.x - dx, this.y - dy!)\n    }\n\n    const p = Point.create(dx)\n    return new Point(this.x - p.x, this.y - p.y)\n  }\n\n  /**\n   * Returns an interpolation between me and point `p` for a parametert in\n   * the closed interval `[0, 1]`.\n   */\n  lerp(p: Point.PointLike | Point.PointData, t: number) {\n    const ref = Point.create(p)\n    return new Point((1 - t) * this.x + t * ref.x, (1 - t) * this.y + t * ref.y)\n  }\n\n  /**\n   * Normalize the point vector, scale the line segment between `(0, 0)`\n   * and the point in order for it to have the given length. If length is\n   * not specified, it is considered to be `1`; in that case, a unit vector\n   * is computed.\n   */\n  normalize(length = 1) {\n    const scale = length / this.magnitude()\n    return this.scale(scale, scale)\n  }\n\n  /**\n   * Moves this point along the line starting from `ref` to this point by a\n   * certain `distance`.\n   */\n  move(ref: Point.PointLike | Point.PointData, distance: number) {\n    const p = Point.create(ref)\n    const rad = Angle.toRad(p.theta(this))\n    return this.translate(Math.cos(rad) * distance, -Math.sin(rad) * distance)\n  }\n\n  /**\n   * Returns a point that is the reflection of me with the center of inversion\n   * in `ref` point.\n   */\n  reflection(ref: Point.PointLike | Point.PointData) {\n    return Point.create(ref).move(this, this.distance(ref))\n  }\n\n  /**\n   * Snaps the point(change its x and y coordinates) to a grid of size `gridSize`\n   * (or `gridSize` x `gridSizeY` for non-uniform grid).\n   */\n  snapToGrid(gridSize: number): this\n  snapToGrid(gx: number, gy: number): this\n  snapToGrid(gx: number, gy?: number): this\n  snapToGrid(gx: number, gy?: number): this {\n    this.x = GeometryUtil.snapToGrid(this.x, gx)\n    this.y = GeometryUtil.snapToGrid(this.y, gy == null ? gx : gy)\n    return this\n  }\n\n  equals(p: Point.PointLike | Point.PointData) {\n    const ref = Point.create(p)\n    return ref != null && ref.x === this.x && ref.y === this.y\n  }\n\n  clone() {\n    return Point.clone(this)\n  }\n\n  /**\n   * Returns the point as a simple JSON object. For example: `{ x: 0, y: 0 }`.\n   */\n  toJSON() {\n    return Point.toJSON(this)\n  }\n\n  serialize() {\n    return `${this.x} ${this.y}`\n  }\n}\n\nexport namespace Point {\n  export function isPoint(instance: any): instance is Point {\n    return instance != null && instance instanceof Point\n  }\n}\n\nexport namespace Point {\n  export interface PointLike {\n    x: number\n    y: number\n  }\n\n  export type PointData = [number, number]\n\n  export type Bearing = 'NE' | 'E' | 'SE' | 'S' | 'SW' | 'W' | 'NW' | 'N'\n\n  export function isPointLike(p: any): p is PointLike {\n    return (\n      p != null &&\n      typeof p === 'object' &&\n      typeof p.x === 'number' &&\n      typeof p.y === 'number'\n    )\n  }\n\n  export function isPointData(p: any): p is PointData {\n    return (\n      p != null &&\n      Array.isArray(p) &&\n      p.length === 2 &&\n      typeof p[0] === 'number' &&\n      typeof p[1] === 'number'\n    )\n  }\n}\n\nexport namespace Point {\n  export function create(\n    x?: number | Point | PointLike | PointData,\n    y?: number,\n  ): Point {\n    if (x == null || typeof x === 'number') {\n      return new Point(x, y)\n    }\n\n    return clone(x)\n  }\n\n  export function clone(p: Point | PointLike | PointData) {\n    if (Point.isPoint(p)) {\n      return new Point(p.x, p.y)\n    }\n\n    if (Array.isArray(p)) {\n      return new Point(p[0], p[1])\n    }\n\n    return new Point(p.x, p.y)\n  }\n\n  export function toJSON(p: Point | PointLike | PointData) {\n    if (Point.isPoint(p)) {\n      return { x: p.x, y: p.y }\n    }\n\n    if (Array.isArray(p)) {\n      return { x: p[0], y: p[1] }\n    }\n\n    return { x: p.x, y: p.y }\n  }\n\n  /**\n   * Returns a new Point object from the given polar coordinates.\n   * @see http://en.wikipedia.org/wiki/Polar_coordinate_system\n   */\n  export function fromPolar(\n    r: number,\n    rad: number,\n    origin: Point | PointLike | PointData = new Point(),\n  ) {\n    let x = Math.abs(r * Math.cos(rad))\n    let y = Math.abs(r * Math.sin(rad))\n    const org = clone(origin)\n    const deg = Angle.normalize(Angle.toDeg(rad))\n\n    if (deg < 90) {\n      y = -y\n    } else if (deg < 180) {\n      x = -x\n      y = -y\n    } else if (deg < 270) {\n      x = -x\n    }\n\n    return new Point(org.x + x, org.y + y)\n  }\n\n  /**\n   * Converts rectangular to polar coordinates.\n   */\n  export function toPolar(\n    point: Point | PointLike | PointData,\n    origin: Point | PointLike | PointData = new Point(),\n  ) {\n    const p = clone(point)\n    const o = clone(origin)\n    const dx = p.x - o.x\n    const dy = p.y - o.y\n    return new Point(\n      Math.sqrt(dx * dx + dy * dy), // r\n      Angle.toRad(o.theta(p)),\n    )\n  }\n\n  export function equals(p1?: Point.PointLike, p2?: Point.PointLike) {\n    if (p1 === p2) {\n      return true\n    }\n\n    if (p1 != null && p2 != null) {\n      return p1.x === p2.x && p1.y === p2.y\n    }\n\n    return false\n  }\n\n  export function equalPoints(p1: Point.PointLike[], p2: Point.PointLike[]) {\n    if (\n      (p1 == null && p2 != null) ||\n      (p1 != null && p2 == null) ||\n      (p1 != null && p2 != null && p1.length !== p2.length)\n    ) {\n      return false\n    }\n\n    if (p1 != null && p2 != null) {\n      for (let i = 0, ii = p1.length; i < ii; i += 1) {\n        if (!equals(p1[i], p2[i])) {\n          return false\n        }\n      }\n    }\n\n    return true\n  }\n\n  /**\n   * Returns a point with random coordinates that fall within the range\n   * `[x1, x2]` and `[y1, y2]`.\n   */\n  export function random(x1: number, x2: number, y1: number, y2: number) {\n    return new Point(GeometryUtil.random(x1, x2), GeometryUtil.random(y1, y2))\n  }\n\n  export function rotate(\n    point: Point | PointLike | PointData,\n    angle: number,\n    center?: Point | PointLike | PointData,\n  ) {\n    const rad = Angle.toRad(Angle.normalize(-angle))\n    const sin = Math.sin(rad)\n    const cos = Math.cos(rad)\n\n    return rotateEx(point, cos, sin, center)\n  }\n\n  export function rotateEx(\n    point: Point | PointLike | PointData,\n    cos: number,\n    sin: number,\n    center: Point | PointLike | PointData = new Point(),\n  ) {\n    const source = clone(point)\n    const origin = clone(center)\n    const dx = source.x - origin.x\n    const dy = source.y - origin.y\n    const x1 = dx * cos - dy * sin\n    const y1 = dy * cos + dx * sin\n    return new Point(x1 + origin.x, y1 + origin.y)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}