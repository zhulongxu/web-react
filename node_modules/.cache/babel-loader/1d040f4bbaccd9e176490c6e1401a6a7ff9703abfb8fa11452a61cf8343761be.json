{"ast":null,"code":"import { Model } from '@antv/x6';\nexport function grid(cells, options = {}) {\n  const model = Model.isModel(cells) ? cells : new Model().resetCells(cells, {\n    sort: false,\n    dryrun: true\n  });\n  const nodes = model.getNodes();\n  const columns = options.columns || 1;\n  const rows = Math.ceil(nodes.length / columns);\n  const dx = options.dx || 0;\n  const dy = options.dy || 0;\n  const centre = options.center !== false;\n  const resizeToFit = options.resizeToFit === true;\n  const marginX = options.marginX || 0;\n  const marginY = options.marginY || 0;\n  const columnWidths = [];\n  let columnWidth = options.columnWidth;\n  if (columnWidth === 'compact') {\n    for (let j = 0; j < columns; j += 1) {\n      const items = GridLayout.getNodesInColumn(nodes, j, columns);\n      columnWidths.push(GridLayout.getMaxDim(items, 'width') + dx);\n    }\n  } else {\n    if (columnWidth == null || columnWidth === 'auto') {\n      columnWidth = GridLayout.getMaxDim(nodes, 'width') + dx;\n    }\n    for (let i = 0; i < columns; i += 1) {\n      columnWidths.push(columnWidth);\n    }\n  }\n  const columnLefts = GridLayout.accumulate(columnWidths, marginX);\n  const rowHeights = [];\n  let rowHeight = options.rowHeight;\n  if (rowHeight === 'compact') {\n    for (let i = 0; i < rows; i += 1) {\n      const items = GridLayout.getNodesInRow(nodes, i, columns);\n      rowHeights.push(GridLayout.getMaxDim(items, 'height') + dy);\n    }\n  } else {\n    if (rowHeight == null || rowHeight === 'auto') {\n      rowHeight = GridLayout.getMaxDim(nodes, 'height') + dy;\n    }\n    for (let i = 0; i < rows; i += 1) {\n      rowHeights.push(rowHeight);\n    }\n  }\n  const rowTops = GridLayout.accumulate(rowHeights, marginY);\n  model.startBatch('layout');\n  nodes.forEach((node, index) => {\n    const rowIndex = index % columns;\n    const columnIndex = Math.floor(index / columns);\n    const columnWidth = columnWidths[rowIndex];\n    const rowHeight = rowHeights[columnIndex];\n    let cx = 0;\n    let cy = 0;\n    let size = node.getSize();\n    if (resizeToFit) {\n      let width = columnWidth - 2 * dx;\n      let height = rowHeight - 2 * dy;\n      const calcHeight = size.height * (size.width ? width / size.width : 1);\n      const calcWidth = size.width * (size.height ? height / size.height : 1);\n      if (rowHeight < calcHeight) {\n        width = calcWidth;\n      } else {\n        height = calcHeight;\n      }\n      size = {\n        width,\n        height\n      };\n      node.setSize(size, options);\n    }\n    if (centre) {\n      cx = (columnWidth - size.width) / 2;\n      cy = (rowHeight - size.height) / 2;\n    }\n    node.position(columnLefts[rowIndex] + dx + cx, rowTops[columnIndex] + dy + cy, options);\n  });\n  model.stopBatch('layout');\n}\nvar GridLayout;\n(function (GridLayout) {\n  function getMaxDim(nodes, name) {\n    return nodes.reduce((memo, node) => Math.max(node === null || node === void 0 ? void 0 : node.getSize()[name], memo), 0);\n  }\n  GridLayout.getMaxDim = getMaxDim;\n  function getNodesInRow(nodes, rowIndex, columnCount) {\n    const res = [];\n    for (let i = columnCount * rowIndex, ii = i + columnCount; i < ii; i += 1) {\n      if (nodes[i]) res.push(nodes[i]);\n    }\n    return res;\n  }\n  GridLayout.getNodesInRow = getNodesInRow;\n  function getNodesInColumn(nodes, columnIndex, columnCount) {\n    const res = [];\n    for (let i = columnIndex, ii = nodes.length; i < ii; i += columnCount) {\n      if (nodes[i]) res.push(nodes[i]);\n    }\n    return res;\n  }\n  GridLayout.getNodesInColumn = getNodesInColumn;\n  function accumulate(items, start) {\n    return items.reduce((memo, item, i) => {\n      memo.push(memo[i] + item);\n      return memo;\n    }, [start || 0]);\n  }\n  GridLayout.accumulate = accumulate;\n})(GridLayout || (GridLayout = {}));","map":{"version":3,"names":["Model","grid","cells","options","model","isModel","resetCells","sort","dryrun","nodes","getNodes","columns","rows","Math","ceil","length","dx","dy","centre","center","resizeToFit","marginX","marginY","columnWidths","columnWidth","j","items","GridLayout","getNodesInColumn","push","getMaxDim","i","columnLefts","accumulate","rowHeights","rowHeight","getNodesInRow","rowTops","startBatch","forEach","node","index","rowIndex","columnIndex","floor","cx","cy","size","getSize","width","height","calcHeight","calcWidth","setSize","position","stopBatch","name","reduce","memo","max","columnCount","res","ii","start","item"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6-plugin-stencil@2.1.5_@antv+x6@2.18.1/node_modules/@antv/x6-plugin-stencil/src/grid.ts"],"sourcesContent":["import { Node, Model } from '@antv/x6'\n\nexport function grid(cells: Node[] | Model, options: GridLayout.Options = {}) {\n  const model = Model.isModel(cells)\n    ? cells\n    : new Model().resetCells(cells, {\n        sort: false,\n        dryrun: true,\n      })\n\n  const nodes = model.getNodes()\n  const columns = options.columns || 1\n  const rows = Math.ceil(nodes.length / columns)\n  const dx = options.dx || 0\n  const dy = options.dy || 0\n  const centre = options.center !== false\n  const resizeToFit = options.resizeToFit === true\n  const marginX = options.marginX || 0\n  const marginY = options.marginY || 0\n  const columnWidths: number[] = []\n\n  let columnWidth = options.columnWidth\n\n  if (columnWidth === 'compact') {\n    for (let j = 0; j < columns; j += 1) {\n      const items = GridLayout.getNodesInColumn(nodes, j, columns)\n      columnWidths.push(GridLayout.getMaxDim(items, 'width') + dx)\n    }\n  } else {\n    if (columnWidth == null || columnWidth === 'auto') {\n      columnWidth = GridLayout.getMaxDim(nodes, 'width') + dx\n    }\n\n    for (let i = 0; i < columns; i += 1) {\n      columnWidths.push(columnWidth)\n    }\n  }\n\n  const columnLefts = GridLayout.accumulate(columnWidths, marginX)\n\n  const rowHeights: number[] = []\n  let rowHeight = options.rowHeight\n  if (rowHeight === 'compact') {\n    for (let i = 0; i < rows; i += 1) {\n      const items = GridLayout.getNodesInRow(nodes, i, columns)\n      rowHeights.push(GridLayout.getMaxDim(items, 'height') + dy)\n    }\n  } else {\n    if (rowHeight == null || rowHeight === 'auto') {\n      rowHeight = GridLayout.getMaxDim(nodes, 'height') + dy\n    }\n\n    for (let i = 0; i < rows; i += 1) {\n      rowHeights.push(rowHeight)\n    }\n  }\n  const rowTops = GridLayout.accumulate(rowHeights, marginY)\n\n  model.startBatch('layout')\n\n  nodes.forEach((node, index) => {\n    const rowIndex = index % columns\n    const columnIndex = Math.floor(index / columns)\n    const columnWidth = columnWidths[rowIndex]\n    const rowHeight = rowHeights[columnIndex]\n\n    let cx = 0\n    let cy = 0\n    let size = node.getSize()\n\n    if (resizeToFit) {\n      let width = columnWidth - 2 * dx\n      let height = rowHeight - 2 * dy\n      const calcHeight = size.height * (size.width ? width / size.width : 1)\n      const calcWidth = size.width * (size.height ? height / size.height : 1)\n      if (rowHeight < calcHeight) {\n        width = calcWidth\n      } else {\n        height = calcHeight\n      }\n      size = {\n        width,\n        height,\n      }\n      node.setSize(size, options)\n    }\n\n    if (centre) {\n      cx = (columnWidth - size.width) / 2\n      cy = (rowHeight - size.height) / 2\n    }\n\n    node.position(\n      columnLefts[rowIndex] + dx + cx,\n      rowTops[columnIndex] + dy + cy,\n      options,\n    )\n  })\n\n  model.stopBatch('layout')\n}\n\nnamespace GridLayout {\n  export interface Options extends Node.SetPositionOptions {\n    columns?: number\n    columnWidth?: number | 'auto' | 'compact'\n    rowHeight?: number | 'auto' | 'compact'\n    dx?: number\n    dy?: number\n    marginX?: number\n    marginY?: number\n    /**\n     * Positions the elements in the center of a grid cell.\n     *\n     * Default: true\n     */\n    center?: boolean\n    /**\n     * Resizes the elements to fit a grid cell, preserving the aspect ratio.\n     *\n     * Default: false\n     */\n    resizeToFit?: boolean\n  }\n\n  export function getMaxDim(nodes: Node[], name: 'width' | 'height') {\n    return nodes.reduce(\n      (memo, node) => Math.max(node?.getSize()[name], memo),\n      0,\n    )\n  }\n\n  export function getNodesInRow(\n    nodes: Node[],\n    rowIndex: number,\n    columnCount: number,\n  ) {\n    const res: Node[] = []\n    for (let i = columnCount * rowIndex, ii = i + columnCount; i < ii; i += 1) {\n      if (nodes[i]) res.push(nodes[i])\n    }\n    return res\n  }\n\n  export function getNodesInColumn(\n    nodes: Node[],\n    columnIndex: number,\n    columnCount: number,\n  ) {\n    const res: Node[] = []\n    for (let i = columnIndex, ii = nodes.length; i < ii; i += columnCount) {\n      if (nodes[i]) res.push(nodes[i])\n    }\n    return res\n  }\n\n  export function accumulate(items: number[], start: number) {\n    return items.reduce(\n      (memo, item, i) => {\n        memo.push(memo[i] + item)\n        return memo\n      },\n      [start || 0],\n    )\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}