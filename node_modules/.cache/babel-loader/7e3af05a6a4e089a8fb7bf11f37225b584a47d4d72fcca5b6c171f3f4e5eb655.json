{"ast":null,"code":"import { ArrayExt } from '@antv/x6-common';\nimport { Point } from '@antv/x6-geometry';\n/**\n * Helper structure to identify whether a point lies inside an obstacle.\n */\nexport class ObstacleMap {\n  constructor(options) {\n    this.options = options;\n    this.mapGridSize = 100;\n    this.map = {};\n  }\n  /**\n   * Builds a map of all nodes for quicker obstacle queries i.e. is a point\n   * contained in any obstacle?\n   *\n   * A simplified grid search.\n   */\n  build(model, edge) {\n    const options = this.options;\n    // source or target node could be excluded from set of obstacles\n    const excludedTerminals = options.excludeTerminals.reduce((memo, type) => {\n      const terminal = edge[type];\n      if (terminal) {\n        const cell = model.getCell(terminal.cell);\n        if (cell) {\n          memo.push(cell);\n        }\n      }\n      return memo;\n    }, []);\n    let excludedAncestors = [];\n    const source = model.getCell(edge.getSourceCellId());\n    if (source) {\n      excludedAncestors = ArrayExt.union(excludedAncestors, source.getAncestors().map(cell => cell.id));\n    }\n    const target = model.getCell(edge.getTargetCellId());\n    if (target) {\n      excludedAncestors = ArrayExt.union(excludedAncestors, target.getAncestors().map(cell => cell.id));\n    }\n    // The graph is divided into smaller cells, where each holds information\n    // about which node belong to it. When we query whether a point lies\n    // inside an obstacle we don't need to go through all obstacles, we check\n    // only those in a particular cell.\n    const mapGridSize = this.mapGridSize;\n    model.getNodes().reduce((map, node) => {\n      const excludedTerminal = excludedTerminals.some(cell => cell.id === node.id);\n      const excludedShape = node.shape ? options.excludeShapes.includes(node.shape) : false;\n      const excludedNode = options.excludeNodes.some(item => {\n        if (typeof item === 'string') {\n          return node.id === item;\n        }\n        return item === node;\n      });\n      const excludedAncestor = excludedAncestors.includes(node.id);\n      const excluded = excludedShape || excludedTerminal || excludedNode || excludedAncestor;\n      if (node.isVisible() && !excluded) {\n        const bbox = node.getBBox().moveAndExpand(options.paddingBox);\n        const origin = bbox.getOrigin().snapToGrid(mapGridSize);\n        const corner = bbox.getCorner().snapToGrid(mapGridSize);\n        for (let x = origin.x; x <= corner.x; x += mapGridSize) {\n          for (let y = origin.y; y <= corner.y; y += mapGridSize) {\n            const key = new Point(x, y).toString();\n            if (map[key] == null) {\n              map[key] = [];\n            }\n            map[key].push(bbox);\n          }\n        }\n      }\n      return map;\n    }, this.map);\n    return this;\n  }\n  isAccessible(point) {\n    const key = point.clone().snapToGrid(this.mapGridSize).toString();\n    const rects = this.map[key];\n    return rects ? rects.every(rect => !rect.containsPoint(point)) : true;\n  }\n}","map":{"version":3,"names":["ArrayExt","Point","ObstacleMap","constructor","options","mapGridSize","map","build","model","edge","excludedTerminals","excludeTerminals","reduce","memo","type","terminal","cell","getCell","push","excludedAncestors","source","getSourceCellId","union","getAncestors","id","target","getTargetCellId","getNodes","node","excludedTerminal","some","excludedShape","shape","excludeShapes","includes","excludedNode","excludeNodes","item","excludedAncestor","excluded","isVisible","bbox","getBBox","moveAndExpand","paddingBox","origin","getOrigin","snapToGrid","corner","getCorner","x","y","key","toString","isAccessible","point","clone","rects","every","rect","containsPoint"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/src/registry/router/manhattan/obstacle-map.ts"],"sourcesContent":["import { ArrayExt, KeyValue } from '@antv/x6-common'\nimport { Rectangle, Point } from '@antv/x6-geometry'\nimport { Cell, Edge, Model } from '../../../model'\nimport { ResolvedOptions } from './options'\n\n/**\n * Helper structure to identify whether a point lies inside an obstacle.\n */\nexport class ObstacleMap {\n  options: ResolvedOptions\n\n  /**\n   * How to divide the paper when creating the elements map\n   */\n  mapGridSize: number\n\n  map: KeyValue<Rectangle[]>\n\n  constructor(options: ResolvedOptions) {\n    this.options = options\n    this.mapGridSize = 100\n    this.map = {}\n  }\n\n  /**\n   * Builds a map of all nodes for quicker obstacle queries i.e. is a point\n   * contained in any obstacle?\n   *\n   * A simplified grid search.\n   */\n  build(model: Model, edge: Edge) {\n    const options = this.options\n    // source or target node could be excluded from set of obstacles\n    const excludedTerminals = options.excludeTerminals.reduce<Cell[]>(\n      (memo, type) => {\n        const terminal = edge[type]\n        if (terminal) {\n          const cell = model.getCell((terminal as Edge.TerminalCellData).cell)\n          if (cell) {\n            memo.push(cell)\n          }\n        }\n\n        return memo\n      },\n      [],\n    )\n\n    let excludedAncestors: string[] = []\n\n    const source = model.getCell(edge.getSourceCellId())\n    if (source) {\n      excludedAncestors = ArrayExt.union(\n        excludedAncestors,\n        source.getAncestors().map((cell) => cell.id),\n      )\n    }\n\n    const target = model.getCell(edge.getTargetCellId())\n    if (target) {\n      excludedAncestors = ArrayExt.union(\n        excludedAncestors,\n        target.getAncestors().map((cell) => cell.id),\n      )\n    }\n\n    // The graph is divided into smaller cells, where each holds information\n    // about which node belong to it. When we query whether a point lies\n    // inside an obstacle we don't need to go through all obstacles, we check\n    // only those in a particular cell.\n    const mapGridSize = this.mapGridSize\n\n    model.getNodes().reduce((map, node) => {\n      const excludedTerminal = excludedTerminals.some(\n        (cell) => cell.id === node.id,\n      )\n      const excludedShape = node.shape\n        ? options.excludeShapes.includes(node.shape)\n        : false\n      const excludedNode = options.excludeNodes.some((item) => {\n        if (typeof item === 'string') {\n          return node.id === item\n        }\n        return item === node\n      })\n      const excludedAncestor = excludedAncestors.includes(node.id)\n      const excluded =\n        excludedShape || excludedTerminal || excludedNode || excludedAncestor\n\n      if (node.isVisible() && !excluded) {\n        const bbox = node.getBBox().moveAndExpand(options.paddingBox)\n        const origin = bbox.getOrigin().snapToGrid(mapGridSize)\n        const corner = bbox.getCorner().snapToGrid(mapGridSize)\n\n        for (let x = origin.x; x <= corner.x; x += mapGridSize) {\n          for (let y = origin.y; y <= corner.y; y += mapGridSize) {\n            const key = new Point(x, y).toString()\n            if (map[key] == null) {\n              map[key] = []\n            }\n            map[key].push(bbox)\n          }\n        }\n      }\n      return map\n    }, this.map)\n\n    return this\n  }\n\n  isAccessible(point: Point) {\n    const key = point.clone().snapToGrid(this.mapGridSize).toString()\n\n    const rects = this.map[key]\n    return rects ? rects.every((rect) => !rect.containsPoint(point)) : true\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}