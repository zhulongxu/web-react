{"ast":null,"code":"const isEdgeView = (val, {\n  view\n}) => {\n  return view.cell.isEdge();\n};\nexport const connection = {\n  qualify: isEdgeView,\n  set(val, args) {\n    var _a, _b, _c, _d;\n    const view = args.view;\n    const reverse = val.reverse || false;\n    const stubs = val.stubs || 0;\n    let d;\n    if (Number.isFinite(stubs) && stubs !== 0) {\n      if (!reverse) {\n        let offset;\n        if (stubs < 0) {\n          const len = view.getConnectionLength() || 0;\n          offset = (len + stubs) / 2;\n        } else {\n          offset = stubs;\n        }\n        const path = view.getConnection();\n        if (path) {\n          const sourceParts = path.divideAtLength(offset);\n          const targetParts = path.divideAtLength(-offset);\n          if (sourceParts && targetParts) {\n            d = `${sourceParts[0].serialize()} ${targetParts[1].serialize()}`;\n          }\n        }\n      } else {\n        let offset;\n        let length;\n        const len = view.getConnectionLength() || 0;\n        if (stubs < 0) {\n          offset = (len + stubs) / 2;\n          length = -stubs;\n        } else {\n          offset = stubs;\n          length = len - stubs * 2;\n        }\n        const path = view.getConnection();\n        d = (_d = (_c = (_b = (_a = path === null || path === void 0 ? void 0 : path.divideAtLength(offset)) === null || _a === void 0 ? void 0 : _a[1]) === null || _b === void 0 ? void 0 : _b.divideAtLength(length)) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.serialize();\n      }\n    }\n    return {\n      d: d || view.getConnectionPathData()\n    };\n  }\n};\nexport const atConnectionLengthKeepGradient = {\n  qualify: isEdgeView,\n  set: atConnectionWrapper('getTangentAtLength', {\n    rotate: true\n  })\n};\nexport const atConnectionLengthIgnoreGradient = {\n  qualify: isEdgeView,\n  set: atConnectionWrapper('getTangentAtLength', {\n    rotate: false\n  })\n};\nexport const atConnectionRatioKeepGradient = {\n  qualify: isEdgeView,\n  set: atConnectionWrapper('getTangentAtRatio', {\n    rotate: true\n  })\n};\nexport const atConnectionRatioIgnoreGradient = {\n  qualify: isEdgeView,\n  set: atConnectionWrapper('getTangentAtRatio', {\n    rotate: false\n  })\n};\n// aliases\n// -------\nexport const atConnectionLength = atConnectionLengthKeepGradient;\nexport const atConnectionRatio = atConnectionRatioKeepGradient;\n// utils\n// -----\nfunction atConnectionWrapper(method, options) {\n  const zeroVector = {\n    x: 1,\n    y: 0\n  };\n  return (value, args) => {\n    let p;\n    let angle;\n    const view = args.view;\n    const tangent = view[method](Number(value));\n    if (tangent) {\n      angle = options.rotate ? tangent.vector().vectorAngle(zeroVector) : 0;\n      p = tangent.start;\n    } else {\n      p = view.path.start;\n      angle = 0;\n    }\n    if (angle === 0) {\n      return {\n        transform: `translate(${p.x},${p.y}')`\n      };\n    }\n    return {\n      transform: `translate(${p.x},${p.y}') rotate(${angle})`\n    };\n  };\n}","map":{"version":3,"names":["isEdgeView","val","view","cell","isEdge","connection","qualify","set","args","reverse","stubs","d","Number","isFinite","offset","len","getConnectionLength","path","getConnection","sourceParts","divideAtLength","targetParts","serialize","length","_d","_c","_b","_a","getConnectionPathData","atConnectionLengthKeepGradient","atConnectionWrapper","rotate","atConnectionLengthIgnoreGradient","atConnectionRatioKeepGradient","atConnectionRatioIgnoreGradient","atConnectionLength","atConnectionRatio","method","options","zeroVector","x","y","value","p","angle","tangent","vector","vectorAngle","start","transform"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/src/registry/attr/connection.ts"],"sourcesContent":["import { EdgeView } from '../../view'\nimport { Attr } from './index'\n\nconst isEdgeView: Attr.QualifyFucntion = (val, { view }) => {\n  return view.cell.isEdge()\n}\n\nexport const connection: Attr.Definition = {\n  qualify: isEdgeView,\n  set(val, args) {\n    const view = args.view as EdgeView\n    const reverse = ((val as any).reverse || false) as boolean\n    const stubs = ((val as any).stubs || 0) as number\n    let d\n    if (Number.isFinite(stubs) && stubs !== 0) {\n      if (!reverse) {\n        let offset\n        if (stubs < 0) {\n          const len = view.getConnectionLength() || 0\n          offset = (len + stubs) / 2\n        } else {\n          offset = stubs\n        }\n\n        const path = view.getConnection()\n        if (path) {\n          const sourceParts = path.divideAtLength(offset)\n          const targetParts = path.divideAtLength(-offset)\n          if (sourceParts && targetParts) {\n            d = `${sourceParts[0].serialize()} ${targetParts[1].serialize()}`\n          }\n        }\n      } else {\n        let offset\n        let length\n        const len = view.getConnectionLength() || 0\n        if (stubs < 0) {\n          offset = (len + stubs) / 2\n          length = -stubs\n        } else {\n          offset = stubs\n          length = len - stubs * 2\n        }\n\n        const path = view.getConnection()\n        d = path\n          ?.divideAtLength(offset)?.[1]\n          ?.divideAtLength(length)?.[0]\n          ?.serialize()\n      }\n    }\n\n    return { d: d || view.getConnectionPathData() }\n  },\n}\n\nexport const atConnectionLengthKeepGradient: Attr.Definition = {\n  qualify: isEdgeView,\n  set: atConnectionWrapper('getTangentAtLength', { rotate: true }),\n}\n\nexport const atConnectionLengthIgnoreGradient: Attr.Definition = {\n  qualify: isEdgeView,\n  set: atConnectionWrapper('getTangentAtLength', { rotate: false }),\n}\n\nexport const atConnectionRatioKeepGradient: Attr.Definition = {\n  qualify: isEdgeView,\n  set: atConnectionWrapper('getTangentAtRatio', { rotate: true }),\n}\n\nexport const atConnectionRatioIgnoreGradient: Attr.Definition = {\n  qualify: isEdgeView,\n  set: atConnectionWrapper('getTangentAtRatio', { rotate: false }),\n}\n\n// aliases\n// -------\nexport const atConnectionLength = atConnectionLengthKeepGradient\nexport const atConnectionRatio = atConnectionRatioKeepGradient\n\n// utils\n// -----\n\nfunction atConnectionWrapper(\n  method: 'getTangentAtLength' | 'getTangentAtRatio',\n  options: { rotate: boolean },\n): Attr.SetFunction {\n  const zeroVector = { x: 1, y: 0 }\n\n  return (value, args) => {\n    let p\n    let angle\n\n    const view = args.view as EdgeView\n    const tangent = view[method](Number(value))\n    if (tangent) {\n      angle = options.rotate ? tangent.vector().vectorAngle(zeroVector) : 0\n      p = tangent.start\n    } else {\n      p = (view as any).path.start\n      angle = 0\n    }\n\n    if (angle === 0) {\n      return { transform: `translate(${p.x},${p.y}')` }\n    }\n\n    return {\n      transform: `translate(${p.x},${p.y}') rotate(${angle})`,\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}