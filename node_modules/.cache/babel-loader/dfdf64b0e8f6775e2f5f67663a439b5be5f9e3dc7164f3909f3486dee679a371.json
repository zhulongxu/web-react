{"ast":null,"code":"import { Point } from './point';\nimport { Rectangle } from './rectangle';\nimport { Geometry } from './geometry';\nexport class Ellipse extends Geometry {\n  get center() {\n    return new Point(this.x, this.y);\n  }\n  constructor(x, y, a, b) {\n    super();\n    this.x = x == null ? 0 : x;\n    this.y = y == null ? 0 : y;\n    this.a = a == null ? 0 : a;\n    this.b = b == null ? 0 : b;\n  }\n  /**\n   * Returns a rectangle that is the bounding box of the ellipse.\n   */\n  bbox() {\n    return Rectangle.fromEllipse(this);\n  }\n  /**\n   * Returns a point that is the center of the ellipse.\n   */\n  getCenter() {\n    return this.center;\n  }\n  inflate(dx, dy) {\n    const w = dx;\n    const h = dy != null ? dy : dx;\n    this.a += 2 * w;\n    this.b += 2 * h;\n    return this;\n  }\n  normalizedDistance(x, y) {\n    const ref = Point.create(x, y);\n    const dx = ref.x - this.x;\n    const dy = ref.y - this.y;\n    const a = this.a;\n    const b = this.b;\n    return dx * dx / (a * a) + dy * dy / (b * b);\n  }\n  containsPoint(x, y) {\n    return this.normalizedDistance(x, y) <= 1;\n  }\n  /**\n   * Returns an array of the intersection points of the ellipse and the line.\n   * Returns `null` if no intersection exists.\n   */\n  intersectsWithLine(line) {\n    const intersections = [];\n    const rx = this.a;\n    const ry = this.b;\n    const a1 = line.start;\n    const a2 = line.end;\n    const dir = line.vector();\n    const diff = a1.diff(new Point(this.x, this.y));\n    const mDir = new Point(dir.x / (rx * rx), dir.y / (ry * ry));\n    const mDiff = new Point(diff.x / (rx * rx), diff.y / (ry * ry));\n    const a = dir.dot(mDir);\n    const b = dir.dot(mDiff);\n    const c = diff.dot(mDiff) - 1.0;\n    const d = b * b - a * c;\n    if (d < 0) {\n      return null;\n    }\n    if (d > 0) {\n      const root = Math.sqrt(d);\n      const ta = (-b - root) / a;\n      const tb = (-b + root) / a;\n      if ((ta < 0 || ta > 1) && (tb < 0 || tb > 1)) {\n        // outside\n        return null;\n      }\n      if (ta >= 0 && ta <= 1) {\n        intersections.push(a1.lerp(a2, ta));\n      }\n      if (tb >= 0 && tb <= 1) {\n        intersections.push(a1.lerp(a2, tb));\n      }\n    } else {\n      const t = -b / a;\n      if (t >= 0 && t <= 1) {\n        intersections.push(a1.lerp(a2, t));\n      } else {\n        // outside\n        return null;\n      }\n    }\n    return intersections;\n  }\n  /**\n   * Returns the point on the boundary of the ellipse that is the\n   * intersection of the ellipse with a line starting in the center\n   * of the ellipse ending in the point `p`.\n   *\n   * If angle is specified, the intersection will take into account\n   * the rotation of the ellipse by angle degrees around its center.\n   */\n  intersectsWithLineFromCenterToPoint(p, angle = 0) {\n    const ref = Point.clone(p);\n    if (angle) {\n      ref.rotate(angle, this.getCenter());\n    }\n    const dx = ref.x - this.x;\n    const dy = ref.y - this.y;\n    let result;\n    if (dx === 0) {\n      result = this.bbox().getNearestPointToPoint(ref);\n      if (angle) {\n        return result.rotate(-angle, this.getCenter());\n      }\n      return result;\n    }\n    const m = dy / dx;\n    const mSquared = m * m;\n    const aSquared = this.a * this.a;\n    const bSquared = this.b * this.b;\n    let x = Math.sqrt(1 / (1 / aSquared + mSquared / bSquared));\n    x = dx < 0 ? -x : x;\n    const y = m * x;\n    result = new Point(this.x + x, this.y + y);\n    if (angle) {\n      return result.rotate(-angle, this.getCenter());\n    }\n    return result;\n  }\n  /**\n   * Returns the angle between the x-axis and the tangent from a point. It is\n   * valid for points lying on the ellipse boundary only.\n   */\n  tangentTheta(p) {\n    const ref = Point.clone(p);\n    const x0 = ref.x;\n    const y0 = ref.y;\n    const a = this.a;\n    const b = this.b;\n    const center = this.bbox().center;\n    const cx = center.x;\n    const cy = center.y;\n    const refPointDelta = 30;\n    const q1 = x0 > center.x + a / 2;\n    const q3 = x0 < center.x - a / 2;\n    let x;\n    let y;\n    if (q1 || q3) {\n      y = x0 > center.x ? y0 - refPointDelta : y0 + refPointDelta;\n      x = a * a / (x0 - cx) - a * a * (y0 - cy) * (y - cy) / (b * b * (x0 - cx)) + cx;\n    } else {\n      x = y0 > center.y ? x0 + refPointDelta : x0 - refPointDelta;\n      y = b * b / (y0 - cy) - b * b * (x0 - cx) * (x - cx) / (a * a * (y0 - cy)) + cy;\n    }\n    return new Point(x, y).theta(ref);\n  }\n  scale(sx, sy) {\n    this.a *= sx;\n    this.b *= sy;\n    return this;\n  }\n  rotate(angle, origin) {\n    const rect = Rectangle.fromEllipse(this);\n    rect.rotate(angle, origin);\n    const ellipse = Ellipse.fromRect(rect);\n    this.a = ellipse.a;\n    this.b = ellipse.b;\n    this.x = ellipse.x;\n    this.y = ellipse.y;\n    return this;\n  }\n  translate(dx, dy) {\n    const p = Point.create(dx, dy);\n    this.x += p.x;\n    this.y += p.y;\n    return this;\n  }\n  equals(ellipse) {\n    return ellipse != null && ellipse.x === this.x && ellipse.y === this.y && ellipse.a === this.a && ellipse.b === this.b;\n  }\n  clone() {\n    return new Ellipse(this.x, this.y, this.a, this.b);\n  }\n  toJSON() {\n    return {\n      x: this.x,\n      y: this.y,\n      a: this.a,\n      b: this.b\n    };\n  }\n  serialize() {\n    return `${this.x} ${this.y} ${this.a} ${this.b}`;\n  }\n}\n(function (Ellipse) {\n  function isEllipse(instance) {\n    return instance != null && instance instanceof Ellipse;\n  }\n  Ellipse.isEllipse = isEllipse;\n})(Ellipse || (Ellipse = {}));\n(function (Ellipse) {\n  function create(x, y, a, b) {\n    if (x == null || typeof x === 'number') {\n      return new Ellipse(x, y, a, b);\n    }\n    return parse(x);\n  }\n  Ellipse.create = create;\n  function parse(e) {\n    if (Ellipse.isEllipse(e)) {\n      return e.clone();\n    }\n    if (Array.isArray(e)) {\n      return new Ellipse(e[0], e[1], e[2], e[3]);\n    }\n    return new Ellipse(e.x, e.y, e.a, e.b);\n  }\n  Ellipse.parse = parse;\n  function fromRect(rect) {\n    const center = rect.center;\n    return new Ellipse(center.x, center.y, rect.width / 2, rect.height / 2);\n  }\n  Ellipse.fromRect = fromRect;\n})(Ellipse || (Ellipse = {}));","map":{"version":3,"names":["Point","Rectangle","Geometry","Ellipse","center","x","y","constructor","a","b","bbox","fromEllipse","getCenter","inflate","dx","dy","w","h","normalizedDistance","ref","create","containsPoint","intersectsWithLine","line","intersections","rx","ry","a1","start","a2","end","dir","vector","diff","mDir","mDiff","dot","c","d","root","Math","sqrt","ta","tb","push","lerp","t","intersectsWithLineFromCenterToPoint","p","angle","clone","rotate","result","getNearestPointToPoint","m","mSquared","aSquared","bSquared","tangentTheta","x0","y0","cx","cy","refPointDelta","q1","q3","theta","scale","sx","sy","origin","rect","ellipse","fromRect","translate","equals","toJSON","serialize","isEllipse","instance","parse","e","Array","isArray","width","height"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6-geometry@2.0.5/node_modules/@antv/x6-geometry/src/ellipse.ts"],"sourcesContent":["import { Line } from './line'\nimport { Point } from './point'\nimport { Rectangle } from './rectangle'\nimport { Geometry } from './geometry'\n\nexport class Ellipse extends Geometry implements Ellipse.EllipseLike {\n  public x: number\n  public y: number\n  public a: number\n  public b: number\n\n  public get center() {\n    return new Point(this.x, this.y)\n  }\n\n  constructor(x?: number, y?: number, a?: number, b?: number) {\n    super()\n    this.x = x == null ? 0 : x\n    this.y = y == null ? 0 : y\n    this.a = a == null ? 0 : a\n    this.b = b == null ? 0 : b\n  }\n\n  /**\n   * Returns a rectangle that is the bounding box of the ellipse.\n   */\n  bbox() {\n    return Rectangle.fromEllipse(this)\n  }\n\n  /**\n   * Returns a point that is the center of the ellipse.\n   */\n  getCenter() {\n    return this.center\n  }\n\n  /**\n   * Returns ellipse inflated in axis-x by `2 * amount` and in axis-y by\n   * `2 * amount`.\n   */\n  inflate(amount: number): this\n  /**\n   * Returns ellipse inflated in axis-x by `2 * dx` and in axis-y by `2 * dy`.\n   */\n  inflate(dx: number, dy: number): this\n  inflate(dx: number, dy?: number): this {\n    const w = dx\n    const h = dy != null ? dy : dx\n    this.a += 2 * w\n    this.b += 2 * h\n\n    return this\n  }\n\n  /**\n   * Returns a normalized distance from the ellipse center to point `p`.\n   * Returns `n < 1` for points inside the ellipse, `n = 1` for points\n   * lying on the ellipse boundary and `n > 1` for points outside the ellipse.\n   */\n  normalizedDistance(x: number, y: number): number\n  normalizedDistance(p: Point.PointLike | Point.PointData): number\n  normalizedDistance(\n    x: number | Point.PointLike | Point.PointData,\n    y?: number,\n  ) {\n    const ref = Point.create(x, y)\n    const dx = ref.x - this.x\n    const dy = ref.y - this.y\n    const a = this.a\n    const b = this.b\n\n    return (dx * dx) / (a * a) + (dy * dy) / (b * b)\n  }\n\n  /**\n   * Returns `true` if the point `p` is inside the ellipse (inclusive).\n   * Returns `false` otherwise.\n   */\n  containsPoint(x: number, y: number): boolean\n  containsPoint(p: Point.PointLike | Point.PointData): boolean\n  containsPoint(x: number | Point.PointLike | Point.PointData, y?: number) {\n    return this.normalizedDistance(x as number, y as number) <= 1\n  }\n\n  /**\n   * Returns an array of the intersection points of the ellipse and the line.\n   * Returns `null` if no intersection exists.\n   */\n  intersectsWithLine(line: Line) {\n    const intersections = []\n    const rx = this.a\n    const ry = this.b\n    const a1 = line.start\n    const a2 = line.end\n    const dir = line.vector()\n    const diff = a1.diff(new Point(this.x, this.y))\n    const mDir = new Point(dir.x / (rx * rx), dir.y / (ry * ry))\n    const mDiff = new Point(diff.x / (rx * rx), diff.y / (ry * ry))\n\n    const a = dir.dot(mDir)\n    const b = dir.dot(mDiff)\n    const c = diff.dot(mDiff) - 1.0\n    const d = b * b - a * c\n\n    if (d < 0) {\n      return null\n    }\n\n    if (d > 0) {\n      const root = Math.sqrt(d)\n      const ta = (-b - root) / a\n      const tb = (-b + root) / a\n\n      if ((ta < 0 || ta > 1) && (tb < 0 || tb > 1)) {\n        // outside\n        return null\n      }\n\n      if (ta >= 0 && ta <= 1) {\n        intersections.push(a1.lerp(a2, ta))\n      }\n\n      if (tb >= 0 && tb <= 1) {\n        intersections.push(a1.lerp(a2, tb))\n      }\n    } else {\n      const t = -b / a\n      if (t >= 0 && t <= 1) {\n        intersections.push(a1.lerp(a2, t))\n      } else {\n        // outside\n        return null\n      }\n    }\n\n    return intersections\n  }\n\n  /**\n   * Returns the point on the boundary of the ellipse that is the\n   * intersection of the ellipse with a line starting in the center\n   * of the ellipse ending in the point `p`.\n   *\n   * If angle is specified, the intersection will take into account\n   * the rotation of the ellipse by angle degrees around its center.\n   */\n  intersectsWithLineFromCenterToPoint(\n    p: Point.PointLike | Point.PointData,\n    angle = 0,\n  ) {\n    const ref = Point.clone(p)\n    if (angle) {\n      ref.rotate(angle, this.getCenter())\n    }\n\n    const dx = ref.x - this.x\n    const dy = ref.y - this.y\n    let result\n\n    if (dx === 0) {\n      result = this.bbox().getNearestPointToPoint(ref)\n      if (angle) {\n        return result.rotate(-angle, this.getCenter())\n      }\n      return result\n    }\n\n    const m = dy / dx\n    const mSquared = m * m\n    const aSquared = this.a * this.a\n    const bSquared = this.b * this.b\n\n    let x = Math.sqrt(1 / (1 / aSquared + mSquared / bSquared))\n    x = dx < 0 ? -x : x\n\n    const y = m * x\n    result = new Point(this.x + x, this.y + y)\n\n    if (angle) {\n      return result.rotate(-angle, this.getCenter())\n    }\n\n    return result\n  }\n\n  /**\n   * Returns the angle between the x-axis and the tangent from a point. It is\n   * valid for points lying on the ellipse boundary only.\n   */\n  tangentTheta(p: Point.PointLike | Point.PointData) {\n    const ref = Point.clone(p)\n    const x0 = ref.x\n    const y0 = ref.y\n    const a = this.a\n    const b = this.b\n    const center = this.bbox().center\n    const cx = center.x\n    const cy = center.y\n    const refPointDelta = 30\n\n    const q1 = x0 > center.x + a / 2\n    const q3 = x0 < center.x - a / 2\n\n    let x\n    let y\n\n    if (q1 || q3) {\n      y = x0 > center.x ? y0 - refPointDelta : y0 + refPointDelta\n      x =\n        (a * a) / (x0 - cx) -\n        (a * a * (y0 - cy) * (y - cy)) / (b * b * (x0 - cx)) +\n        cx\n    } else {\n      x = y0 > center.y ? x0 + refPointDelta : x0 - refPointDelta\n      y =\n        (b * b) / (y0 - cy) -\n        (b * b * (x0 - cx) * (x - cx)) / (a * a * (y0 - cy)) +\n        cy\n    }\n\n    return new Point(x, y).theta(ref)\n  }\n\n  scale(sx: number, sy: number) {\n    this.a *= sx\n    this.b *= sy\n    return this\n  }\n\n  rotate(angle: number, origin?: Point.PointLike | Point.PointData) {\n    const rect = Rectangle.fromEllipse(this)\n    rect.rotate(angle, origin)\n    const ellipse = Ellipse.fromRect(rect)\n    this.a = ellipse.a\n    this.b = ellipse.b\n    this.x = ellipse.x\n    this.y = ellipse.y\n    return this\n  }\n\n  translate(dx: number, dy: number): this\n  translate(p: Point.PointLike | Point.PointData): this\n  translate(dx: number | Point.PointLike | Point.PointData, dy?: number): this {\n    const p = Point.create(dx, dy)\n    this.x += p.x\n    this.y += p.y\n    return this\n  }\n\n  equals(ellipse: Ellipse) {\n    return (\n      ellipse != null &&\n      ellipse.x === this.x &&\n      ellipse.y === this.y &&\n      ellipse.a === this.a &&\n      ellipse.b === this.b\n    )\n  }\n\n  clone() {\n    return new Ellipse(this.x, this.y, this.a, this.b)\n  }\n\n  toJSON() {\n    return { x: this.x, y: this.y, a: this.a, b: this.b }\n  }\n\n  serialize() {\n    return `${this.x} ${this.y} ${this.a} ${this.b}`\n  }\n}\n\nexport namespace Ellipse {\n  export function isEllipse(instance: any): instance is Ellipse {\n    return instance != null && instance instanceof Ellipse\n  }\n}\n\nexport namespace Ellipse {\n  export interface EllipseLike extends Point.PointLike {\n    x: number\n    y: number\n    a: number\n    b: number\n  }\n\n  export type EllipseData = [number, number, number, number]\n}\n\nexport namespace Ellipse {\n  export function create(\n    x?: number | Ellipse | EllipseLike | EllipseData,\n    y?: number,\n    a?: number,\n    b?: number,\n  ): Ellipse {\n    if (x == null || typeof x === 'number') {\n      return new Ellipse(x, y, a, b)\n    }\n\n    return parse(x)\n  }\n\n  export function parse(e: Ellipse | EllipseLike | EllipseData) {\n    if (Ellipse.isEllipse(e)) {\n      return e.clone()\n    }\n\n    if (Array.isArray(e)) {\n      return new Ellipse(e[0], e[1], e[2], e[3])\n    }\n\n    return new Ellipse(e.x, e.y, e.a, e.b)\n  }\n\n  export function fromRect(rect: Rectangle) {\n    const center = rect.center\n    return new Ellipse(center.x, center.y, rect.width / 2, rect.height / 2)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}