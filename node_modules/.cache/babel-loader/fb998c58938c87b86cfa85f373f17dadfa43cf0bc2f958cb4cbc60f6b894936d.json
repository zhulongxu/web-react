{"ast":null,"code":"import { Angle } from '@antv/x6-geometry';\nimport { resolve } from './util';\nconst orthogonal = function (view, magnet, refPoint, options) {\n  const angle = Angle.normalize(view.cell.getAngle());\n  const bbox = view.getBBoxOfElement(magnet);\n  const result = bbox.getCenter();\n  const topLeft = bbox.getTopLeft();\n  const bottomRight = bbox.getBottomRight();\n  let padding = options.padding;\n  if (!Number.isFinite(padding)) {\n    padding = 0;\n  }\n  if (topLeft.y + padding <= refPoint.y && refPoint.y <= bottomRight.y - padding) {\n    const dy = refPoint.y - result.y;\n    result.x += angle === 0 || angle === 180 ? 0 : dy * 1 / Math.tan(Angle.toRad(angle));\n    result.y += dy;\n  } else if (topLeft.x + padding <= refPoint.x && refPoint.x <= bottomRight.x - padding) {\n    const dx = refPoint.x - result.x;\n    result.y += angle === 90 || angle === 270 ? 0 : dx * Math.tan(Angle.toRad(angle));\n    result.x += dx;\n  }\n  return result;\n};\n/**\n * Tries to place the anchor of the edge inside the view bbox so that the\n * edge is made orthogonal. The anchor is placed along two line segments\n * inside the view bbox (between the centers of the top and bottom side and\n * between the centers of the left and right sides). If it is not possible\n * to place the anchor so that the edge would be orthogonal, the anchor is\n * placed at the center of the view bbox instead.\n */\nexport const orth = resolve(orthogonal);","map":{"version":3,"names":["Angle","resolve","orthogonal","view","magnet","refPoint","options","angle","normalize","cell","getAngle","bbox","getBBoxOfElement","result","getCenter","topLeft","getTopLeft","bottomRight","getBottomRight","padding","Number","isFinite","y","dy","x","Math","tan","toRad","dx","orth"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/src/registry/node-anchor/orth.ts"],"sourcesContent":["import { Angle } from '@antv/x6-geometry'\nimport { ResolveOptions, resolve } from './util'\nimport { NodeAnchor } from './index'\n\nexport interface OrthEndpointOptions extends ResolveOptions {\n  padding: number\n}\n\nconst orthogonal: NodeAnchor.ResolvedDefinition<OrthEndpointOptions> =\n  function (view, magnet, refPoint, options) {\n    const angle = Angle.normalize(view.cell.getAngle())\n    const bbox = view.getBBoxOfElement(magnet)\n    const result = bbox.getCenter()\n    const topLeft = bbox.getTopLeft()\n    const bottomRight = bbox.getBottomRight()\n\n    let padding = options.padding\n    if (!Number.isFinite(padding)) {\n      padding = 0\n    }\n\n    if (\n      topLeft.y + padding <= refPoint.y &&\n      refPoint.y <= bottomRight.y - padding\n    ) {\n      const dy = refPoint.y - result.y\n      result.x +=\n        angle === 0 || angle === 180\n          ? 0\n          : (dy * 1) / Math.tan(Angle.toRad(angle))\n      result.y += dy\n    } else if (\n      topLeft.x + padding <= refPoint.x &&\n      refPoint.x <= bottomRight.x - padding\n    ) {\n      const dx = refPoint.x - result.x\n      result.y +=\n        angle === 90 || angle === 270 ? 0 : dx * Math.tan(Angle.toRad(angle))\n      result.x += dx\n    }\n\n    return result\n  }\n\n/**\n * Tries to place the anchor of the edge inside the view bbox so that the\n * edge is made orthogonal. The anchor is placed along two line segments\n * inside the view bbox (between the centers of the top and bottom side and\n * between the centers of the left and right sides). If it is not possible\n * to place the anchor so that the edge would be orthogonal, the anchor is\n * placed at the center of the view bbox instead.\n */\nexport const orth = resolve<\n  NodeAnchor.ResolvedDefinition<OrthEndpointOptions>,\n  NodeAnchor.Definition<OrthEndpointOptions>\n>(orthogonal)\n"],"mappings":"AAAA,SAASA,KAAK,QAAQ,mBAAmB;AACzC,SAAyBC,OAAO,QAAQ,QAAQ;AAOhD,MAAMC,UAAU,GACd,SAAAA,CAAUC,IAAI,EAAEC,MAAM,EAAEC,QAAQ,EAAEC,OAAO;EACvC,MAAMC,KAAK,GAAGP,KAAK,CAACQ,SAAS,CAACL,IAAI,CAACM,IAAI,CAACC,QAAQ,EAAE,CAAC;EACnD,MAAMC,IAAI,GAAGR,IAAI,CAACS,gBAAgB,CAACR,MAAM,CAAC;EAC1C,MAAMS,MAAM,GAAGF,IAAI,CAACG,SAAS,EAAE;EAC/B,MAAMC,OAAO,GAAGJ,IAAI,CAACK,UAAU,EAAE;EACjC,MAAMC,WAAW,GAAGN,IAAI,CAACO,cAAc,EAAE;EAEzC,IAAIC,OAAO,GAAGb,OAAO,CAACa,OAAO;EAC7B,IAAI,CAACC,MAAM,CAACC,QAAQ,CAACF,OAAO,CAAC,EAAE;IAC7BA,OAAO,GAAG,CAAC;;EAGb,IACEJ,OAAO,CAACO,CAAC,GAAGH,OAAO,IAAId,QAAQ,CAACiB,CAAC,IACjCjB,QAAQ,CAACiB,CAAC,IAAIL,WAAW,CAACK,CAAC,GAAGH,OAAO,EACrC;IACA,MAAMI,EAAE,GAAGlB,QAAQ,CAACiB,CAAC,GAAGT,MAAM,CAACS,CAAC;IAChCT,MAAM,CAACW,CAAC,IACNjB,KAAK,KAAK,CAAC,IAAIA,KAAK,KAAK,GAAG,GACxB,CAAC,GACAgB,EAAE,GAAG,CAAC,GAAIE,IAAI,CAACC,GAAG,CAAC1B,KAAK,CAAC2B,KAAK,CAACpB,KAAK,CAAC,CAAC;IAC7CM,MAAM,CAACS,CAAC,IAAIC,EAAE;GACf,MAAM,IACLR,OAAO,CAACS,CAAC,GAAGL,OAAO,IAAId,QAAQ,CAACmB,CAAC,IACjCnB,QAAQ,CAACmB,CAAC,IAAIP,WAAW,CAACO,CAAC,GAAGL,OAAO,EACrC;IACA,MAAMS,EAAE,GAAGvB,QAAQ,CAACmB,CAAC,GAAGX,MAAM,CAACW,CAAC;IAChCX,MAAM,CAACS,CAAC,IACNf,KAAK,KAAK,EAAE,IAAIA,KAAK,KAAK,GAAG,GAAG,CAAC,GAAGqB,EAAE,GAAGH,IAAI,CAACC,GAAG,CAAC1B,KAAK,CAAC2B,KAAK,CAACpB,KAAK,CAAC,CAAC;IACvEM,MAAM,CAACW,CAAC,IAAII,EAAE;;EAGhB,OAAOf,MAAM;AACf,CAAC;AAEH;;;;;;;;AAQA,OAAO,MAAMgB,IAAI,GAAG5B,OAAO,CAGzBC,UAAU,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}