{"ast":null,"code":"var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { ObjectExt, Basecoat } from '@antv/x6-common';\nexport class Store extends Basecoat {\n  constructor(data = {}) {\n    super();\n    this.pending = false;\n    this.changing = false;\n    this.data = {};\n    this.mutate(ObjectExt.cloneDeep(data));\n    this.changed = {};\n  }\n  mutate(data, options = {}) {\n    const unset = options.unset === true;\n    const silent = options.silent === true;\n    const changes = [];\n    const changing = this.changing;\n    this.changing = true;\n    if (!changing) {\n      this.previous = ObjectExt.cloneDeep(this.data);\n      this.changed = {};\n    }\n    const current = this.data;\n    const previous = this.previous;\n    const changed = this.changed;\n    Object.keys(data).forEach(k => {\n      const key = k;\n      const newValue = data[key];\n      if (!ObjectExt.isEqual(current[key], newValue)) {\n        changes.push(key);\n      }\n      if (!ObjectExt.isEqual(previous[key], newValue)) {\n        changed[key] = newValue;\n      } else {\n        delete changed[key];\n      }\n      if (unset) {\n        delete current[key];\n      } else {\n        current[key] = newValue;\n      }\n    });\n    if (!silent && changes.length > 0) {\n      this.pending = true;\n      this.pendingOptions = options;\n      changes.forEach(key => {\n        this.emit('change:*', {\n          key,\n          options,\n          store: this,\n          current: current[key],\n          previous: previous[key]\n        });\n      });\n    }\n    if (changing) {\n      return this;\n    }\n    if (!silent) {\n      // Changes can be recursively nested within `\"change\"` events.\n      while (this.pending) {\n        this.pending = false;\n        this.emit('changed', {\n          current,\n          previous,\n          store: this,\n          options: this.pendingOptions\n        });\n      }\n    }\n    this.pending = false;\n    this.changing = false;\n    this.pendingOptions = null;\n    return this;\n  }\n  get(key, defaultValue) {\n    if (key == null) {\n      return this.data;\n    }\n    const ret = this.data[key];\n    return ret == null ? defaultValue : ret;\n  }\n  getPrevious(key) {\n    if (this.previous) {\n      const ret = this.previous[key];\n      return ret == null ? undefined : ret;\n    }\n    return undefined;\n  }\n  set(key, value, options) {\n    if (key != null) {\n      if (typeof key === 'object') {\n        this.mutate(key, value);\n      } else {\n        this.mutate({\n          [key]: value\n        }, options);\n      }\n    }\n    return this;\n  }\n  remove(key, options) {\n    const empty = undefined;\n    const subset = {};\n    let opts;\n    if (typeof key === 'string') {\n      subset[key] = empty;\n      opts = options;\n    } else if (Array.isArray(key)) {\n      key.forEach(k => subset[k] = empty);\n      opts = options;\n    } else {\n      // eslint-disable-next-line\n      for (const key in this.data) {\n        subset[key] = empty;\n      }\n      opts = key;\n    }\n    this.mutate(subset, Object.assign(Object.assign({}, opts), {\n      unset: true\n    }));\n    return this;\n  }\n  getByPath(path) {\n    return ObjectExt.getByPath(this.data, path, '/');\n  }\n  setByPath(path, value, options = {}) {\n    const delim = '/';\n    const pathArray = Array.isArray(path) ? [...path] : path.split(delim);\n    const pathString = Array.isArray(path) ? path.join(delim) : path;\n    const property = pathArray[0];\n    const pathArrayLength = pathArray.length;\n    options.propertyPath = pathString;\n    options.propertyValue = value;\n    options.propertyPathArray = pathArray;\n    if (pathArrayLength === 1) {\n      this.set(property, value, options);\n    } else {\n      const update = {};\n      let diver = update;\n      let nextKey = property;\n      // Initialize the nested object. Subobjects are either arrays or objects.\n      // An empty array is created if the sub-key is an integer. Otherwise, an\n      // empty object is created.\n      for (let i = 1; i < pathArrayLength; i += 1) {\n        const key = pathArray[i];\n        const isArrayIndex = Number.isFinite(Number(key));\n        diver = diver[nextKey] = isArrayIndex ? [] : {};\n        nextKey = key;\n      }\n      // Fills update with the `value` on `path`.\n      ObjectExt.setByPath(update, pathArray, value, delim);\n      const data = ObjectExt.cloneDeep(this.data);\n      // If rewrite mode enabled, we replace value referenced by path with the\n      // new one (we don't merge).\n      if (options.rewrite) {\n        ObjectExt.unsetByPath(data, path, delim);\n      }\n      const merged = ObjectExt.merge(data, update);\n      this.set(property, merged[property], options);\n    }\n    return this;\n  }\n  removeByPath(path, options) {\n    const keys = Array.isArray(path) ? path : path.split('/');\n    const key = keys[0];\n    if (keys.length === 1) {\n      this.remove(key, options);\n    } else {\n      const paths = keys.slice(1);\n      const prop = ObjectExt.cloneDeep(this.get(key));\n      if (prop) {\n        ObjectExt.unsetByPath(prop, paths);\n      }\n      this.set(key, prop, options);\n    }\n    return this;\n  }\n  hasChanged(key) {\n    if (key == null) {\n      return Object.keys(this.changed).length > 0;\n    }\n    return key in this.changed;\n  }\n  /**\n   * Returns an object containing all the data that have changed,\n   * or `null` if there are no changes. Useful for determining what\n   * parts of a view need to be updated.\n   */\n  getChanges(diff) {\n    if (diff == null) {\n      return this.hasChanged() ? ObjectExt.cloneDeep(this.changed) : null;\n    }\n    const old = this.changing ? this.previous : this.data;\n    const changed = {};\n    let hasChanged;\n    // eslint-disable-next-line\n    for (const key in diff) {\n      const val = diff[key];\n      if (!ObjectExt.isEqual(old[key], val)) {\n        changed[key] = val;\n        hasChanged = true;\n      }\n    }\n    return hasChanged ? ObjectExt.cloneDeep(changed) : null;\n  }\n  /**\n   * Returns a copy of the store's `data` object.\n   */\n  toJSON() {\n    return ObjectExt.cloneDeep(this.data);\n  }\n  clone() {\n    const constructor = this.constructor;\n    return new constructor(this.data);\n  }\n  dispose() {\n    this.off();\n    this.data = {};\n    this.previous = {};\n    this.changed = {};\n    this.pending = false;\n    this.changing = false;\n    this.pendingOptions = null;\n    this.trigger('disposed', {\n      store: this\n    });\n  }\n}\n__decorate([Basecoat.dispose()], Store.prototype, \"dispose\", null);","map":{"version":3,"names":["ObjectExt","Basecoat","Store","constructor","data","pending","changing","mutate","cloneDeep","changed","options","unset","silent","changes","previous","current","Object","keys","forEach","k","key","newValue","isEqual","push","length","pendingOptions","emit","store","get","defaultValue","ret","getPrevious","undefined","set","value","remove","empty","subset","opts","Array","isArray","assign","getByPath","path","setByPath","delim","pathArray","split","pathString","join","property","pathArrayLength","propertyPath","propertyValue","propertyPathArray","update","diver","nextKey","i","isArrayIndex","Number","isFinite","rewrite","unsetByPath","merged","merge","removeByPath","paths","slice","prop","hasChanged","getChanges","diff","old","val","toJSON","clone","dispose","off","trigger","__decorate"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/src/model/store.ts"],"sourcesContent":["import { ObjectExt, KeyValue, Basecoat } from '@antv/x6-common'\nimport { Assign, NonUndefined } from 'utility-types'\n\nexport class Store<D> extends Basecoat<Store.EventArgs<D>> {\n  protected data: D\n  protected previous: D\n  protected changed: Partial<D>\n  protected pending = false\n  protected changing = false\n  protected pendingOptions: Store.MutateOptions | null\n\n  constructor(data: Partial<D> = {}) {\n    super()\n    this.data = {} as D\n    this.mutate(ObjectExt.cloneDeep(data))\n    this.changed = {}\n  }\n\n  protected mutate<K extends keyof D>(\n    data: Partial<D>,\n    options: Store.MutateOptions = {},\n  ) {\n    const unset = options.unset === true\n    const silent = options.silent === true\n    const changes: K[] = []\n    const changing = this.changing\n\n    this.changing = true\n\n    if (!changing) {\n      this.previous = ObjectExt.cloneDeep(this.data)\n      this.changed = {}\n    }\n\n    const current = this.data\n    const previous = this.previous\n    const changed = this.changed\n\n    Object.keys(data).forEach((k) => {\n      const key = k as K\n      const newValue = data[key]\n      if (!ObjectExt.isEqual(current[key], newValue)) {\n        changes.push(key)\n      }\n\n      if (!ObjectExt.isEqual(previous[key], newValue)) {\n        changed[key] = newValue\n      } else {\n        delete changed[key]\n      }\n\n      if (unset) {\n        delete current[key]\n      } else {\n        current[key] = newValue as any\n      }\n    })\n\n    if (!silent && changes.length > 0) {\n      this.pending = true\n      this.pendingOptions = options\n      changes.forEach((key) => {\n        this.emit('change:*', {\n          key,\n          options,\n          store: this,\n          current: current[key],\n          previous: previous[key],\n        })\n      })\n    }\n\n    if (changing) {\n      return this\n    }\n\n    if (!silent) {\n      // Changes can be recursively nested within `\"change\"` events.\n      while (this.pending) {\n        this.pending = false\n        this.emit('changed', {\n          current,\n          previous,\n          store: this,\n          options: this.pendingOptions!,\n        })\n      }\n    }\n\n    this.pending = false\n    this.changing = false\n    this.pendingOptions = null\n\n    return this\n  }\n\n  get(): D\n  get<K extends keyof D>(key: K): D[K]\n  get<K extends keyof D>(key: K, defaultValue: D[K]): NonUndefined<D[K]>\n  get<T>(key: string): T\n  get<T>(key: string, defaultValue: T): T\n  get<K extends keyof D>(key?: K, defaultValue?: D[K]): D | D[K] | undefined {\n    if (key == null) {\n      return this.data\n    }\n\n    const ret = this.data[key]\n    return ret == null ? defaultValue : ret\n  }\n\n  getPrevious<T>(key: keyof D) {\n    if (this.previous) {\n      const ret = this.previous[key]\n      return ret == null ? undefined : (ret as any as T)\n    }\n\n    return undefined\n  }\n\n  set<K extends keyof D>(\n    key: K,\n    value: D[K] | null | undefined | void,\n    options?: Store.SetOptions,\n  ): this\n  set(key: string, value: any, options?: Store.SetOptions): this\n  set(data: D, options?: Store.SetOptions): this\n  set<K extends keyof D>(\n    key: K | Partial<D>,\n    value?: D[K] | null | undefined | void | Store.SetOptions,\n    options?: Store.SetOptions,\n  ): this {\n    if (key != null) {\n      if (typeof key === 'object') {\n        this.mutate(key, value as Store.SetOptions)\n      } else {\n        this.mutate({ [key]: value } as Partial<D>, options)\n      }\n    }\n\n    return this\n  }\n\n  remove<K extends keyof D>(key: K | K[], options?: Store.SetOptions): this\n  remove(options?: Store.SetOptions): this\n  remove<K extends keyof D>(\n    key: K | K[] | Store.SetOptions,\n    options?: Store.SetOptions,\n  ) {\n    const empty = undefined\n    const subset: Partial<D> = {}\n    let opts: Store.SetOptions | undefined\n\n    if (typeof key === 'string') {\n      subset[key] = empty\n      opts = options\n    } else if (Array.isArray(key)) {\n      key.forEach((k) => (subset[k] = empty))\n      opts = options\n    } else {\n      // eslint-disable-next-line\n      for (const key in this.data) {\n        subset[key] = empty\n      }\n      opts = key as Store.SetOptions\n    }\n\n    this.mutate(subset, { ...opts, unset: true })\n    return this\n  }\n\n  getByPath<T>(path: string | string[]) {\n    return ObjectExt.getByPath(this.data, path, '/') as T\n  }\n\n  setByPath<K extends keyof D>(\n    path: string | string[],\n    value: any,\n    options: Store.SetByPathOptions = {},\n  ) {\n    const delim = '/'\n    const pathArray = Array.isArray(path) ? [...path] : path.split(delim)\n    const pathString = Array.isArray(path) ? path.join(delim) : path\n\n    const property = pathArray[0] as K\n    const pathArrayLength = pathArray.length\n\n    options.propertyPath = pathString\n    options.propertyValue = value\n    options.propertyPathArray = pathArray\n\n    if (pathArrayLength === 1) {\n      this.set(property, value, options)\n    } else {\n      const update: KeyValue = {}\n      let diver = update\n      let nextKey = property as string\n\n      // Initialize the nested object. Subobjects are either arrays or objects.\n      // An empty array is created if the sub-key is an integer. Otherwise, an\n      // empty object is created.\n      for (let i = 1; i < pathArrayLength; i += 1) {\n        const key = pathArray[i]\n        const isArrayIndex = Number.isFinite(Number(key))\n        diver = diver[nextKey] = isArrayIndex ? [] : {}\n        nextKey = key\n      }\n\n      // Fills update with the `value` on `path`.\n      ObjectExt.setByPath(update, pathArray, value, delim)\n\n      const data = ObjectExt.cloneDeep(this.data)\n\n      // If rewrite mode enabled, we replace value referenced by path with the\n      // new one (we don't merge).\n      if (options.rewrite) {\n        ObjectExt.unsetByPath(data, path, delim)\n      }\n\n      const merged = ObjectExt.merge(data, update)\n      this.set(property, merged[property], options)\n    }\n\n    return this\n  }\n\n  removeByPath<K extends keyof D>(\n    path: string | string[],\n    options?: Store.SetOptions,\n  ) {\n    const keys = Array.isArray(path) ? path : path.split('/')\n    const key = keys[0] as K\n    if (keys.length === 1) {\n      this.remove(key, options)\n    } else {\n      const paths = keys.slice(1)\n      const prop = ObjectExt.cloneDeep(this.get(key))\n      if (prop) {\n        ObjectExt.unsetByPath(prop, paths)\n      }\n\n      this.set(key, prop as D[K], options)\n    }\n\n    return this\n  }\n\n  hasChanged(): boolean\n  hasChanged<K extends keyof D>(key: K | null): boolean\n  hasChanged(key: string | null): boolean\n  hasChanged<K extends keyof D>(key?: K | null) {\n    if (key == null) {\n      return Object.keys(this.changed).length > 0\n    }\n\n    return key in this.changed\n  }\n\n  /**\n   * Returns an object containing all the data that have changed,\n   * or `null` if there are no changes. Useful for determining what\n   * parts of a view need to be updated.\n   */\n  getChanges(diff?: Partial<D>) {\n    if (diff == null) {\n      return this.hasChanged() ? ObjectExt.cloneDeep(this.changed) : null\n    }\n\n    const old = this.changing ? this.previous : this.data\n    const changed: Partial<D> = {}\n    let hasChanged\n    // eslint-disable-next-line\n    for (const key in diff) {\n      const val = diff[key]\n      if (!ObjectExt.isEqual(old[key], val)) {\n        changed[key] = val\n        hasChanged = true\n      }\n    }\n    return hasChanged ? ObjectExt.cloneDeep(changed) : null\n  }\n\n  /**\n   * Returns a copy of the store's `data` object.\n   */\n  toJSON() {\n    return ObjectExt.cloneDeep(this.data)\n  }\n\n  clone<T extends typeof Store>() {\n    const constructor = this.constructor as any\n    return new constructor(this.data) as T\n  }\n\n  @Basecoat.dispose()\n  dispose() {\n    this.off()\n    this.data = {} as D\n    this.previous = {} as D\n    this.changed = {}\n    this.pending = false\n    this.changing = false\n    this.pendingOptions = null\n    this.trigger('disposed', { store: this })\n  }\n}\n\nexport namespace Store {\n  export interface SetOptions extends KeyValue {\n    silent?: boolean\n  }\n\n  export interface MutateOptions extends SetOptions {\n    unset?: boolean\n  }\n\n  export interface SetByPathOptions extends SetOptions {\n    rewrite?: boolean\n  }\n\n  type CommonArgs<D> = { store: Store<D> }\n\n  export interface EventArgs<D, K extends keyof D = keyof D> {\n    'change:*': Assign<\n      {\n        key: K\n        current: D[K]\n        previous: D[K]\n        options: MutateOptions\n      },\n      CommonArgs<D>\n    >\n    changed: Assign<\n      {\n        current: D\n        previous: D\n        options: MutateOptions\n      },\n      CommonArgs<D>\n    >\n    disposed: CommonArgs<D>\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}