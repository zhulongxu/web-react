{"ast":null,"code":"export { isNumber, clamp } from 'lodash-es';\n/**\n * Returns the remainder of division of `n` by `m`. You should use this\n * instead of the built-in operation as the built-in operation does not\n * properly handle negative numbers.\n */\nexport function mod(n, m) {\n  return (n % m + m) % m;\n}\nexport function random(lower, upper) {\n  if (upper == null) {\n    upper = lower == null ? 1 : lower; // eslint-disable-line\n    lower = 0; // eslint-disable-line\n  } else if (upper < lower) {\n    const tmp = lower;\n    lower = upper; // eslint-disable-line\n    upper = tmp; // eslint-disable-line\n  }\n  return Math.floor(Math.random() * (upper - lower + 1) + lower);\n}\nexport function isPercentage(val) {\n  return typeof val === 'string' && val.slice(-1) === '%';\n}\nexport function normalizePercentage(num, ref) {\n  if (num == null) {\n    return 0;\n  }\n  let raw;\n  if (typeof num === 'string') {\n    raw = parseFloat(num);\n    if (isPercentage(num)) {\n      raw /= 100;\n      if (Number.isFinite(raw)) {\n        return raw * ref;\n      }\n    }\n  } else {\n    raw = num;\n  }\n  if (!Number.isFinite(raw)) {\n    return 0;\n  }\n  if (raw > 0 && raw < 1) {\n    return raw * ref;\n  }\n  return raw;\n}\nexport function parseCssNumeric(val, units) {\n  function getUnit(regexp) {\n    const matches = new RegExp(`(?:\\\\d+(?:\\\\.\\\\d+)*)(${regexp})$`).exec(val);\n    if (!matches) {\n      return null;\n    }\n    return matches[1];\n  }\n  const number = parseFloat(val);\n  if (Number.isNaN(number)) {\n    return null;\n  }\n  // determine the unit\n  let regexp;\n  if (units == null) {\n    // accept any unit, as well as no unit\n    regexp = '[A-Za-z]*';\n  } else if (Array.isArray(units)) {\n    if (units.length === 0) {\n      return null;\n    }\n    regexp = units.join('|');\n  } else if (typeof units === 'string') {\n    regexp = units;\n  }\n  const unit = getUnit(regexp);\n  if (unit === null) {\n    return null;\n  }\n  return {\n    unit,\n    value: number\n  };\n}\nexport function normalizeSides(box) {\n  if (typeof box === 'object') {\n    let left = 0;\n    let top = 0;\n    let right = 0;\n    let bottom = 0;\n    if (box.vertical != null && Number.isFinite(box.vertical)) {\n      top = bottom = box.vertical;\n    }\n    if (box.horizontal != null && Number.isFinite(box.horizontal)) {\n      right = left = box.horizontal;\n    }\n    if (box.left != null && Number.isFinite(box.left)) left = box.left;\n    if (box.top != null && Number.isFinite(box.top)) top = box.top;\n    if (box.right != null && Number.isFinite(box.right)) right = box.right;\n    if (box.bottom != null && Number.isFinite(box.bottom)) bottom = box.bottom;\n    return {\n      top,\n      right,\n      bottom,\n      left\n    };\n  }\n  let val = 0;\n  if (box != null && Number.isFinite(box)) {\n    val = box;\n  }\n  return {\n    top: val,\n    right: val,\n    bottom: val,\n    left: val\n  };\n}","map":{"version":3,"names":["isNumber","clamp","mod","n","m","random","lower","upper","tmp","Math","floor","isPercentage","val","slice","normalizePercentage","num","ref","raw","parseFloat","Number","isFinite","parseCssNumeric","units","getUnit","regexp","matches","RegExp","exec","number","isNaN","Array","isArray","length","join","unit","value","normalizeSides","box","left","top","right","bottom","vertical","horizontal"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/src/number/number.ts"],"sourcesContent":["export { isNumber, clamp } from 'lodash-es'\n\n/**\n * Returns the remainder of division of `n` by `m`. You should use this\n * instead of the built-in operation as the built-in operation does not\n * properly handle negative numbers.\n */\nexport function mod(n: number, m: number) {\n  return ((n % m) + m) % m\n}\n\nexport function random(lower: number, upper: number) {\n  if (upper == null) {\n    upper = lower == null ? 1 : lower // eslint-disable-line\n    lower = 0 // eslint-disable-line\n  } else if (upper < lower) {\n    const tmp = lower\n    lower = upper // eslint-disable-line\n    upper = tmp // eslint-disable-line\n  }\n  return Math.floor(Math.random() * (upper - lower + 1) + lower)\n}\n\nexport function isPercentage(val: any): val is string {\n  return typeof val === 'string' && val.slice(-1) === '%'\n}\n\nexport function normalizePercentage(\n  num: number | string | null | undefined,\n  ref: number,\n) {\n  if (num == null) {\n    return 0\n  }\n\n  let raw: number\n\n  if (typeof num === 'string') {\n    raw = parseFloat(num)\n    if (isPercentage(num)) {\n      raw /= 100\n      if (Number.isFinite(raw)) {\n        return raw * ref\n      }\n    }\n  } else {\n    raw = num\n  }\n\n  if (!Number.isFinite(raw)) {\n    return 0\n  }\n\n  if (raw > 0 && raw < 1) {\n    return raw * ref\n  }\n\n  return raw\n}\n\nexport function parseCssNumeric(val: string, units?: string | string[]) {\n  function getUnit(regexp: string) {\n    const matches = new RegExp(`(?:\\\\d+(?:\\\\.\\\\d+)*)(${regexp})$`).exec(val)\n    if (!matches) {\n      return null\n    }\n\n    return matches[1]\n  }\n\n  const number = parseFloat(val)\n\n  if (Number.isNaN(number)) {\n    return null\n  }\n\n  // determine the unit\n  let regexp: string\n  if (units == null) {\n    // accept any unit, as well as no unit\n    regexp = '[A-Za-z]*'\n  } else if (Array.isArray(units)) {\n    if (units.length === 0) {\n      return null\n    }\n\n    regexp = units.join('|')\n  } else if (typeof units === 'string') {\n    regexp = units\n  }\n\n  const unit = getUnit(regexp!)\n\n  if (unit === null) {\n    return null\n  }\n\n  return {\n    unit,\n    value: number,\n  }\n}\n\nexport type SideOptions =\n  | number\n  | {\n      vertical?: number\n      horizontal?: number\n      left?: number\n      top?: number\n      right?: number\n      bottom?: number\n    }\n\nexport function normalizeSides(box?: SideOptions) {\n  if (typeof box === 'object') {\n    let left = 0\n    let top = 0\n    let right = 0\n    let bottom = 0\n\n    if (box.vertical != null && Number.isFinite(box.vertical)) {\n      top = bottom = box.vertical\n    }\n    if (box.horizontal != null && Number.isFinite(box.horizontal)) {\n      right = left = box.horizontal\n    }\n\n    if (box.left != null && Number.isFinite(box.left)) left = box.left\n    if (box.top != null && Number.isFinite(box.top)) top = box.top\n    if (box.right != null && Number.isFinite(box.right)) right = box.right\n    if (box.bottom != null && Number.isFinite(box.bottom)) bottom = box.bottom\n\n    return { top, right, bottom, left }\n  }\n\n  let val = 0\n  if (box != null && Number.isFinite(box)) {\n    val = box\n  }\n\n  return { top: val, right: val, bottom: val, left: val }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}