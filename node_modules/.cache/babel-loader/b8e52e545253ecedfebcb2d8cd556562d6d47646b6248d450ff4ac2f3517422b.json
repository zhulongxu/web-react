{"ast":null,"code":"import { Curve } from '../curve';\nimport { Point } from '../point';\nimport { Segment } from './segment';\nexport class CurveTo extends Segment {\n  constructor(arg0, arg1, arg2, arg3, arg4, arg5) {\n    super();\n    if (Curve.isCurve(arg0)) {\n      this.controlPoint1 = arg0.controlPoint1.clone().round(2);\n      this.controlPoint2 = arg0.controlPoint2.clone().round(2);\n      this.endPoint = arg0.end.clone().round(2);\n    } else if (typeof arg0 === 'number') {\n      this.controlPoint1 = new Point(arg0, arg1).round(2);\n      this.controlPoint2 = new Point(arg2, arg3).round(2);\n      this.endPoint = new Point(arg4, arg5).round(2);\n    } else {\n      this.controlPoint1 = Point.create(arg0).round(2);\n      this.controlPoint2 = Point.create(arg1).round(2);\n      this.endPoint = Point.create(arg2).round(2);\n    }\n  }\n  get type() {\n    return 'C';\n  }\n  get curve() {\n    return new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n  }\n  bbox() {\n    return this.curve.bbox();\n  }\n  closestPoint(p) {\n    return this.curve.closestPoint(p);\n  }\n  closestPointLength(p) {\n    return this.curve.closestPointLength(p);\n  }\n  closestPointNormalizedLength(p) {\n    return this.curve.closestPointNormalizedLength(p);\n  }\n  closestPointTangent(p) {\n    return this.curve.closestPointTangent(p);\n  }\n  length() {\n    return this.curve.length();\n  }\n  divideAt(ratio, options = {}) {\n    // TODO: fix options\n    const divided = this.curve.divideAt(ratio, options);\n    return [new CurveTo(divided[0]), new CurveTo(divided[1])];\n  }\n  divideAtLength(length, options = {}) {\n    // TODO: fix options\n    const divided = this.curve.divideAtLength(length, options);\n    return [new CurveTo(divided[0]), new CurveTo(divided[1])];\n  }\n  divideAtT(t) {\n    const divided = this.curve.divideAtT(t);\n    return [new CurveTo(divided[0]), new CurveTo(divided[1])];\n  }\n  getSubdivisions() {\n    return [];\n  }\n  pointAt(ratio) {\n    return this.curve.pointAt(ratio);\n  }\n  pointAtLength(length) {\n    return this.curve.pointAtLength(length);\n  }\n  tangentAt(ratio) {\n    return this.curve.tangentAt(ratio);\n  }\n  tangentAtLength(length) {\n    return this.curve.tangentAtLength(length);\n  }\n  isDifferentiable() {\n    if (!this.previousSegment) {\n      return false;\n    }\n    const start = this.start;\n    const control1 = this.controlPoint1;\n    const control2 = this.controlPoint2;\n    const end = this.end;\n    return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));\n  }\n  scale(sx, sy, origin) {\n    this.controlPoint1.scale(sx, sy, origin);\n    this.controlPoint2.scale(sx, sy, origin);\n    this.end.scale(sx, sy, origin);\n    return this;\n  }\n  rotate(angle, origin) {\n    this.controlPoint1.rotate(angle, origin);\n    this.controlPoint2.rotate(angle, origin);\n    this.end.rotate(angle, origin);\n    return this;\n  }\n  translate(tx, ty) {\n    if (typeof tx === 'number') {\n      this.controlPoint1.translate(tx, ty);\n      this.controlPoint2.translate(tx, ty);\n      this.end.translate(tx, ty);\n    } else {\n      this.controlPoint1.translate(tx);\n      this.controlPoint2.translate(tx);\n      this.end.translate(tx);\n    }\n    return this;\n  }\n  equals(s) {\n    return this.start.equals(s.start) && this.end.equals(s.end) && this.controlPoint1.equals(s.controlPoint1) && this.controlPoint2.equals(s.controlPoint2);\n  }\n  clone() {\n    return new CurveTo(this.controlPoint1, this.controlPoint2, this.end);\n  }\n  toJSON() {\n    return {\n      type: this.type,\n      start: this.start.toJSON(),\n      controlPoint1: this.controlPoint1.toJSON(),\n      controlPoint2: this.controlPoint2.toJSON(),\n      end: this.end.toJSON()\n    };\n  }\n  serialize() {\n    const c1 = this.controlPoint1;\n    const c2 = this.controlPoint2;\n    const end = this.end;\n    return [this.type, c1.x, c1.y, c2.x, c2.y, end.x, end.y].join(' ');\n  }\n}\n(function (CurveTo) {\n  function create(...args) {\n    const len = args.length;\n    const arg0 = args[0];\n    // curve provided\n    if (Curve.isCurve(arg0)) {\n      return new CurveTo(arg0);\n    }\n    // points provided\n    if (Point.isPointLike(arg0)) {\n      if (len === 3) {\n        return new CurveTo(args[0], args[1], args[2]);\n      }\n      // this is a poly-bezier segment\n      const segments = [];\n      for (let i = 0; i < len; i += 3) {\n        segments.push(new CurveTo(args[i], args[i + 1], args[i + 2]));\n      }\n      return segments;\n    }\n    // coordinates provided\n    if (len === 6) {\n      return new CurveTo(args[0], args[1], args[2], args[3], args[4], args[5]);\n    }\n    // this is a poly-bezier segment\n    const segments = [];\n    for (let i = 0; i < len; i += 6) {\n      segments.push(new CurveTo(args[i], args[i + 1], args[i + 2], args[i + 3], args[i + 4], args[i + 5]));\n    }\n    return segments;\n  }\n  CurveTo.create = create;\n})(CurveTo || (CurveTo = {}));","map":{"version":3,"names":["Curve","Point","Segment","CurveTo","constructor","arg0","arg1","arg2","arg3","arg4","arg5","isCurve","controlPoint1","clone","round","controlPoint2","endPoint","end","create","type","curve","start","bbox","closestPoint","p","closestPointLength","closestPointNormalizedLength","closestPointTangent","length","divideAt","ratio","options","divided","divideAtLength","divideAtT","t","getSubdivisions","pointAt","pointAtLength","tangentAt","tangentAtLength","isDifferentiable","previousSegment","control1","control2","equals","scale","sx","sy","origin","rotate","angle","translate","tx","ty","s","toJSON","serialize","c1","c2","x","y","join","args","len","isPointLike","segments","i","push"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6-geometry@2.0.5/node_modules/@antv/x6-geometry/src/path/curveto.ts"],"sourcesContent":["import { Curve } from '../curve'\nimport { Point } from '../point'\nimport { Segment } from './segment'\n\nexport class CurveTo extends Segment {\n  controlPoint1: Point\n  controlPoint2: Point\n\n  constructor(curve: Curve)\n  constructor(\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    x: number,\n    y: number,\n  )\n  constructor(\n    p1: Point.PointLike | Point.PointData,\n    p2: Point.PointLike | Point.PointData,\n    p3: Point.PointLike | Point.PointData,\n  )\n  constructor(\n    arg0: number | Curve | (Point.PointLike | Point.PointData),\n    arg1?: number | (Point.PointLike | Point.PointData),\n    arg2?: number | (Point.PointLike | Point.PointData),\n    arg3?: number,\n    arg4?: number,\n    arg5?: number,\n  ) {\n    super()\n\n    if (Curve.isCurve(arg0)) {\n      this.controlPoint1 = arg0.controlPoint1.clone().round(2)\n      this.controlPoint2 = arg0.controlPoint2.clone().round(2)\n      this.endPoint = arg0.end.clone().round(2)\n    } else if (typeof arg0 === 'number') {\n      this.controlPoint1 = new Point(arg0, arg1 as number).round(2)\n      this.controlPoint2 = new Point(arg2 as number, arg3).round(2)\n      this.endPoint = new Point(arg4, arg5).round(2)\n    } else {\n      this.controlPoint1 = Point.create(arg0).round(2)\n      this.controlPoint2 = Point.create(arg1).round(2)\n      this.endPoint = Point.create(arg2).round(2)\n    }\n  }\n\n  get type() {\n    return 'C'\n  }\n\n  get curve() {\n    return new Curve(\n      this.start,\n      this.controlPoint1,\n      this.controlPoint2,\n      this.end,\n    )\n  }\n\n  bbox() {\n    return this.curve.bbox()\n  }\n\n  closestPoint(p: Point.PointLike | Point.PointData) {\n    return this.curve.closestPoint(p)\n  }\n\n  closestPointLength(p: Point.PointLike | Point.PointData) {\n    return this.curve.closestPointLength(p)\n  }\n\n  closestPointNormalizedLength(p: Point.PointLike | Point.PointData) {\n    return this.curve.closestPointNormalizedLength(p)\n  }\n\n  closestPointTangent(p: Point.PointLike | Point.PointData) {\n    return this.curve.closestPointTangent(p)\n  }\n\n  length() {\n    return this.curve.length()\n  }\n\n  divideAt(ratio: number, options: Segment.Options = {}): [Segment, Segment] {\n    // TODO: fix options\n    const divided = this.curve.divideAt(ratio, options as any)\n    return [new CurveTo(divided[0]), new CurveTo(divided[1])]\n  }\n\n  divideAtLength(\n    length: number,\n    options: Segment.Options = {},\n  ): [Segment, Segment] {\n    // TODO: fix options\n    const divided = this.curve.divideAtLength(length, options as any)\n    return [new CurveTo(divided[0]), new CurveTo(divided[1])]\n  }\n\n  divideAtT(t: number): [Segment, Segment] {\n    const divided = this.curve.divideAtT(t)\n    return [new CurveTo(divided[0]), new CurveTo(divided[1])]\n  }\n\n  getSubdivisions() {\n    return []\n  }\n\n  pointAt(ratio: number) {\n    return this.curve.pointAt(ratio)\n  }\n\n  pointAtLength(length: number) {\n    return this.curve.pointAtLength(length)\n  }\n\n  tangentAt(ratio: number) {\n    return this.curve.tangentAt(ratio)\n  }\n\n  tangentAtLength(length: number) {\n    return this.curve.tangentAtLength(length)\n  }\n\n  isDifferentiable() {\n    if (!this.previousSegment) {\n      return false\n    }\n\n    const start = this.start\n    const control1 = this.controlPoint1\n    const control2 = this.controlPoint2\n    const end = this.end\n\n    return !(\n      start.equals(control1) &&\n      control1.equals(control2) &&\n      control2.equals(end)\n    )\n  }\n\n  scale(sx: number, sy: number, origin?: Point.PointLike | Point.PointData) {\n    this.controlPoint1.scale(sx, sy, origin)\n    this.controlPoint2.scale(sx, sy, origin)\n    this.end.scale(sx, sy, origin)\n    return this\n  }\n\n  rotate(angle: number, origin?: Point.PointLike | Point.PointData) {\n    this.controlPoint1.rotate(angle, origin)\n    this.controlPoint2.rotate(angle, origin)\n    this.end.rotate(angle, origin)\n    return this\n  }\n\n  translate(tx: number, ty: number): this\n  translate(p: Point.PointLike | Point.PointData): this\n  translate(tx: number | Point.PointLike | Point.PointData, ty?: number): this {\n    if (typeof tx === 'number') {\n      this.controlPoint1.translate(tx, ty as number)\n      this.controlPoint2.translate(tx, ty as number)\n      this.end.translate(tx, ty as number)\n    } else {\n      this.controlPoint1.translate(tx)\n      this.controlPoint2.translate(tx)\n      this.end.translate(tx)\n    }\n\n    return this\n  }\n\n  equals(s: Segment) {\n    return (\n      this.start.equals(s.start) &&\n      this.end.equals(s.end) &&\n      this.controlPoint1.equals((s as CurveTo).controlPoint1) &&\n      this.controlPoint2.equals((s as CurveTo).controlPoint2)\n    )\n  }\n\n  clone() {\n    return new CurveTo(this.controlPoint1, this.controlPoint2, this.end)\n  }\n\n  toJSON() {\n    return {\n      type: this.type,\n      start: this.start.toJSON(),\n      controlPoint1: this.controlPoint1.toJSON(),\n      controlPoint2: this.controlPoint2.toJSON(),\n      end: this.end.toJSON(),\n    }\n  }\n\n  serialize() {\n    const c1 = this.controlPoint1\n    const c2 = this.controlPoint2\n    const end = this.end\n    return [this.type, c1.x, c1.y, c2.x, c2.y, end.x, end.y].join(' ')\n  }\n}\n\nexport namespace CurveTo {\n  export function create(\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    x: number,\n    y: number,\n  ): CurveTo\n  export function create(\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    x: number,\n    y: number,\n    ...coords: number[]\n  ): CurveTo[]\n  export function create(\n    c1: Point.PointLike,\n    c2: Point.PointLike,\n    p: Point.PointLike,\n  ): CurveTo\n  export function create(\n    c1: Point.PointLike,\n    c2: Point.PointLike,\n    p: Point.PointLike,\n    ...points: Point.PointLike[]\n  ): CurveTo[]\n  export function create(...args: any[]): CurveTo | CurveTo[] {\n    const len = args.length\n    const arg0 = args[0]\n\n    // curve provided\n    if (Curve.isCurve(arg0)) {\n      return new CurveTo(arg0)\n    }\n\n    // points provided\n    if (Point.isPointLike(arg0)) {\n      if (len === 3) {\n        return new CurveTo(args[0], args[1], args[2])\n      }\n\n      // this is a poly-bezier segment\n      const segments: CurveTo[] = []\n      for (let i = 0; i < len; i += 3) {\n        segments.push(new CurveTo(args[i], args[i + 1], args[i + 2]))\n      }\n      return segments\n    }\n\n    // coordinates provided\n    if (len === 6) {\n      return new CurveTo(args[0], args[1], args[2], args[3], args[4], args[5])\n    }\n\n    // this is a poly-bezier segment\n    const segments: CurveTo[] = []\n    for (let i = 0; i < len; i += 6) {\n      segments.push(\n        new CurveTo(\n          args[i],\n          args[i + 1],\n          args[i + 2],\n          args[i + 3],\n          args[i + 4],\n          args[i + 5],\n        ),\n      )\n    }\n    return segments\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}