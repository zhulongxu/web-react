{"ast":null,"code":"import * as Dom from '../dom/main';\nexport class Vector {\n  get [Symbol.toStringTag]() {\n    return Vector.toStringTag;\n  }\n  get type() {\n    return this.node.nodeName;\n  }\n  get id() {\n    return this.node.id;\n  }\n  set id(id) {\n    this.node.id = id;\n  }\n  constructor(elem, attrs, children) {\n    if (!elem) {\n      throw new TypeError('Invalid element to create vector');\n    }\n    let node;\n    if (Vector.isVector(elem)) {\n      node = elem.node;\n    } else if (typeof elem === 'string') {\n      if (elem.toLowerCase() === 'svg') {\n        node = Dom.createSvgDocument();\n      } else if (elem[0] === '<') {\n        const doc = Dom.createSvgDocument(elem);\n        // only import the first child\n        node = document.importNode(doc.firstChild, true);\n      } else {\n        node = document.createElementNS(Dom.ns.svg, elem);\n      }\n    } else {\n      node = elem;\n    }\n    this.node = node;\n    if (attrs) {\n      this.setAttributes(attrs);\n    }\n    if (children) {\n      this.append(children);\n    }\n  }\n  transform(matrix, options) {\n    if (matrix == null) {\n      return Dom.transform(this.node);\n    }\n    Dom.transform(this.node, matrix, options);\n    return this;\n  }\n  translate(tx, ty = 0, options = {}) {\n    if (tx == null) {\n      return Dom.translate(this.node);\n    }\n    Dom.translate(this.node, tx, ty, options);\n    return this;\n  }\n  rotate(angle, cx, cy, options = {}) {\n    if (angle == null) {\n      return Dom.rotate(this.node);\n    }\n    Dom.rotate(this.node, angle, cx, cy, options);\n    return this;\n  }\n  scale(sx, sy) {\n    if (sx == null) {\n      return Dom.scale(this.node);\n    }\n    Dom.scale(this.node, sx, sy);\n    return this;\n  }\n  /**\n   * Returns an SVGMatrix that specifies the transformation necessary\n   * to convert this coordinate system into `target` coordinate system.\n   */\n  getTransformToElement(target) {\n    const ref = Vector.toNode(target);\n    return Dom.getTransformToElement(this.node, ref);\n  }\n  removeAttribute(name) {\n    Dom.removeAttribute(this.node, name);\n    return this;\n  }\n  getAttribute(name) {\n    return Dom.getAttribute(this.node, name);\n  }\n  setAttribute(name, value) {\n    Dom.setAttribute(this.node, name, value);\n    return this;\n  }\n  setAttributes(attrs) {\n    Dom.setAttributes(this.node, attrs);\n    return this;\n  }\n  attr(name, value) {\n    if (name == null) {\n      return Dom.attr(this.node);\n    }\n    if (typeof name === 'string' && value === undefined) {\n      return Dom.attr(this.node, name);\n    }\n    if (typeof name === 'object') {\n      Dom.attr(this.node, name);\n    } else {\n      Dom.attr(this.node, name, value);\n    }\n    return this;\n  }\n  svg() {\n    return this.node instanceof SVGSVGElement ? this : Vector.create(this.node.ownerSVGElement);\n  }\n  defs() {\n    const context = this.svg() || this;\n    const defsNode = context.node.getElementsByTagName('defs')[0];\n    if (defsNode) {\n      return Vector.create(defsNode);\n    }\n    return Vector.create('defs').appendTo(context);\n  }\n  text(content, options = {}) {\n    Dom.text(this.node, content, options);\n    return this;\n  }\n  tagName() {\n    return Dom.tagName(this.node);\n  }\n  clone() {\n    return Vector.create(this.node.cloneNode(true));\n  }\n  remove() {\n    Dom.remove(this.node);\n    return this;\n  }\n  empty() {\n    Dom.empty(this.node);\n    return this;\n  }\n  append(elems) {\n    Dom.append(this.node, Vector.toNodes(elems));\n    return this;\n  }\n  appendTo(target) {\n    Dom.appendTo(this.node, Vector.isVector(target) ? target.node : target);\n    return this;\n  }\n  prepend(elems) {\n    Dom.prepend(this.node, Vector.toNodes(elems));\n    return this;\n  }\n  before(elems) {\n    Dom.before(this.node, Vector.toNodes(elems));\n    return this;\n  }\n  replace(elem) {\n    if (this.node.parentNode) {\n      this.node.parentNode.replaceChild(Vector.toNode(elem), this.node);\n    }\n    return Vector.create(elem);\n  }\n  first() {\n    return this.node.firstChild ? Vector.create(this.node.firstChild) : null;\n  }\n  last() {\n    return this.node.lastChild ? Vector.create(this.node.lastChild) : null;\n  }\n  get(index) {\n    const child = this.node.childNodes[index];\n    return child ? Vector.create(child) : null;\n  }\n  indexOf(elem) {\n    const children = Array.prototype.slice.call(this.node.childNodes);\n    return children.indexOf(Vector.toNode(elem));\n  }\n  find(selector) {\n    const vels = [];\n    const nodes = Dom.find(this.node, selector);\n    if (nodes) {\n      for (let i = 0, ii = nodes.length; i < ii; i += 1) {\n        vels.push(Vector.create(nodes[i]));\n      }\n    }\n    return vels;\n  }\n  findOne(selector) {\n    const found = Dom.findOne(this.node, selector);\n    return found ? Vector.create(found) : null;\n  }\n  findParentByClass(className, terminator) {\n    const node = Dom.findParentByClass(this.node, className, terminator);\n    return node ? Vector.create(node) : null;\n  }\n  matches(selector) {\n    const node = this.node;\n    const matches = this.node.matches;\n    const matcher = node.matches || node.matchesSelector || node.msMatchesSelector || node.mozMatchesSelector || node.webkitMatchesSelector || node.oMatchesSelector || null;\n    return matcher && matcher.call(node, selector);\n  }\n  contains(child) {\n    return Dom.contains(this.node, Vector.isVector(child) ? child.node : child);\n  }\n  wrap(node) {\n    const vel = Vector.create(node);\n    const parentNode = this.node.parentNode;\n    if (parentNode != null) {\n      parentNode.insertBefore(vel.node, this.node);\n    }\n    return vel.append(this);\n  }\n  parent(type) {\n    let parent = this; // eslint-disable-line @typescript-eslint/no-this-alias\n    // check for parent\n    if (parent.node.parentNode == null) {\n      return null;\n    }\n    // get parent element\n    parent = Vector.create(parent.node.parentNode);\n    if (type == null) {\n      return parent;\n    }\n    // loop trough ancestors if type is given\n    do {\n      if (typeof type === 'string' ? parent.matches(type) : parent instanceof type) {\n        return parent;\n      }\n    } while (parent = Vector.create(parent.node.parentNode));\n    return parent;\n  }\n  children() {\n    const children = this.node.childNodes;\n    const vels = [];\n    for (let i = 0; i < children.length; i += 1) {\n      const currentChild = children[i];\n      if (currentChild.nodeType === 1) {\n        vels.push(Vector.create(children[i]));\n      }\n    }\n    return vels;\n  }\n  eachChild(fn, deep) {\n    const children = this.children();\n    for (let i = 0, l = children.length; i < l; i += 1) {\n      fn.call(children[i], children[i], i, children);\n      if (deep) {\n        children[i].eachChild(fn, deep);\n      }\n    }\n    return this;\n  }\n  index() {\n    return Dom.index(this.node);\n  }\n  hasClass(className) {\n    return Dom.hasClass(this.node, className);\n  }\n  addClass(className) {\n    Dom.addClass(this.node, className);\n    return this;\n  }\n  removeClass(className) {\n    Dom.removeClass(this.node, className);\n    return this;\n  }\n  toggleClass(className, stateVal) {\n    Dom.toggleClass(this.node, className, stateVal);\n    return this;\n  }\n  toLocalPoint(x, y) {\n    return Dom.toLocalPoint(this.node, x, y);\n  }\n  /**\n   * Samples the underlying SVG element (it currently works only on\n   * paths - where it is most useful anyway). Returns an array of objects\n   * of the form `{ x: Number, y: Number, distance: Number }`. Each of these\n   * objects represent a point on the path. This basically creates a discrete\n   * representation of the path (which is possible a curve). The sampling\n   * interval defines the accuracy of the sampling. In other words, we travel\n   * from the beginning of the path to the end by interval distance (on the\n   * path, not between the resulting points) and collect the discrete points\n   * on the path. This is very useful in many situations. For example, SVG\n   * does not provide a built-in mechanism to find intersections between two\n   * paths. Using sampling, we can just generate bunch of points for each of\n   * the path and find the closest ones from each set.\n   */\n  sample(interval = 1) {\n    if (this.node instanceof SVGPathElement) {\n      return Dom.sample(this.node, interval);\n    }\n    return [];\n  }\n  toPath() {\n    return Vector.create(Dom.toPath(this.node));\n  }\n  toPathData() {\n    return Dom.toPathData(this.node);\n  }\n}\n(function (Vector) {\n  Vector.toStringTag = `X6.${Vector.name}`;\n  function isVector(instance) {\n    if (instance == null) {\n      return false;\n    }\n    if (instance instanceof Vector) {\n      return true;\n    }\n    const tag = instance[Symbol.toStringTag];\n    const vector = instance;\n    if ((tag == null || tag === Vector.toStringTag) && vector.node instanceof SVGElement && typeof vector.sample === 'function' && typeof vector.toPath === 'function') {\n      return true;\n    }\n    return false;\n  }\n  Vector.isVector = isVector;\n  function create(elem, attrs, children) {\n    return new Vector(elem, attrs, children);\n  }\n  Vector.create = create;\n  function createVectors(markup) {\n    if (markup[0] === '<') {\n      const svgDoc = Dom.createSvgDocument(markup);\n      const vels = [];\n      for (let i = 0, ii = svgDoc.childNodes.length; i < ii; i += 1) {\n        const childNode = svgDoc.childNodes[i];\n        vels.push(create(document.importNode(childNode, true)));\n      }\n      return vels;\n    }\n    return [create(markup)];\n  }\n  Vector.createVectors = createVectors;\n  function toNode(elem) {\n    if (isVector(elem)) {\n      return elem.node;\n    }\n    return elem;\n  }\n  Vector.toNode = toNode;\n  function toNodes(elems) {\n    if (Array.isArray(elems)) {\n      return elems.map(elem => toNode(elem));\n    }\n    return [toNode(elems)];\n  }\n  Vector.toNodes = toNodes;\n})(Vector || (Vector = {}));","map":{"version":3,"names":["Dom","Vector","Symbol","toStringTag","type","node","nodeName","id","constructor","elem","attrs","children","TypeError","isVector","toLowerCase","createSvgDocument","doc","document","importNode","firstChild","createElementNS","ns","svg","setAttributes","append","transform","matrix","options","translate","tx","ty","rotate","angle","cx","cy","scale","sx","sy","getTransformToElement","target","ref","toNode","removeAttribute","name","getAttribute","setAttribute","value","attr","undefined","SVGSVGElement","create","ownerSVGElement","defs","context","defsNode","getElementsByTagName","appendTo","text","content","tagName","clone","cloneNode","remove","empty","elems","toNodes","prepend","before","replace","parentNode","replaceChild","first","last","lastChild","get","index","child","childNodes","indexOf","Array","prototype","slice","call","find","selector","vels","nodes","i","ii","length","push","findOne","found","findParentByClass","className","terminator","matches","matcher","matchesSelector","msMatchesSelector","mozMatchesSelector","webkitMatchesSelector","oMatchesSelector","contains","wrap","vel","insertBefore","parent","currentChild","nodeType","eachChild","fn","deep","l","hasClass","addClass","removeClass","toggleClass","stateVal","toLocalPoint","x","y","sample","interval","SVGPathElement","toPath","toPathData","instance","tag","vector","SVGElement","createVectors","markup","svgDoc","childNode","isArray","map"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/src/vector/index.ts"],"sourcesContent":["import * as Dom from '../dom/main'\nimport { Translation, Rotation, Scale } from '../types'\n\nexport class Vector {\n  public node: SVGElement\n\n  protected get [Symbol.toStringTag]() {\n    return Vector.toStringTag\n  }\n\n  public get type() {\n    return this.node.nodeName\n  }\n\n  public get id() {\n    return this.node.id\n  }\n\n  public set id(id: string) {\n    this.node.id = id\n  }\n\n  constructor(\n    elem: Vector | SVGElement | string,\n    attrs?: Dom.Attributes,\n    children?: SVGElement | Vector | (SVGElement | Vector)[],\n  ) {\n    if (!elem) {\n      throw new TypeError('Invalid element to create vector')\n    }\n\n    let node: SVGElement\n    if (Vector.isVector(elem)) {\n      node = elem.node\n    } else if (typeof elem === 'string') {\n      if (elem.toLowerCase() === 'svg') {\n        node = Dom.createSvgDocument()\n      } else if (elem[0] === '<') {\n        const doc = Dom.createSvgDocument(elem)\n        // only import the first child\n        node = document.importNode(doc.firstChild!, true) as SVGElement\n      } else {\n        node = document.createElementNS(Dom.ns.svg, elem) as SVGElement\n      }\n    } else {\n      node = elem\n    }\n\n    this.node = node\n\n    if (attrs) {\n      this.setAttributes(attrs)\n    }\n\n    if (children) {\n      this.append(children)\n    }\n  }\n\n  /**\n   * Returns the current transformation matrix of the Vector element.\n   */\n  transform(): DOMMatrix\n  /**\n   * Applies the provided transformation matrix to the Vector element.\n   */\n  transform(matrix: DOMMatrix, options?: Dom.TransformOptions): this\n  transform(matrix?: DOMMatrix, options?: Dom.TransformOptions) {\n    if (matrix == null) {\n      return Dom.transform(this.node)\n    }\n\n    Dom.transform(this.node, matrix, options)\n\n    return this\n  }\n\n  /**\n   * Returns the current translate metadata of the Vector element.\n   */\n  translate(): Translation\n  /**\n   * Translates the element by `tx` pixels in x axis and `ty` pixels\n   * in y axis. `ty` is optional in which case the translation in y axis\n   * is considered zero.\n   */\n  translate(tx: number, ty?: number, options?: Dom.TransformOptions): this\n  translate(tx?: number, ty = 0, options: Dom.TransformOptions = {}) {\n    if (tx == null) {\n      return Dom.translate(this.node)\n    }\n\n    Dom.translate(this.node, tx, ty, options)\n    return this\n  }\n\n  /**\n   * Returns the current rotate metadata of the Vector element.\n   */\n  rotate(): Rotation\n  /**\n   * Rotates the element by `angle` degrees. If the optional `cx` and `cy`\n   * coordinates are passed, they will be used as an origin for the rotation.\n   */\n  rotate(\n    angle: number,\n    cx?: number,\n    cy?: number,\n    options?: Dom.TransformOptions,\n  ): this\n  rotate(\n    angle?: number,\n    cx?: number,\n    cy?: number,\n    options: Dom.TransformOptions = {},\n  ) {\n    if (angle == null) {\n      return Dom.rotate(this.node)\n    }\n\n    Dom.rotate(this.node, angle, cx, cy, options)\n    return this\n  }\n\n  /**\n   * Returns the current scale metadata of the Vector element.\n   */\n  scale(): Scale\n  /**\n   * Scale the element by `sx` and `sy` factors. If `sy` is not specified,\n   * it will be considered the same as `sx`.\n   */\n  scale(sx: number, sy?: number): this\n  scale(sx?: number, sy?: number) {\n    if (sx == null) {\n      return Dom.scale(this.node)\n    }\n    Dom.scale(this.node, sx, sy)\n    return this\n  }\n\n  /**\n   * Returns an SVGMatrix that specifies the transformation necessary\n   * to convert this coordinate system into `target` coordinate system.\n   */\n  getTransformToElement(target: SVGElement | Vector) {\n    const ref = Vector.toNode(target) as SVGGraphicsElement\n    return Dom.getTransformToElement(this.node, ref)\n  }\n\n  removeAttribute(name: string) {\n    Dom.removeAttribute(this.node, name)\n    return this\n  }\n\n  getAttribute(name: string) {\n    return Dom.getAttribute(this.node, name)\n  }\n\n  setAttribute(name: string, value?: string | number | null) {\n    Dom.setAttribute(this.node, name, value)\n    return this\n  }\n\n  setAttributes(attrs: { [attr: string]: string | number | null | undefined }) {\n    Dom.setAttributes(this.node, attrs)\n    return this\n  }\n\n  attr(): { [attr: string]: string }\n  attr(name: string): string\n  attr(attrs: { [attr: string]: string | number | null | undefined }): this\n  attr(name: string, value: string | number): this\n  attr(\n    name?: string | { [attr: string]: string | number | null | undefined },\n    value?: string | number | null,\n  ) {\n    if (name == null) {\n      return Dom.attr(this.node)\n    }\n\n    if (typeof name === 'string' && value === undefined) {\n      return Dom.attr(this.node, name)\n    }\n\n    if (typeof name === 'object') {\n      Dom.attr(this.node, name)\n    } else {\n      Dom.attr(this.node, name, value!)\n    }\n\n    return this\n  }\n\n  svg() {\n    return this.node instanceof SVGSVGElement\n      ? this\n      : Vector.create(this.node.ownerSVGElement as SVGSVGElement)\n  }\n\n  defs() {\n    const context = this.svg() || this\n    const defsNode = context.node.getElementsByTagName('defs')[0]\n    if (defsNode) {\n      return Vector.create(defsNode)\n    }\n\n    return Vector.create('defs').appendTo(context)\n  }\n\n  text(content: string, options: Dom.TextOptions = {}) {\n    Dom.text(this.node, content, options)\n    return this\n  }\n\n  tagName() {\n    return Dom.tagName(this.node)\n  }\n\n  clone() {\n    return Vector.create(this.node.cloneNode(true) as SVGElement)\n  }\n\n  remove() {\n    Dom.remove(this.node)\n    return this\n  }\n\n  empty() {\n    Dom.empty(this.node)\n    return this\n  }\n\n  append(\n    elems:\n      | SVGElement\n      | DocumentFragment\n      | Vector\n      | (SVGElement | DocumentFragment | Vector)[],\n  ) {\n    Dom.append(this.node, Vector.toNodes(elems))\n    return this\n  }\n\n  appendTo(target: Element | Vector) {\n    Dom.appendTo(this.node, Vector.isVector(target) ? target.node : target)\n    return this\n  }\n\n  prepend(\n    elems:\n      | SVGElement\n      | DocumentFragment\n      | Vector\n      | (SVGElement | DocumentFragment | Vector)[],\n  ) {\n    Dom.prepend(this.node, Vector.toNodes(elems))\n    return this\n  }\n\n  before(\n    elems:\n      | SVGElement\n      | DocumentFragment\n      | Vector\n      | (SVGElement | DocumentFragment | Vector)[],\n  ) {\n    Dom.before(this.node, Vector.toNodes(elems))\n    return this\n  }\n\n  replace(elem: SVGElement | Vector) {\n    if (this.node.parentNode) {\n      this.node.parentNode.replaceChild(Vector.toNode(elem), this.node)\n    }\n    return Vector.create(elem)\n  }\n\n  first() {\n    return this.node.firstChild\n      ? Vector.create(this.node.firstChild as SVGElement)\n      : null\n  }\n\n  last() {\n    return this.node.lastChild\n      ? Vector.create(this.node.lastChild as SVGElement)\n      : null\n  }\n\n  get(index: number) {\n    const child = this.node.childNodes[index] as SVGElement\n    return child ? Vector.create(child) : null\n  }\n\n  indexOf(elem: SVGElement | Vector) {\n    const children: SVGElement[] = Array.prototype.slice.call(\n      this.node.childNodes,\n    )\n    return children.indexOf(Vector.toNode(elem))\n  }\n\n  find(selector: string) {\n    const vels: Vector[] = []\n    const nodes = Dom.find(this.node, selector)\n    if (nodes) {\n      for (let i = 0, ii = nodes.length; i < ii; i += 1) {\n        vels.push(Vector.create(nodes[i] as SVGElement))\n      }\n    }\n\n    return vels\n  }\n\n  findOne(selector: string) {\n    const found = Dom.findOne(this.node, selector)\n    return found ? Vector.create(found as SVGElement) : null\n  }\n\n  findParentByClass(className: string, terminator?: SVGElement) {\n    const node = Dom.findParentByClass(this.node, className, terminator)\n    return node ? Vector.create(node as SVGElement) : null\n  }\n\n  matches(selector: string): boolean {\n    const node = this.node as any\n    const matches = this.node.matches\n    const matcher: typeof matches =\n      node.matches ||\n      node.matchesSelector ||\n      node.msMatchesSelector ||\n      node.mozMatchesSelector ||\n      node.webkitMatchesSelector ||\n      node.oMatchesSelector ||\n      null\n    return matcher && matcher.call(node, selector)\n  }\n\n  contains(child: SVGElement | Vector) {\n    return Dom.contains(this.node, Vector.isVector(child) ? child.node : child)\n  }\n\n  wrap(node: SVGElement | Vector) {\n    const vel = Vector.create(node)\n    const parentNode = this.node.parentNode as SVGElement\n    if (parentNode != null) {\n      parentNode.insertBefore(vel.node, this.node)\n    }\n    return vel.append(this)\n  }\n\n  parent(type?: string) {\n    let parent: Vector = this // eslint-disable-line @typescript-eslint/no-this-alias\n\n    // check for parent\n    if (parent.node.parentNode == null) {\n      return null\n    }\n\n    // get parent element\n    parent = Vector.create(parent.node.parentNode as SVGElement)\n\n    if (type == null) {\n      return parent\n    }\n\n    // loop trough ancestors if type is given\n    do {\n      if (\n        typeof type === 'string' ? parent.matches(type) : parent instanceof type\n      ) {\n        return parent\n      }\n    } while ((parent = Vector.create(parent.node.parentNode as SVGElement)))\n\n    return parent\n  }\n\n  children() {\n    const children = this.node.childNodes\n    const vels: Vector[] = []\n    for (let i = 0; i < children.length; i += 1) {\n      const currentChild = children[i]\n      if (currentChild.nodeType === 1) {\n        vels.push(Vector.create(children[i] as SVGElement))\n      }\n    }\n    return vels\n  }\n\n  eachChild(\n    fn: (\n      this: Vector,\n      currentValue: Vector,\n      index: number,\n      children: Vector[],\n    ) => void,\n    deep?: boolean,\n  ) {\n    const children = this.children()\n    for (let i = 0, l = children.length; i < l; i += 1) {\n      fn.call(children[i], children[i], i, children)\n      if (deep) {\n        children[i].eachChild(fn, deep)\n      }\n    }\n\n    return this\n  }\n\n  index() {\n    return Dom.index(this.node)\n  }\n\n  hasClass(className: string) {\n    return Dom.hasClass(this.node, className)\n  }\n\n  addClass(className: string) {\n    Dom.addClass(this.node, className)\n    return this\n  }\n\n  removeClass(className?: string) {\n    Dom.removeClass(this.node, className)\n    return this\n  }\n\n  toggleClass(className: string, stateVal?: boolean) {\n    Dom.toggleClass(this.node, className, stateVal)\n    return this\n  }\n\n  toLocalPoint(x: number, y: number) {\n    return Dom.toLocalPoint(this.node, x, y)\n  }\n\n  /**\n   * Samples the underlying SVG element (it currently works only on\n   * paths - where it is most useful anyway). Returns an array of objects\n   * of the form `{ x: Number, y: Number, distance: Number }`. Each of these\n   * objects represent a point on the path. This basically creates a discrete\n   * representation of the path (which is possible a curve). The sampling\n   * interval defines the accuracy of the sampling. In other words, we travel\n   * from the beginning of the path to the end by interval distance (on the\n   * path, not between the resulting points) and collect the discrete points\n   * on the path. This is very useful in many situations. For example, SVG\n   * does not provide a built-in mechanism to find intersections between two\n   * paths. Using sampling, we can just generate bunch of points for each of\n   * the path and find the closest ones from each set.\n   */\n  sample(interval = 1) {\n    if (this.node instanceof SVGPathElement) {\n      return Dom.sample(this.node, interval)\n    }\n    return []\n  }\n\n  toPath() {\n    return Vector.create(Dom.toPath(this.node as any))\n  }\n\n  toPathData() {\n    return Dom.toPathData(this.node as any)\n  }\n}\n\nexport namespace Vector {\n  export const toStringTag = `X6.${Vector.name}`\n\n  export function isVector(instance: any): instance is Vector {\n    if (instance == null) {\n      return false\n    }\n\n    if (instance instanceof Vector) {\n      return true\n    }\n\n    const tag = instance[Symbol.toStringTag]\n    const vector = instance as Vector\n\n    if (\n      (tag == null || tag === toStringTag) &&\n      vector.node instanceof SVGElement &&\n      typeof vector.sample === 'function' &&\n      typeof vector.toPath === 'function'\n    ) {\n      return true\n    }\n\n    return false\n  }\n\n  export function create(\n    elem: Vector | SVGElement | string,\n    attrs?: Dom.Attributes,\n    children?: SVGElement | Vector | (SVGElement | Vector)[],\n  ) {\n    return new Vector(elem, attrs, children)\n  }\n\n  export function createVectors(markup: string) {\n    if (markup[0] === '<') {\n      const svgDoc = Dom.createSvgDocument(markup)\n      const vels: Vector[] = []\n      for (let i = 0, ii = svgDoc.childNodes.length; i < ii; i += 1) {\n        const childNode = svgDoc.childNodes[i]!\n        vels.push(create(document.importNode(childNode, true) as SVGElement))\n      }\n\n      return vels\n    }\n\n    return [create(markup)]\n  }\n\n  export function toNode<T extends SVGElement = SVGElement>(\n    elem: SVGElement | DocumentFragment | Vector,\n  ): T {\n    if (isVector(elem)) {\n      return elem.node as T\n    }\n    return elem as T\n  }\n\n  export function toNodes(\n    elems:\n      | SVGElement\n      | DocumentFragment\n      | Vector\n      | (SVGElement | DocumentFragment | Vector)[],\n  ) {\n    if (Array.isArray(elems)) {\n      return elems.map((elem) => toNode(elem))\n    }\n\n    return [toNode(elems)]\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}