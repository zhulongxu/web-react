{"ast":null,"code":"/* eslint-disable no-param-reassign */\nimport { Core } from './core';\nimport { Util } from './util';\nexport var Event;\n(function (Event) {\n  function on(elem, events, selector, data, handler) {\n    Private.on(elem, events, selector, data, handler);\n    return elem;\n  }\n  Event.on = on;\n  function once(elem, events, selector, data, handler) {\n    Private.on(elem, events, selector, data, handler, true);\n    return elem;\n  }\n  Event.once = once;\n  function off(elem, events, selector, handler) {\n    Private.off(elem, events, selector, handler);\n    return elem;\n  }\n  Event.off = off;\n  function trigger(elem, event, args,\n  /**\n   * When onlyHandlers is `true`\n   * - Will not call `.event()` on the element it is triggered on. This means\n   *   `.trigger('submit', [], true)` on a form will not call `.submit()` on\n   *   the form.\n   * - Events will not bubble up the DOM hierarchy; if they are not handled\n   *   by the target element directly, they do nothing.\n   */\n  onlyHandlers) {\n    Core.trigger(event, args, elem, onlyHandlers);\n    return elem;\n  }\n  Event.trigger = trigger;\n})(Event || (Event = {}));\nvar Private;\n(function (Private) {\n  function on(elem, types, selector, data, fn, once) {\n    // Types can be a map of types/handlers\n    if (typeof types === 'object') {\n      // ( types-Object, selector, data )\n      if (typeof selector !== 'string') {\n        // ( types-Object, data )\n        data = data || selector;\n        selector = undefined;\n      }\n      Object.keys(types).forEach(type => on(elem, type, selector, data, types[type], once));\n      return;\n    }\n    if (data == null && fn == null) {\n      // ( types, fn )\n      fn = selector;\n      data = selector = undefined;\n    } else if (fn == null) {\n      if (typeof selector === 'string') {\n        // ( types, selector, fn )\n        fn = data;\n        data = undefined;\n      } else {\n        // ( types, data, fn )\n        fn = data;\n        data = selector;\n        selector = undefined;\n      }\n    }\n    if (fn === false) {\n      fn = Util.returnFalse;\n    } else if (!fn) {\n      return;\n    }\n    if (once) {\n      const originHandler = fn;\n      fn = function (event, ...args) {\n        // Can use an empty set, since event contains the info\n        Private.off(elem, event);\n        return originHandler.call(this, event, ...args);\n      };\n      // Use same guid so caller can remove using origFn\n      Util.setHandlerId(fn, Util.ensureHandlerId(originHandler));\n    }\n    Core.on(elem, types, fn, data, selector);\n  }\n  Private.on = on;\n  function off(elem, events, selector, fn) {\n    const evt = events;\n    if (evt && evt.preventDefault != null && evt.handleObj != null) {\n      const obj = evt.handleObj;\n      off(evt.delegateTarget, obj.namespace ? `${obj.originType}.${obj.namespace}` : obj.originType, obj.selector, obj.handler);\n      return;\n    }\n    if (typeof events === 'object') {\n      // ( types-object [, selector] )\n      const types = events;\n      Object.keys(types).forEach(type => off(elem, type, selector, types[type]));\n      return;\n    }\n    if (selector === false || typeof selector === 'function') {\n      // ( types [, fn] )\n      fn = selector;\n      selector = undefined;\n    }\n    if (fn === false) {\n      fn = Util.returnFalse;\n    }\n    Core.off(elem, events, fn, selector);\n  }\n  Private.off = off;\n})(Private || (Private = {}));","map":{"version":3,"names":["Core","Util","Event","on","elem","events","selector","data","handler","Private","once","off","trigger","event","args","onlyHandlers","types","fn","undefined","Object","keys","forEach","type","returnFalse","originHandler","call","setHandlerId","ensureHandlerId","evt","preventDefault","handleObj","obj","delegateTarget","namespace","originType"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/src/dom/event/main.ts"],"sourcesContent":["/* eslint-disable no-param-reassign */\n\nimport { Core } from './core'\nimport { Util } from './util'\nimport { EventObject } from './object'\nimport { TypeEventHandler, TypeEventHandlers } from './types'\n\nexport namespace Event {\n  export function on<TType extends string>(\n    elem: Element,\n    events: TType,\n    selector: string,\n    handler: TypeEventHandler<Element, undefined, any, any, TType> | false,\n  ): Element\n  export function on<TType extends string, TData>(\n    elem: Element,\n    events: TType,\n    selector: string | null | undefined,\n    data: TData,\n    handler: TypeEventHandler<Element, TData, Element, Element, TType> | false,\n  ): Element\n  export function on<TType extends string, TData>(\n    elem: Element,\n    events: TType,\n    data: TData,\n    handler: TypeEventHandler<Element, TData, Element, Element, TType> | false,\n  ): Element\n  export function on<TType extends string, TData>(\n    elem: Element,\n    events: TType,\n    data: TData,\n    handlerObject: {\n      handler: TypeEventHandler<Element, TData, Element, Element, TType>\n      selector?: string\n      [key: string]: any\n    },\n  ): Element\n  export function on<TType extends string>(\n    elem: Element,\n    events: TType,\n    handler:\n      | TypeEventHandler<Element, undefined, Element, Element, TType>\n      | false,\n  ): Element\n  export function on<TType extends string>(\n    elem: Element,\n    events: TType,\n    handlerObject: {\n      handler: TypeEventHandler<Element, undefined, Element, Element, TType>\n      selector?: string\n      [key: string]: any\n    },\n  ): Element\n  export function on<TData>(\n    elem: Element,\n    events: TypeEventHandlers<Element, TData, any, any>,\n    selector: string | null | undefined,\n    data: TData,\n  ): Element\n  export function on(\n    elem: Element,\n    events: TypeEventHandlers<Element, undefined, any, any>,\n    selector: string,\n  ): Element\n  export function on<TData>(\n    elem: Element,\n    events: TypeEventHandlers<Element, TData, Element, Element>,\n    data: TData,\n  ): Element\n  export function on(\n    elem: Element,\n    events: TypeEventHandlers<Element, undefined, Element, Element>,\n  ): void\n  export function on(\n    elem: Element,\n    events: any,\n    selector?: any,\n    data?: any,\n    handler?: any,\n  ) {\n    Private.on(elem, events, selector, data, handler)\n    return elem\n  }\n\n  export function once<TType extends string>(\n    elem: Element,\n    events: TType,\n    selector: string,\n    handler: TypeEventHandler<Element, undefined, any, any, TType> | false,\n  ): Element\n  export function once<TType extends string, TData>(\n    elem: Element,\n    events: TType,\n    selector: string | null | undefined,\n    data: TData,\n    handler: TypeEventHandler<Element, TData, Element, Element, TType> | false,\n  ): Element\n  export function once<TType extends string, TData>(\n    elem: Element,\n    events: TType,\n    data: TData,\n    handler: TypeEventHandler<Element, TData, Element, Element, TType> | false,\n  ): Element\n  export function once<TType extends string, TData>(\n    elem: Element,\n    events: TType,\n    data: TData,\n    handlerObject: {\n      handler: TypeEventHandler<Element, TData, Element, Element, TType>\n      selector?: string\n      [key: string]: any\n    },\n  ): Element\n  export function once<TType extends string>(\n    elem: Element,\n    events: TType,\n    handler:\n      | TypeEventHandler<Element, undefined, Element, Element, TType>\n      | false,\n  ): Element\n  export function once<TType extends string>(\n    elem: Element,\n    events: TType,\n    handlerObject: {\n      handler: TypeEventHandler<Element, undefined, Element, Element, TType>\n      selector?: string\n      [key: string]: any\n    },\n  ): Element\n  export function once<TData>(\n    elem: Element,\n    events: TypeEventHandlers<Element, TData, any, any>,\n    selector: string | null | undefined,\n    data: TData,\n  ): Element\n  export function once(\n    elem: Element,\n    events: TypeEventHandlers<Element, undefined, any, any>,\n    selector: string,\n  ): Element\n  export function once<TData>(\n    elem: Element,\n    events: TypeEventHandlers<Element, TData, Element, Element>,\n    data: TData,\n  ): Element\n  export function once(\n    elem: Element,\n    events: TypeEventHandlers<Element, undefined, Element, Element>,\n  ): Element\n  export function once(\n    elem: Element,\n    events: any,\n    selector?: any,\n    data?: any,\n    handler?: any,\n  ) {\n    Private.on(elem as any, events, selector, data, handler, true)\n    return elem\n  }\n\n  export function off<TType extends string>(\n    elem: Element,\n    events: TType,\n    selector: string,\n    handler: TypeEventHandler<Element, any, any, any, TType> | false,\n  ): Element\n  export function off<TType extends string>(\n    elem: Element,\n    events: TType,\n    handler: TypeEventHandler<Element, any, any, any, TType> | false,\n  ): Element\n  export function off<TType extends string>(\n    elem: Element,\n    events: TType,\n    selector_handler?:\n      | string\n      | TypeEventHandler<Element, any, any, any, TType>\n      | false,\n  ): Element\n  export function off(\n    elem: Element,\n    events: TypeEventHandlers<Element, any, any, any>,\n    selector?: string,\n  ): Element\n  export function off(elem: Element, event?: EventObject<Element>): Element\n  export function off<TType extends string>(\n    elem: Element,\n    events?:\n      | TType\n      | TypeEventHandlers<Element, any, any, any>\n      | EventObject<Element>,\n    selector?: string | TypeEventHandler<Element, any, any, any, TType> | false,\n    handler?: TypeEventHandler<Element, any, any, any, TType> | false,\n  ) {\n    Private.off(elem, events, selector, handler)\n    return elem\n  }\n\n  export function trigger(\n    elem: Element,\n    event:\n      | string\n      | EventObject\n      | (Partial<EventObject.Event> & { type: string }),\n    args?: any[] | Record<string, any> | string | number | boolean,\n    /**\n     * When onlyHandlers is `true`\n     * - Will not call `.event()` on the element it is triggered on. This means\n     *   `.trigger('submit', [], true)` on a form will not call `.submit()` on\n     *   the form.\n     * - Events will not bubble up the DOM hierarchy; if they are not handled\n     *   by the target element directly, they do nothing.\n     */\n    onlyHandlers?: boolean,\n  ) {\n    Core.trigger(event, args, elem, onlyHandlers)\n    return elem\n  }\n}\n\nnamespace Private {\n  type EventHandler = false | ((...args: any[]) => any)\n\n  export function on(\n    elem: Element,\n    types: any,\n    selector?: string | EventHandler | null,\n    data?: any | EventHandler | null,\n    fn?: EventHandler | null,\n    once?: boolean,\n  ) {\n    // Types can be a map of types/handlers\n    if (typeof types === 'object') {\n      // ( types-Object, selector, data )\n      if (typeof selector !== 'string') {\n        // ( types-Object, data )\n        data = data || selector\n        selector = undefined\n      }\n\n      Object.keys(types).forEach((type) =>\n        on(elem, type, selector, data, types[type], once),\n      )\n      return\n    }\n\n    if (data == null && fn == null) {\n      // ( types, fn )\n      fn = selector as EventHandler\n      data = selector = undefined\n    } else if (fn == null) {\n      if (typeof selector === 'string') {\n        // ( types, selector, fn )\n        fn = data\n        data = undefined\n      } else {\n        // ( types, data, fn )\n        fn = data\n        data = selector\n        selector = undefined\n      }\n    }\n\n    if (fn === false) {\n      fn = Util.returnFalse\n    } else if (!fn) {\n      return\n    }\n\n    if (once) {\n      const originHandler = fn\n      fn = function (event, ...args: any[]) {\n        // Can use an empty set, since event contains the info\n        Private.off(elem, event)\n        return originHandler.call(this, event, ...args)\n      }\n\n      // Use same guid so caller can remove using origFn\n      Util.setHandlerId(fn, Util.ensureHandlerId(originHandler))\n    }\n\n    Core.on(elem, types as string, fn, data, selector as string)\n  }\n\n  export function off<TType extends string, TElement>(\n    elem: TElement,\n    events?:\n      | TType\n      | TypeEventHandlers<TElement, any, any, any>\n      | EventObject<TElement>,\n    selector?:\n      | string\n      | TypeEventHandler<TElement, any, any, any, TType>\n      | false,\n    fn?: TypeEventHandler<TElement, any, any, any, TType> | false,\n  ) {\n    const evt = events as EventObject\n    if (evt && evt.preventDefault != null && evt.handleObj != null) {\n      const obj = evt.handleObj\n      off(\n        evt.delegateTarget,\n        obj.namespace ? `${obj.originType}.${obj.namespace}` : obj.originType,\n        obj.selector,\n        obj.handler,\n      )\n\n      return\n    }\n\n    if (typeof events === 'object') {\n      // ( types-object [, selector] )\n      const types = events as TypeEventHandlers<TElement, any, any, any>\n      Object.keys(types).forEach((type) =>\n        off(elem, type, selector, types[type] as any),\n      )\n      return\n    }\n\n    if (selector === false || typeof selector === 'function') {\n      // ( types [, fn] )\n      fn = selector\n      selector = undefined\n    }\n\n    if (fn === false) {\n      fn = Util.returnFalse\n    }\n\n    Core.off(elem as any, events as string, fn, selector)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}