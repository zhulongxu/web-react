{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { ObjectExt, StringExt } from '@antv/x6-common';\nimport { Point, Polyline } from '@antv/x6-geometry';\nimport { Registry } from '../registry/registry';\nimport { Markup } from '../view/markup';\nimport { ShareRegistry } from './registry';\nimport { Cell } from './cell';\nexport class Edge extends Cell {\n  get [Symbol.toStringTag]() {\n    return Edge.toStringTag;\n  }\n  constructor(metadata = {}) {\n    super(metadata);\n  }\n  preprocess(metadata, ignoreIdCheck) {\n    const {\n        source,\n        sourceCell,\n        sourcePort,\n        sourcePoint,\n        target,\n        targetCell,\n        targetPort,\n        targetPoint\n      } = metadata,\n      others = __rest(metadata, [\"source\", \"sourceCell\", \"sourcePort\", \"sourcePoint\", \"target\", \"targetCell\", \"targetPort\", \"targetPoint\"]);\n    const data = others;\n    const isValidId = val => typeof val === 'string' || typeof val === 'number';\n    if (source != null) {\n      if (Cell.isCell(source)) {\n        data.source = {\n          cell: source.id\n        };\n      } else if (isValidId(source)) {\n        data.source = {\n          cell: source\n        };\n      } else if (Point.isPoint(source)) {\n        data.source = source.toJSON();\n      } else if (Array.isArray(source)) {\n        data.source = {\n          x: source[0],\n          y: source[1]\n        };\n      } else {\n        const cell = source.cell;\n        if (Cell.isCell(cell)) {\n          data.source = Object.assign(Object.assign({}, source), {\n            cell: cell.id\n          });\n        } else {\n          data.source = source;\n        }\n      }\n    }\n    if (sourceCell != null || sourcePort != null) {\n      let terminal = data.source;\n      if (sourceCell != null) {\n        const id = isValidId(sourceCell) ? sourceCell : sourceCell.id;\n        if (terminal) {\n          terminal.cell = id;\n        } else {\n          terminal = data.source = {\n            cell: id\n          };\n        }\n      }\n      if (sourcePort != null && terminal) {\n        terminal.port = sourcePort;\n      }\n    } else if (sourcePoint != null) {\n      data.source = Point.create(sourcePoint).toJSON();\n    }\n    if (target != null) {\n      if (Cell.isCell(target)) {\n        data.target = {\n          cell: target.id\n        };\n      } else if (isValidId(target)) {\n        data.target = {\n          cell: target\n        };\n      } else if (Point.isPoint(target)) {\n        data.target = target.toJSON();\n      } else if (Array.isArray(target)) {\n        data.target = {\n          x: target[0],\n          y: target[1]\n        };\n      } else {\n        const cell = target.cell;\n        if (Cell.isCell(cell)) {\n          data.target = Object.assign(Object.assign({}, target), {\n            cell: cell.id\n          });\n        } else {\n          data.target = target;\n        }\n      }\n    }\n    if (targetCell != null || targetPort != null) {\n      let terminal = data.target;\n      if (targetCell != null) {\n        const id = isValidId(targetCell) ? targetCell : targetCell.id;\n        if (terminal) {\n          terminal.cell = id;\n        } else {\n          terminal = data.target = {\n            cell: id\n          };\n        }\n      }\n      if (targetPort != null && terminal) {\n        terminal.port = targetPort;\n      }\n    } else if (targetPoint != null) {\n      data.target = Point.create(targetPoint).toJSON();\n    }\n    return super.preprocess(data, ignoreIdCheck);\n  }\n  setup() {\n    super.setup();\n    this.on('change:labels', args => this.onLabelsChanged(args));\n    this.on('change:vertices', args => this.onVertexsChanged(args));\n  }\n  isEdge() {\n    return true;\n  }\n  // #region terminal\n  disconnect(options = {}) {\n    this.store.set({\n      source: {\n        x: 0,\n        y: 0\n      },\n      target: {\n        x: 0,\n        y: 0\n      }\n    }, options);\n    return this;\n  }\n  get source() {\n    return this.getSource();\n  }\n  set source(data) {\n    this.setSource(data);\n  }\n  getSource() {\n    return this.getTerminal('source');\n  }\n  getSourceCellId() {\n    return this.source.cell;\n  }\n  getSourcePortId() {\n    return this.source.port;\n  }\n  setSource(source, args, options = {}) {\n    return this.setTerminal('source', source, args, options);\n  }\n  get target() {\n    return this.getTarget();\n  }\n  set target(data) {\n    this.setTarget(data);\n  }\n  getTarget() {\n    return this.getTerminal('target');\n  }\n  getTargetCellId() {\n    return this.target.cell;\n  }\n  getTargetPortId() {\n    return this.target.port;\n  }\n  setTarget(target, args, options = {}) {\n    return this.setTerminal('target', target, args, options);\n  }\n  getTerminal(type) {\n    return Object.assign({}, this.store.get(type));\n  }\n  setTerminal(type, terminal, args, options = {}) {\n    // `terminal` is a cell\n    if (Cell.isCell(terminal)) {\n      this.store.set(type, ObjectExt.merge({}, args, {\n        cell: terminal.id\n      }), options);\n      return this;\n    }\n    // `terminal` is a point-like object\n    const p = terminal;\n    if (Point.isPoint(terminal) || p.x != null && p.y != null) {\n      this.store.set(type, ObjectExt.merge({}, args, {\n        x: p.x,\n        y: p.y\n      }), options);\n      return this;\n    }\n    // `terminal` is an object\n    this.store.set(type, ObjectExt.cloneDeep(terminal), options);\n    return this;\n  }\n  getSourcePoint() {\n    return this.getTerminalPoint('source');\n  }\n  getTargetPoint() {\n    return this.getTerminalPoint('target');\n  }\n  getTerminalPoint(type) {\n    const terminal = this[type];\n    if (Point.isPointLike(terminal)) {\n      return Point.create(terminal);\n    }\n    const cell = this.getTerminalCell(type);\n    if (cell) {\n      return cell.getConnectionPoint(this, type);\n    }\n    return new Point();\n  }\n  getSourceCell() {\n    return this.getTerminalCell('source');\n  }\n  getTargetCell() {\n    return this.getTerminalCell('target');\n  }\n  getTerminalCell(type) {\n    if (this.model) {\n      const cellId = type === 'source' ? this.getSourceCellId() : this.getTargetCellId();\n      if (cellId) {\n        return this.model.getCell(cellId);\n      }\n    }\n    return null;\n  }\n  getSourceNode() {\n    return this.getTerminalNode('source');\n  }\n  getTargetNode() {\n    return this.getTerminalNode('target');\n  }\n  getTerminalNode(type) {\n    let cell = this; // eslint-disable-line\n    const visited = {};\n    while (cell && cell.isEdge()) {\n      if (visited[cell.id]) {\n        return null;\n      }\n      visited[cell.id] = true;\n      cell = cell.getTerminalCell(type);\n    }\n    return cell && cell.isNode() ? cell : null;\n  }\n  // #endregion\n  // #region router\n  get router() {\n    return this.getRouter();\n  }\n  set router(data) {\n    if (data == null) {\n      this.removeRouter();\n    } else {\n      this.setRouter(data);\n    }\n  }\n  getRouter() {\n    return this.store.get('router');\n  }\n  setRouter(name, args, options) {\n    if (typeof name === 'object') {\n      this.store.set('router', name, args);\n    } else {\n      this.store.set('router', {\n        name,\n        args\n      }, options);\n    }\n    return this;\n  }\n  removeRouter(options = {}) {\n    this.store.remove('router', options);\n    return this;\n  }\n  // #endregion\n  // #region connector\n  get connector() {\n    return this.getConnector();\n  }\n  set connector(data) {\n    if (data == null) {\n      this.removeConnector();\n    } else {\n      this.setConnector(data);\n    }\n  }\n  getConnector() {\n    return this.store.get('connector');\n  }\n  setConnector(name, args, options) {\n    if (typeof name === 'object') {\n      this.store.set('connector', name, args);\n    } else {\n      this.store.set('connector', {\n        name,\n        args\n      }, options);\n    }\n    return this;\n  }\n  removeConnector(options = {}) {\n    return this.store.remove('connector', options);\n  }\n  // #endregion\n  // #region labels\n  getDefaultLabel() {\n    const ctor = this.constructor;\n    const defaults = this.store.get('defaultLabel') || ctor.defaultLabel || {};\n    return ObjectExt.cloneDeep(defaults);\n  }\n  get labels() {\n    return this.getLabels();\n  }\n  set labels(labels) {\n    this.setLabels(labels);\n  }\n  getLabels() {\n    return [...this.store.get('labels', [])].map(item => this.parseLabel(item));\n  }\n  setLabels(labels, options = {}) {\n    this.store.set('labels', Array.isArray(labels) ? labels : [labels], options);\n    return this;\n  }\n  insertLabel(label, index, options = {}) {\n    const labels = this.getLabels();\n    const len = labels.length;\n    let idx = index != null && Number.isFinite(index) ? index : len;\n    if (idx < 0) {\n      idx = len + idx + 1;\n    }\n    labels.splice(idx, 0, this.parseLabel(label));\n    return this.setLabels(labels, options);\n  }\n  appendLabel(label, options = {}) {\n    return this.insertLabel(label, -1, options);\n  }\n  getLabelAt(index) {\n    const labels = this.getLabels();\n    if (index != null && Number.isFinite(index)) {\n      return this.parseLabel(labels[index]);\n    }\n    return null;\n  }\n  setLabelAt(index, label, options = {}) {\n    if (index != null && Number.isFinite(index)) {\n      const labels = this.getLabels();\n      labels[index] = this.parseLabel(label);\n      this.setLabels(labels, options);\n    }\n    return this;\n  }\n  removeLabelAt(index, options = {}) {\n    const labels = this.getLabels();\n    const idx = index != null && Number.isFinite(index) ? index : -1;\n    const removed = labels.splice(idx, 1);\n    this.setLabels(labels, options);\n    return removed.length ? removed[0] : null;\n  }\n  parseLabel(label) {\n    if (typeof label === 'string') {\n      const ctor = this.constructor;\n      return ctor.parseStringLabel(label);\n    }\n    return label;\n  }\n  onLabelsChanged({\n    previous,\n    current\n  }) {\n    const added = previous && current ? current.filter(label1 => {\n      if (!previous.find(label2 => label1 === label2 || ObjectExt.isEqual(label1, label2))) {\n        return label1;\n      }\n      return null;\n    }) : current ? [...current] : [];\n    const removed = previous && current ? previous.filter(label1 => {\n      if (!current.find(label2 => label1 === label2 || ObjectExt.isEqual(label1, label2))) {\n        return label1;\n      }\n      return null;\n    }) : previous ? [...previous] : [];\n    if (added.length > 0) {\n      this.notify('labels:added', {\n        added,\n        cell: this,\n        edge: this\n      });\n    }\n    if (removed.length > 0) {\n      this.notify('labels:removed', {\n        removed,\n        cell: this,\n        edge: this\n      });\n    }\n  }\n  // #endregion\n  // #region vertices\n  get vertices() {\n    return this.getVertices();\n  }\n  set vertices(vertices) {\n    this.setVertices(vertices);\n  }\n  getVertices() {\n    return [...this.store.get('vertices', [])];\n  }\n  setVertices(vertices, options = {}) {\n    const points = Array.isArray(vertices) ? vertices : [vertices];\n    this.store.set('vertices', points.map(p => Point.toJSON(p)), options);\n    return this;\n  }\n  insertVertex(vertice, index, options = {}) {\n    const vertices = this.getVertices();\n    const len = vertices.length;\n    let idx = index != null && Number.isFinite(index) ? index : len;\n    if (idx < 0) {\n      idx = len + idx + 1;\n    }\n    vertices.splice(idx, 0, Point.toJSON(vertice));\n    return this.setVertices(vertices, options);\n  }\n  appendVertex(vertex, options = {}) {\n    return this.insertVertex(vertex, -1, options);\n  }\n  getVertexAt(index) {\n    if (index != null && Number.isFinite(index)) {\n      const vertices = this.getVertices();\n      return vertices[index];\n    }\n    return null;\n  }\n  setVertexAt(index, vertice, options = {}) {\n    if (index != null && Number.isFinite(index)) {\n      const vertices = this.getVertices();\n      vertices[index] = vertice;\n      this.setVertices(vertices, options);\n    }\n    return this;\n  }\n  removeVertexAt(index, options = {}) {\n    const vertices = this.getVertices();\n    const idx = index != null && Number.isFinite(index) ? index : -1;\n    vertices.splice(idx, 1);\n    return this.setVertices(vertices, options);\n  }\n  onVertexsChanged({\n    previous,\n    current\n  }) {\n    const added = previous && current ? current.filter(p1 => {\n      if (!previous.find(p2 => Point.equals(p1, p2))) {\n        return p1;\n      }\n      return null;\n    }) : current ? [...current] : [];\n    const removed = previous && current ? previous.filter(p1 => {\n      if (!current.find(p2 => Point.equals(p1, p2))) {\n        return p1;\n      }\n      return null;\n    }) : previous ? [...previous] : [];\n    if (added.length > 0) {\n      this.notify('vertexs:added', {\n        added,\n        cell: this,\n        edge: this\n      });\n    }\n    if (removed.length > 0) {\n      this.notify('vertexs:removed', {\n        removed,\n        cell: this,\n        edge: this\n      });\n    }\n  }\n  // #endregion\n  // #region markup\n  getDefaultMarkup() {\n    return this.store.get('defaultMarkup') || Markup.getEdgeMarkup();\n  }\n  getMarkup() {\n    return super.getMarkup() || this.getDefaultMarkup();\n  }\n  // #endregion\n  // #region transform\n  /**\n   * Translate the edge vertices (and source and target if they are points)\n   * by `tx` pixels in the x-axis and `ty` pixels in the y-axis.\n   */\n  translate(tx, ty, options = {}) {\n    options.translateBy = options.translateBy || this.id;\n    options.tx = tx;\n    options.ty = ty;\n    return this.applyToPoints(p => ({\n      x: (p.x || 0) + tx,\n      y: (p.y || 0) + ty\n    }), options);\n  }\n  /**\n   * Scales the edge's points (vertices) relative to the given origin.\n   */\n  scale(sx, sy, origin, options = {}) {\n    return this.applyToPoints(p => {\n      return Point.create(p).scale(sx, sy, origin).toJSON();\n    }, options);\n  }\n  applyToPoints(worker, options = {}) {\n    const attrs = {};\n    const source = this.getSource();\n    const target = this.getTarget();\n    if (Point.isPointLike(source)) {\n      attrs.source = worker(source);\n    }\n    if (Point.isPointLike(target)) {\n      attrs.target = worker(target);\n    }\n    const vertices = this.getVertices();\n    if (vertices.length > 0) {\n      attrs.vertices = vertices.map(worker);\n    }\n    this.store.set(attrs, options);\n    return this;\n  }\n  // #endregion\n  // #region common\n  getBBox() {\n    return this.getPolyline().bbox();\n  }\n  getConnectionPoint() {\n    return this.getPolyline().pointAt(0.5);\n  }\n  getPolyline() {\n    const points = [this.getSourcePoint(), ...this.getVertices().map(vertice => Point.create(vertice)), this.getTargetPoint()];\n    return new Polyline(points);\n  }\n  updateParent(options) {\n    let newParent = null;\n    const source = this.getSourceCell();\n    const target = this.getTargetCell();\n    const prevParent = this.getParent();\n    if (source && target) {\n      if (source === target || source.isDescendantOf(target)) {\n        newParent = target;\n      } else if (target.isDescendantOf(source)) {\n        newParent = source;\n      } else {\n        newParent = Cell.getCommonAncestor(source, target);\n      }\n    }\n    // Unembeds the edge if source and target has no common\n    // ancestor or common ancestor changed\n    if (prevParent && newParent && newParent.id !== prevParent.id) {\n      prevParent.unembed(this, options);\n    }\n    // Embeds the edge if source and target are not same\n    if (newParent && (!prevParent || prevParent.id !== newParent.id)) {\n      newParent.embed(this, options);\n    }\n    return newParent;\n  }\n  hasLoop(options = {}) {\n    const source = this.getSource();\n    const target = this.getTarget();\n    const sourceId = source.cell;\n    const targetId = target.cell;\n    if (!sourceId || !targetId) {\n      return false;\n    }\n    let loop = sourceId === targetId;\n    // Note that there in the deep mode a edge can have a loop,\n    // even if it connects only a parent and its embed.\n    // A loop \"target equals source\" is valid in both shallow and deep mode.\n    // eslint-disable-next-line\n    if (!loop && options.deep && this._model) {\n      const sourceCell = this.getSourceCell();\n      const targetCell = this.getTargetCell();\n      if (sourceCell && targetCell) {\n        loop = sourceCell.isAncestorOf(targetCell, options) || targetCell.isAncestorOf(sourceCell, options);\n      }\n    }\n    return loop;\n  }\n  getFragmentAncestor() {\n    const cells = [this, this.getSourceNode(), this.getTargetNode()].filter(item => item != null);\n    return this.getCommonAncestor(...cells);\n  }\n  isFragmentDescendantOf(cell) {\n    const ancestor = this.getFragmentAncestor();\n    return !!ancestor && (ancestor.id === cell.id || ancestor.isDescendantOf(cell));\n  }\n}\nEdge.defaults = {};\n(function (Edge) {\n  function equalTerminals(a, b) {\n    const a1 = a;\n    const b1 = b;\n    if (a1.cell === b1.cell) {\n      return a1.port === b1.port || a1.port == null && b1.port == null;\n    }\n    return false;\n  }\n  Edge.equalTerminals = equalTerminals;\n})(Edge || (Edge = {}));\n(function (Edge) {\n  Edge.defaultLabel = {\n    markup: [{\n      tagName: 'rect',\n      selector: 'body'\n    }, {\n      tagName: 'text',\n      selector: 'label'\n    }],\n    attrs: {\n      text: {\n        fill: '#000',\n        fontSize: 14,\n        textAnchor: 'middle',\n        textVerticalAnchor: 'middle',\n        pointerEvents: 'none'\n      },\n      rect: {\n        ref: 'label',\n        fill: '#fff',\n        rx: 3,\n        ry: 3,\n        refWidth: 1,\n        refHeight: 1,\n        refX: 0,\n        refY: 0\n      }\n    },\n    position: {\n      distance: 0.5\n    }\n  };\n  function parseStringLabel(text) {\n    return {\n      attrs: {\n        label: {\n          text\n        }\n      }\n    };\n  }\n  Edge.parseStringLabel = parseStringLabel;\n})(Edge || (Edge = {}));\n(function (Edge) {\n  Edge.toStringTag = `X6.${Edge.name}`;\n  function isEdge(instance) {\n    if (instance == null) {\n      return false;\n    }\n    if (instance instanceof Edge) {\n      return true;\n    }\n    const tag = instance[Symbol.toStringTag];\n    const edge = instance;\n    if ((tag == null || tag === Edge.toStringTag) && typeof edge.isNode === 'function' && typeof edge.isEdge === 'function' && typeof edge.prop === 'function' && typeof edge.attr === 'function' && typeof edge.disconnect === 'function' && typeof edge.getSource === 'function' && typeof edge.getTarget === 'function') {\n      return true;\n    }\n    return false;\n  }\n  Edge.isEdge = isEdge;\n})(Edge || (Edge = {}));\n(function (Edge) {\n  Edge.registry = Registry.create({\n    type: 'edge',\n    process(shape, options) {\n      if (ShareRegistry.exist(shape, false)) {\n        throw new Error(`Edge with name '${shape}' was registered by anthor Node`);\n      }\n      if (typeof options === 'function') {\n        options.config({\n          shape\n        });\n        return options;\n      }\n      let parent = Edge;\n      // default inherit from 'dege'\n      const {\n          inherit = 'edge'\n        } = options,\n        others = __rest(options, [\"inherit\"]);\n      if (typeof inherit === 'string') {\n        const base = this.get(inherit || 'edge');\n        if (base == null && inherit) {\n          this.onNotFound(inherit, 'inherited');\n        } else {\n          parent = base;\n        }\n      } else {\n        parent = inherit;\n      }\n      if (others.constructorName == null) {\n        others.constructorName = shape;\n      }\n      const ctor = parent.define.call(parent, others);\n      ctor.config({\n        shape\n      });\n      return ctor;\n    }\n  });\n  ShareRegistry.setEdgeRegistry(Edge.registry);\n})(Edge || (Edge = {}));\n(function (Edge) {\n  let counter = 0;\n  function getClassName(name) {\n    if (name) {\n      return StringExt.pascalCase(name);\n    }\n    counter += 1;\n    return `CustomEdge${counter}`;\n  }\n  function define(config) {\n    const {\n        constructorName,\n        overwrite\n      } = config,\n      others = __rest(config, [\"constructorName\", \"overwrite\"]);\n    const ctor = ObjectExt.createClass(getClassName(constructorName || others.shape), this);\n    ctor.config(others);\n    if (others.shape) {\n      Edge.registry.register(others.shape, ctor, overwrite);\n    }\n    return ctor;\n  }\n  Edge.define = define;\n  function create(options) {\n    const shape = options.shape || 'edge';\n    const Ctor = Edge.registry.get(shape);\n    if (Ctor) {\n      return new Ctor(options);\n    }\n    return Edge.registry.onNotFound(shape);\n  }\n  Edge.create = create;\n})(Edge || (Edge = {}));\n(function (Edge) {\n  const shape = 'basic.edge';\n  Edge.config({\n    shape,\n    propHooks(metadata) {\n      const {\n          label,\n          vertices\n        } = metadata,\n        others = __rest(metadata, [\"label\", \"vertices\"]);\n      if (label) {\n        if (others.labels == null) {\n          others.labels = [];\n        }\n        const formated = typeof label === 'string' ? Edge.parseStringLabel(label) : label;\n        others.labels.push(formated);\n      }\n      if (vertices) {\n        if (Array.isArray(vertices)) {\n          others.vertices = vertices.map(item => Point.create(item).toJSON());\n        }\n      }\n      return others;\n    }\n  });\n  Edge.registry.register(shape, Edge);\n})(Edge || (Edge = {}));","map":{"version":3,"names":["ObjectExt","StringExt","Point","Polyline","Registry","Markup","ShareRegistry","Cell","Edge","Symbol","toStringTag","constructor","metadata","preprocess","ignoreIdCheck","source","sourceCell","sourcePort","sourcePoint","target","targetCell","targetPort","targetPoint","others","__rest","data","isValidId","val","isCell","cell","id","isPoint","toJSON","Array","isArray","x","y","Object","assign","terminal","port","create","setup","on","args","onLabelsChanged","onVertexsChanged","isEdge","disconnect","options","store","set","getSource","setSource","getTerminal","getSourceCellId","getSourcePortId","setTerminal","getTarget","setTarget","getTargetCellId","getTargetPortId","type","get","merge","p","cloneDeep","getSourcePoint","getTerminalPoint","getTargetPoint","isPointLike","getTerminalCell","getConnectionPoint","getSourceCell","getTargetCell","model","cellId","getCell","getSourceNode","getTerminalNode","getTargetNode","visited","isNode","router","getRouter","removeRouter","setRouter","name","remove","connector","getConnector","removeConnector","setConnector","getDefaultLabel","ctor","defaults","defaultLabel","labels","getLabels","setLabels","map","item","parseLabel","insertLabel","label","index","len","length","idx","Number","isFinite","splice","appendLabel","getLabelAt","setLabelAt","removeLabelAt","removed","parseStringLabel","previous","current","added","filter","label1","find","label2","isEqual","notify","edge","vertices","getVertices","setVertices","points","insertVertex","vertice","appendVertex","vertex","getVertexAt","setVertexAt","removeVertexAt","p1","p2","equals","getDefaultMarkup","getEdgeMarkup","getMarkup","translate","tx","ty","translateBy","applyToPoints","scale","sx","sy","origin","worker","attrs","getBBox","getPolyline","bbox","pointAt","updateParent","newParent","prevParent","getParent","isDescendantOf","getCommonAncestor","unembed","embed","hasLoop","sourceId","targetId","loop","deep","_model","isAncestorOf","getFragmentAncestor","cells","isFragmentDescendantOf","ancestor","equalTerminals","a","b","a1","b1","markup","tagName","selector","text","fill","fontSize","textAnchor","textVerticalAnchor","pointerEvents","rect","ref","rx","ry","refWidth","refHeight","refX","refY","position","distance","instance","tag","prop","attr","registry","process","shape","exist","Error","config","parent","inherit","base","onNotFound","constructorName","define","call","setEdgeRegistry","counter","getClassName","pascalCase","overwrite","createClass","register","Ctor","propHooks","formated","push"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/src/model/edge.ts"],"sourcesContent":["import { ObjectExt, StringExt, Size, KeyValue } from '@antv/x6-common'\nimport { Point, Polyline } from '@antv/x6-geometry'\nimport { Registry } from '../registry/registry'\nimport {\n  Attr,\n  Router,\n  Connector,\n  EdgeAnchor,\n  NodeAnchor,\n  ConnectionPoint,\n} from '../registry'\nimport { Markup } from '../view/markup'\nimport { ShareRegistry } from './registry'\nimport { Store } from './store'\nimport { Cell } from './cell'\nimport { Node } from './node'\n\nexport class Edge<\n  Properties extends Edge.Properties = Edge.Properties,\n> extends Cell<Properties> {\n  protected static defaults: Edge.Defaults = {}\n  protected readonly store: Store<Edge.Properties>\n\n  protected get [Symbol.toStringTag]() {\n    return Edge.toStringTag\n  }\n\n  constructor(metadata: Edge.Metadata = {}) {\n    super(metadata)\n  }\n\n  protected preprocess(metadata: Edge.Metadata, ignoreIdCheck?: boolean) {\n    const {\n      source,\n      sourceCell,\n      sourcePort,\n      sourcePoint,\n      target,\n      targetCell,\n      targetPort,\n      targetPoint,\n      ...others\n    } = metadata\n\n    const data = others as Edge.BaseOptions\n    const isValidId = (val: any): val is string =>\n      typeof val === 'string' || typeof val === 'number'\n\n    if (source != null) {\n      if (Cell.isCell(source)) {\n        data.source = { cell: source.id }\n      } else if (isValidId(source)) {\n        data.source = { cell: source }\n      } else if (Point.isPoint(source)) {\n        data.source = source.toJSON()\n      } else if (Array.isArray(source)) {\n        data.source = { x: source[0], y: source[1] }\n      } else {\n        const cell = (source as Edge.TerminalCellLooseData).cell\n        if (Cell.isCell(cell)) {\n          data.source = {\n            ...source,\n            cell: cell.id,\n          }\n        } else {\n          data.source = source as Edge.TerminalCellData\n        }\n      }\n    }\n\n    if (sourceCell != null || sourcePort != null) {\n      let terminal = data.source as Edge.TerminalCellData\n      if (sourceCell != null) {\n        const id = isValidId(sourceCell) ? sourceCell : sourceCell.id\n        if (terminal) {\n          terminal.cell = id\n        } else {\n          terminal = data.source = { cell: id }\n        }\n      }\n\n      if (sourcePort != null && terminal) {\n        terminal.port = sourcePort\n      }\n    } else if (sourcePoint != null) {\n      data.source = Point.create(sourcePoint).toJSON()\n    }\n\n    if (target != null) {\n      if (Cell.isCell(target)) {\n        data.target = { cell: target.id }\n      } else if (isValidId(target)) {\n        data.target = { cell: target }\n      } else if (Point.isPoint(target)) {\n        data.target = target.toJSON()\n      } else if (Array.isArray(target)) {\n        data.target = { x: target[0], y: target[1] }\n      } else {\n        const cell = (target as Edge.TerminalCellLooseData).cell\n        if (Cell.isCell(cell)) {\n          data.target = {\n            ...target,\n            cell: cell.id,\n          }\n        } else {\n          data.target = target as Edge.TerminalCellData\n        }\n      }\n    }\n\n    if (targetCell != null || targetPort != null) {\n      let terminal = data.target as Edge.TerminalCellData\n\n      if (targetCell != null) {\n        const id = isValidId(targetCell) ? targetCell : targetCell.id\n        if (terminal) {\n          terminal.cell = id\n        } else {\n          terminal = data.target = { cell: id }\n        }\n      }\n\n      if (targetPort != null && terminal) {\n        terminal.port = targetPort\n      }\n    } else if (targetPoint != null) {\n      data.target = Point.create(targetPoint).toJSON()\n    }\n\n    return super.preprocess(data, ignoreIdCheck)\n  }\n\n  protected setup() {\n    super.setup()\n    this.on('change:labels', (args) => this.onLabelsChanged(args))\n    this.on('change:vertices', (args) => this.onVertexsChanged(args))\n  }\n\n  isEdge(): this is Edge {\n    return true\n  }\n\n  // #region terminal\n\n  disconnect(options: Edge.SetOptions = {}) {\n    this.store.set(\n      {\n        source: { x: 0, y: 0 },\n        target: { x: 0, y: 0 },\n      },\n      options,\n    )\n    return this\n  }\n\n  get source() {\n    return this.getSource()\n  }\n\n  set source(data: Edge.TerminalData) {\n    this.setSource(data)\n  }\n\n  getSource() {\n    return this.getTerminal('source')\n  }\n\n  getSourceCellId() {\n    return (this.source as Edge.TerminalCellData).cell\n  }\n\n  getSourcePortId() {\n    return (this.source as Edge.TerminalCellData).port\n  }\n\n  setSource(\n    node: Node,\n    args?: Edge.SetCellTerminalArgs,\n    options?: Edge.SetOptions,\n  ): this\n  setSource(\n    edge: Edge,\n    args?: Edge.SetEdgeTerminalArgs,\n    options?: Edge.SetOptions,\n  ): this\n  setSource(\n    point: Point | Point.PointLike,\n    args?: Edge.SetTerminalCommonArgs,\n    options?: Edge.SetOptions,\n  ): this\n  setSource(args: Edge.TerminalData, options?: Edge.SetOptions): this\n  setSource(\n    source: Node | Edge | Point | Point.PointLike | Edge.TerminalData,\n    args?: Edge.SetTerminalCommonArgs | Edge.SetOptions,\n    options: Edge.SetOptions = {},\n  ) {\n    return this.setTerminal('source', source, args, options)\n  }\n\n  get target() {\n    return this.getTarget()\n  }\n\n  set target(data: Edge.TerminalData) {\n    this.setTarget(data)\n  }\n\n  getTarget() {\n    return this.getTerminal('target')\n  }\n\n  getTargetCellId() {\n    return (this.target as Edge.TerminalCellData).cell\n  }\n\n  getTargetPortId() {\n    return (this.target as Edge.TerminalCellData).port\n  }\n\n  setTarget(\n    edge: Node,\n    args?: Edge.SetCellTerminalArgs,\n    options?: Edge.SetOptions,\n  ): this\n  setTarget(\n    edge: Edge,\n    args?: Edge.SetEdgeTerminalArgs,\n    options?: Edge.SetOptions,\n  ): this\n  setTarget(\n    point: Point | Point.PointLike,\n    args?: Edge.SetTerminalCommonArgs,\n    options?: Edge.SetOptions,\n  ): this\n  setTarget(args: Edge.TerminalData, options?: Edge.SetOptions): this\n  setTarget(\n    target: Node | Edge | Point | Point.PointLike | Edge.TerminalData,\n    args?: Edge.SetTerminalCommonArgs | Edge.SetOptions,\n    options: Edge.SetOptions = {},\n  ) {\n    return this.setTerminal('target', target, args, options)\n  }\n\n  getTerminal(type: Edge.TerminalType) {\n    return { ...this.store.get(type) } as Edge.TerminalData\n  }\n\n  setTerminal(\n    type: Edge.TerminalType,\n    terminal: Node | Edge | Point | Point.PointLike | Edge.TerminalData,\n    args?: Edge.SetTerminalCommonArgs | Edge.SetOptions,\n    options: Edge.SetOptions = {},\n  ): this {\n    // `terminal` is a cell\n    if (Cell.isCell(terminal)) {\n      this.store.set(\n        type,\n        ObjectExt.merge({}, args, { cell: terminal.id }),\n        options,\n      )\n      return this\n    }\n\n    // `terminal` is a point-like object\n    const p = terminal as Point.PointLike\n    if (Point.isPoint(terminal) || (p.x != null && p.y != null)) {\n      this.store.set(\n        type,\n        ObjectExt.merge({}, args, { x: p.x, y: p.y }),\n        options,\n      )\n      return this\n    }\n\n    // `terminal` is an object\n    this.store.set(\n      type,\n      ObjectExt.cloneDeep(terminal as Edge.TerminalData),\n      options,\n    )\n\n    return this\n  }\n\n  getSourcePoint() {\n    return this.getTerminalPoint('source')\n  }\n\n  getTargetPoint() {\n    return this.getTerminalPoint('target')\n  }\n\n  protected getTerminalPoint(type: Edge.TerminalType): Point {\n    const terminal = this[type]\n    if (Point.isPointLike(terminal)) {\n      return Point.create(terminal)\n    }\n\n    const cell = this.getTerminalCell(type)\n    if (cell) {\n      return cell.getConnectionPoint(this as any, type)\n    }\n\n    return new Point()\n  }\n\n  getSourceCell() {\n    return this.getTerminalCell('source')\n  }\n\n  getTargetCell() {\n    return this.getTerminalCell('target')\n  }\n\n  protected getTerminalCell(type: Edge.TerminalType) {\n    if (this.model) {\n      const cellId =\n        type === 'source' ? this.getSourceCellId() : this.getTargetCellId()\n      if (cellId) {\n        return this.model.getCell(cellId)\n      }\n    }\n\n    return null\n  }\n\n  getSourceNode() {\n    return this.getTerminalNode('source')\n  }\n\n  getTargetNode() {\n    return this.getTerminalNode('target')\n  }\n\n  protected getTerminalNode(type: Edge.TerminalType): Node | null {\n    let cell: Cell | null = this // eslint-disable-line\n    const visited: { [id: string]: boolean } = {}\n\n    while (cell && cell.isEdge()) {\n      if (visited[cell.id]) {\n        return null\n      }\n      visited[cell.id] = true\n      cell = cell.getTerminalCell(type)\n    }\n\n    return cell && cell.isNode() ? cell : null\n  }\n\n  // #endregion\n\n  // #region router\n\n  get router() {\n    return this.getRouter()\n  }\n\n  set router(data: Edge.RouterData | undefined) {\n    if (data == null) {\n      this.removeRouter()\n    } else {\n      this.setRouter(data)\n    }\n  }\n\n  getRouter() {\n    return this.store.get<Edge.RouterData>('router')\n  }\n\n  setRouter(name: string, args?: KeyValue, options?: Edge.SetOptions): this\n  setRouter(router: Edge.RouterData, options?: Edge.SetOptions): this\n  setRouter(\n    name?: string | Edge.RouterData,\n    args?: KeyValue,\n    options?: Edge.SetOptions,\n  ) {\n    if (typeof name === 'object') {\n      this.store.set('router', name, args)\n    } else {\n      this.store.set('router', { name, args }, options)\n    }\n    return this\n  }\n\n  removeRouter(options: Edge.SetOptions = {}) {\n    this.store.remove('router', options)\n    return this\n  }\n\n  // #endregion\n\n  // #region connector\n\n  get connector() {\n    return this.getConnector()\n  }\n\n  set connector(data: Edge.ConnectorData | undefined) {\n    if (data == null) {\n      this.removeConnector()\n    } else {\n      this.setConnector(data)\n    }\n  }\n\n  getConnector() {\n    return this.store.get('connector')\n  }\n\n  setConnector(name: string, args?: KeyValue, options?: Edge.SetOptions): this\n  setConnector(connector: Edge.ConnectorData, options?: Edge.SetOptions): this\n  setConnector(\n    name?: string | Edge.ConnectorData,\n    args?: KeyValue | Edge.SetOptions,\n    options?: Edge.SetOptions,\n  ) {\n    if (typeof name === 'object') {\n      this.store.set('connector', name, args)\n    } else {\n      this.store.set('connector', { name, args }, options)\n    }\n    return this\n  }\n\n  removeConnector(options: Edge.SetOptions = {}) {\n    return this.store.remove('connector', options)\n  }\n\n  // #endregion\n\n  // #region labels\n\n  getDefaultLabel(): Edge.Label {\n    const ctor = this.constructor as Edge.Definition\n    const defaults = this.store.get('defaultLabel') || ctor.defaultLabel || {}\n    return ObjectExt.cloneDeep(defaults)\n  }\n\n  get labels() {\n    return this.getLabels()\n  }\n\n  set labels(labels: Edge.Label[]) {\n    this.setLabels(labels)\n  }\n\n  getLabels(): Edge.Label[] {\n    return [...this.store.get('labels', [])].map((item) =>\n      this.parseLabel(item),\n    )\n  }\n\n  setLabels(\n    labels: Edge.Label | Edge.Label[] | string | string[],\n    options: Edge.SetOptions = {},\n  ) {\n    this.store.set('labels', Array.isArray(labels) ? labels : [labels], options)\n    return this\n  }\n\n  insertLabel(\n    label: Edge.Label | string,\n    index?: number,\n    options: Edge.SetOptions = {},\n  ) {\n    const labels = this.getLabels()\n    const len = labels.length\n    let idx = index != null && Number.isFinite(index) ? index : len\n    if (idx < 0) {\n      idx = len + idx + 1\n    }\n\n    labels.splice(idx, 0, this.parseLabel(label))\n    return this.setLabels(labels, options)\n  }\n\n  appendLabel(label: Edge.Label | string, options: Edge.SetOptions = {}) {\n    return this.insertLabel(label, -1, options)\n  }\n\n  getLabelAt(index: number) {\n    const labels = this.getLabels()\n    if (index != null && Number.isFinite(index)) {\n      return this.parseLabel(labels[index])\n    }\n    return null\n  }\n\n  setLabelAt(\n    index: number,\n    label: Edge.Label | string,\n    options: Edge.SetOptions = {},\n  ) {\n    if (index != null && Number.isFinite(index)) {\n      const labels = this.getLabels()\n      labels[index] = this.parseLabel(label)\n      this.setLabels(labels, options)\n    }\n    return this\n  }\n\n  removeLabelAt(index: number, options: Edge.SetOptions = {}) {\n    const labels = this.getLabels()\n    const idx = index != null && Number.isFinite(index) ? index : -1\n\n    const removed = labels.splice(idx, 1)\n    this.setLabels(labels, options)\n    return removed.length ? removed[0] : null\n  }\n\n  protected parseLabel(label: string | Edge.Label) {\n    if (typeof label === 'string') {\n      const ctor = this.constructor as Edge.Definition\n      return ctor.parseStringLabel(label)\n    }\n    return label\n  }\n\n  protected onLabelsChanged({\n    previous,\n    current,\n  }: Cell.ChangeArgs<Edge.Label[]>) {\n    const added =\n      previous && current\n        ? current.filter((label1) => {\n            if (\n              !previous.find(\n                (label2) =>\n                  label1 === label2 || ObjectExt.isEqual(label1, label2),\n              )\n            ) {\n              return label1\n            }\n            return null\n          })\n        : current\n        ? [...current]\n        : []\n\n    const removed =\n      previous && current\n        ? previous.filter((label1) => {\n            if (\n              !current.find(\n                (label2) =>\n                  label1 === label2 || ObjectExt.isEqual(label1, label2),\n              )\n            ) {\n              return label1\n            }\n            return null\n          })\n        : previous\n        ? [...previous]\n        : []\n\n    if (added.length > 0) {\n      this.notify('labels:added', { added, cell: this, edge: this })\n    }\n\n    if (removed.length > 0) {\n      this.notify('labels:removed', { removed, cell: this, edge: this })\n    }\n  }\n\n  // #endregion\n\n  // #region vertices\n  get vertices() {\n    return this.getVertices()\n  }\n\n  set vertices(vertices: Point.PointLike | Point.PointLike[]) {\n    this.setVertices(vertices)\n  }\n\n  getVertices() {\n    return [...this.store.get('vertices', [])]\n  }\n\n  setVertices(\n    vertices: Point.PointLike | Point.PointLike[],\n    options: Edge.SetOptions = {},\n  ) {\n    const points = Array.isArray(vertices) ? vertices : [vertices]\n    this.store.set(\n      'vertices',\n      points.map((p) => Point.toJSON(p)),\n      options,\n    )\n    return this\n  }\n\n  insertVertex(\n    vertice: Point.PointLike,\n    index?: number,\n    options: Edge.SetOptions = {},\n  ) {\n    const vertices = this.getVertices()\n    const len = vertices.length\n    let idx = index != null && Number.isFinite(index) ? index : len\n    if (idx < 0) {\n      idx = len + idx + 1\n    }\n\n    vertices.splice(idx, 0, Point.toJSON(vertice))\n    return this.setVertices(vertices, options)\n  }\n\n  appendVertex(vertex: Point.PointLike, options: Edge.SetOptions = {}) {\n    return this.insertVertex(vertex, -1, options)\n  }\n\n  getVertexAt(index: number) {\n    if (index != null && Number.isFinite(index)) {\n      const vertices = this.getVertices()\n      return vertices[index]\n    }\n    return null\n  }\n\n  setVertexAt(\n    index: number,\n    vertice: Point.PointLike,\n    options: Edge.SetOptions = {},\n  ) {\n    if (index != null && Number.isFinite(index)) {\n      const vertices = this.getVertices()\n      vertices[index] = vertice\n      this.setVertices(vertices, options)\n    }\n    return this\n  }\n\n  removeVertexAt(index: number, options: Edge.SetOptions = {}) {\n    const vertices = this.getVertices()\n    const idx = index != null && Number.isFinite(index) ? index : -1\n    vertices.splice(idx, 1)\n    return this.setVertices(vertices, options)\n  }\n\n  protected onVertexsChanged({\n    previous,\n    current,\n  }: Cell.ChangeArgs<Point.PointLike[]>) {\n    const added =\n      previous && current\n        ? current.filter((p1) => {\n            if (!previous.find((p2) => Point.equals(p1, p2))) {\n              return p1\n            }\n            return null\n          })\n        : current\n        ? [...current]\n        : []\n\n    const removed =\n      previous && current\n        ? previous.filter((p1) => {\n            if (!current.find((p2) => Point.equals(p1, p2))) {\n              return p1\n            }\n            return null\n          })\n        : previous\n        ? [...previous]\n        : []\n\n    if (added.length > 0) {\n      this.notify('vertexs:added', { added, cell: this, edge: this })\n    }\n\n    if (removed.length > 0) {\n      this.notify('vertexs:removed', { removed, cell: this, edge: this })\n    }\n  }\n\n  // #endregion\n\n  // #region markup\n\n  getDefaultMarkup() {\n    return this.store.get('defaultMarkup') || Markup.getEdgeMarkup()\n  }\n\n  getMarkup() {\n    return super.getMarkup() || this.getDefaultMarkup()\n  }\n\n  // #endregion\n\n  // #region transform\n\n  /**\n   * Translate the edge vertices (and source and target if they are points)\n   * by `tx` pixels in the x-axis and `ty` pixels in the y-axis.\n   */\n  translate(tx: number, ty: number, options: Cell.TranslateOptions = {}) {\n    options.translateBy = options.translateBy || this.id\n    options.tx = tx\n    options.ty = ty\n\n    return this.applyToPoints(\n      (p) => ({\n        x: (p.x || 0) + tx,\n        y: (p.y || 0) + ty,\n      }),\n      options,\n    )\n  }\n\n  /**\n   * Scales the edge's points (vertices) relative to the given origin.\n   */\n  scale(\n    sx: number,\n    sy: number,\n    origin?: Point | Point.PointLike,\n    options: Edge.SetOptions = {},\n  ) {\n    return this.applyToPoints((p) => {\n      return Point.create(p).scale(sx, sy, origin).toJSON()\n    }, options)\n  }\n\n  protected applyToPoints(\n    worker: (p: Point.PointLike) => Point.PointLike,\n    options: Edge.SetOptions = {},\n  ) {\n    const attrs: {\n      source?: Edge.TerminalPointData\n      target?: Edge.TerminalPointData\n      vertices?: Point.PointLike[]\n    } = {}\n\n    const source = this.getSource()\n    const target = this.getTarget()\n    if (Point.isPointLike(source)) {\n      attrs.source = worker(source)\n    }\n\n    if (Point.isPointLike(target)) {\n      attrs.target = worker(target)\n    }\n\n    const vertices = this.getVertices()\n    if (vertices.length > 0) {\n      attrs.vertices = vertices.map(worker)\n    }\n\n    this.store.set(attrs, options)\n    return this\n  }\n\n  // #endregion\n\n  // #region common\n\n  getBBox() {\n    return this.getPolyline().bbox()\n  }\n\n  getConnectionPoint() {\n    return this.getPolyline().pointAt(0.5)!\n  }\n\n  getPolyline() {\n    const points = [\n      this.getSourcePoint(),\n      ...this.getVertices().map((vertice) => Point.create(vertice)),\n      this.getTargetPoint(),\n    ]\n    return new Polyline(points)\n  }\n\n  updateParent(options?: Edge.SetOptions) {\n    let newParent: Cell | null = null\n\n    const source = this.getSourceCell()\n    const target = this.getTargetCell()\n    const prevParent = this.getParent()\n\n    if (source && target) {\n      if (source === target || source.isDescendantOf(target)) {\n        newParent = target\n      } else if (target.isDescendantOf(source)) {\n        newParent = source\n      } else {\n        newParent = Cell.getCommonAncestor(source, target)\n      }\n    }\n\n    // Unembeds the edge if source and target has no common\n    // ancestor or common ancestor changed\n    if (prevParent && newParent && newParent.id !== prevParent.id) {\n      prevParent.unembed(this, options)\n    }\n\n    // Embeds the edge if source and target are not same\n    if (newParent && (!prevParent || prevParent.id !== newParent.id)) {\n      newParent.embed(this, options)\n    }\n\n    return newParent\n  }\n\n  hasLoop(options: { deep?: boolean } = {}) {\n    const source = this.getSource() as Edge.TerminalCellData\n    const target = this.getTarget() as Edge.TerminalCellData\n    const sourceId = source.cell\n    const targetId = target.cell\n\n    if (!sourceId || !targetId) {\n      return false\n    }\n\n    let loop = sourceId === targetId\n\n    // Note that there in the deep mode a edge can have a loop,\n    // even if it connects only a parent and its embed.\n    // A loop \"target equals source\" is valid in both shallow and deep mode.\n    // eslint-disable-next-line\n    if (!loop && options.deep && this._model) {\n      const sourceCell = this.getSourceCell()\n      const targetCell = this.getTargetCell()\n\n      if (sourceCell && targetCell) {\n        loop =\n          sourceCell.isAncestorOf(targetCell, options) ||\n          targetCell.isAncestorOf(sourceCell, options)\n      }\n    }\n\n    return loop\n  }\n\n  getFragmentAncestor(): Cell | null {\n    const cells = [this, this.getSourceNode(), this.getTargetNode()].filter(\n      (item) => item != null,\n    )\n    return this.getCommonAncestor(...cells)\n  }\n\n  isFragmentDescendantOf(cell: Cell) {\n    const ancestor = this.getFragmentAncestor()\n    return (\n      !!ancestor && (ancestor.id === cell.id || ancestor.isDescendantOf(cell))\n    )\n  }\n\n  // #endregion\n}\n\nexport namespace Edge {\n  export type RouterData = Router.NativeItem | Router.ManaualItem\n  export type ConnectorData = Connector.NativeItem | Connector.ManaualItem\n}\n\nexport namespace Edge {\n  interface Common extends Cell.Common {\n    source?: TerminalData\n    target?: TerminalData\n    router?: RouterData\n    connector?: ConnectorData\n    labels?: Label[] | string[]\n    defaultLabel?: Label\n    vertices?: (Point.PointLike | Point.PointData)[]\n    defaultMarkup?: Markup\n  }\n\n  interface TerminalOptions {\n    sourceCell?: Cell | string\n    sourcePort?: string\n    sourcePoint?: Point.PointLike | Point.PointData\n    targetCell?: Cell | string\n    targetPort?: string\n    targetPoint?: Point.PointLike | Point.PointData\n    source?:\n      | string\n      | Cell\n      | Point.PointLike\n      | Point.PointData\n      | TerminalPointData\n      | TerminalCellLooseData\n    target?:\n      | string\n      | Cell\n      | Point.PointLike\n      | Point.PointData\n      | TerminalPointData\n      | TerminalCellLooseData\n  }\n\n  export interface BaseOptions extends Common, Cell.Metadata {}\n\n  export interface Metadata\n    extends Omit<BaseOptions, TerminalType>,\n      TerminalOptions {}\n\n  export interface Defaults extends Common, Cell.Defaults {}\n\n  export interface Properties\n    extends Cell.Properties,\n      Omit<BaseOptions, 'tools'> {}\n\n  export interface Config\n    extends Omit<Defaults, TerminalType>,\n      TerminalOptions,\n      Cell.Config<Metadata, Edge> {}\n}\n\nexport namespace Edge {\n  export interface SetOptions extends Cell.SetOptions {}\n\n  export type TerminalType = 'source' | 'target'\n\n  export interface SetTerminalCommonArgs {\n    selector?: string\n    magnet?: string\n    connectionPoint?:\n      | string\n      | ConnectionPoint.NativeItem\n      | ConnectionPoint.ManaualItem\n  }\n\n  export type NodeAnchorItem =\n    | string\n    | NodeAnchor.NativeItem\n    | NodeAnchor.ManaualItem\n\n  export type EdgeAnchorItem =\n    | string\n    | EdgeAnchor.NativeItem\n    | EdgeAnchor.ManaualItem\n\n  export interface SetCellTerminalArgs extends SetTerminalCommonArgs {\n    port?: string\n    priority?: boolean\n    anchor?: NodeAnchorItem\n  }\n\n  export interface SetEdgeTerminalArgs extends SetTerminalCommonArgs {\n    anchor?: EdgeAnchorItem\n  }\n\n  export interface TerminalPointData\n    extends SetTerminalCommonArgs,\n      Point.PointLike {}\n\n  export interface TerminalCellData extends SetCellTerminalArgs {\n    cell: string\n    port?: string\n  }\n\n  export interface TerminalCellLooseData extends SetCellTerminalArgs {\n    cell: string | Cell\n    port?: string\n  }\n\n  export type TerminalData = TerminalPointData | TerminalCellLooseData\n\n  export function equalTerminals(a: TerminalData, b: TerminalData) {\n    const a1 = a as TerminalCellData\n    const b1 = b as TerminalCellData\n    if (a1.cell === b1.cell) {\n      return a1.port === b1.port || (a1.port == null && b1.port == null)\n    }\n    return false\n  }\n}\n\nexport namespace Edge {\n  export interface Label extends KeyValue {\n    markup?: Markup\n    attrs?: Attr.CellAttrs\n    /**\n     * If the distance is in the `[0,1]` range (inclusive), then the position\n     * of the label is defined as a percentage of the total length of the edge\n     * (the normalized length). For example, passing the number `0.5` positions\n     * the label to the middle of the edge.\n     *\n     * If the distance is larger than `1` (exclusive), the label will be\n     * positioned distance pixels away from the beginning of the path along\n     * the edge.\n     *\n     * If the distance is a negative number, the label will be positioned\n     * distance pixels away from the end of the path along the edge.\n     */\n    position?: LabelPosition\n    size?: Size\n  }\n\n  export interface LabelPositionOptions {\n    /**\n     * Forces absolute coordinates for distance.\n     */\n    absoluteDistance?: boolean\n    /**\n     * Forces reverse absolute coordinates (if absoluteDistance = true)\n     */\n    reverseDistance?: boolean\n    /**\n     * Forces absolute coordinates for offset.\n     */\n    absoluteOffset?: boolean\n    /**\n     * Auto-adjusts the angle of the label to match path gradient at position.\n     */\n    keepGradient?: boolean\n    /**\n     * Whether rotates labels so they are never upside-down.\n     */\n    ensureLegibility?: boolean\n  }\n\n  export interface LabelPositionObject {\n    distance: number\n    offset?:\n      | number\n      | {\n          x?: number\n          y?: number\n        }\n    angle?: number\n    options?: LabelPositionOptions\n  }\n\n  export type LabelPosition = number | LabelPositionObject\n\n  export const defaultLabel: Label = {\n    markup: [\n      {\n        tagName: 'rect',\n        selector: 'body',\n      },\n      {\n        tagName: 'text',\n        selector: 'label',\n      },\n    ],\n    attrs: {\n      text: {\n        fill: '#000',\n        fontSize: 14,\n        textAnchor: 'middle',\n        textVerticalAnchor: 'middle',\n        pointerEvents: 'none',\n      },\n      rect: {\n        ref: 'label',\n        fill: '#fff',\n        rx: 3,\n        ry: 3,\n        refWidth: 1,\n        refHeight: 1,\n        refX: 0,\n        refY: 0,\n      },\n    },\n    position: {\n      distance: 0.5,\n    },\n  }\n\n  export function parseStringLabel(text: string): Label {\n    return {\n      attrs: { label: { text } },\n    }\n  }\n}\n\nexport namespace Edge {\n  export const toStringTag = `X6.${Edge.name}`\n\n  export function isEdge(instance: any): instance is Edge {\n    if (instance == null) {\n      return false\n    }\n\n    if (instance instanceof Edge) {\n      return true\n    }\n\n    const tag = instance[Symbol.toStringTag]\n    const edge = instance as Edge\n\n    if (\n      (tag == null || tag === toStringTag) &&\n      typeof edge.isNode === 'function' &&\n      typeof edge.isEdge === 'function' &&\n      typeof edge.prop === 'function' &&\n      typeof edge.attr === 'function' &&\n      typeof edge.disconnect === 'function' &&\n      typeof edge.getSource === 'function' &&\n      typeof edge.getTarget === 'function'\n    ) {\n      return true\n    }\n\n    return false\n  }\n}\n\nexport namespace Edge {\n  export const registry = Registry.create<\n    Definition,\n    never,\n    Config & { inherit?: string | Definition }\n  >({\n    type: 'edge',\n    process(shape, options) {\n      if (ShareRegistry.exist(shape, false)) {\n        throw new Error(\n          `Edge with name '${shape}' was registered by anthor Node`,\n        )\n      }\n\n      if (typeof options === 'function') {\n        options.config({ shape })\n        return options\n      }\n\n      let parent = Edge\n\n      // default inherit from 'dege'\n      const { inherit = 'edge', ...others } = options\n      if (typeof inherit === 'string') {\n        const base = this.get(inherit || 'edge')\n        if (base == null && inherit) {\n          this.onNotFound(inherit, 'inherited')\n        } else {\n          parent = base\n        }\n      } else {\n        parent = inherit\n      }\n\n      if (others.constructorName == null) {\n        others.constructorName = shape\n      }\n\n      const ctor: Definition = parent.define.call(parent, others)\n      ctor.config({ shape })\n      return ctor as any\n    },\n  })\n\n  ShareRegistry.setEdgeRegistry(registry)\n}\n\nexport namespace Edge {\n  type EdgeClass = typeof Edge\n\n  export interface Definition extends EdgeClass {\n    new <T extends Properties = Properties>(metadata: T): Edge\n  }\n\n  let counter = 0\n  function getClassName(name?: string) {\n    if (name) {\n      return StringExt.pascalCase(name)\n    }\n    counter += 1\n    return `CustomEdge${counter}`\n  }\n\n  export function define(config: Config) {\n    const { constructorName, overwrite, ...others } = config\n    const ctor = ObjectExt.createClass<Definition>(\n      getClassName(constructorName || others.shape),\n      this as Definition,\n    )\n\n    ctor.config(others)\n\n    if (others.shape) {\n      registry.register(others.shape, ctor, overwrite)\n    }\n\n    return ctor\n  }\n\n  export function create(options: Metadata) {\n    const shape = options.shape || 'edge'\n    const Ctor = registry.get(shape)\n    if (Ctor) {\n      return new Ctor(options)\n    }\n    return registry.onNotFound(shape)\n  }\n}\n\nexport namespace Edge {\n  const shape = 'basic.edge'\n  Edge.config({\n    shape,\n    propHooks(metadata: Properties) {\n      const { label, vertices, ...others } = metadata\n      if (label) {\n        if (others.labels == null) {\n          others.labels = []\n        }\n        const formated =\n          typeof label === 'string' ? parseStringLabel(label) : label\n        others.labels.push(formated)\n      }\n\n      if (vertices) {\n        if (Array.isArray(vertices)) {\n          others.vertices = vertices.map((item) => Point.create(item).toJSON())\n        }\n      }\n\n      return others\n    },\n  })\n  registry.register(shape, Edge)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}