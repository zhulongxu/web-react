{"ast":null,"code":"import { FunctionExt } from '@antv/x6-common';\nimport { Point, Line, Angle } from '@antv/x6-geometry';\nimport { resolve } from './manhattan/options';\nimport { manhattan } from './manhattan/index';\nconst defaults = {\n  maxDirectionChange: 45,\n  // an array of directions to find next points on the route\n  // different from start/end directions\n  directions() {\n    const step = resolve(this.step, this);\n    const cost = resolve(this.cost, this);\n    const diagonalCost = Math.ceil(Math.sqrt(step * step << 1)); // eslint-disable-line no-bitwise\n    return [{\n      cost,\n      offsetX: step,\n      offsetY: 0\n    }, {\n      cost: diagonalCost,\n      offsetX: step,\n      offsetY: step\n    }, {\n      cost,\n      offsetX: 0,\n      offsetY: step\n    }, {\n      cost: diagonalCost,\n      offsetX: -step,\n      offsetY: step\n    }, {\n      cost,\n      offsetX: -step,\n      offsetY: 0\n    }, {\n      cost: diagonalCost,\n      offsetX: -step,\n      offsetY: -step\n    }, {\n      cost,\n      offsetX: 0,\n      offsetY: -step\n    }, {\n      cost: diagonalCost,\n      offsetX: step,\n      offsetY: -step\n    }];\n  },\n  // a simple route used in situations when main routing method fails\n  // (exceed max number of loop iterations, inaccessible)\n  fallbackRoute(from, to, options) {\n    // Find a route which breaks by 45 degrees ignoring all obstacles.\n    const theta = from.theta(to);\n    const route = [];\n    let a = {\n      x: to.x,\n      y: from.y\n    };\n    let b = {\n      x: from.x,\n      y: to.y\n    };\n    if (theta % 180 > 90) {\n      const t = a;\n      a = b;\n      b = t;\n    }\n    const p1 = theta % 90 < 45 ? a : b;\n    const l1 = new Line(from, p1);\n    const alpha = 90 * Math.ceil(theta / 90);\n    const p2 = Point.fromPolar(l1.squaredLength(), Angle.toRad(alpha + 135), p1);\n    const l2 = new Line(to, p2);\n    const intersectionPoint = l1.intersectsWithLine(l2);\n    const point = intersectionPoint || to;\n    const directionFrom = intersectionPoint ? point : from;\n    const quadrant = 360 / options.directions.length;\n    const angleTheta = directionFrom.theta(to);\n    const normalizedAngle = Angle.normalize(angleTheta + quadrant / 2);\n    const directionAngle = quadrant * Math.floor(normalizedAngle / quadrant);\n    options.previousDirectionAngle = directionAngle;\n    if (point) route.push(point.round());\n    route.push(to);\n    return route;\n  }\n};\nexport const metro = function (vertices, options, linkView) {\n  return FunctionExt.call(manhattan, this, vertices, Object.assign(Object.assign({}, defaults), options), linkView);\n};","map":{"version":3,"names":["FunctionExt","Point","Line","Angle","resolve","manhattan","defaults","maxDirectionChange","directions","step","cost","diagonalCost","Math","ceil","sqrt","offsetX","offsetY","fallbackRoute","from","to","options","theta","route","a","x","y","b","t","p1","l1","alpha","p2","fromPolar","squaredLength","toRad","l2","intersectionPoint","intersectsWithLine","point","directionFrom","quadrant","length","angleTheta","normalizedAngle","normalize","directionAngle","floor","previousDirectionAngle","push","round","metro","vertices","linkView","call","Object","assign"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/src/registry/router/metro.ts"],"sourcesContent":["import { FunctionExt } from '@antv/x6-common'\nimport { Point, Line, Angle } from '@antv/x6-geometry'\nimport { ManhattanRouterOptions, resolve } from './manhattan/options'\nimport { manhattan } from './manhattan/index'\nimport { Router } from './index'\n\nexport interface MetroRouterOptions extends ManhattanRouterOptions {}\n\nconst defaults: Partial<MetroRouterOptions> = {\n  maxDirectionChange: 45,\n\n  // an array of directions to find next points on the route\n  // different from start/end directions\n  directions() {\n    const step = resolve(this.step, this)\n    const cost = resolve(this.cost, this)\n    const diagonalCost = Math.ceil(Math.sqrt((step * step) << 1)) // eslint-disable-line no-bitwise\n\n    return [\n      { cost, offsetX: step, offsetY: 0 },\n      { cost: diagonalCost, offsetX: step, offsetY: step },\n      { cost, offsetX: 0, offsetY: step },\n      { cost: diagonalCost, offsetX: -step, offsetY: step },\n      { cost, offsetX: -step, offsetY: 0 },\n      { cost: diagonalCost, offsetX: -step, offsetY: -step },\n      { cost, offsetX: 0, offsetY: -step },\n      { cost: diagonalCost, offsetX: step, offsetY: -step },\n    ]\n  },\n\n  // a simple route used in situations when main routing method fails\n  // (exceed max number of loop iterations, inaccessible)\n  fallbackRoute(from, to, options) {\n    // Find a route which breaks by 45 degrees ignoring all obstacles.\n\n    const theta = from.theta(to)\n\n    const route = []\n\n    let a = { x: to.x, y: from.y }\n    let b = { x: from.x, y: to.y }\n\n    if (theta % 180 > 90) {\n      const t = a\n      a = b\n      b = t\n    }\n\n    const p1 = theta % 90 < 45 ? a : b\n    const l1 = new Line(from, p1)\n\n    const alpha = 90 * Math.ceil(theta / 90)\n\n    const p2 = Point.fromPolar(l1.squaredLength(), Angle.toRad(alpha + 135), p1)\n    const l2 = new Line(to, p2)\n\n    const intersectionPoint = l1.intersectsWithLine(l2)\n    const point = intersectionPoint || to\n\n    const directionFrom = intersectionPoint ? point : from\n\n    const quadrant = 360 / options.directions.length\n    const angleTheta = directionFrom.theta(to)\n    const normalizedAngle = Angle.normalize(angleTheta + quadrant / 2)\n    const directionAngle = quadrant * Math.floor(normalizedAngle / quadrant)\n\n    options.previousDirectionAngle = directionAngle\n\n    if (point) route.push(point.round())\n    route.push(to)\n\n    return route\n  },\n}\n\nexport const metro: Router.Definition<Partial<MetroRouterOptions>> = function (\n  vertices,\n  options,\n  linkView,\n) {\n  return FunctionExt.call(\n    manhattan,\n    this,\n    vertices,\n    { ...defaults, ...options },\n    linkView,\n  )\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}