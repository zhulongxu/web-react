{"ast":null,"code":"import { NumberExt } from '@antv/x6-common';\nimport { Point, Angle } from '@antv/x6-geometry';\nimport { orth } from '../orth';\nexport const defaults = {\n  step: 10,\n  maxLoopCount: 2000,\n  precision: 1,\n  maxDirectionChange: 90,\n  perpendicular: true,\n  excludeTerminals: [],\n  excludeNodes: [],\n  excludeShapes: [],\n  startDirections: ['top', 'right', 'bottom', 'left'],\n  endDirections: ['top', 'right', 'bottom', 'left'],\n  directionMap: {\n    top: {\n      x: 0,\n      y: -1\n    },\n    right: {\n      x: 1,\n      y: 0\n    },\n    bottom: {\n      x: 0,\n      y: 1\n    },\n    left: {\n      x: -1,\n      y: 0\n    }\n  },\n  cost() {\n    const step = resolve(this.step, this);\n    return step;\n  },\n  directions() {\n    const step = resolve(this.step, this);\n    const cost = resolve(this.cost, this);\n    return [{\n      cost,\n      offsetX: step,\n      offsetY: 0\n    }, {\n      cost,\n      offsetX: -step,\n      offsetY: 0\n    }, {\n      cost,\n      offsetX: 0,\n      offsetY: step\n    }, {\n      cost,\n      offsetX: 0,\n      offsetY: -step\n    }];\n  },\n  penalties() {\n    const step = resolve(this.step, this);\n    return {\n      0: 0,\n      45: step / 2,\n      90: step / 2\n    };\n  },\n  paddingBox() {\n    const step = resolve(this.step, this);\n    return {\n      x: -step,\n      y: -step,\n      width: 2 * step,\n      height: 2 * step\n    };\n  },\n  fallbackRouter: orth,\n  draggingRouter: null,\n  snapToGrid: true\n};\nexport function resolve(input, options) {\n  if (typeof input === 'function') {\n    return input.call(options);\n  }\n  return input;\n}\nexport function resolveOptions(options) {\n  const result = Object.keys(options).reduce((memo, key) => {\n    const ret = memo;\n    if (key === 'fallbackRouter' || key === 'draggingRouter' || key === 'fallbackRoute') {\n      ret[key] = options[key];\n    } else {\n      ret[key] = resolve(options[key], options);\n    }\n    return memo;\n  }, {});\n  if (result.padding) {\n    const sides = NumberExt.normalizeSides(result.padding);\n    result.paddingBox = {\n      x: -sides.left,\n      y: -sides.top,\n      width: sides.left + sides.right,\n      height: sides.top + sides.bottom\n    };\n  }\n  result.directions.forEach(direction => {\n    const point1 = new Point(0, 0);\n    const point2 = new Point(direction.offsetX, direction.offsetY);\n    direction.angle = Angle.normalize(point1.theta(point2));\n  });\n  return result;\n}","map":{"version":3,"names":["NumberExt","Point","Angle","orth","defaults","step","maxLoopCount","precision","maxDirectionChange","perpendicular","excludeTerminals","excludeNodes","excludeShapes","startDirections","endDirections","directionMap","top","x","y","right","bottom","left","cost","resolve","directions","offsetX","offsetY","penalties","paddingBox","width","height","fallbackRouter","draggingRouter","snapToGrid","input","options","call","resolveOptions","result","Object","keys","reduce","memo","key","ret","padding","sides","normalizeSides","forEach","direction","point1","point2","angle","normalize","theta"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/src/registry/router/manhattan/options.ts"],"sourcesContent":["import { NumberExt } from '@antv/x6-common'\nimport { Point, Rectangle, Angle } from '@antv/x6-geometry'\nimport { Node, Edge } from '../../../model'\nimport { EdgeView } from '../../../view'\nimport { orth } from '../orth'\nimport { Router } from '../index'\n\nexport type Direction = 'top' | 'right' | 'bottom' | 'left'\ntype Callable<T> = T | ((this: ManhattanRouterOptions) => T)\n\nexport interface ResolvedOptions {\n  /**\n   * The size of step to find a route (the grid of the manhattan pathfinder).\n   */\n  step: number\n\n  /**\n   * The number of route finding loops that cause the router to abort returns\n   * fallback route instead.\n   */\n  maxLoopCount: number\n\n  /**\n   * The number of decimal places to round floating point coordinates.\n   */\n  precision: number\n\n  /**\n   * The maximum change of direction.\n   */\n  maxDirectionChange: number\n\n  /**\n   * Should the router use perpendicular edgeView option? Does not connect\n   * to the anchor of node but rather a point close-by that is orthogonal.\n   */\n  perpendicular: boolean\n\n  /**\n   * Should the source and/or target not be considered as obstacles?\n   */\n  excludeTerminals: Edge.TerminalType[]\n\n  /**\n   * Should certain nodes not be considered as obstacles?\n   */\n  excludeNodes: (Node | string)[]\n\n  /**\n   * Should certain types of nodes not be considered as obstacles?\n   */\n  excludeShapes: string[]\n\n  /**\n   * Possible starting directions from a node.\n   */\n  startDirections: Direction[]\n\n  /**\n   * Possible ending directions to a node.\n   */\n  endDirections: Direction[]\n\n  /**\n   * Specify the directions used above and what they mean\n   */\n  directionMap: {\n    top: Point.PointLike\n    right: Point.PointLike\n    bottom: Point.PointLike\n    left: Point.PointLike\n  }\n\n  /**\n   * Returns the cost of an orthogonal step.\n   */\n  cost: number\n\n  /**\n   * Returns an array of directions to find next points on the route different\n   * from start/end directions.\n   */\n  directions: {\n    cost: number\n    offsetX: number\n    offsetY: number\n    angle?: number\n    gridOffsetX?: number\n    gridOffsetY?: number\n  }[]\n\n  /**\n   * A penalty received for direction change.\n   */\n  penalties: {\n    [key: number]: number\n  }\n\n  padding?: {\n    top: number\n    right: number\n    bottom: number\n    left: number\n  }\n\n  /**\n   * The padding applied on the element bounding boxes.\n   */\n  paddingBox: Rectangle.RectangleLike\n\n  fallbackRouter: Router.Definition<any>\n\n  draggingRouter?:\n    | ((\n        this: EdgeView,\n        dragFrom: Point.PointLike,\n        dragTo: Point.PointLike,\n        options: ResolvedOptions,\n      ) => Point[])\n    | null\n\n  fallbackRoute?: (\n    this: EdgeView,\n    from: Point,\n    to: Point,\n    options: ResolvedOptions,\n  ) => Point[] | null\n\n  previousDirectionAngle?: number | null\n\n  // Whether the calculation results are aligned with the grid\n  snapToGrid?: boolean\n}\n\nexport type ManhattanRouterOptions = {\n  [Key in keyof ResolvedOptions]: Callable<ResolvedOptions[Key]>\n}\n\nexport const defaults: ManhattanRouterOptions = {\n  step: 10,\n  maxLoopCount: 2000,\n  precision: 1,\n  maxDirectionChange: 90,\n  perpendicular: true,\n  excludeTerminals: [],\n  excludeNodes: [],\n  excludeShapes: [],\n  startDirections: ['top', 'right', 'bottom', 'left'],\n  endDirections: ['top', 'right', 'bottom', 'left'],\n  directionMap: {\n    top: { x: 0, y: -1 },\n    right: { x: 1, y: 0 },\n    bottom: { x: 0, y: 1 },\n    left: { x: -1, y: 0 },\n  },\n\n  cost() {\n    const step = resolve(this.step, this)\n    return step\n  },\n\n  directions() {\n    const step = resolve(this.step, this)\n    const cost = resolve(this.cost, this)\n\n    return [\n      { cost, offsetX: step, offsetY: 0 },\n      { cost, offsetX: -step, offsetY: 0 },\n      { cost, offsetX: 0, offsetY: step },\n      { cost, offsetX: 0, offsetY: -step },\n    ]\n  },\n\n  penalties() {\n    const step = resolve(this.step, this)\n    return {\n      0: 0,\n      45: step / 2,\n      90: step / 2,\n    }\n  },\n\n  paddingBox() {\n    const step = resolve(this.step, this)\n    return {\n      x: -step,\n      y: -step,\n      width: 2 * step,\n      height: 2 * step,\n    }\n  },\n\n  fallbackRouter: orth,\n  draggingRouter: null,\n  snapToGrid: true,\n}\n\nexport function resolve<T>(\n  input: Callable<T>,\n  options: ManhattanRouterOptions,\n) {\n  if (typeof input === 'function') {\n    return input.call(options)\n  }\n  return input\n}\n\nexport function resolveOptions(options: ManhattanRouterOptions) {\n  const result = Object.keys(options).reduce(\n    (memo, key: keyof ResolvedOptions) => {\n      const ret = memo as any\n      if (\n        key === 'fallbackRouter' ||\n        key === 'draggingRouter' ||\n        key === 'fallbackRoute'\n      ) {\n        ret[key] = options[key]\n      } else {\n        ret[key] = resolve(options[key], options)\n      }\n      return memo\n    },\n    {} as ResolvedOptions,\n  )\n\n  if (result.padding) {\n    const sides = NumberExt.normalizeSides(result.padding)\n    result.paddingBox = {\n      x: -sides.left,\n      y: -sides.top,\n      width: sides.left + sides.right,\n      height: sides.top + sides.bottom,\n    }\n  }\n\n  result.directions.forEach((direction) => {\n    const point1 = new Point(0, 0)\n    const point2 = new Point(direction.offsetX, direction.offsetY)\n    direction.angle = Angle.normalize(point1.theta(point2))\n  })\n\n  return result\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}