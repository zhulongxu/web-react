{"ast":null,"code":"export var GeometryUtil;\n(function (GeometryUtil) {\n  function round(num, precision = 0) {\n    return Number.isInteger(num) ? num : +num.toFixed(precision);\n  }\n  GeometryUtil.round = round;\n  function random(min, max) {\n    let mmin;\n    let mmax;\n    if (max == null) {\n      mmax = min == null ? 1 : min;\n      mmin = 0;\n    } else {\n      mmax = max;\n      mmin = min == null ? 0 : min;\n    }\n    if (mmax < mmin) {\n      const temp = mmin;\n      mmin = mmax;\n      mmax = temp;\n    }\n    return Math.floor(Math.random() * (mmax - mmin + 1) + mmin);\n  }\n  GeometryUtil.random = random;\n  function clamp(value, min, max) {\n    if (Number.isNaN(value)) {\n      return NaN;\n    }\n    if (Number.isNaN(min) || Number.isNaN(max)) {\n      return 0;\n    }\n    return min < max ? value < min ? min : value > max ? max : value : value < max ? max : value > min ? min : value;\n  }\n  GeometryUtil.clamp = clamp;\n  function snapToGrid(value, gridSize) {\n    return gridSize * Math.round(value / gridSize);\n  }\n  GeometryUtil.snapToGrid = snapToGrid;\n  function containsPoint(rect, point) {\n    return point != null && rect != null && point.x >= rect.x && point.x <= rect.x + rect.width && point.y >= rect.y && point.y <= rect.y + rect.height;\n  }\n  GeometryUtil.containsPoint = containsPoint;\n  function squaredLength(p1, p2) {\n    const dx = p1.x - p2.x;\n    const dy = p1.y - p2.y;\n    return dx * dx + dy * dy;\n  }\n  GeometryUtil.squaredLength = squaredLength;\n})(GeometryUtil || (GeometryUtil = {}));","map":{"version":3,"names":["GeometryUtil","round","num","precision","Number","isInteger","toFixed","random","min","max","mmin","mmax","temp","Math","floor","clamp","value","isNaN","NaN","snapToGrid","gridSize","containsPoint","rect","point","x","width","y","height","squaredLength","p1","p2","dx","dy"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6-geometry@2.0.5/node_modules/@antv/x6-geometry/src/util.ts"],"sourcesContent":["import { Point } from './point'\nimport { Rectangle } from './rectangle'\n\nexport namespace GeometryUtil {\n  export function round(num: number, precision = 0) {\n    return Number.isInteger(num) ? num : +num.toFixed(precision)\n  }\n\n  export function random(): number\n  export function random(max: number): number\n  export function random(min: number, max: number): number\n  export function random(min?: number, max?: number): number {\n    let mmin\n    let mmax\n\n    if (max == null) {\n      mmax = min == null ? 1 : min\n      mmin = 0\n    } else {\n      mmax = max\n      mmin = min == null ? 0 : min\n    }\n\n    if (mmax < mmin) {\n      const temp = mmin\n      mmin = mmax\n      mmax = temp\n    }\n\n    return Math.floor(Math.random() * (mmax - mmin + 1) + mmin)\n  }\n\n  export function clamp(value: number, min: number, max: number) {\n    if (Number.isNaN(value)) {\n      return NaN\n    }\n\n    if (Number.isNaN(min) || Number.isNaN(max)) {\n      return 0\n    }\n\n    return min < max\n      ? value < min\n        ? min\n        : value > max\n        ? max\n        : value\n      : value < max\n      ? max\n      : value > min\n      ? min\n      : value\n  }\n\n  export function snapToGrid(value: number, gridSize: number) {\n    return gridSize * Math.round(value / gridSize)\n  }\n\n  export function containsPoint(\n    rect: Rectangle.RectangleLike,\n    point: Point.PointLike,\n  ) {\n    return (\n      point != null &&\n      rect != null &&\n      point.x >= rect.x &&\n      point.x <= rect.x + rect.width &&\n      point.y >= rect.y &&\n      point.y <= rect.y + rect.height\n    )\n  }\n\n  export function squaredLength(p1: Point.PointLike, p2: Point.PointLike) {\n    const dx = p1.x - p2.x\n    const dy = p1.y - p2.y\n    return dx * dx + dy * dy\n  }\n}\n"],"mappings":"AAGA,OAAM,IAAWA,YAAY;AAA7B,WAAiBA,YAAY;EAC3B,SAAgBC,KAAKA,CAACC,GAAW,EAAEC,SAAS,GAAG,CAAC;IAC9C,OAAOC,MAAM,CAACC,SAAS,CAACH,GAAG,CAAC,GAAGA,GAAG,GAAG,CAACA,GAAG,CAACI,OAAO,CAACH,SAAS,CAAC;EAC9D;EAFgBH,YAAA,CAAAC,KAAK,GAAAA,KAEpB;EAKD,SAAgBM,MAAMA,CAACC,GAAY,EAAEC,GAAY;IAC/C,IAAIC,IAAI;IACR,IAAIC,IAAI;IAER,IAAIF,GAAG,IAAI,IAAI,EAAE;MACfE,IAAI,GAAGH,GAAG,IAAI,IAAI,GAAG,CAAC,GAAGA,GAAG;MAC5BE,IAAI,GAAG,CAAC;KACT,MAAM;MACLC,IAAI,GAAGF,GAAG;MACVC,IAAI,GAAGF,GAAG,IAAI,IAAI,GAAG,CAAC,GAAGA,GAAG;;IAG9B,IAAIG,IAAI,GAAGD,IAAI,EAAE;MACf,MAAME,IAAI,GAAGF,IAAI;MACjBA,IAAI,GAAGC,IAAI;MACXA,IAAI,GAAGC,IAAI;;IAGb,OAAOC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACN,MAAM,EAAE,IAAII,IAAI,GAAGD,IAAI,GAAG,CAAC,CAAC,GAAGA,IAAI,CAAC;EAC7D;EAnBgBV,YAAA,CAAAO,MAAM,GAAAA,MAmBrB;EAED,SAAgBQ,KAAKA,CAACC,KAAa,EAAER,GAAW,EAAEC,GAAW;IAC3D,IAAIL,MAAM,CAACa,KAAK,CAACD,KAAK,CAAC,EAAE;MACvB,OAAOE,GAAG;;IAGZ,IAAId,MAAM,CAACa,KAAK,CAACT,GAAG,CAAC,IAAIJ,MAAM,CAACa,KAAK,CAACR,GAAG,CAAC,EAAE;MAC1C,OAAO,CAAC;;IAGV,OAAOD,GAAG,GAAGC,GAAG,GACZO,KAAK,GAAGR,GAAG,GACTA,GAAG,GACHQ,KAAK,GAAGP,GAAG,GACXA,GAAG,GACHO,KAAK,GACPA,KAAK,GAAGP,GAAG,GACXA,GAAG,GACHO,KAAK,GAAGR,GAAG,GACXA,GAAG,GACHQ,KAAK;EACX;EApBgBhB,YAAA,CAAAe,KAAK,GAAAA,KAoBpB;EAED,SAAgBI,UAAUA,CAACH,KAAa,EAAEI,QAAgB;IACxD,OAAOA,QAAQ,GAAGP,IAAI,CAACZ,KAAK,CAACe,KAAK,GAAGI,QAAQ,CAAC;EAChD;EAFgBpB,YAAA,CAAAmB,UAAU,GAAAA,UAEzB;EAED,SAAgBE,aAAaA,CAC3BC,IAA6B,EAC7BC,KAAsB;IAEtB,OACEA,KAAK,IAAI,IAAI,IACbD,IAAI,IAAI,IAAI,IACZC,KAAK,CAACC,CAAC,IAAIF,IAAI,CAACE,CAAC,IACjBD,KAAK,CAACC,CAAC,IAAIF,IAAI,CAACE,CAAC,GAAGF,IAAI,CAACG,KAAK,IAC9BF,KAAK,CAACG,CAAC,IAAIJ,IAAI,CAACI,CAAC,IACjBH,KAAK,CAACG,CAAC,IAAIJ,IAAI,CAACI,CAAC,GAAGJ,IAAI,CAACK,MAAM;EAEnC;EAZgB3B,YAAA,CAAAqB,aAAa,GAAAA,aAY5B;EAED,SAAgBO,aAAaA,CAACC,EAAmB,EAAEC,EAAmB;IACpE,MAAMC,EAAE,GAAGF,EAAE,CAACL,CAAC,GAAGM,EAAE,CAACN,CAAC;IACtB,MAAMQ,EAAE,GAAGH,EAAE,CAACH,CAAC,GAAGI,EAAE,CAACJ,CAAC;IACtB,OAAOK,EAAE,GAAGA,EAAE,GAAGC,EAAE,GAAGA,EAAE;EAC1B;EAJgBhC,YAAA,CAAA4B,aAAa,GAAAA,aAI5B;AACH,CAAC,EA1EgB5B,YAAY,KAAZA,YAAY","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}