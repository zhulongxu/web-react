{"ast":null,"code":"import { Point, Line, Angle, GeometryUtil } from '@antv/x6-geometry';\nexport function getSourceBBox(view, options) {\n  const bbox = view.sourceBBox.clone();\n  if (options && options.paddingBox) {\n    return bbox.moveAndExpand(options.paddingBox);\n  }\n  return bbox;\n}\nexport function getTargetBBox(view, options) {\n  const bbox = view.targetBBox.clone();\n  if (options && options.paddingBox) {\n    return bbox.moveAndExpand(options.paddingBox);\n  }\n  return bbox;\n}\nexport function getSourceEndpoint(view, options) {\n  if (view.sourceAnchor) {\n    return view.sourceAnchor;\n  }\n  const sourceBBox = getSourceBBox(view, options);\n  return sourceBBox.getCenter();\n}\nexport function getTargetEndpoint(view, options) {\n  if (view.targetAnchor) {\n    return view.targetAnchor;\n  }\n  const targetBBox = getTargetBBox(view, options);\n  return targetBBox.getCenter();\n}\n// returns a direction index from start point to end point\n// corrects for grid deformation between start and end\nexport function getDirectionAngle(start, end, directionCount, grid, options) {\n  const quadrant = 360 / directionCount;\n  const angleTheta = start.theta(fixAngleEnd(start, end, grid, options));\n  const normalizedAngle = Angle.normalize(angleTheta + quadrant / 2);\n  return quadrant * Math.floor(normalizedAngle / quadrant);\n}\nfunction fixAngleEnd(start, end, grid, options) {\n  const step = options.step;\n  const diffX = end.x - start.x;\n  const diffY = end.y - start.y;\n  const gridStepsX = diffX / grid.x;\n  const gridStepsY = diffY / grid.y;\n  const distanceX = gridStepsX * step;\n  const distanceY = gridStepsY * step;\n  return new Point(start.x + distanceX, start.y + distanceY);\n}\n/**\n * Returns the change in direction between two direction angles.\n */\nexport function getDirectionChange(angle1, angle2) {\n  const change = Math.abs(angle1 - angle2);\n  return change > 180 ? 360 - change : change;\n}\n// fix direction offsets according to current grid\nexport function getGridOffsets(grid, options) {\n  const step = options.step;\n  options.directions.forEach(direction => {\n    direction.gridOffsetX = direction.offsetX / step * grid.x;\n    direction.gridOffsetY = direction.offsetY / step * grid.y;\n  });\n  return options.directions;\n}\n// get grid size in x and y dimensions, adapted to source and target positions\nexport function getGrid(step, source, target) {\n  return {\n    source: source.clone(),\n    x: getGridDimension(target.x - source.x, step),\n    y: getGridDimension(target.y - source.y, step)\n  };\n}\nfunction getGridDimension(diff, step) {\n  // return step if diff = 0\n  if (!diff) {\n    return step;\n  }\n  const abs = Math.abs(diff);\n  const count = Math.round(abs / step);\n  // return `abs` if less than one step apart\n  if (!count) {\n    return abs;\n  }\n  // otherwise, return corrected step\n  const roundedDiff = count * step;\n  const remainder = abs - roundedDiff;\n  const correction = remainder / count;\n  return step + correction;\n}\nfunction snapGrid(point, grid) {\n  const source = grid.source;\n  const x = GeometryUtil.snapToGrid(point.x - source.x, grid.x) + source.x;\n  const y = GeometryUtil.snapToGrid(point.y - source.y, grid.y) + source.y;\n  return new Point(x, y);\n}\nexport function round(point, precision) {\n  return point.round(precision);\n}\nexport function align(point, grid, precision) {\n  return round(snapGrid(point.clone(), grid), precision);\n}\nexport function getKey(point) {\n  return point.toString();\n}\nexport function normalizePoint(point) {\n  return new Point(point.x === 0 ? 0 : Math.abs(point.x) / point.x, point.y === 0 ? 0 : Math.abs(point.y) / point.y);\n}\nexport function getCost(from, anchors) {\n  let min = Infinity;\n  for (let i = 0, len = anchors.length; i < len; i += 1) {\n    const dist = from.manhattanDistance(anchors[i]);\n    if (dist < min) {\n      min = dist;\n    }\n  }\n  return min;\n}\n// Find points around the bbox taking given directions into account\n// lines are drawn from anchor in given directions, intersections recorded\n// if anchor is outside bbox, only those directions that intersect get a rect point\n// the anchor itself is returned as rect point (representing some directions)\n// (since those directions are unobstructed by the bbox)\nexport function getRectPoints(anchor, bbox, directionList, grid, options) {\n  const precision = options.precision;\n  const directionMap = options.directionMap;\n  const centerVector = anchor.diff(bbox.getCenter());\n  const rectPoints = Object.keys(directionMap).reduce((res, key) => {\n    if (directionList.includes(key)) {\n      const direction = directionMap[key];\n      // Create a line that is guaranteed to intersect the bbox if bbox\n      // is in the direction even if anchor lies outside of bbox.\n      const ending = new Point(anchor.x + direction.x * (Math.abs(centerVector.x) + bbox.width), anchor.y + direction.y * (Math.abs(centerVector.y) + bbox.height));\n      const intersectionLine = new Line(anchor, ending);\n      // Get the farther intersection, in case there are two\n      // (that happens if anchor lies next to bbox)\n      const intersections = intersectionLine.intersect(bbox) || [];\n      let farthestIntersectionDistance;\n      let farthestIntersection = null;\n      for (let i = 0; i < intersections.length; i += 1) {\n        const intersection = intersections[i];\n        const distance = anchor.squaredDistance(intersection);\n        if (farthestIntersectionDistance == null || distance > farthestIntersectionDistance) {\n          farthestIntersectionDistance = distance;\n          farthestIntersection = intersection;\n        }\n      }\n      // If an intersection was found in this direction, it is our rectPoint\n      if (farthestIntersection) {\n        let target = align(farthestIntersection, grid, precision);\n        // If the rectPoint lies inside the bbox, offset it by one more step\n        if (bbox.containsPoint(target)) {\n          target = align(target.translate(direction.x * grid.x, direction.y * grid.y), grid, precision);\n        }\n        res.push(target);\n      }\n    }\n    return res;\n  }, []);\n  // if anchor lies outside of bbox, add it to the array of points\n  if (!bbox.containsPoint(anchor)) {\n    rectPoints.push(align(anchor, grid, precision));\n  }\n  return rectPoints;\n}\n// reconstructs a route by concatenating points with their parents\nexport function reconstructRoute(parents, points, tailPoint, from, to) {\n  const route = [];\n  let prevDiff = normalizePoint(to.diff(tailPoint));\n  // tailPoint is assumed to be aligned already\n  let currentKey = getKey(tailPoint);\n  let parent = parents[currentKey];\n  let point;\n  while (parent) {\n    // point is assumed to be aligned already\n    point = points[currentKey];\n    const diff = normalizePoint(point.diff(parent));\n    if (!diff.equals(prevDiff)) {\n      route.unshift(point);\n      prevDiff = diff;\n    }\n    // parent is assumed to be aligned already\n    currentKey = getKey(parent);\n    parent = parents[currentKey];\n  }\n  // leadPoint is assumed to be aligned already\n  const leadPoint = points[currentKey];\n  const fromDiff = normalizePoint(leadPoint.diff(from));\n  if (!fromDiff.equals(prevDiff)) {\n    route.unshift(leadPoint);\n  }\n  return route;\n}","map":{"version":3,"names":["Point","Line","Angle","GeometryUtil","getSourceBBox","view","options","bbox","sourceBBox","clone","paddingBox","moveAndExpand","getTargetBBox","targetBBox","getSourceEndpoint","sourceAnchor","getCenter","getTargetEndpoint","targetAnchor","getDirectionAngle","start","end","directionCount","grid","quadrant","angleTheta","theta","fixAngleEnd","normalizedAngle","normalize","Math","floor","step","diffX","x","diffY","y","gridStepsX","gridStepsY","distanceX","distanceY","getDirectionChange","angle1","angle2","change","abs","getGridOffsets","directions","forEach","direction","gridOffsetX","offsetX","gridOffsetY","offsetY","getGrid","source","target","getGridDimension","diff","count","round","roundedDiff","remainder","correction","snapGrid","point","snapToGrid","precision","align","getKey","toString","normalizePoint","getCost","from","anchors","min","Infinity","i","len","length","dist","manhattanDistance","getRectPoints","anchor","directionList","directionMap","centerVector","rectPoints","Object","keys","reduce","res","key","includes","ending","width","height","intersectionLine","intersections","intersect","farthestIntersectionDistance","farthestIntersection","intersection","distance","squaredDistance","containsPoint","translate","push","reconstructRoute","parents","points","tailPoint","to","route","prevDiff","currentKey","parent","equals","unshift","leadPoint","fromDiff"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/src/registry/router/manhattan/util.ts"],"sourcesContent":["import { Point, Line, Angle, Rectangle, GeometryUtil } from '@antv/x6-geometry'\nimport { KeyValue } from '@antv/x6-common'\nimport { EdgeView } from '../../../view/edge'\nimport { ResolvedOptions, Direction } from './options'\n\nexport function getSourceBBox(view: EdgeView, options: ResolvedOptions) {\n  const bbox = view.sourceBBox.clone()\n  if (options && options.paddingBox) {\n    return bbox.moveAndExpand(options.paddingBox)\n  }\n\n  return bbox\n}\n\nexport function getTargetBBox(view: EdgeView, options: ResolvedOptions) {\n  const bbox = view.targetBBox.clone()\n  if (options && options.paddingBox) {\n    return bbox.moveAndExpand(options.paddingBox)\n  }\n\n  return bbox\n}\n\nexport function getSourceEndpoint(view: EdgeView, options: ResolvedOptions) {\n  if (view.sourceAnchor) {\n    return view.sourceAnchor\n  }\n\n  const sourceBBox = getSourceBBox(view, options)\n  return sourceBBox.getCenter()\n}\n\nexport function getTargetEndpoint(view: EdgeView, options: ResolvedOptions) {\n  if (view.targetAnchor) {\n    return view.targetAnchor\n  }\n\n  const targetBBox = getTargetBBox(view, options)\n  return targetBBox.getCenter()\n}\n\n// returns a direction index from start point to end point\n// corrects for grid deformation between start and end\nexport function getDirectionAngle(\n  start: Point,\n  end: Point,\n  directionCount: number,\n  grid: Grid,\n  options: ResolvedOptions,\n) {\n  const quadrant = 360 / directionCount\n  const angleTheta = start.theta(fixAngleEnd(start, end, grid, options))\n  const normalizedAngle = Angle.normalize(angleTheta + quadrant / 2)\n  return quadrant * Math.floor(normalizedAngle / quadrant)\n}\n\nfunction fixAngleEnd(\n  start: Point,\n  end: Point,\n  grid: Grid,\n  options: ResolvedOptions,\n) {\n  const step = options.step\n\n  const diffX = end.x - start.x\n  const diffY = end.y - start.y\n\n  const gridStepsX = diffX / grid.x\n  const gridStepsY = diffY / grid.y\n\n  const distanceX = gridStepsX * step\n  const distanceY = gridStepsY * step\n\n  return new Point(start.x + distanceX, start.y + distanceY)\n}\n\n/**\n * Returns the change in direction between two direction angles.\n */\nexport function getDirectionChange(angle1: number, angle2: number) {\n  const change = Math.abs(angle1 - angle2)\n  return change > 180 ? 360 - change : change\n}\n\n// fix direction offsets according to current grid\nexport function getGridOffsets(grid: Grid, options: ResolvedOptions) {\n  const step = options.step\n\n  options.directions.forEach((direction) => {\n    direction.gridOffsetX = (direction.offsetX / step) * grid.x\n    direction.gridOffsetY = (direction.offsetY / step) * grid.y\n  })\n\n  return options.directions\n}\n\nexport interface Grid {\n  source: Point\n  x: number\n  y: number\n}\n\n// get grid size in x and y dimensions, adapted to source and target positions\nexport function getGrid(step: number, source: Point, target: Point): Grid {\n  return {\n    source: source.clone(),\n    x: getGridDimension(target.x - source.x, step),\n    y: getGridDimension(target.y - source.y, step),\n  }\n}\n\nfunction getGridDimension(diff: number, step: number) {\n  // return step if diff = 0\n  if (!diff) {\n    return step\n  }\n\n  const abs = Math.abs(diff)\n  const count = Math.round(abs / step)\n\n  // return `abs` if less than one step apart\n  if (!count) {\n    return abs\n  }\n\n  // otherwise, return corrected step\n  const roundedDiff = count * step\n  const remainder = abs - roundedDiff\n  const correction = remainder / count\n\n  return step + correction\n}\n\nfunction snapGrid(point: Point, grid: Grid) {\n  const source = grid.source\n  const x = GeometryUtil.snapToGrid(point.x - source.x, grid.x) + source.x\n  const y = GeometryUtil.snapToGrid(point.y - source.y, grid.y) + source.y\n\n  return new Point(x, y)\n}\n\nexport function round(point: Point, precision: number) {\n  return point.round(precision)\n}\n\nexport function align(point: Point, grid: Grid, precision: number) {\n  return round(snapGrid(point.clone(), grid), precision)\n}\n\nexport function getKey(point: Point) {\n  return point.toString()\n}\n\nexport function normalizePoint(point: Point.PointLike) {\n  return new Point(\n    point.x === 0 ? 0 : Math.abs(point.x) / point.x,\n    point.y === 0 ? 0 : Math.abs(point.y) / point.y,\n  )\n}\n\nexport function getCost(from: Point, anchors: Point[]) {\n  let min = Infinity\n\n  for (let i = 0, len = anchors.length; i < len; i += 1) {\n    const dist = from.manhattanDistance(anchors[i])\n    if (dist < min) {\n      min = dist\n    }\n  }\n\n  return min\n}\n\n// Find points around the bbox taking given directions into account\n// lines are drawn from anchor in given directions, intersections recorded\n// if anchor is outside bbox, only those directions that intersect get a rect point\n// the anchor itself is returned as rect point (representing some directions)\n// (since those directions are unobstructed by the bbox)\nexport function getRectPoints(\n  anchor: Point,\n  bbox: Rectangle,\n  directionList: Direction[],\n  grid: Grid,\n  options: ResolvedOptions,\n) {\n  const precision = options.precision\n  const directionMap = options.directionMap\n  const centerVector = anchor.diff(bbox.getCenter())\n\n  const rectPoints = Object.keys(directionMap).reduce<Point[]>(\n    (res, key: Direction) => {\n      if (directionList.includes(key)) {\n        const direction = directionMap[key]\n\n        // Create a line that is guaranteed to intersect the bbox if bbox\n        // is in the direction even if anchor lies outside of bbox.\n        const ending = new Point(\n          anchor.x + direction.x * (Math.abs(centerVector.x) + bbox.width),\n          anchor.y + direction.y * (Math.abs(centerVector.y) + bbox.height),\n        )\n        const intersectionLine = new Line(anchor, ending)\n\n        // Get the farther intersection, in case there are two\n        // (that happens if anchor lies next to bbox)\n        const intersections = intersectionLine.intersect(bbox) || []\n        let farthestIntersectionDistance\n        let farthestIntersection = null\n        for (let i = 0; i < intersections.length; i += 1) {\n          const intersection = intersections[i]\n          const distance = anchor.squaredDistance(intersection)\n          if (\n            farthestIntersectionDistance == null ||\n            distance > farthestIntersectionDistance\n          ) {\n            farthestIntersectionDistance = distance\n            farthestIntersection = intersection\n          }\n        }\n\n        // If an intersection was found in this direction, it is our rectPoint\n        if (farthestIntersection) {\n          let target = align(farthestIntersection, grid, precision)\n          // If the rectPoint lies inside the bbox, offset it by one more step\n          if (bbox.containsPoint(target)) {\n            target = align(\n              target.translate(direction.x * grid.x, direction.y * grid.y),\n              grid,\n              precision,\n            )\n          }\n\n          res.push(target)\n        }\n      }\n\n      return res\n    },\n    [],\n  )\n\n  // if anchor lies outside of bbox, add it to the array of points\n  if (!bbox.containsPoint(anchor)) {\n    rectPoints.push(align(anchor, grid, precision))\n  }\n\n  return rectPoints\n}\n\n// reconstructs a route by concatenating points with their parents\nexport function reconstructRoute(\n  parents: KeyValue<Point>,\n  points: KeyValue<Point>,\n  tailPoint: Point,\n  from: Point,\n  to: Point,\n) {\n  const route = []\n\n  let prevDiff = normalizePoint(to.diff(tailPoint))\n\n  // tailPoint is assumed to be aligned already\n  let currentKey = getKey(tailPoint)\n  let parent = parents[currentKey]\n\n  let point\n  while (parent) {\n    // point is assumed to be aligned already\n    point = points[currentKey]\n\n    const diff = normalizePoint(point.diff(parent))\n    if (!diff.equals(prevDiff)) {\n      route.unshift(point)\n      prevDiff = diff\n    }\n\n    // parent is assumed to be aligned already\n    currentKey = getKey(parent)\n    parent = parents[currentKey]\n  }\n\n  // leadPoint is assumed to be aligned already\n  const leadPoint = points[currentKey]\n\n  const fromDiff = normalizePoint(leadPoint.diff(from))\n  if (!fromDiff.equals(prevDiff)) {\n    route.unshift(leadPoint)\n  }\n\n  return route\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}