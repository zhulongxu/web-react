{"ast":null,"code":"var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { GeometryUtil, Rectangle, FunctionExt, Dom, CssLoader, View, Graph } from '@antv/x6';\nimport { content } from './style/raw';\nexport class Dnd extends View {\n  get targetScroller() {\n    const target = this.options.target;\n    const scroller = target.getPlugin('scroller');\n    return scroller;\n  }\n  get targetGraph() {\n    return this.options.target;\n  }\n  get targetModel() {\n    return this.targetGraph.model;\n  }\n  get snapline() {\n    const target = this.options.target;\n    const snapline = target.getPlugin('snapline');\n    return snapline;\n  }\n  constructor(options) {\n    super();\n    this.name = 'dnd';\n    this.options = Object.assign(Object.assign({}, Dnd.defaults), options);\n    this.init();\n  }\n  init() {\n    CssLoader.ensure(this.name, content);\n    this.container = document.createElement('div');\n    Dom.addClass(this.container, this.prefixClassName('widget-dnd'));\n    this.draggingGraph = new Graph(Object.assign(Object.assign({}, this.options.delegateGraphOptions), {\n      container: document.createElement('div'),\n      width: 1,\n      height: 1,\n      async: false\n    }));\n    Dom.append(this.container, this.draggingGraph.container);\n  }\n  start(node, evt) {\n    const e = evt;\n    e.preventDefault();\n    this.targetModel.startBatch('dnd');\n    Dom.addClass(this.container, 'dragging');\n    Dom.appendTo(this.container, this.options.draggingContainer || document.body);\n    this.sourceNode = node;\n    this.prepareDragging(node, e.clientX, e.clientY);\n    const local = this.updateNodePosition(e.clientX, e.clientY);\n    if (this.isSnaplineEnabled()) {\n      this.snapline.captureCursorOffset({\n        e,\n        node,\n        cell: node,\n        view: this.draggingView,\n        x: local.x,\n        y: local.y\n      });\n      this.draggingNode.on('change:position', this.snap, this);\n    }\n    this.delegateDocumentEvents(Dnd.documentEvents, e.data);\n  }\n  isSnaplineEnabled() {\n    return this.snapline && this.snapline.isEnabled();\n  }\n  prepareDragging(sourceNode, clientX, clientY) {\n    const draggingGraph = this.draggingGraph;\n    const draggingModel = draggingGraph.model;\n    const draggingNode = this.options.getDragNode(sourceNode, {\n      sourceNode,\n      draggingGraph,\n      targetGraph: this.targetGraph\n    });\n    draggingNode.position(0, 0);\n    let padding = 5;\n    if (this.isSnaplineEnabled()) {\n      padding += this.snapline.options.tolerance || 0;\n    }\n    if (this.isSnaplineEnabled() || this.options.scaled) {\n      const scale = this.targetGraph.transform.getScale();\n      draggingGraph.scale(scale.sx, scale.sy);\n      padding *= Math.max(scale.sx, scale.sy);\n    } else {\n      draggingGraph.scale(1, 1);\n    }\n    this.clearDragging();\n    // if (this.options.animation) {\n    //   this.$container.stop(true, true)\n    // }\n    draggingModel.resetCells([draggingNode]);\n    const delegateView = draggingGraph.findViewByCell(draggingNode);\n    delegateView.undelegateEvents();\n    delegateView.cell.off('changed');\n    draggingGraph.fitToContent({\n      padding,\n      allowNewOrigin: 'any',\n      useCellGeometry: false\n    });\n    const bbox = delegateView.getBBox();\n    this.geometryBBox = delegateView.getBBox({\n      useCellGeometry: true\n    });\n    this.delta = this.geometryBBox.getTopLeft().diff(bbox.getTopLeft());\n    this.draggingNode = draggingNode;\n    this.draggingView = delegateView;\n    this.draggingBBox = draggingNode.getBBox();\n    this.padding = padding;\n    this.originOffset = this.updateGraphPosition(clientX, clientY);\n  }\n  updateGraphPosition(clientX, clientY) {\n    const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n    const scrollLeft = document.body.scrollLeft || document.documentElement.scrollLeft;\n    const delta = this.delta;\n    const nodeBBox = this.geometryBBox;\n    const padding = this.padding || 5;\n    const offset = {\n      left: clientX - delta.x - nodeBBox.width / 2 - padding + scrollLeft,\n      top: clientY - delta.y - nodeBBox.height / 2 - padding + scrollTop\n    };\n    if (this.draggingGraph) {\n      Dom.css(this.container, {\n        left: `${offset.left}px`,\n        top: `${offset.top}px`\n      });\n    }\n    return offset;\n  }\n  updateNodePosition(x, y) {\n    const local = this.targetGraph.clientToLocal(x, y);\n    const bbox = this.draggingBBox;\n    local.x -= bbox.width / 2;\n    local.y -= bbox.height / 2;\n    this.draggingNode.position(local.x, local.y);\n    return local;\n  }\n  snap({\n    cell,\n    current,\n    options\n  }) {\n    const node = cell;\n    if (options.snapped) {\n      const bbox = this.draggingBBox;\n      node.position(bbox.x + options.tx, bbox.y + options.ty, {\n        silent: true\n      });\n      this.draggingView.translate();\n      node.position(current.x, current.y, {\n        silent: true\n      });\n      this.snapOffset = {\n        x: options.tx,\n        y: options.ty\n      };\n    } else {\n      this.snapOffset = null;\n    }\n  }\n  onDragging(evt) {\n    const draggingView = this.draggingView;\n    if (draggingView) {\n      evt.preventDefault();\n      const e = this.normalizeEvent(evt);\n      const clientX = e.clientX;\n      const clientY = e.clientY;\n      this.updateGraphPosition(clientX, clientY);\n      const local = this.updateNodePosition(clientX, clientY);\n      const embeddingMode = this.targetGraph.options.embedding.enabled;\n      const isValidArea = (embeddingMode || this.isSnaplineEnabled()) && this.isInsideValidArea({\n        x: clientX,\n        y: clientY\n      });\n      if (embeddingMode) {\n        draggingView.setEventData(e, {\n          graph: this.targetGraph,\n          candidateEmbedView: this.candidateEmbedView\n        });\n        const data = draggingView.getEventData(e);\n        if (isValidArea) {\n          draggingView.processEmbedding(e, data);\n        } else {\n          draggingView.clearEmbedding(data);\n        }\n        this.candidateEmbedView = data.candidateEmbedView;\n      }\n      // update snapline\n      if (this.isSnaplineEnabled()) {\n        if (isValidArea) {\n          this.snapline.snapOnMoving({\n            e,\n            view: draggingView,\n            x: local.x,\n            y: local.y\n          });\n        } else {\n          this.snapline.hide();\n        }\n      }\n    }\n  }\n  onDragEnd(evt) {\n    const draggingNode = this.draggingNode;\n    if (draggingNode) {\n      const e = this.normalizeEvent(evt);\n      const draggingView = this.draggingView;\n      const draggingBBox = this.draggingBBox;\n      const snapOffset = this.snapOffset;\n      let x = draggingBBox.x;\n      let y = draggingBBox.y;\n      if (snapOffset) {\n        x += snapOffset.x;\n        y += snapOffset.y;\n      }\n      draggingNode.position(x, y, {\n        silent: true\n      });\n      const ret = this.drop(draggingNode, {\n        x: e.clientX,\n        y: e.clientY\n      });\n      const callback = node => {\n        if (node) {\n          this.onDropped(draggingNode);\n          if (this.targetGraph.options.embedding.enabled && draggingView) {\n            draggingView.setEventData(e, {\n              cell: node,\n              graph: this.targetGraph,\n              candidateEmbedView: this.candidateEmbedView\n            });\n            draggingView.finalizeEmbedding(e, draggingView.getEventData(e));\n          }\n        } else {\n          this.onDropInvalid();\n        }\n        this.candidateEmbedView = null;\n        this.targetModel.stopBatch('dnd');\n      };\n      if (FunctionExt.isAsync(ret)) {\n        // stop dragging\n        this.undelegateDocumentEvents();\n        ret.then(callback); // eslint-disable-line\n      } else {\n        callback(ret);\n      }\n    }\n  }\n  clearDragging() {\n    if (this.draggingNode) {\n      this.sourceNode = null;\n      this.draggingNode.remove();\n      this.draggingNode = null;\n      this.draggingView = null;\n      this.delta = null;\n      this.padding = null;\n      this.snapOffset = null;\n      this.originOffset = null;\n      this.undelegateDocumentEvents();\n    }\n  }\n  onDropped(draggingNode) {\n    if (this.draggingNode === draggingNode) {\n      this.clearDragging();\n      Dom.removeClass(this.container, 'dragging');\n      Dom.remove(this.container);\n    }\n  }\n  onDropInvalid() {\n    const draggingNode = this.draggingNode;\n    if (draggingNode) {\n      this.onDropped(draggingNode);\n      // todo\n      // const anim = this.options.animation\n      // if (anim) {\n      //   const duration = (typeof anim === 'object' && anim.duration) || 150\n      //   const easing = (typeof anim === 'object' && anim.easing) || 'swing'\n      //   this.draggingView = null\n      //   this.$container.animate(this.originOffset!, duration, easing, () =>\n      //     this.onDropped(draggingNode),\n      //   )\n      // } else {\n      //   this.onDropped(draggingNode)\n      // }\n    }\n  }\n  isInsideValidArea(p) {\n    let targetRect;\n    let dndRect = null;\n    const targetGraph = this.targetGraph;\n    const targetScroller = this.targetScroller;\n    if (this.options.dndContainer) {\n      dndRect = this.getDropArea(this.options.dndContainer);\n    }\n    const isInsideDndRect = dndRect && dndRect.containsPoint(p);\n    if (targetScroller) {\n      if (targetScroller.options.autoResize) {\n        targetRect = this.getDropArea(targetScroller.container);\n      } else {\n        const outter = this.getDropArea(targetScroller.container);\n        targetRect = this.getDropArea(targetGraph.container).intersectsWithRect(outter);\n      }\n    } else {\n      targetRect = this.getDropArea(targetGraph.container);\n    }\n    return !isInsideDndRect && targetRect && targetRect.containsPoint(p);\n  }\n  getDropArea(elem) {\n    const offset = Dom.offset(elem);\n    const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n    const scrollLeft = document.body.scrollLeft || document.documentElement.scrollLeft;\n    return Rectangle.create({\n      x: offset.left + parseInt(Dom.css(elem, 'border-left-width'), 10) - scrollLeft,\n      y: offset.top + parseInt(Dom.css(elem, 'border-top-width'), 10) - scrollTop,\n      width: elem.clientWidth,\n      height: elem.clientHeight\n    });\n  }\n  drop(draggingNode, pos) {\n    if (this.isInsideValidArea(pos)) {\n      const targetGraph = this.targetGraph;\n      const targetModel = targetGraph.model;\n      const local = targetGraph.clientToLocal(pos);\n      const sourceNode = this.sourceNode;\n      const droppingNode = this.options.getDropNode(draggingNode, {\n        sourceNode,\n        draggingNode,\n        targetGraph: this.targetGraph,\n        draggingGraph: this.draggingGraph\n      });\n      const bbox = droppingNode.getBBox();\n      local.x += bbox.x - bbox.width / 2;\n      local.y += bbox.y - bbox.height / 2;\n      const gridSize = this.snapOffset ? 1 : targetGraph.getGridSize();\n      droppingNode.position(GeometryUtil.snapToGrid(local.x, gridSize), GeometryUtil.snapToGrid(local.y, gridSize));\n      droppingNode.removeZIndex();\n      const validateNode = this.options.validateNode;\n      const ret = validateNode ? validateNode(droppingNode, {\n        sourceNode,\n        draggingNode,\n        droppingNode,\n        targetGraph,\n        draggingGraph: this.draggingGraph\n      }) : true;\n      if (typeof ret === 'boolean') {\n        if (ret) {\n          targetModel.addCell(droppingNode, {\n            stencil: this.cid\n          });\n          return droppingNode;\n        }\n        return null;\n      }\n      return FunctionExt.toDeferredBoolean(ret).then(valid => {\n        if (valid) {\n          targetModel.addCell(droppingNode, {\n            stencil: this.cid\n          });\n          return droppingNode;\n        }\n        return null;\n      });\n    }\n    return null;\n  }\n  onRemove() {\n    if (this.draggingGraph) {\n      this.draggingGraph.view.remove();\n      this.draggingGraph.dispose();\n    }\n  }\n  dispose() {\n    this.remove();\n    CssLoader.clean(this.name);\n  }\n}\n__decorate([View.dispose()], Dnd.prototype, \"dispose\", null);\n(function (Dnd) {\n  Dnd.defaults = {\n    // animation: false,\n    getDragNode: sourceNode => sourceNode.clone(),\n    getDropNode: draggingNode => draggingNode.clone()\n  };\n  Dnd.documentEvents = {\n    mousemove: 'onDragging',\n    touchmove: 'onDragging',\n    mouseup: 'onDragEnd',\n    touchend: 'onDragEnd',\n    touchcancel: 'onDragEnd'\n  };\n})(Dnd || (Dnd = {}));","map":{"version":3,"names":["GeometryUtil","Rectangle","FunctionExt","Dom","CssLoader","View","Graph","content","Dnd","targetScroller","target","options","scroller","getPlugin","targetGraph","targetModel","model","snapline","constructor","name","Object","assign","defaults","init","ensure","container","document","createElement","addClass","prefixClassName","draggingGraph","delegateGraphOptions","width","height","async","append","start","node","evt","e","preventDefault","startBatch","appendTo","draggingContainer","body","sourceNode","prepareDragging","clientX","clientY","local","updateNodePosition","isSnaplineEnabled","captureCursorOffset","cell","view","draggingView","x","y","draggingNode","on","snap","delegateDocumentEvents","documentEvents","data","isEnabled","draggingModel","getDragNode","position","padding","tolerance","scaled","scale","transform","getScale","sx","sy","Math","max","clearDragging","resetCells","delegateView","findViewByCell","undelegateEvents","off","fitToContent","allowNewOrigin","useCellGeometry","bbox","getBBox","geometryBBox","delta","getTopLeft","diff","draggingBBox","originOffset","updateGraphPosition","scrollTop","documentElement","scrollLeft","nodeBBox","offset","left","top","css","clientToLocal","current","snapped","tx","ty","silent","translate","snapOffset","onDragging","normalizeEvent","embeddingMode","embedding","enabled","isValidArea","isInsideValidArea","setEventData","graph","candidateEmbedView","getEventData","processEmbedding","clearEmbedding","snapOnMoving","hide","onDragEnd","ret","drop","callback","onDropped","finalizeEmbedding","onDropInvalid","stopBatch","isAsync","undelegateDocumentEvents","then","remove","removeClass","p","targetRect","dndRect","dndContainer","getDropArea","isInsideDndRect","containsPoint","autoResize","outter","intersectsWithRect","elem","create","parseInt","clientWidth","clientHeight","pos","droppingNode","getDropNode","gridSize","getGridSize","snapToGrid","removeZIndex","validateNode","addCell","stencil","cid","toDeferredBoolean","valid","onRemove","dispose","clean","__decorate","clone","mousemove","touchmove","mouseup","touchend","touchcancel"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6-plugin-dnd@2.1.1_@antv+x6@2.18.1/node_modules/@antv/x6-plugin-dnd/src/index.ts"],"sourcesContent":["import {\n  GeometryUtil,\n  Rectangle,\n  Point,\n  FunctionExt,\n  Dom,\n  CssLoader,\n  Cell,\n  Node,\n  View,\n  NodeView,\n  Graph,\n  EventArgs,\n} from '@antv/x6'\nimport { content } from './style/raw'\n\nexport class Dnd extends View implements Graph.Plugin {\n  public name = 'dnd'\n\n  protected sourceNode: Node | null\n  protected draggingNode: Node | null\n  protected draggingView: NodeView | null\n  protected draggingBBox: Rectangle\n  protected geometryBBox: Rectangle\n  protected candidateEmbedView: NodeView | null\n  protected delta: Point | null\n  protected padding: number | null\n  protected snapOffset: Point.PointLike | null\n  protected originOffset: null | { left: number; top: number }\n\n  public options: Dnd.Options\n  public draggingGraph: Graph\n\n  protected get targetScroller() {\n    const target = this.options.target\n    const scroller = target.getPlugin<any>('scroller')\n    return scroller\n  }\n\n  protected get targetGraph() {\n    return this.options.target\n  }\n\n  protected get targetModel() {\n    return this.targetGraph.model\n  }\n\n  protected get snapline() {\n    const target = this.options.target\n    const snapline = target.getPlugin<any>('snapline')\n    return snapline\n  }\n\n  constructor(options: Partial<Dnd.Options> & { target: Graph }) {\n    super()\n    this.options = {\n      ...Dnd.defaults,\n      ...options,\n    } as Dnd.Options\n    this.init()\n  }\n\n  init() {\n    CssLoader.ensure(this.name, content)\n\n    this.container = document.createElement('div')\n    Dom.addClass(this.container, this.prefixClassName('widget-dnd'))\n\n    this.draggingGraph = new Graph({\n      ...this.options.delegateGraphOptions,\n      container: document.createElement('div'),\n      width: 1,\n      height: 1,\n      async: false,\n    })\n\n    Dom.append(this.container, this.draggingGraph.container)\n  }\n\n  start(node: Node, evt: Dom.MouseDownEvent | MouseEvent) {\n    const e = evt as Dom.MouseDownEvent\n\n    e.preventDefault()\n\n    this.targetModel.startBatch('dnd')\n    Dom.addClass(this.container, 'dragging')\n    Dom.appendTo(\n      this.container,\n      this.options.draggingContainer || document.body,\n    )\n\n    this.sourceNode = node\n    this.prepareDragging(node, e.clientX, e.clientY)\n\n    const local = this.updateNodePosition(e.clientX, e.clientY)\n\n    if (this.isSnaplineEnabled()) {\n      this.snapline.captureCursorOffset({\n        e,\n        node,\n        cell: node,\n        view: this.draggingView!,\n        x: local.x,\n        y: local.y,\n      })\n      this.draggingNode!.on('change:position', this.snap, this)\n    }\n\n    this.delegateDocumentEvents(Dnd.documentEvents, e.data)\n  }\n\n  protected isSnaplineEnabled() {\n    return this.snapline && this.snapline.isEnabled()\n  }\n\n  protected prepareDragging(\n    sourceNode: Node,\n    clientX: number,\n    clientY: number,\n  ) {\n    const draggingGraph = this.draggingGraph\n    const draggingModel = draggingGraph.model\n    const draggingNode = this.options.getDragNode(sourceNode, {\n      sourceNode,\n      draggingGraph,\n      targetGraph: this.targetGraph,\n    })\n\n    draggingNode.position(0, 0)\n\n    let padding = 5\n    if (this.isSnaplineEnabled()) {\n      padding += this.snapline.options.tolerance || 0\n    }\n\n    if (this.isSnaplineEnabled() || this.options.scaled) {\n      const scale = this.targetGraph.transform.getScale()\n      draggingGraph.scale(scale.sx, scale.sy)\n      padding *= Math.max(scale.sx, scale.sy)\n    } else {\n      draggingGraph.scale(1, 1)\n    }\n\n    this.clearDragging()\n\n    // if (this.options.animation) {\n    //   this.$container.stop(true, true)\n    // }\n\n    draggingModel.resetCells([draggingNode])\n\n    const delegateView = draggingGraph.findViewByCell(draggingNode) as NodeView\n    delegateView.undelegateEvents()\n    delegateView.cell.off('changed')\n    draggingGraph.fitToContent({\n      padding,\n      allowNewOrigin: 'any',\n      useCellGeometry: false,\n    })\n\n    const bbox = delegateView.getBBox()\n    this.geometryBBox = delegateView.getBBox({ useCellGeometry: true })\n    this.delta = this.geometryBBox.getTopLeft().diff(bbox.getTopLeft())\n    this.draggingNode = draggingNode\n    this.draggingView = delegateView\n    this.draggingBBox = draggingNode.getBBox()\n    this.padding = padding\n    this.originOffset = this.updateGraphPosition(clientX, clientY)\n  }\n\n  protected updateGraphPosition(clientX: number, clientY: number) {\n    const scrollTop =\n      document.body.scrollTop || document.documentElement.scrollTop\n    const scrollLeft =\n      document.body.scrollLeft || document.documentElement.scrollLeft\n    const delta = this.delta!\n    const nodeBBox = this.geometryBBox\n    const padding = this.padding || 5\n    const offset = {\n      left: clientX - delta.x - nodeBBox.width / 2 - padding + scrollLeft,\n      top: clientY - delta.y - nodeBBox.height / 2 - padding + scrollTop,\n    }\n\n    if (this.draggingGraph) {\n      Dom.css(this.container, {\n        left: `${offset.left}px`,\n        top: `${offset.top}px`,\n      })\n    }\n\n    return offset\n  }\n\n  protected updateNodePosition(x: number, y: number) {\n    const local = this.targetGraph.clientToLocal(x, y)\n    const bbox = this.draggingBBox!\n    local.x -= bbox.width / 2\n    local.y -= bbox.height / 2\n    this.draggingNode!.position(local.x, local.y)\n    return local\n  }\n\n  protected snap({\n    cell,\n    current,\n    options,\n  }: Cell.EventArgs['change:position']) {\n    const node = cell as Node\n    if (options.snapped) {\n      const bbox = this.draggingBBox\n      node.position(bbox.x + options.tx, bbox.y + options.ty, { silent: true })\n      this.draggingView!.translate()\n      node.position(current!.x, current!.y, { silent: true })\n\n      this.snapOffset = {\n        x: options.tx,\n        y: options.ty,\n      }\n    } else {\n      this.snapOffset = null\n    }\n  }\n\n  protected onDragging(evt: Dom.MouseMoveEvent) {\n    const draggingView = this.draggingView\n    if (draggingView) {\n      evt.preventDefault()\n      const e = this.normalizeEvent(evt)\n      const clientX = e.clientX\n      const clientY = e.clientY\n\n      this.updateGraphPosition(clientX, clientY)\n      const local = this.updateNodePosition(clientX, clientY)\n      const embeddingMode = this.targetGraph.options.embedding.enabled\n      const isValidArea =\n        (embeddingMode || this.isSnaplineEnabled()) &&\n        this.isInsideValidArea({\n          x: clientX,\n          y: clientY,\n        })\n\n      if (embeddingMode) {\n        draggingView.setEventData(e, {\n          graph: this.targetGraph,\n          candidateEmbedView: this.candidateEmbedView,\n        })\n        const data = draggingView.getEventData<any>(e)\n        if (isValidArea) {\n          draggingView.processEmbedding(e, data)\n        } else {\n          draggingView.clearEmbedding(data)\n        }\n        this.candidateEmbedView = data.candidateEmbedView\n      }\n\n      // update snapline\n      if (this.isSnaplineEnabled()) {\n        if (isValidArea) {\n          this.snapline.snapOnMoving({\n            e,\n            view: draggingView!,\n            x: local.x,\n            y: local.y,\n          } as EventArgs['node:mousemove'])\n        } else {\n          this.snapline.hide()\n        }\n      }\n    }\n  }\n\n  protected onDragEnd(evt: Dom.MouseUpEvent) {\n    const draggingNode = this.draggingNode\n    if (draggingNode) {\n      const e = this.normalizeEvent(evt)\n      const draggingView = this.draggingView\n      const draggingBBox = this.draggingBBox\n      const snapOffset = this.snapOffset\n      let x = draggingBBox.x\n      let y = draggingBBox.y\n\n      if (snapOffset) {\n        x += snapOffset.x\n        y += snapOffset.y\n      }\n\n      draggingNode.position(x, y, { silent: true })\n\n      const ret = this.drop(draggingNode, { x: e.clientX, y: e.clientY })\n      const callback = (node: null | Node) => {\n        if (node) {\n          this.onDropped(draggingNode)\n          if (this.targetGraph.options.embedding.enabled && draggingView) {\n            draggingView.setEventData(e, {\n              cell: node,\n              graph: this.targetGraph,\n              candidateEmbedView: this.candidateEmbedView,\n            })\n            draggingView.finalizeEmbedding(e, draggingView.getEventData<any>(e))\n          }\n        } else {\n          this.onDropInvalid()\n        }\n\n        this.candidateEmbedView = null\n        this.targetModel.stopBatch('dnd')\n      }\n\n      if (FunctionExt.isAsync(ret)) {\n        // stop dragging\n        this.undelegateDocumentEvents()\n        ret.then(callback) // eslint-disable-line\n      } else {\n        callback(ret)\n      }\n    }\n  }\n\n  protected clearDragging() {\n    if (this.draggingNode) {\n      this.sourceNode = null\n      this.draggingNode.remove()\n      this.draggingNode = null\n      this.draggingView = null\n      this.delta = null\n      this.padding = null\n      this.snapOffset = null\n      this.originOffset = null\n      this.undelegateDocumentEvents()\n    }\n  }\n\n  protected onDropped(draggingNode: Node) {\n    if (this.draggingNode === draggingNode) {\n      this.clearDragging()\n      Dom.removeClass(this.container, 'dragging')\n      Dom.remove(this.container)\n    }\n  }\n\n  protected onDropInvalid() {\n    const draggingNode = this.draggingNode\n    if (draggingNode) {\n      this.onDropped(draggingNode)\n      // todo\n      // const anim = this.options.animation\n      // if (anim) {\n      //   const duration = (typeof anim === 'object' && anim.duration) || 150\n      //   const easing = (typeof anim === 'object' && anim.easing) || 'swing'\n\n      //   this.draggingView = null\n\n      //   this.$container.animate(this.originOffset!, duration, easing, () =>\n      //     this.onDropped(draggingNode),\n      //   )\n      // } else {\n      //   this.onDropped(draggingNode)\n      // }\n    }\n  }\n\n  protected isInsideValidArea(p: Point.PointLike) {\n    let targetRect: Rectangle\n    let dndRect: Rectangle | null = null\n    const targetGraph = this.targetGraph\n    const targetScroller = this.targetScroller\n\n    if (this.options.dndContainer) {\n      dndRect = this.getDropArea(this.options.dndContainer)\n    }\n    const isInsideDndRect = dndRect && dndRect.containsPoint(p)\n\n    if (targetScroller) {\n      if (targetScroller.options.autoResize) {\n        targetRect = this.getDropArea(targetScroller.container)\n      } else {\n        const outter = this.getDropArea(targetScroller.container)\n        targetRect = this.getDropArea(targetGraph.container).intersectsWithRect(\n          outter,\n        )!\n      }\n    } else {\n      targetRect = this.getDropArea(targetGraph.container)\n    }\n\n    return !isInsideDndRect && targetRect && targetRect.containsPoint(p)\n  }\n\n  protected getDropArea(elem: Element) {\n    const offset = Dom.offset(elem)!\n    const scrollTop =\n      document.body.scrollTop || document.documentElement.scrollTop\n    const scrollLeft =\n      document.body.scrollLeft || document.documentElement.scrollLeft\n\n    return Rectangle.create({\n      x:\n        offset.left +\n        parseInt(Dom.css(elem, 'border-left-width')!, 10) -\n        scrollLeft,\n      y:\n        offset.top +\n        parseInt(Dom.css(elem, 'border-top-width')!, 10) -\n        scrollTop,\n      width: elem.clientWidth,\n      height: elem.clientHeight,\n    })\n  }\n\n  protected drop(draggingNode: Node, pos: Point.PointLike) {\n    if (this.isInsideValidArea(pos)) {\n      const targetGraph = this.targetGraph\n      const targetModel = targetGraph.model\n      const local = targetGraph.clientToLocal(pos)\n      const sourceNode = this.sourceNode!\n      const droppingNode = this.options.getDropNode(draggingNode, {\n        sourceNode,\n        draggingNode,\n        targetGraph: this.targetGraph,\n        draggingGraph: this.draggingGraph,\n      })\n      const bbox = droppingNode.getBBox()\n      local.x += bbox.x - bbox.width / 2\n      local.y += bbox.y - bbox.height / 2\n      const gridSize = this.snapOffset ? 1 : targetGraph.getGridSize()\n\n      droppingNode.position(\n        GeometryUtil.snapToGrid(local.x, gridSize),\n        GeometryUtil.snapToGrid(local.y, gridSize),\n      )\n\n      droppingNode.removeZIndex()\n\n      const validateNode = this.options.validateNode\n      const ret = validateNode\n        ? validateNode(droppingNode, {\n            sourceNode,\n            draggingNode,\n            droppingNode,\n            targetGraph,\n            draggingGraph: this.draggingGraph,\n          })\n        : true\n\n      if (typeof ret === 'boolean') {\n        if (ret) {\n          targetModel.addCell(droppingNode, { stencil: this.cid })\n          return droppingNode\n        }\n        return null\n      }\n\n      return FunctionExt.toDeferredBoolean(ret).then((valid) => {\n        if (valid) {\n          targetModel.addCell(droppingNode, { stencil: this.cid })\n          return droppingNode\n        }\n        return null\n      })\n    }\n\n    return null\n  }\n\n  protected onRemove() {\n    if (this.draggingGraph) {\n      this.draggingGraph.view.remove()\n      this.draggingGraph.dispose()\n    }\n  }\n\n  @View.dispose()\n  dispose() {\n    this.remove()\n    CssLoader.clean(this.name)\n  }\n}\n\nexport namespace Dnd {\n  export interface Options {\n    target: Graph\n    /**\n     * Should scale the dragging node or not.\n     */\n    scaled?: boolean\n    delegateGraphOptions?: Graph.Options\n    // animation?:\n    //   | boolean\n    //   | {\n    //       duration?: number\n    //       easing?: string\n    //     }\n    draggingContainer?: HTMLElement\n    /**\n     * dnd tool box container.\n     */\n    dndContainer?: HTMLElement\n    getDragNode: (sourceNode: Node, options: GetDragNodeOptions) => Node\n    getDropNode: (draggingNode: Node, options: GetDropNodeOptions) => Node\n    validateNode?: (\n      droppingNode: Node,\n      options: ValidateNodeOptions,\n    ) => boolean | Promise<boolean>\n  }\n\n  export interface GetDragNodeOptions {\n    sourceNode: Node\n    targetGraph: Graph\n    draggingGraph: Graph\n  }\n\n  export interface GetDropNodeOptions extends GetDragNodeOptions {\n    draggingNode: Node\n  }\n\n  export interface ValidateNodeOptions extends GetDropNodeOptions {\n    droppingNode: Node\n  }\n\n  export const defaults: Partial<Options> = {\n    // animation: false,\n    getDragNode: (sourceNode) => sourceNode.clone(),\n    getDropNode: (draggingNode) => draggingNode.clone(),\n  }\n\n  export const documentEvents = {\n    mousemove: 'onDragging',\n    touchmove: 'onDragging',\n    mouseup: 'onDragEnd',\n    touchend: 'onDragEnd',\n    touchcancel: 'onDragEnd',\n  }\n}\n"],"mappings":";;;;;;;AAAA,SACEA,YAAY,EACZC,SAAS,EAETC,WAAW,EACXC,GAAG,EACHC,SAAS,EAGTC,IAAI,EAEJC,KAAK,QAEA,UAAU;AACjB,SAASC,OAAO,QAAQ,aAAa;AAErC,OAAM,MAAOC,GAAI,SAAQH,IAAI;EAiB3B,IAAcI,cAAcA,CAAA;IAC1B,MAAMC,MAAM,GAAG,IAAI,CAACC,OAAO,CAACD,MAAM;IAClC,MAAME,QAAQ,GAAGF,MAAM,CAACG,SAAS,CAAM,UAAU,CAAC;IAClD,OAAOD,QAAQ;EACjB;EAEA,IAAcE,WAAWA,CAAA;IACvB,OAAO,IAAI,CAACH,OAAO,CAACD,MAAM;EAC5B;EAEA,IAAcK,WAAWA,CAAA;IACvB,OAAO,IAAI,CAACD,WAAW,CAACE,KAAK;EAC/B;EAEA,IAAcC,QAAQA,CAAA;IACpB,MAAMP,MAAM,GAAG,IAAI,CAACC,OAAO,CAACD,MAAM;IAClC,MAAMO,QAAQ,GAAGP,MAAM,CAACG,SAAS,CAAM,UAAU,CAAC;IAClD,OAAOI,QAAQ;EACjB;EAEAC,YAAYP,OAAiD;IAC3D,KAAK,EAAE;IArCF,KAAAQ,IAAI,GAAG,KAAK;IAsCjB,IAAI,CAACR,OAAO,GAAGS,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACVb,GAAG,CAACc,QAAQ,GACZX,OAAO,CACI;IAChB,IAAI,CAACY,IAAI,EAAE;EACb;EAEAA,IAAIA,CAAA;IACFnB,SAAS,CAACoB,MAAM,CAAC,IAAI,CAACL,IAAI,EAAEZ,OAAO,CAAC;IAEpC,IAAI,CAACkB,SAAS,GAAGC,QAAQ,CAACC,aAAa,CAAC,KAAK,CAAC;IAC9CxB,GAAG,CAACyB,QAAQ,CAAC,IAAI,CAACH,SAAS,EAAE,IAAI,CAACI,eAAe,CAAC,YAAY,CAAC,CAAC;IAEhE,IAAI,CAACC,aAAa,GAAG,IAAIxB,KAAK,CAAAc,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACzB,IAAI,CAACV,OAAO,CAACoB,oBAAoB;MACpCN,SAAS,EAAEC,QAAQ,CAACC,aAAa,CAAC,KAAK,CAAC;MACxCK,KAAK,EAAE,CAAC;MACRC,MAAM,EAAE,CAAC;MACTC,KAAK,EAAE;IAAK,GACZ;IAEF/B,GAAG,CAACgC,MAAM,CAAC,IAAI,CAACV,SAAS,EAAE,IAAI,CAACK,aAAa,CAACL,SAAS,CAAC;EAC1D;EAEAW,KAAKA,CAACC,IAAU,EAAEC,GAAoC;IACpD,MAAMC,CAAC,GAAGD,GAAyB;IAEnCC,CAAC,CAACC,cAAc,EAAE;IAElB,IAAI,CAACzB,WAAW,CAAC0B,UAAU,CAAC,KAAK,CAAC;IAClCtC,GAAG,CAACyB,QAAQ,CAAC,IAAI,CAACH,SAAS,EAAE,UAAU,CAAC;IACxCtB,GAAG,CAACuC,QAAQ,CACV,IAAI,CAACjB,SAAS,EACd,IAAI,CAACd,OAAO,CAACgC,iBAAiB,IAAIjB,QAAQ,CAACkB,IAAI,CAChD;IAED,IAAI,CAACC,UAAU,GAAGR,IAAI;IACtB,IAAI,CAACS,eAAe,CAACT,IAAI,EAAEE,CAAC,CAACQ,OAAO,EAAER,CAAC,CAACS,OAAO,CAAC;IAEhD,MAAMC,KAAK,GAAG,IAAI,CAACC,kBAAkB,CAACX,CAAC,CAACQ,OAAO,EAAER,CAAC,CAACS,OAAO,CAAC;IAE3D,IAAI,IAAI,CAACG,iBAAiB,EAAE,EAAE;MAC5B,IAAI,CAAClC,QAAQ,CAACmC,mBAAmB,CAAC;QAChCb,CAAC;QACDF,IAAI;QACJgB,IAAI,EAAEhB,IAAI;QACViB,IAAI,EAAE,IAAI,CAACC,YAAa;QACxBC,CAAC,EAAEP,KAAK,CAACO,CAAC;QACVC,CAAC,EAAER,KAAK,CAACQ;OACV,CAAC;MACF,IAAI,CAACC,YAAa,CAACC,EAAE,CAAC,iBAAiB,EAAE,IAAI,CAACC,IAAI,EAAE,IAAI,CAAC;;IAG3D,IAAI,CAACC,sBAAsB,CAACrD,GAAG,CAACsD,cAAc,EAAEvB,CAAC,CAACwB,IAAI,CAAC;EACzD;EAEUZ,iBAAiBA,CAAA;IACzB,OAAO,IAAI,CAAClC,QAAQ,IAAI,IAAI,CAACA,QAAQ,CAAC+C,SAAS,EAAE;EACnD;EAEUlB,eAAeA,CACvBD,UAAgB,EAChBE,OAAe,EACfC,OAAe;IAEf,MAAMlB,aAAa,GAAG,IAAI,CAACA,aAAa;IACxC,MAAMmC,aAAa,GAAGnC,aAAa,CAACd,KAAK;IACzC,MAAM0C,YAAY,GAAG,IAAI,CAAC/C,OAAO,CAACuD,WAAW,CAACrB,UAAU,EAAE;MACxDA,UAAU;MACVf,aAAa;MACbhB,WAAW,EAAE,IAAI,CAACA;KACnB,CAAC;IAEF4C,YAAY,CAACS,QAAQ,CAAC,CAAC,EAAE,CAAC,CAAC;IAE3B,IAAIC,OAAO,GAAG,CAAC;IACf,IAAI,IAAI,CAACjB,iBAAiB,EAAE,EAAE;MAC5BiB,OAAO,IAAI,IAAI,CAACnD,QAAQ,CAACN,OAAO,CAAC0D,SAAS,IAAI,CAAC;;IAGjD,IAAI,IAAI,CAAClB,iBAAiB,EAAE,IAAI,IAAI,CAACxC,OAAO,CAAC2D,MAAM,EAAE;MACnD,MAAMC,KAAK,GAAG,IAAI,CAACzD,WAAW,CAAC0D,SAAS,CAACC,QAAQ,EAAE;MACnD3C,aAAa,CAACyC,KAAK,CAACA,KAAK,CAACG,EAAE,EAAEH,KAAK,CAACI,EAAE,CAAC;MACvCP,OAAO,IAAIQ,IAAI,CAACC,GAAG,CAACN,KAAK,CAACG,EAAE,EAAEH,KAAK,CAACI,EAAE,CAAC;KACxC,MAAM;MACL7C,aAAa,CAACyC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC;;IAG3B,IAAI,CAACO,aAAa,EAAE;IAEpB;IACA;IACA;IAEAb,aAAa,CAACc,UAAU,CAAC,CAACrB,YAAY,CAAC,CAAC;IAExC,MAAMsB,YAAY,GAAGlD,aAAa,CAACmD,cAAc,CAACvB,YAAY,CAAa;IAC3EsB,YAAY,CAACE,gBAAgB,EAAE;IAC/BF,YAAY,CAAC3B,IAAI,CAAC8B,GAAG,CAAC,SAAS,CAAC;IAChCrD,aAAa,CAACsD,YAAY,CAAC;MACzBhB,OAAO;MACPiB,cAAc,EAAE,KAAK;MACrBC,eAAe,EAAE;KAClB,CAAC;IAEF,MAAMC,IAAI,GAAGP,YAAY,CAACQ,OAAO,EAAE;IACnC,IAAI,CAACC,YAAY,GAAGT,YAAY,CAACQ,OAAO,CAAC;MAAEF,eAAe,EAAE;IAAI,CAAE,CAAC;IACnE,IAAI,CAACI,KAAK,GAAG,IAAI,CAACD,YAAY,CAACE,UAAU,EAAE,CAACC,IAAI,CAACL,IAAI,CAACI,UAAU,EAAE,CAAC;IACnE,IAAI,CAACjC,YAAY,GAAGA,YAAY;IAChC,IAAI,CAACH,YAAY,GAAGyB,YAAY;IAChC,IAAI,CAACa,YAAY,GAAGnC,YAAY,CAAC8B,OAAO,EAAE;IAC1C,IAAI,CAACpB,OAAO,GAAGA,OAAO;IACtB,IAAI,CAAC0B,YAAY,GAAG,IAAI,CAACC,mBAAmB,CAAChD,OAAO,EAAEC,OAAO,CAAC;EAChE;EAEU+C,mBAAmBA,CAAChD,OAAe,EAAEC,OAAe;IAC5D,MAAMgD,SAAS,GACbtE,QAAQ,CAACkB,IAAI,CAACoD,SAAS,IAAItE,QAAQ,CAACuE,eAAe,CAACD,SAAS;IAC/D,MAAME,UAAU,GACdxE,QAAQ,CAACkB,IAAI,CAACsD,UAAU,IAAIxE,QAAQ,CAACuE,eAAe,CAACC,UAAU;IACjE,MAAMR,KAAK,GAAG,IAAI,CAACA,KAAM;IACzB,MAAMS,QAAQ,GAAG,IAAI,CAACV,YAAY;IAClC,MAAMrB,OAAO,GAAG,IAAI,CAACA,OAAO,IAAI,CAAC;IACjC,MAAMgC,MAAM,GAAG;MACbC,IAAI,EAAEtD,OAAO,GAAG2C,KAAK,CAAClC,CAAC,GAAG2C,QAAQ,CAACnE,KAAK,GAAG,CAAC,GAAGoC,OAAO,GAAG8B,UAAU;MACnEI,GAAG,EAAEtD,OAAO,GAAG0C,KAAK,CAACjC,CAAC,GAAG0C,QAAQ,CAAClE,MAAM,GAAG,CAAC,GAAGmC,OAAO,GAAG4B;KAC1D;IAED,IAAI,IAAI,CAAClE,aAAa,EAAE;MACtB3B,GAAG,CAACoG,GAAG,CAAC,IAAI,CAAC9E,SAAS,EAAE;QACtB4E,IAAI,EAAE,GAAGD,MAAM,CAACC,IAAI,IAAI;QACxBC,GAAG,EAAE,GAAGF,MAAM,CAACE,GAAG;OACnB,CAAC;;IAGJ,OAAOF,MAAM;EACf;EAEUlD,kBAAkBA,CAACM,CAAS,EAAEC,CAAS;IAC/C,MAAMR,KAAK,GAAG,IAAI,CAACnC,WAAW,CAAC0F,aAAa,CAAChD,CAAC,EAAEC,CAAC,CAAC;IAClD,MAAM8B,IAAI,GAAG,IAAI,CAACM,YAAa;IAC/B5C,KAAK,CAACO,CAAC,IAAI+B,IAAI,CAACvD,KAAK,GAAG,CAAC;IACzBiB,KAAK,CAACQ,CAAC,IAAI8B,IAAI,CAACtD,MAAM,GAAG,CAAC;IAC1B,IAAI,CAACyB,YAAa,CAACS,QAAQ,CAAClB,KAAK,CAACO,CAAC,EAAEP,KAAK,CAACQ,CAAC,CAAC;IAC7C,OAAOR,KAAK;EACd;EAEUW,IAAIA,CAAC;IACbP,IAAI;IACJoD,OAAO;IACP9F;EAAO,CAC2B;IAClC,MAAM0B,IAAI,GAAGgB,IAAY;IACzB,IAAI1C,OAAO,CAAC+F,OAAO,EAAE;MACnB,MAAMnB,IAAI,GAAG,IAAI,CAACM,YAAY;MAC9BxD,IAAI,CAAC8B,QAAQ,CAACoB,IAAI,CAAC/B,CAAC,GAAG7C,OAAO,CAACgG,EAAE,EAAEpB,IAAI,CAAC9B,CAAC,GAAG9C,OAAO,CAACiG,EAAE,EAAE;QAAEC,MAAM,EAAE;MAAI,CAAE,CAAC;MACzE,IAAI,CAACtD,YAAa,CAACuD,SAAS,EAAE;MAC9BzE,IAAI,CAAC8B,QAAQ,CAACsC,OAAQ,CAACjD,CAAC,EAAEiD,OAAQ,CAAChD,CAAC,EAAE;QAAEoD,MAAM,EAAE;MAAI,CAAE,CAAC;MAEvD,IAAI,CAACE,UAAU,GAAG;QAChBvD,CAAC,EAAE7C,OAAO,CAACgG,EAAE;QACblD,CAAC,EAAE9C,OAAO,CAACiG;OACZ;KACF,MAAM;MACL,IAAI,CAACG,UAAU,GAAG,IAAI;;EAE1B;EAEUC,UAAUA,CAAC1E,GAAuB;IAC1C,MAAMiB,YAAY,GAAG,IAAI,CAACA,YAAY;IACtC,IAAIA,YAAY,EAAE;MAChBjB,GAAG,CAACE,cAAc,EAAE;MACpB,MAAMD,CAAC,GAAG,IAAI,CAAC0E,cAAc,CAAC3E,GAAG,CAAC;MAClC,MAAMS,OAAO,GAAGR,CAAC,CAACQ,OAAO;MACzB,MAAMC,OAAO,GAAGT,CAAC,CAACS,OAAO;MAEzB,IAAI,CAAC+C,mBAAmB,CAAChD,OAAO,EAAEC,OAAO,CAAC;MAC1C,MAAMC,KAAK,GAAG,IAAI,CAACC,kBAAkB,CAACH,OAAO,EAAEC,OAAO,CAAC;MACvD,MAAMkE,aAAa,GAAG,IAAI,CAACpG,WAAW,CAACH,OAAO,CAACwG,SAAS,CAACC,OAAO;MAChE,MAAMC,WAAW,GACf,CAACH,aAAa,IAAI,IAAI,CAAC/D,iBAAiB,EAAE,KAC1C,IAAI,CAACmE,iBAAiB,CAAC;QACrB9D,CAAC,EAAET,OAAO;QACVU,CAAC,EAAET;OACJ,CAAC;MAEJ,IAAIkE,aAAa,EAAE;QACjB3D,YAAY,CAACgE,YAAY,CAAChF,CAAC,EAAE;UAC3BiF,KAAK,EAAE,IAAI,CAAC1G,WAAW;UACvB2G,kBAAkB,EAAE,IAAI,CAACA;SAC1B,CAAC;QACF,MAAM1D,IAAI,GAAGR,YAAY,CAACmE,YAAY,CAAMnF,CAAC,CAAC;QAC9C,IAAI8E,WAAW,EAAE;UACf9D,YAAY,CAACoE,gBAAgB,CAACpF,CAAC,EAAEwB,IAAI,CAAC;SACvC,MAAM;UACLR,YAAY,CAACqE,cAAc,CAAC7D,IAAI,CAAC;;QAEnC,IAAI,CAAC0D,kBAAkB,GAAG1D,IAAI,CAAC0D,kBAAkB;;MAGnD;MACA,IAAI,IAAI,CAACtE,iBAAiB,EAAE,EAAE;QAC5B,IAAIkE,WAAW,EAAE;UACf,IAAI,CAACpG,QAAQ,CAAC4G,YAAY,CAAC;YACzBtF,CAAC;YACDe,IAAI,EAAEC,YAAa;YACnBC,CAAC,EAAEP,KAAK,CAACO,CAAC;YACVC,CAAC,EAAER,KAAK,CAACQ;WACqB,CAAC;SAClC,MAAM;UACL,IAAI,CAACxC,QAAQ,CAAC6G,IAAI,EAAE;;;;EAI5B;EAEUC,SAASA,CAACzF,GAAqB;IACvC,MAAMoB,YAAY,GAAG,IAAI,CAACA,YAAY;IACtC,IAAIA,YAAY,EAAE;MAChB,MAAMnB,CAAC,GAAG,IAAI,CAAC0E,cAAc,CAAC3E,GAAG,CAAC;MAClC,MAAMiB,YAAY,GAAG,IAAI,CAACA,YAAY;MACtC,MAAMsC,YAAY,GAAG,IAAI,CAACA,YAAY;MACtC,MAAMkB,UAAU,GAAG,IAAI,CAACA,UAAU;MAClC,IAAIvD,CAAC,GAAGqC,YAAY,CAACrC,CAAC;MACtB,IAAIC,CAAC,GAAGoC,YAAY,CAACpC,CAAC;MAEtB,IAAIsD,UAAU,EAAE;QACdvD,CAAC,IAAIuD,UAAU,CAACvD,CAAC;QACjBC,CAAC,IAAIsD,UAAU,CAACtD,CAAC;;MAGnBC,YAAY,CAACS,QAAQ,CAACX,CAAC,EAAEC,CAAC,EAAE;QAAEoD,MAAM,EAAE;MAAI,CAAE,CAAC;MAE7C,MAAMmB,GAAG,GAAG,IAAI,CAACC,IAAI,CAACvE,YAAY,EAAE;QAAEF,CAAC,EAAEjB,CAAC,CAACQ,OAAO;QAAEU,CAAC,EAAElB,CAAC,CAACS;MAAO,CAAE,CAAC;MACnE,MAAMkF,QAAQ,GAAI7F,IAAiB,IAAI;QACrC,IAAIA,IAAI,EAAE;UACR,IAAI,CAAC8F,SAAS,CAACzE,YAAY,CAAC;UAC5B,IAAI,IAAI,CAAC5C,WAAW,CAACH,OAAO,CAACwG,SAAS,CAACC,OAAO,IAAI7D,YAAY,EAAE;YAC9DA,YAAY,CAACgE,YAAY,CAAChF,CAAC,EAAE;cAC3Bc,IAAI,EAAEhB,IAAI;cACVmF,KAAK,EAAE,IAAI,CAAC1G,WAAW;cACvB2G,kBAAkB,EAAE,IAAI,CAACA;aAC1B,CAAC;YACFlE,YAAY,CAAC6E,iBAAiB,CAAC7F,CAAC,EAAEgB,YAAY,CAACmE,YAAY,CAAMnF,CAAC,CAAC,CAAC;;SAEvE,MAAM;UACL,IAAI,CAAC8F,aAAa,EAAE;;QAGtB,IAAI,CAACZ,kBAAkB,GAAG,IAAI;QAC9B,IAAI,CAAC1G,WAAW,CAACuH,SAAS,CAAC,KAAK,CAAC;MACnC,CAAC;MAED,IAAIpI,WAAW,CAACqI,OAAO,CAACP,GAAG,CAAC,EAAE;QAC5B;QACA,IAAI,CAACQ,wBAAwB,EAAE;QAC/BR,GAAG,CAACS,IAAI,CAACP,QAAQ,CAAC,EAAC;OACpB,MAAM;QACLA,QAAQ,CAACF,GAAG,CAAC;;;EAGnB;EAEUlD,aAAaA,CAAA;IACrB,IAAI,IAAI,CAACpB,YAAY,EAAE;MACrB,IAAI,CAACb,UAAU,GAAG,IAAI;MACtB,IAAI,CAACa,YAAY,CAACgF,MAAM,EAAE;MAC1B,IAAI,CAAChF,YAAY,GAAG,IAAI;MACxB,IAAI,CAACH,YAAY,GAAG,IAAI;MACxB,IAAI,CAACmC,KAAK,GAAG,IAAI;MACjB,IAAI,CAACtB,OAAO,GAAG,IAAI;MACnB,IAAI,CAAC2C,UAAU,GAAG,IAAI;MACtB,IAAI,CAACjB,YAAY,GAAG,IAAI;MACxB,IAAI,CAAC0C,wBAAwB,EAAE;;EAEnC;EAEUL,SAASA,CAACzE,YAAkB;IACpC,IAAI,IAAI,CAACA,YAAY,KAAKA,YAAY,EAAE;MACtC,IAAI,CAACoB,aAAa,EAAE;MACpB3E,GAAG,CAACwI,WAAW,CAAC,IAAI,CAAClH,SAAS,EAAE,UAAU,CAAC;MAC3CtB,GAAG,CAACuI,MAAM,CAAC,IAAI,CAACjH,SAAS,CAAC;;EAE9B;EAEU4G,aAAaA,CAAA;IACrB,MAAM3E,YAAY,GAAG,IAAI,CAACA,YAAY;IACtC,IAAIA,YAAY,EAAE;MAChB,IAAI,CAACyE,SAAS,CAACzE,YAAY,CAAC;MAC5B;MACA;MACA;MACA;MACA;MAEA;MAEA;MACA;MACA;MACA;MACA;MACA;;EAEJ;EAEU4D,iBAAiBA,CAACsB,CAAkB;IAC5C,IAAIC,UAAqB;IACzB,IAAIC,OAAO,GAAqB,IAAI;IACpC,MAAMhI,WAAW,GAAG,IAAI,CAACA,WAAW;IACpC,MAAML,cAAc,GAAG,IAAI,CAACA,cAAc;IAE1C,IAAI,IAAI,CAACE,OAAO,CAACoI,YAAY,EAAE;MAC7BD,OAAO,GAAG,IAAI,CAACE,WAAW,CAAC,IAAI,CAACrI,OAAO,CAACoI,YAAY,CAAC;;IAEvD,MAAME,eAAe,GAAGH,OAAO,IAAIA,OAAO,CAACI,aAAa,CAACN,CAAC,CAAC;IAE3D,IAAInI,cAAc,EAAE;MAClB,IAAIA,cAAc,CAACE,OAAO,CAACwI,UAAU,EAAE;QACrCN,UAAU,GAAG,IAAI,CAACG,WAAW,CAACvI,cAAc,CAACgB,SAAS,CAAC;OACxD,MAAM;QACL,MAAM2H,MAAM,GAAG,IAAI,CAACJ,WAAW,CAACvI,cAAc,CAACgB,SAAS,CAAC;QACzDoH,UAAU,GAAG,IAAI,CAACG,WAAW,CAAClI,WAAW,CAACW,SAAS,CAAC,CAAC4H,kBAAkB,CACrED,MAAM,CACN;;KAEL,MAAM;MACLP,UAAU,GAAG,IAAI,CAACG,WAAW,CAAClI,WAAW,CAACW,SAAS,CAAC;;IAGtD,OAAO,CAACwH,eAAe,IAAIJ,UAAU,IAAIA,UAAU,CAACK,aAAa,CAACN,CAAC,CAAC;EACtE;EAEUI,WAAWA,CAACM,IAAa;IACjC,MAAMlD,MAAM,GAAGjG,GAAG,CAACiG,MAAM,CAACkD,IAAI,CAAE;IAChC,MAAMtD,SAAS,GACbtE,QAAQ,CAACkB,IAAI,CAACoD,SAAS,IAAItE,QAAQ,CAACuE,eAAe,CAACD,SAAS;IAC/D,MAAME,UAAU,GACdxE,QAAQ,CAACkB,IAAI,CAACsD,UAAU,IAAIxE,QAAQ,CAACuE,eAAe,CAACC,UAAU;IAEjE,OAAOjG,SAAS,CAACsJ,MAAM,CAAC;MACtB/F,CAAC,EACC4C,MAAM,CAACC,IAAI,GACXmD,QAAQ,CAACrJ,GAAG,CAACoG,GAAG,CAAC+C,IAAI,EAAE,mBAAmB,CAAE,EAAE,EAAE,CAAC,GACjDpD,UAAU;MACZzC,CAAC,EACC2C,MAAM,CAACE,GAAG,GACVkD,QAAQ,CAACrJ,GAAG,CAACoG,GAAG,CAAC+C,IAAI,EAAE,kBAAkB,CAAE,EAAE,EAAE,CAAC,GAChDtD,SAAS;MACXhE,KAAK,EAAEsH,IAAI,CAACG,WAAW;MACvBxH,MAAM,EAAEqH,IAAI,CAACI;KACd,CAAC;EACJ;EAEUzB,IAAIA,CAACvE,YAAkB,EAAEiG,GAAoB;IACrD,IAAI,IAAI,CAACrC,iBAAiB,CAACqC,GAAG,CAAC,EAAE;MAC/B,MAAM7I,WAAW,GAAG,IAAI,CAACA,WAAW;MACpC,MAAMC,WAAW,GAAGD,WAAW,CAACE,KAAK;MACrC,MAAMiC,KAAK,GAAGnC,WAAW,CAAC0F,aAAa,CAACmD,GAAG,CAAC;MAC5C,MAAM9G,UAAU,GAAG,IAAI,CAACA,UAAW;MACnC,MAAM+G,YAAY,GAAG,IAAI,CAACjJ,OAAO,CAACkJ,WAAW,CAACnG,YAAY,EAAE;QAC1Db,UAAU;QACVa,YAAY;QACZ5C,WAAW,EAAE,IAAI,CAACA,WAAW;QAC7BgB,aAAa,EAAE,IAAI,CAACA;OACrB,CAAC;MACF,MAAMyD,IAAI,GAAGqE,YAAY,CAACpE,OAAO,EAAE;MACnCvC,KAAK,CAACO,CAAC,IAAI+B,IAAI,CAAC/B,CAAC,GAAG+B,IAAI,CAACvD,KAAK,GAAG,CAAC;MAClCiB,KAAK,CAACQ,CAAC,IAAI8B,IAAI,CAAC9B,CAAC,GAAG8B,IAAI,CAACtD,MAAM,GAAG,CAAC;MACnC,MAAM6H,QAAQ,GAAG,IAAI,CAAC/C,UAAU,GAAG,CAAC,GAAGjG,WAAW,CAACiJ,WAAW,EAAE;MAEhEH,YAAY,CAACzF,QAAQ,CACnBnE,YAAY,CAACgK,UAAU,CAAC/G,KAAK,CAACO,CAAC,EAAEsG,QAAQ,CAAC,EAC1C9J,YAAY,CAACgK,UAAU,CAAC/G,KAAK,CAACQ,CAAC,EAAEqG,QAAQ,CAAC,CAC3C;MAEDF,YAAY,CAACK,YAAY,EAAE;MAE3B,MAAMC,YAAY,GAAG,IAAI,CAACvJ,OAAO,CAACuJ,YAAY;MAC9C,MAAMlC,GAAG,GAAGkC,YAAY,GACpBA,YAAY,CAACN,YAAY,EAAE;QACzB/G,UAAU;QACVa,YAAY;QACZkG,YAAY;QACZ9I,WAAW;QACXgB,aAAa,EAAE,IAAI,CAACA;OACrB,CAAC,GACF,IAAI;MAER,IAAI,OAAOkG,GAAG,KAAK,SAAS,EAAE;QAC5B,IAAIA,GAAG,EAAE;UACPjH,WAAW,CAACoJ,OAAO,CAACP,YAAY,EAAE;YAAEQ,OAAO,EAAE,IAAI,CAACC;UAAG,CAAE,CAAC;UACxD,OAAOT,YAAY;;QAErB,OAAO,IAAI;;MAGb,OAAO1J,WAAW,CAACoK,iBAAiB,CAACtC,GAAG,CAAC,CAACS,IAAI,CAAE8B,KAAK,IAAI;QACvD,IAAIA,KAAK,EAAE;UACTxJ,WAAW,CAACoJ,OAAO,CAACP,YAAY,EAAE;YAAEQ,OAAO,EAAE,IAAI,CAACC;UAAG,CAAE,CAAC;UACxD,OAAOT,YAAY;;QAErB,OAAO,IAAI;MACb,CAAC,CAAC;;IAGJ,OAAO,IAAI;EACb;EAEUY,QAAQA,CAAA;IAChB,IAAI,IAAI,CAAC1I,aAAa,EAAE;MACtB,IAAI,CAACA,aAAa,CAACwB,IAAI,CAACoF,MAAM,EAAE;MAChC,IAAI,CAAC5G,aAAa,CAAC2I,OAAO,EAAE;;EAEhC;EAGAA,OAAOA,CAAA;IACL,IAAI,CAAC/B,MAAM,EAAE;IACbtI,SAAS,CAACsK,KAAK,CAAC,IAAI,CAACvJ,IAAI,CAAC;EAC5B;;AAHAwJ,UAAA,EADCtK,IAAI,CAACoK,OAAO,EAAE,C,iCAId;AAGH,WAAiBjK,GAAG;EAyCLA,GAAA,CAAAc,QAAQ,GAAqB;IACxC;IACA4C,WAAW,EAAGrB,UAAU,IAAKA,UAAU,CAAC+H,KAAK,EAAE;IAC/Cf,WAAW,EAAGnG,YAAY,IAAKA,YAAY,CAACkH,KAAK;GAClD;EAEYpK,GAAA,CAAAsD,cAAc,GAAG;IAC5B+G,SAAS,EAAE,YAAY;IACvBC,SAAS,EAAE,YAAY;IACvBC,OAAO,EAAE,WAAW;IACpBC,QAAQ,EAAE,WAAW;IACrBC,WAAW,EAAE;GACd;AACH,CAAC,EAtDgBzK,GAAG,KAAHA,GAAG","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}