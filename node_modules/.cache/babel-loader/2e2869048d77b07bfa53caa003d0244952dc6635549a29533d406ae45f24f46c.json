{"ast":null,"code":"import { ArrayExt, FunctionExt, Dom } from '@antv/x6-common';\nimport { Rectangle, Point, GeometryUtil } from '@antv/x6-geometry';\nimport { Config } from '../config';\nimport { Cell } from '../model/cell';\nimport { CellView } from './cell';\nimport { Markup } from './markup';\nexport class NodeView extends CellView {\n  constructor() {\n    super(...arguments);\n    this.portsCache = {};\n    // #endregion\n  }\n  get [Symbol.toStringTag]() {\n    return NodeView.toStringTag;\n  }\n  getContainerClassName() {\n    const classList = [super.getContainerClassName(), this.prefixClassName('node')];\n    if (!this.can('nodeMovable')) {\n      classList.push(this.prefixClassName('node-immovable'));\n    }\n    return classList.join(' ');\n  }\n  updateClassName(e) {\n    const target = e.target;\n    if (target.hasAttribute('magnet')) {\n      // port\n      const className = this.prefixClassName('port-unconnectable');\n      if (this.can('magnetConnectable')) {\n        Dom.removeClass(target, className);\n      } else {\n        Dom.addClass(target, className);\n      }\n    } else {\n      // node\n      const className = this.prefixClassName('node-immovable');\n      if (this.can('nodeMovable')) {\n        this.removeClass(className);\n      } else {\n        this.addClass(className);\n      }\n    }\n  }\n  isNodeView() {\n    return true;\n  }\n  confirmUpdate(flag, options = {}) {\n    let ret = flag;\n    if (this.hasAction(ret, 'ports')) {\n      this.removePorts();\n      this.cleanPortsCache();\n    }\n    if (this.hasAction(ret, 'render')) {\n      this.render();\n      ret = this.removeAction(ret, ['render', 'update', 'resize', 'translate', 'rotate', 'ports', 'tools']);\n    } else {\n      ret = this.handleAction(ret, 'resize', () => this.resize(), 'update');\n      ret = this.handleAction(ret, 'update', () => this.update(),\n      // `update()` will render ports when useCSSSelectors are enabled\n      Config.useCSSSelector ? 'ports' : null);\n      ret = this.handleAction(ret, 'translate', () => this.translate());\n      ret = this.handleAction(ret, 'rotate', () => this.rotate());\n      ret = this.handleAction(ret, 'ports', () => this.renderPorts());\n      ret = this.handleAction(ret, 'tools', () => {\n        if (this.getFlag('tools') === flag) {\n          this.renderTools();\n        } else {\n          this.updateTools(options);\n        }\n      });\n    }\n    return ret;\n  }\n  update(partialAttrs) {\n    this.cleanCache();\n    // When CSS selector strings are used, make sure no rule matches port nodes.\n    if (Config.useCSSSelector) {\n      this.removePorts();\n    }\n    const node = this.cell;\n    const size = node.getSize();\n    const attrs = node.getAttrs();\n    this.updateAttrs(this.container, attrs, {\n      attrs: partialAttrs === attrs ? null : partialAttrs,\n      rootBBox: new Rectangle(0, 0, size.width, size.height),\n      selectors: this.selectors\n    });\n    if (Config.useCSSSelector) {\n      this.renderPorts();\n    }\n  }\n  renderMarkup() {\n    const markup = this.cell.markup;\n    if (markup) {\n      if (typeof markup === 'string') {\n        throw new TypeError('Not support string markup.');\n      }\n      return this.renderJSONMarkup(markup);\n    }\n    throw new TypeError('Invalid node markup.');\n  }\n  renderJSONMarkup(markup) {\n    const ret = this.parseJSONMarkup(markup, this.container);\n    this.selectors = ret.selectors;\n    this.container.appendChild(ret.fragment);\n  }\n  render() {\n    this.empty();\n    this.renderMarkup();\n    this.resize();\n    this.updateTransform();\n    if (!Config.useCSSSelector) {\n      this.renderPorts();\n    }\n    this.renderTools();\n    return this;\n  }\n  resize() {\n    if (this.cell.getAngle()) {\n      this.rotate();\n    }\n    this.update();\n  }\n  translate() {\n    this.updateTransform();\n  }\n  rotate() {\n    this.updateTransform();\n  }\n  getTranslationString() {\n    const position = this.cell.getPosition();\n    return `translate(${position.x},${position.y})`;\n  }\n  getRotationString() {\n    const angle = this.cell.getAngle();\n    if (angle) {\n      const size = this.cell.getSize();\n      return `rotate(${angle},${size.width / 2},${size.height / 2})`;\n    }\n  }\n  updateTransform() {\n    let transform = this.getTranslationString();\n    const rot = this.getRotationString();\n    if (rot) {\n      transform += ` ${rot}`;\n    }\n    this.container.setAttribute('transform', transform);\n  }\n  // #region ports\n  findPortElem(portId, selector) {\n    const cache = portId ? this.portsCache[portId] : null;\n    if (!cache) {\n      return null;\n    }\n    const portRoot = cache.portContentElement;\n    const portSelectors = cache.portContentSelectors || {};\n    return this.findOne(selector, portRoot, portSelectors);\n  }\n  cleanPortsCache() {\n    this.portsCache = {};\n  }\n  removePorts() {\n    Object.values(this.portsCache).forEach(cached => {\n      Dom.remove(cached.portElement);\n    });\n  }\n  renderPorts() {\n    const container = this.container;\n    // References to rendered elements without z-index\n    const references = [];\n    container.childNodes.forEach(child => {\n      references.push(child);\n    });\n    const parsedPorts = this.cell.getParsedPorts();\n    const portsGropsByZ = ArrayExt.groupBy(parsedPorts, 'zIndex');\n    const autoZIndexKey = 'auto';\n    // render non-z first\n    if (portsGropsByZ[autoZIndexKey]) {\n      portsGropsByZ[autoZIndexKey].forEach(port => {\n        const portElement = this.getPortElement(port);\n        container.append(portElement);\n        references.push(portElement);\n      });\n    }\n    Object.keys(portsGropsByZ).forEach(key => {\n      if (key !== autoZIndexKey) {\n        const zIndex = parseInt(key, 10);\n        this.appendPorts(portsGropsByZ[key], zIndex, references);\n      }\n    });\n    this.updatePorts();\n  }\n  appendPorts(ports, zIndex, refs) {\n    const elems = ports.map(p => this.getPortElement(p));\n    if (refs[zIndex] || zIndex < 0) {\n      Dom.before(refs[Math.max(zIndex, 0)], elems);\n    } else {\n      Dom.append(this.container, elems);\n    }\n  }\n  getPortElement(port) {\n    const cached = this.portsCache[port.id];\n    if (cached) {\n      return cached.portElement;\n    }\n    return this.createPortElement(port);\n  }\n  createPortElement(port) {\n    let renderResult = Markup.renderMarkup(this.cell.getPortContainerMarkup());\n    const portElement = renderResult.elem;\n    if (portElement == null) {\n      throw new Error('Invalid port container markup.');\n    }\n    renderResult = Markup.renderMarkup(this.getPortMarkup(port));\n    const portContentElement = renderResult.elem;\n    const portContentSelectors = renderResult.selectors;\n    if (portContentElement == null) {\n      throw new Error('Invalid port markup.');\n    }\n    this.setAttrs({\n      port: port.id,\n      'port-group': port.group\n    }, portContentElement);\n    let portClass = 'x6-port';\n    if (port.group) {\n      portClass += ` x6-port-${port.group}`;\n    }\n    Dom.addClass(portElement, portClass);\n    Dom.addClass(portElement, 'x6-port');\n    Dom.addClass(portContentElement, 'x6-port-body');\n    portElement.appendChild(portContentElement);\n    let portSelectors = portContentSelectors;\n    let portLabelElement;\n    let portLabelSelectors;\n    const existLabel = this.existPortLabel(port);\n    if (existLabel) {\n      renderResult = Markup.renderMarkup(this.getPortLabelMarkup(port.label));\n      portLabelElement = renderResult.elem;\n      portLabelSelectors = renderResult.selectors;\n      if (portLabelElement == null) {\n        throw new Error('Invalid port label markup.');\n      }\n      if (portContentSelectors && portLabelSelectors) {\n        // eslint-disable-next-line\n        for (const key in portLabelSelectors) {\n          if (portContentSelectors[key] && key !== this.rootSelector) {\n            throw new Error('Selectors within port must be unique.');\n          }\n        }\n        portSelectors = Object.assign(Object.assign({}, portContentSelectors), portLabelSelectors);\n      }\n      Dom.addClass(portLabelElement, 'x6-port-label');\n      portElement.appendChild(portLabelElement);\n    }\n    this.portsCache[port.id] = {\n      portElement,\n      portSelectors,\n      portLabelElement,\n      portLabelSelectors,\n      portContentElement,\n      portContentSelectors\n    };\n    if (this.graph.options.onPortRendered) {\n      this.graph.options.onPortRendered({\n        port,\n        node: this.cell,\n        container: portElement,\n        selectors: portSelectors,\n        labelContainer: portLabelElement,\n        labelSelectors: portLabelSelectors,\n        contentContainer: portContentElement,\n        contentSelectors: portContentSelectors\n      });\n    }\n    return portElement;\n  }\n  updatePorts() {\n    const groups = this.cell.getParsedGroups();\n    const groupList = Object.keys(groups);\n    if (groupList.length === 0) {\n      this.updatePortGroup();\n    } else {\n      groupList.forEach(groupName => this.updatePortGroup(groupName));\n    }\n  }\n  updatePortGroup(groupName) {\n    const bbox = Rectangle.fromSize(this.cell.getSize());\n    const metrics = this.cell.getPortsLayoutByGroup(groupName, bbox);\n    for (let i = 0, n = metrics.length; i < n; i += 1) {\n      const metric = metrics[i];\n      const portId = metric.portId;\n      const cached = this.portsCache[portId] || {};\n      const portLayout = metric.portLayout;\n      this.applyPortTransform(cached.portElement, portLayout);\n      if (metric.portAttrs != null) {\n        const options = {\n          selectors: cached.portSelectors || {}\n        };\n        if (metric.portSize) {\n          options.rootBBox = Rectangle.fromSize(metric.portSize);\n        }\n        this.updateAttrs(cached.portElement, metric.portAttrs, options);\n      }\n      const labelLayout = metric.labelLayout;\n      if (labelLayout && cached.portLabelElement) {\n        this.applyPortTransform(cached.portLabelElement, labelLayout, -(portLayout.angle || 0));\n        if (labelLayout.attrs) {\n          const options = {\n            selectors: cached.portLabelSelectors || {}\n          };\n          if (metric.labelSize) {\n            options.rootBBox = Rectangle.fromSize(metric.labelSize);\n          }\n          this.updateAttrs(cached.portLabelElement, labelLayout.attrs, options);\n        }\n      }\n    }\n  }\n  applyPortTransform(element, layout, initialAngle = 0) {\n    const angle = layout.angle;\n    const position = layout.position;\n    const matrix = Dom.createSVGMatrix().rotate(initialAngle).translate(position.x || 0, position.y || 0).rotate(angle || 0);\n    Dom.transform(element, matrix, {\n      absolute: true\n    });\n  }\n  getPortMarkup(port) {\n    return port.markup || this.cell.portMarkup;\n  }\n  getPortLabelMarkup(label) {\n    return label.markup || this.cell.portLabelMarkup;\n  }\n  existPortLabel(port) {\n    return port.attrs && port.attrs.text;\n  }\n  getEventArgs(e, x, y) {\n    const view = this; // eslint-disable-line\n    const node = view.cell;\n    const cell = node;\n    if (x == null || y == null) {\n      return {\n        e,\n        view,\n        node,\n        cell\n      };\n    }\n    return {\n      e,\n      x,\n      y,\n      view,\n      node,\n      cell\n    };\n  }\n  getPortEventArgs(e, port, pos) {\n    const view = this; // eslint-disable-line\n    const node = view.cell;\n    const cell = node;\n    if (pos) {\n      return {\n        e,\n        x: pos.x,\n        y: pos.y,\n        view,\n        node,\n        cell,\n        port\n      };\n    }\n    return {\n      e,\n      view,\n      node,\n      cell,\n      port\n    };\n  }\n  notifyMouseDown(e, x, y) {\n    super.onMouseDown(e, x, y);\n    this.notify('node:mousedown', this.getEventArgs(e, x, y));\n  }\n  notifyMouseMove(e, x, y) {\n    super.onMouseMove(e, x, y);\n    this.notify('node:mousemove', this.getEventArgs(e, x, y));\n  }\n  notifyMouseUp(e, x, y) {\n    super.onMouseUp(e, x, y);\n    this.notify('node:mouseup', this.getEventArgs(e, x, y));\n  }\n  notifyPortEvent(name, e, pos) {\n    const port = this.findAttr('port', e.target);\n    if (port) {\n      const originType = e.type;\n      if (name === 'node:port:mouseenter') {\n        e.type = 'mouseenter';\n      } else if (name === 'node:port:mouseleave') {\n        e.type = 'mouseleave';\n      }\n      this.notify(name, this.getPortEventArgs(e, port, pos));\n      e.type = originType;\n    }\n  }\n  onClick(e, x, y) {\n    super.onClick(e, x, y);\n    this.notify('node:click', this.getEventArgs(e, x, y));\n    this.notifyPortEvent('node:port:click', e, {\n      x,\n      y\n    });\n  }\n  onDblClick(e, x, y) {\n    super.onDblClick(e, x, y);\n    this.notify('node:dblclick', this.getEventArgs(e, x, y));\n    this.notifyPortEvent('node:port:dblclick', e, {\n      x,\n      y\n    });\n  }\n  onContextMenu(e, x, y) {\n    super.onContextMenu(e, x, y);\n    this.notify('node:contextmenu', this.getEventArgs(e, x, y));\n    this.notifyPortEvent('node:port:contextmenu', e, {\n      x,\n      y\n    });\n  }\n  onMouseDown(e, x, y) {\n    if (this.isPropagationStopped(e)) {\n      return;\n    }\n    this.notifyMouseDown(e, x, y);\n    this.notifyPortEvent('node:port:mousedown', e, {\n      x,\n      y\n    });\n    this.startNodeDragging(e, x, y);\n  }\n  onMouseMove(e, x, y) {\n    const data = this.getEventData(e);\n    const action = data.action;\n    if (action === 'magnet') {\n      this.dragMagnet(e, x, y);\n    } else {\n      if (action === 'move') {\n        const meta = data;\n        const view = meta.targetView || this;\n        view.dragNode(e, x, y);\n        view.notify('node:moving', {\n          e,\n          x,\n          y,\n          view,\n          cell: view.cell,\n          node: view.cell\n        });\n      }\n      this.notifyMouseMove(e, x, y);\n      this.notifyPortEvent('node:port:mousemove', e, {\n        x,\n        y\n      });\n    }\n    this.setEventData(e, data);\n  }\n  onMouseUp(e, x, y) {\n    const data = this.getEventData(e);\n    const action = data.action;\n    if (action === 'magnet') {\n      this.stopMagnetDragging(e, x, y);\n    } else {\n      this.notifyMouseUp(e, x, y);\n      this.notifyPortEvent('node:port:mouseup', e, {\n        x,\n        y\n      });\n      if (action === 'move') {\n        const meta = data;\n        const view = meta.targetView || this;\n        view.stopNodeDragging(e, x, y);\n      }\n    }\n    const magnet = data.targetMagnet;\n    if (magnet) {\n      this.onMagnetClick(e, magnet, x, y);\n    }\n    this.checkMouseleave(e);\n  }\n  onMouseOver(e) {\n    super.onMouseOver(e);\n    this.notify('node:mouseover', this.getEventArgs(e));\n    // mock mouseenter event,so we can get correct trigger time when move mouse from node to port\n    // wo also need to change e.type for use get correct event args\n    this.notifyPortEvent('node:port:mouseenter', e);\n    this.notifyPortEvent('node:port:mouseover', e);\n  }\n  onMouseOut(e) {\n    super.onMouseOut(e);\n    this.notify('node:mouseout', this.getEventArgs(e));\n    // mock mouseleave event,so we can get correct trigger time when move mouse from port to node\n    // wo also need to change e.type for use get correct event args\n    this.notifyPortEvent('node:port:mouseleave', e);\n    this.notifyPortEvent('node:port:mouseout', e);\n  }\n  onMouseEnter(e) {\n    this.updateClassName(e);\n    super.onMouseEnter(e);\n    this.notify('node:mouseenter', this.getEventArgs(e));\n  }\n  onMouseLeave(e) {\n    super.onMouseLeave(e);\n    this.notify('node:mouseleave', this.getEventArgs(e));\n  }\n  onMouseWheel(e, x, y, delta) {\n    super.onMouseWheel(e, x, y, delta);\n    this.notify('node:mousewheel', Object.assign({\n      delta\n    }, this.getEventArgs(e, x, y)));\n  }\n  onMagnetClick(e, magnet, x, y) {\n    const graph = this.graph;\n    const count = graph.view.getMouseMovedCount(e);\n    if (count > graph.options.clickThreshold) {\n      return;\n    }\n    this.notify('node:magnet:click', Object.assign({\n      magnet\n    }, this.getEventArgs(e, x, y)));\n  }\n  onMagnetDblClick(e, magnet, x, y) {\n    this.notify('node:magnet:dblclick', Object.assign({\n      magnet\n    }, this.getEventArgs(e, x, y)));\n  }\n  onMagnetContextMenu(e, magnet, x, y) {\n    this.notify('node:magnet:contextmenu', Object.assign({\n      magnet\n    }, this.getEventArgs(e, x, y)));\n  }\n  onMagnetMouseDown(e, magnet, x, y) {\n    this.startMagnetDragging(e, x, y);\n  }\n  onCustomEvent(e, name, x, y) {\n    this.notify('node:customevent', Object.assign({\n      name\n    }, this.getEventArgs(e, x, y)));\n    super.onCustomEvent(e, name, x, y);\n  }\n  prepareEmbedding(e) {\n    const graph = this.graph;\n    const data = this.getEventData(e);\n    const node = data.cell || this.cell;\n    const view = graph.findViewByCell(node);\n    const localPoint = graph.snapToGrid(e.clientX, e.clientY);\n    this.notify('node:embed', {\n      e,\n      node,\n      view,\n      cell: node,\n      x: localPoint.x,\n      y: localPoint.y,\n      currentParent: node.getParent()\n    });\n  }\n  processEmbedding(e, data) {\n    const cell = data.cell || this.cell;\n    const graph = data.graph || this.graph;\n    const options = graph.options.embedding;\n    const findParent = options.findParent;\n    let candidates = typeof findParent === 'function' ? FunctionExt.call(findParent, graph, {\n      view: this,\n      node: this.cell\n    }).filter(c => {\n      return Cell.isCell(c) && this.cell.id !== c.id && !c.isDescendantOf(this.cell);\n    }) : graph.model.getNodesUnderNode(cell, {\n      by: findParent\n    });\n    // Picks the node with the highest `z` index\n    if (options.frontOnly) {\n      if (candidates.length > 0) {\n        const zIndexMap = ArrayExt.groupBy(candidates, 'zIndex');\n        const maxZIndex = ArrayExt.max(Object.keys(zIndexMap).map(z => parseInt(z, 10)));\n        if (maxZIndex) {\n          candidates = zIndexMap[maxZIndex];\n        }\n      }\n    }\n    // Filter the nodes which is invisiable\n    candidates = candidates.filter(candidate => candidate.visible);\n    let newCandidateView = null;\n    const prevCandidateView = data.candidateEmbedView;\n    const validateEmbeding = options.validate;\n    for (let i = candidates.length - 1; i >= 0; i -= 1) {\n      const candidate = candidates[i];\n      if (prevCandidateView && prevCandidateView.cell.id === candidate.id) {\n        // candidate remains the same\n        newCandidateView = prevCandidateView;\n        break;\n      } else {\n        const view = candidate.findView(graph);\n        if (validateEmbeding && FunctionExt.call(validateEmbeding, graph, {\n          child: this.cell,\n          parent: view.cell,\n          childView: this,\n          parentView: view\n        })) {\n          // flip to the new candidate\n          newCandidateView = view;\n          break;\n        }\n      }\n    }\n    this.clearEmbedding(data);\n    if (newCandidateView) {\n      newCandidateView.highlight(null, {\n        type: 'embedding'\n      });\n    }\n    data.candidateEmbedView = newCandidateView;\n    const localPoint = graph.snapToGrid(e.clientX, e.clientY);\n    this.notify('node:embedding', {\n      e,\n      cell,\n      node: cell,\n      view: graph.findViewByCell(cell),\n      x: localPoint.x,\n      y: localPoint.y,\n      currentParent: cell.getParent(),\n      candidateParent: newCandidateView ? newCandidateView.cell : null\n    });\n  }\n  clearEmbedding(data) {\n    const candidateView = data.candidateEmbedView;\n    if (candidateView) {\n      candidateView.unhighlight(null, {\n        type: 'embedding'\n      });\n      data.candidateEmbedView = null;\n    }\n  }\n  finalizeEmbedding(e, data) {\n    this.graph.startBatch('embedding');\n    const cell = data.cell || this.cell;\n    const graph = data.graph || this.graph;\n    const view = graph.findViewByCell(cell);\n    const parent = cell.getParent();\n    const candidateView = data.candidateEmbedView;\n    if (candidateView) {\n      // Candidate view is chosen to become the parent of the node.\n      candidateView.unhighlight(null, {\n        type: 'embedding'\n      });\n      data.candidateEmbedView = null;\n      if (parent == null || parent.id !== candidateView.cell.id) {\n        candidateView.cell.insertChild(cell, undefined, {\n          ui: true\n        });\n      }\n    } else if (parent) {\n      parent.unembed(cell, {\n        ui: true\n      });\n    }\n    graph.model.getConnectedEdges(cell, {\n      deep: true\n    }).forEach(edge => {\n      edge.updateParent({\n        ui: true\n      });\n    });\n    if (view && candidateView) {\n      const localPoint = graph.snapToGrid(e.clientX, e.clientY);\n      view.notify('node:embedded', {\n        e,\n        cell,\n        x: localPoint.x,\n        y: localPoint.y,\n        node: cell,\n        view: graph.findViewByCell(cell),\n        previousParent: parent,\n        currentParent: cell.getParent()\n      });\n    }\n    this.graph.stopBatch('embedding');\n  }\n  getDelegatedView() {\n    let cell = this.cell;\n    let view = this; // eslint-disable-line\n    while (view) {\n      if (cell.isEdge()) {\n        break;\n      }\n      if (!cell.hasParent() || view.can('stopDelegateOnDragging')) {\n        return view;\n      }\n      cell = cell.getParent();\n      view = this.graph.findViewByCell(cell);\n    }\n    return null;\n  }\n  validateMagnet(cellView, magnet, e) {\n    if (magnet.getAttribute('magnet') !== 'passive') {\n      const validate = this.graph.options.connecting.validateMagnet;\n      if (validate) {\n        return FunctionExt.call(validate, this.graph, {\n          e,\n          magnet,\n          view: cellView,\n          cell: cellView.cell\n        });\n      }\n      return true;\n    }\n    return false;\n  }\n  startMagnetDragging(e, x, y) {\n    if (!this.can('magnetConnectable')) {\n      return;\n    }\n    e.stopPropagation();\n    const magnet = e.currentTarget;\n    const graph = this.graph;\n    this.setEventData(e, {\n      targetMagnet: magnet\n    });\n    if (this.validateMagnet(this, magnet, e)) {\n      if (graph.options.magnetThreshold <= 0) {\n        this.startConnectting(e, magnet, x, y);\n      }\n      this.setEventData(e, {\n        action: 'magnet'\n      });\n      this.stopPropagation(e);\n    } else {\n      this.onMouseDown(e, x, y);\n    }\n    graph.view.delegateDragEvents(e, this);\n  }\n  startConnectting(e, magnet, x, y) {\n    this.graph.model.startBatch('add-edge');\n    const edgeView = this.createEdgeFromMagnet(magnet, x, y);\n    edgeView.setEventData(e, edgeView.prepareArrowheadDragging('target', {\n      x,\n      y,\n      isNewEdge: true,\n      fallbackAction: 'remove'\n    }));\n    this.setEventData(e, {\n      edgeView\n    });\n    edgeView.notifyMouseDown(e, x, y);\n  }\n  getDefaultEdge(sourceView, sourceMagnet) {\n    let edge;\n    const create = this.graph.options.connecting.createEdge;\n    if (create) {\n      edge = FunctionExt.call(create, this.graph, {\n        sourceMagnet,\n        sourceView,\n        sourceCell: sourceView.cell\n      });\n    }\n    return edge;\n  }\n  createEdgeFromMagnet(magnet, x, y) {\n    const graph = this.graph;\n    const model = graph.model;\n    const edge = this.getDefaultEdge(this, magnet);\n    edge.setSource(Object.assign(Object.assign({}, edge.getSource()), this.getEdgeTerminal(magnet, x, y, edge, 'source')));\n    edge.setTarget(Object.assign(Object.assign({}, edge.getTarget()), {\n      x,\n      y\n    }));\n    edge.addTo(model, {\n      async: false,\n      ui: true\n    });\n    return edge.findView(graph);\n  }\n  dragMagnet(e, x, y) {\n    const data = this.getEventData(e);\n    const edgeView = data.edgeView;\n    if (edgeView) {\n      edgeView.onMouseMove(e, x, y);\n      this.autoScrollGraph(e.clientX, e.clientY);\n    } else {\n      const graph = this.graph;\n      const magnetThreshold = graph.options.magnetThreshold;\n      const currentTarget = this.getEventTarget(e);\n      const targetMagnet = data.targetMagnet;\n      // magnetThreshold when the pointer leaves the magnet\n      if (magnetThreshold === 'onleave') {\n        if (targetMagnet === currentTarget || targetMagnet.contains(currentTarget)) {\n          return;\n        }\n        // eslint-disable-next-line no-lonely-if\n      } else {\n        // magnetThreshold defined as a number of movements\n        if (graph.view.getMouseMovedCount(e) <= magnetThreshold) {\n          return;\n        }\n      }\n      this.startConnectting(e, targetMagnet, x, y);\n    }\n  }\n  stopMagnetDragging(e, x, y) {\n    const data = this.eventData(e);\n    const edgeView = data.edgeView;\n    if (edgeView) {\n      edgeView.onMouseUp(e, x, y);\n      this.graph.model.stopBatch('add-edge');\n    }\n  }\n  notifyUnhandledMouseDown(e, x, y) {\n    this.notify('node:unhandled:mousedown', {\n      e,\n      x,\n      y,\n      view: this,\n      cell: this.cell,\n      node: this.cell\n    });\n  }\n  notifyNodeMove(name, e, x, y, cell) {\n    let cells = [cell];\n    const selection = this.graph.getPlugin('selection');\n    if (selection && selection.isSelectionMovable()) {\n      const selectedCells = selection.getSelectedCells();\n      if (selectedCells.includes(cell)) {\n        cells = selectedCells.filter(c => c.isNode());\n      }\n    }\n    cells.forEach(c => {\n      this.notify(name, {\n        e,\n        x,\n        y,\n        cell: c,\n        node: c,\n        view: c.findView(this.graph)\n      });\n    });\n  }\n  getRestrictArea(view) {\n    const restrict = this.graph.options.translating.restrict;\n    const area = typeof restrict === 'function' ? FunctionExt.call(restrict, this.graph, view) : restrict;\n    if (typeof area === 'number') {\n      return this.graph.transform.getGraphArea().inflate(area);\n    }\n    if (area === true) {\n      return this.graph.transform.getGraphArea();\n    }\n    return area || null;\n  }\n  startNodeDragging(e, x, y) {\n    const targetView = this.getDelegatedView();\n    if (targetView == null || !targetView.can('nodeMovable')) {\n      return this.notifyUnhandledMouseDown(e, x, y);\n    }\n    this.setEventData(e, {\n      targetView,\n      action: 'move'\n    });\n    const position = Point.create(targetView.cell.getPosition());\n    targetView.setEventData(e, {\n      moving: false,\n      offset: position.diff(x, y),\n      restrict: this.getRestrictArea(targetView)\n    });\n  }\n  dragNode(e, x, y) {\n    const node = this.cell;\n    const graph = this.graph;\n    const gridSize = graph.getGridSize();\n    const data = this.getEventData(e);\n    const offset = data.offset;\n    const restrict = data.restrict;\n    if (!data.moving) {\n      data.moving = true;\n      this.addClass('node-moving');\n      this.notifyNodeMove('node:move', e, x, y, this.cell);\n    }\n    this.autoScrollGraph(e.clientX, e.clientY);\n    const posX = GeometryUtil.snapToGrid(x + offset.x, gridSize);\n    const posY = GeometryUtil.snapToGrid(y + offset.y, gridSize);\n    node.setPosition(posX, posY, {\n      restrict,\n      deep: true,\n      ui: true\n    });\n    if (graph.options.embedding.enabled) {\n      if (!data.embedding) {\n        this.prepareEmbedding(e);\n        data.embedding = true;\n      }\n      this.processEmbedding(e, data);\n    }\n  }\n  stopNodeDragging(e, x, y) {\n    const data = this.getEventData(e);\n    if (data.embedding) {\n      this.finalizeEmbedding(e, data);\n    }\n    if (data.moving) {\n      this.removeClass('node-moving');\n      this.notifyNodeMove('node:moved', e, x, y, this.cell);\n    }\n    data.moving = false;\n    data.embedding = false;\n  }\n  // eslint-disable-next-line\n  autoScrollGraph(x, y) {\n    const scroller = this.graph.getPlugin('scroller');\n    if (scroller) {\n      scroller.autoScroll(x, y);\n    }\n  }\n}\n(function (NodeView) {\n  NodeView.toStringTag = `X6.${NodeView.name}`;\n  function isNodeView(instance) {\n    if (instance == null) {\n      return false;\n    }\n    if (instance instanceof NodeView) {\n      return true;\n    }\n    const tag = instance[Symbol.toStringTag];\n    const view = instance;\n    if ((tag == null || tag === NodeView.toStringTag) && typeof view.isNodeView === 'function' && typeof view.isEdgeView === 'function' && typeof view.confirmUpdate === 'function' && typeof view.update === 'function' && typeof view.findPortElem === 'function' && typeof view.resize === 'function' && typeof view.rotate === 'function' && typeof view.translate === 'function') {\n      return true;\n    }\n    return false;\n  }\n  NodeView.isNodeView = isNodeView;\n})(NodeView || (NodeView = {}));\nNodeView.config({\n  isSvgElement: true,\n  priority: 0,\n  bootstrap: ['render'],\n  actions: {\n    view: ['render'],\n    markup: ['render'],\n    attrs: ['update'],\n    size: ['resize', 'ports', 'tools'],\n    angle: ['rotate', 'tools'],\n    position: ['translate', 'tools'],\n    ports: ['ports'],\n    tools: ['tools']\n  }\n});\nNodeView.registry.register('node', NodeView, true);","map":{"version":3,"names":["ArrayExt","FunctionExt","Dom","Rectangle","Point","GeometryUtil","Config","Cell","CellView","Markup","NodeView","constructor","portsCache","Symbol","toStringTag","getContainerClassName","classList","prefixClassName","can","push","join","updateClassName","e","target","hasAttribute","className","removeClass","addClass","isNodeView","confirmUpdate","flag","options","ret","hasAction","removePorts","cleanPortsCache","render","removeAction","handleAction","resize","update","useCSSSelector","translate","rotate","renderPorts","getFlag","renderTools","updateTools","partialAttrs","cleanCache","node","cell","size","getSize","attrs","getAttrs","updateAttrs","container","rootBBox","width","height","selectors","renderMarkup","markup","TypeError","renderJSONMarkup","parseJSONMarkup","appendChild","fragment","empty","updateTransform","getAngle","getTranslationString","position","getPosition","x","y","getRotationString","angle","transform","rot","setAttribute","findPortElem","portId","selector","cache","portRoot","portContentElement","portSelectors","portContentSelectors","findOne","Object","values","forEach","cached","remove","portElement","references","childNodes","child","parsedPorts","getParsedPorts","portsGropsByZ","groupBy","autoZIndexKey","port","getPortElement","append","keys","key","zIndex","parseInt","appendPorts","updatePorts","ports","refs","elems","map","p","before","Math","max","id","createPortElement","renderResult","getPortContainerMarkup","elem","Error","getPortMarkup","setAttrs","group","portClass","portLabelElement","portLabelSelectors","existLabel","existPortLabel","getPortLabelMarkup","label","rootSelector","assign","graph","onPortRendered","labelContainer","labelSelectors","contentContainer","contentSelectors","groups","getParsedGroups","groupList","length","updatePortGroup","groupName","bbox","fromSize","metrics","getPortsLayoutByGroup","i","n","metric","portLayout","applyPortTransform","portAttrs","portSize","labelLayout","labelSize","element","layout","initialAngle","matrix","createSVGMatrix","absolute","portMarkup","portLabelMarkup","text","getEventArgs","view","getPortEventArgs","pos","notifyMouseDown","onMouseDown","notify","notifyMouseMove","onMouseMove","notifyMouseUp","onMouseUp","notifyPortEvent","name","findAttr","originType","type","onClick","onDblClick","onContextMenu","isPropagationStopped","startNodeDragging","data","getEventData","action","dragMagnet","meta","targetView","dragNode","setEventData","stopMagnetDragging","stopNodeDragging","magnet","targetMagnet","onMagnetClick","checkMouseleave","onMouseOver","onMouseOut","onMouseEnter","onMouseLeave","onMouseWheel","delta","count","getMouseMovedCount","clickThreshold","onMagnetDblClick","onMagnetContextMenu","onMagnetMouseDown","startMagnetDragging","onCustomEvent","prepareEmbedding","findViewByCell","localPoint","snapToGrid","clientX","clientY","currentParent","getParent","processEmbedding","embedding","findParent","candidates","call","filter","c","isCell","isDescendantOf","model","getNodesUnderNode","by","frontOnly","zIndexMap","maxZIndex","z","candidate","visible","newCandidateView","prevCandidateView","candidateEmbedView","validateEmbeding","validate","findView","parent","childView","parentView","clearEmbedding","highlight","candidateParent","candidateView","unhighlight","finalizeEmbedding","startBatch","insertChild","undefined","ui","unembed","getConnectedEdges","deep","edge","updateParent","previousParent","stopBatch","getDelegatedView","isEdge","hasParent","validateMagnet","cellView","getAttribute","connecting","stopPropagation","currentTarget","magnetThreshold","startConnectting","delegateDragEvents","edgeView","createEdgeFromMagnet","prepareArrowheadDragging","isNewEdge","fallbackAction","getDefaultEdge","sourceView","sourceMagnet","create","createEdge","sourceCell","setSource","getSource","getEdgeTerminal","setTarget","getTarget","addTo","async","autoScrollGraph","getEventTarget","contains","eventData","notifyUnhandledMouseDown","notifyNodeMove","cells","selection","getPlugin","isSelectionMovable","selectedCells","getSelectedCells","includes","isNode","getRestrictArea","restrict","translating","area","getGraphArea","inflate","moving","offset","diff","gridSize","getGridSize","posX","posY","setPosition","enabled","scroller","autoScroll","instance","tag","isEdgeView","config","isSvgElement","priority","bootstrap","actions","tools","registry","register"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/src/view/node.ts"],"sourcesContent":["import { ArrayExt, FunctionExt, Dom } from '@antv/x6-common'\nimport { Rectangle, Point, GeometryUtil } from '@antv/x6-geometry'\nimport { Config } from '../config'\nimport { Attr, PortLayout } from '../registry'\nimport { Cell } from '../model/cell'\nimport { Node } from '../model/node'\nimport { Edge } from '../model/edge'\nimport { PortManager } from '../model/port'\nimport { CellView } from './cell'\nimport { EdgeView } from './edge'\nimport { Markup } from './markup'\nimport { AttrManager } from './attr'\nimport { Graph } from '../graph'\n\nexport class NodeView<\n  Entity extends Node = Node,\n  Options extends NodeView.Options = NodeView.Options,\n> extends CellView<Entity, Options> {\n  protected portsCache: { [id: string]: NodeView.PortCache } = {}\n\n  protected get [Symbol.toStringTag]() {\n    return NodeView.toStringTag\n  }\n\n  protected getContainerClassName() {\n    const classList = [\n      super.getContainerClassName(),\n      this.prefixClassName('node'),\n    ]\n    if (!this.can('nodeMovable')) {\n      classList.push(this.prefixClassName('node-immovable'))\n    }\n    return classList.join(' ')\n  }\n\n  protected updateClassName(e: Dom.MouseEnterEvent) {\n    const target = e.target\n    if (target.hasAttribute('magnet')) {\n      // port\n      const className = this.prefixClassName('port-unconnectable')\n      if (this.can('magnetConnectable')) {\n        Dom.removeClass(target, className)\n      } else {\n        Dom.addClass(target, className)\n      }\n    } else {\n      // node\n      const className = this.prefixClassName('node-immovable')\n      if (this.can('nodeMovable')) {\n        this.removeClass(className)\n      } else {\n        this.addClass(className)\n      }\n    }\n  }\n\n  isNodeView(): this is NodeView {\n    return true\n  }\n\n  confirmUpdate(flag: number, options: any = {}) {\n    let ret = flag\n    if (this.hasAction(ret, 'ports')) {\n      this.removePorts()\n      this.cleanPortsCache()\n    }\n\n    if (this.hasAction(ret, 'render')) {\n      this.render()\n      ret = this.removeAction(ret, [\n        'render',\n        'update',\n        'resize',\n        'translate',\n        'rotate',\n        'ports',\n        'tools',\n      ])\n    } else {\n      ret = this.handleAction(\n        ret,\n        'resize',\n        () => this.resize(),\n        'update', // Resize method is calling `update()` internally\n      )\n\n      ret = this.handleAction(\n        ret,\n        'update',\n        () => this.update(),\n        // `update()` will render ports when useCSSSelectors are enabled\n        Config.useCSSSelector ? 'ports' : null,\n      )\n\n      ret = this.handleAction(ret, 'translate', () => this.translate())\n      ret = this.handleAction(ret, 'rotate', () => this.rotate())\n      ret = this.handleAction(ret, 'ports', () => this.renderPorts())\n      ret = this.handleAction(ret, 'tools', () => {\n        if (this.getFlag('tools') === flag) {\n          this.renderTools()\n        } else {\n          this.updateTools(options)\n        }\n      })\n    }\n\n    return ret\n  }\n\n  update(partialAttrs?: Attr.CellAttrs) {\n    this.cleanCache()\n\n    // When CSS selector strings are used, make sure no rule matches port nodes.\n    if (Config.useCSSSelector) {\n      this.removePorts()\n    }\n\n    const node = this.cell\n    const size = node.getSize()\n    const attrs = node.getAttrs()\n    this.updateAttrs(this.container, attrs, {\n      attrs: partialAttrs === attrs ? null : partialAttrs,\n      rootBBox: new Rectangle(0, 0, size.width, size.height),\n      selectors: this.selectors,\n    })\n\n    if (Config.useCSSSelector) {\n      this.renderPorts()\n    }\n  }\n\n  protected renderMarkup() {\n    const markup = this.cell.markup\n    if (markup) {\n      if (typeof markup === 'string') {\n        throw new TypeError('Not support string markup.')\n      }\n\n      return this.renderJSONMarkup(markup)\n    }\n\n    throw new TypeError('Invalid node markup.')\n  }\n\n  protected renderJSONMarkup(markup: Markup.JSONMarkup | Markup.JSONMarkup[]) {\n    const ret = this.parseJSONMarkup(markup, this.container)\n    this.selectors = ret.selectors\n    this.container.appendChild(ret.fragment)\n  }\n\n  render() {\n    this.empty()\n    this.renderMarkup()\n\n    this.resize()\n    this.updateTransform()\n\n    if (!Config.useCSSSelector) {\n      this.renderPorts()\n    }\n\n    this.renderTools()\n\n    return this\n  }\n\n  resize() {\n    if (this.cell.getAngle()) {\n      this.rotate()\n    }\n\n    this.update()\n  }\n\n  translate() {\n    this.updateTransform()\n  }\n\n  rotate() {\n    this.updateTransform()\n  }\n\n  protected getTranslationString() {\n    const position = this.cell.getPosition()\n    return `translate(${position.x},${position.y})`\n  }\n\n  protected getRotationString() {\n    const angle = this.cell.getAngle()\n    if (angle) {\n      const size = this.cell.getSize()\n      return `rotate(${angle},${size.width / 2},${size.height / 2})`\n    }\n  }\n\n  protected updateTransform() {\n    let transform = this.getTranslationString()\n    const rot = this.getRotationString()\n    if (rot) {\n      transform += ` ${rot}`\n    }\n    this.container.setAttribute('transform', transform)\n  }\n\n  // #region ports\n\n  findPortElem(portId?: string, selector?: string) {\n    const cache = portId ? this.portsCache[portId] : null\n    if (!cache) {\n      return null\n    }\n    const portRoot = cache.portContentElement\n    const portSelectors = cache.portContentSelectors || {}\n    return this.findOne(selector, portRoot, portSelectors)\n  }\n\n  protected cleanPortsCache() {\n    this.portsCache = {}\n  }\n\n  protected removePorts() {\n    Object.values(this.portsCache).forEach((cached) => {\n      Dom.remove(cached.portElement)\n    })\n  }\n\n  protected renderPorts() {\n    const container = this.container\n    // References to rendered elements without z-index\n    const references: Element[] = []\n    container.childNodes.forEach((child) => {\n      references.push(child as Element)\n    })\n    const parsedPorts = this.cell.getParsedPorts()\n    const portsGropsByZ = ArrayExt.groupBy(parsedPorts, 'zIndex')\n    const autoZIndexKey = 'auto'\n\n    // render non-z first\n    if (portsGropsByZ[autoZIndexKey]) {\n      portsGropsByZ[autoZIndexKey].forEach((port) => {\n        const portElement = this.getPortElement(port)\n        container.append(portElement)\n        references.push(portElement)\n      })\n    }\n\n    Object.keys(portsGropsByZ).forEach((key) => {\n      if (key !== autoZIndexKey) {\n        const zIndex = parseInt(key, 10)\n        this.appendPorts(portsGropsByZ[key], zIndex, references)\n      }\n    })\n\n    this.updatePorts()\n  }\n\n  protected appendPorts(\n    ports: PortManager.Port[],\n    zIndex: number,\n    refs: Element[],\n  ) {\n    const elems = ports.map((p) => this.getPortElement(p))\n    if (refs[zIndex] || zIndex < 0) {\n      Dom.before(refs[Math.max(zIndex, 0)], elems)\n    } else {\n      Dom.append(this.container, elems)\n    }\n  }\n\n  protected getPortElement(port: PortManager.Port) {\n    const cached = this.portsCache[port.id]\n    if (cached) {\n      return cached.portElement\n    }\n\n    return this.createPortElement(port)\n  }\n\n  protected createPortElement(port: PortManager.Port) {\n    let renderResult = Markup.renderMarkup(this.cell.getPortContainerMarkup())\n    const portElement = renderResult.elem\n    if (portElement == null) {\n      throw new Error('Invalid port container markup.')\n    }\n\n    renderResult = Markup.renderMarkup(this.getPortMarkup(port))\n    const portContentElement = renderResult.elem\n    const portContentSelectors = renderResult.selectors\n\n    if (portContentElement == null) {\n      throw new Error('Invalid port markup.')\n    }\n\n    this.setAttrs(\n      {\n        port: port.id,\n        'port-group': port.group,\n      },\n      portContentElement,\n    )\n\n    let portClass = 'x6-port'\n    if (port.group) {\n      portClass += ` x6-port-${port.group}`\n    }\n    Dom.addClass(portElement, portClass)\n    Dom.addClass(portElement, 'x6-port')\n    Dom.addClass(portContentElement, 'x6-port-body')\n    portElement.appendChild(portContentElement)\n\n    let portSelectors: Markup.Selectors | undefined = portContentSelectors\n    let portLabelElement: Element | undefined\n    let portLabelSelectors: Markup.Selectors | null | undefined\n    const existLabel = this.existPortLabel(port)\n    if (existLabel) {\n      renderResult = Markup.renderMarkup(this.getPortLabelMarkup(port.label))\n      portLabelElement = renderResult.elem\n      portLabelSelectors = renderResult.selectors\n      if (portLabelElement == null) {\n        throw new Error('Invalid port label markup.')\n      }\n      if (portContentSelectors && portLabelSelectors) {\n        // eslint-disable-next-line\n        for (const key in portLabelSelectors) {\n          if (portContentSelectors[key] && key !== this.rootSelector) {\n            throw new Error('Selectors within port must be unique.')\n          }\n        }\n        portSelectors = {\n          ...portContentSelectors,\n          ...portLabelSelectors,\n        }\n      }\n      Dom.addClass(portLabelElement, 'x6-port-label')\n      portElement.appendChild(portLabelElement)\n    }\n\n    this.portsCache[port.id] = {\n      portElement,\n      portSelectors,\n      portLabelElement,\n      portLabelSelectors,\n      portContentElement,\n      portContentSelectors,\n    }\n\n    if (this.graph.options.onPortRendered) {\n      this.graph.options.onPortRendered({\n        port,\n        node: this.cell,\n        container: portElement,\n        selectors: portSelectors,\n        labelContainer: portLabelElement,\n        labelSelectors: portLabelSelectors,\n        contentContainer: portContentElement,\n        contentSelectors: portContentSelectors,\n      })\n    }\n\n    return portElement\n  }\n\n  protected updatePorts() {\n    const groups = this.cell.getParsedGroups()\n    const groupList = Object.keys(groups)\n    if (groupList.length === 0) {\n      this.updatePortGroup()\n    } else {\n      groupList.forEach((groupName) => this.updatePortGroup(groupName))\n    }\n  }\n\n  protected updatePortGroup(groupName?: string) {\n    const bbox = Rectangle.fromSize(this.cell.getSize())\n    const metrics = this.cell.getPortsLayoutByGroup(groupName, bbox)\n\n    for (let i = 0, n = metrics.length; i < n; i += 1) {\n      const metric = metrics[i]\n      const portId = metric.portId\n      const cached = this.portsCache[portId] || {}\n      const portLayout = metric.portLayout\n      this.applyPortTransform(cached.portElement, portLayout)\n      if (metric.portAttrs != null) {\n        const options: Partial<AttrManager.UpdateOptions> = {\n          selectors: cached.portSelectors || {},\n        }\n\n        if (metric.portSize) {\n          options.rootBBox = Rectangle.fromSize(metric.portSize)\n        }\n\n        this.updateAttrs(cached.portElement, metric.portAttrs, options)\n      }\n\n      const labelLayout = metric.labelLayout\n      if (labelLayout && cached.portLabelElement) {\n        this.applyPortTransform(\n          cached.portLabelElement,\n          labelLayout,\n          -(portLayout.angle || 0),\n        )\n\n        if (labelLayout.attrs) {\n          const options: Partial<AttrManager.UpdateOptions> = {\n            selectors: cached.portLabelSelectors || {},\n          }\n\n          if (metric.labelSize) {\n            options.rootBBox = Rectangle.fromSize(metric.labelSize)\n          }\n\n          this.updateAttrs(cached.portLabelElement, labelLayout.attrs, options)\n        }\n      }\n    }\n  }\n\n  protected applyPortTransform(\n    element: Element,\n    layout: PortLayout.Result,\n    initialAngle = 0,\n  ) {\n    const angle = layout.angle\n    const position = layout.position\n    const matrix = Dom.createSVGMatrix()\n      .rotate(initialAngle)\n      .translate(position.x || 0, position.y || 0)\n      .rotate(angle || 0)\n\n    Dom.transform(element as SVGElement, matrix, { absolute: true })\n  }\n\n  protected getPortMarkup(port: PortManager.Port) {\n    return port.markup || this.cell.portMarkup\n  }\n\n  protected getPortLabelMarkup(label: PortManager.Label) {\n    return label.markup || this.cell.portLabelMarkup\n  }\n\n  protected existPortLabel(port: PortManager.Port) {\n    return port.attrs && port.attrs.text\n  }\n\n  // #endregion\n\n  // #region events\n\n  protected getEventArgs<E>(e: E): NodeView.MouseEventArgs<E>\n  protected getEventArgs<E>(\n    e: E,\n    x: number,\n    y: number,\n  ): NodeView.PositionEventArgs<E>\n  protected getEventArgs<E>(e: E, x?: number, y?: number) {\n    const view = this // eslint-disable-line\n    const node = view.cell\n    const cell = node\n    if (x == null || y == null) {\n      return { e, view, node, cell } as NodeView.MouseEventArgs<E>\n    }\n    return { e, x, y, view, node, cell } as NodeView.PositionEventArgs<E>\n  }\n\n  protected getPortEventArgs<E>(\n    e: E,\n    port: string,\n    pos?: { x: number; y: number },\n  ): NodeView.PositionEventArgs<E> | NodeView.MouseEventArgs<E> {\n    const view = this // eslint-disable-line\n    const node = view.cell\n    const cell = node\n    if (pos) {\n      return {\n        e,\n        x: pos.x,\n        y: pos.y,\n        view,\n        node,\n        cell,\n        port,\n      } as NodeView.PositionEventArgs<E>\n    }\n    return { e, view, node, cell, port } as NodeView.MouseEventArgs<E>\n  }\n\n  notifyMouseDown(e: Dom.MouseDownEvent, x: number, y: number) {\n    super.onMouseDown(e, x, y)\n    this.notify('node:mousedown', this.getEventArgs(e, x, y))\n  }\n\n  notifyMouseMove(e: Dom.MouseMoveEvent, x: number, y: number) {\n    super.onMouseMove(e, x, y)\n    this.notify('node:mousemove', this.getEventArgs(e, x, y))\n  }\n\n  notifyMouseUp(e: Dom.MouseUpEvent, x: number, y: number) {\n    super.onMouseUp(e, x, y)\n    this.notify('node:mouseup', this.getEventArgs(e, x, y))\n  }\n\n  notifyPortEvent(\n    name: string,\n    e: Dom.EventObject,\n    pos?: { x: number; y: number },\n  ) {\n    const port = this.findAttr('port', e.target)\n    if (port) {\n      const originType = e.type\n      if (name === 'node:port:mouseenter') {\n        e.type = 'mouseenter'\n      } else if (name === 'node:port:mouseleave') {\n        e.type = 'mouseleave'\n      }\n      this.notify(name, this.getPortEventArgs(e, port, pos))\n      e.type = originType\n    }\n  }\n\n  onClick(e: Dom.ClickEvent, x: number, y: number) {\n    super.onClick(e, x, y)\n    this.notify('node:click', this.getEventArgs(e, x, y))\n    this.notifyPortEvent('node:port:click', e, { x, y })\n  }\n\n  onDblClick(e: Dom.DoubleClickEvent, x: number, y: number) {\n    super.onDblClick(e, x, y)\n    this.notify('node:dblclick', this.getEventArgs(e, x, y))\n    this.notifyPortEvent('node:port:dblclick', e, { x, y })\n  }\n\n  onContextMenu(e: Dom.ContextMenuEvent, x: number, y: number) {\n    super.onContextMenu(e, x, y)\n    this.notify('node:contextmenu', this.getEventArgs(e, x, y))\n    this.notifyPortEvent('node:port:contextmenu', e, { x, y })\n  }\n\n  onMouseDown(e: Dom.MouseDownEvent, x: number, y: number) {\n    if (this.isPropagationStopped(e)) {\n      return\n    }\n    this.notifyMouseDown(e, x, y)\n    this.notifyPortEvent('node:port:mousedown', e, { x, y })\n    this.startNodeDragging(e, x, y)\n  }\n\n  onMouseMove(e: Dom.MouseMoveEvent, x: number, y: number) {\n    const data = this.getEventData<EventData.Mousemove>(e)\n    const action = data.action\n    if (action === 'magnet') {\n      this.dragMagnet(e, x, y)\n    } else {\n      if (action === 'move') {\n        const meta = data as EventData.Moving\n        const view = meta.targetView || this\n        view.dragNode(e, x, y)\n        view.notify('node:moving', {\n          e,\n          x,\n          y,\n          view,\n          cell: view.cell,\n          node: view.cell,\n        })\n      }\n      this.notifyMouseMove(e, x, y)\n      this.notifyPortEvent('node:port:mousemove', e, { x, y })\n    }\n\n    this.setEventData<EventData.Mousemove>(e, data)\n  }\n\n  onMouseUp(e: Dom.MouseUpEvent, x: number, y: number) {\n    const data = this.getEventData<EventData.Mousemove>(e)\n    const action = data.action\n    if (action === 'magnet') {\n      this.stopMagnetDragging(e, x, y)\n    } else {\n      this.notifyMouseUp(e, x, y)\n      this.notifyPortEvent('node:port:mouseup', e, { x, y })\n      if (action === 'move') {\n        const meta = data as EventData.Moving\n        const view = meta.targetView || this\n        view.stopNodeDragging(e, x, y)\n      }\n    }\n\n    const magnet = (data as EventData.Magnet).targetMagnet\n    if (magnet) {\n      this.onMagnetClick(e, magnet, x, y)\n    }\n\n    this.checkMouseleave(e)\n  }\n\n  onMouseOver(e: Dom.MouseOverEvent) {\n    super.onMouseOver(e)\n    this.notify('node:mouseover', this.getEventArgs(e))\n    // mock mouseenter event,so we can get correct trigger time when move mouse from node to port\n    // wo also need to change e.type for use get correct event args\n    this.notifyPortEvent('node:port:mouseenter', e)\n    this.notifyPortEvent('node:port:mouseover', e)\n  }\n\n  onMouseOut(e: Dom.MouseOutEvent) {\n    super.onMouseOut(e)\n    this.notify('node:mouseout', this.getEventArgs(e))\n    // mock mouseleave event,so we can get correct trigger time when move mouse from port to node\n    // wo also need to change e.type for use get correct event args\n    this.notifyPortEvent('node:port:mouseleave', e)\n    this.notifyPortEvent('node:port:mouseout', e)\n  }\n\n  onMouseEnter(e: Dom.MouseEnterEvent) {\n    this.updateClassName(e)\n    super.onMouseEnter(e)\n    this.notify('node:mouseenter', this.getEventArgs(e))\n  }\n\n  onMouseLeave(e: Dom.MouseLeaveEvent) {\n    super.onMouseLeave(e)\n    this.notify('node:mouseleave', this.getEventArgs(e))\n  }\n\n  onMouseWheel(e: Dom.EventObject, x: number, y: number, delta: number) {\n    super.onMouseWheel(e, x, y, delta)\n    this.notify('node:mousewheel', {\n      delta,\n      ...this.getEventArgs(e, x, y),\n    })\n  }\n\n  onMagnetClick(e: Dom.MouseUpEvent, magnet: Element, x: number, y: number) {\n    const graph = this.graph\n    const count = graph.view.getMouseMovedCount(e)\n    if (count > graph.options.clickThreshold) {\n      return\n    }\n    this.notify('node:magnet:click', {\n      magnet,\n      ...this.getEventArgs(e, x, y),\n    })\n  }\n\n  onMagnetDblClick(\n    e: Dom.DoubleClickEvent,\n    magnet: Element,\n    x: number,\n    y: number,\n  ) {\n    this.notify('node:magnet:dblclick', {\n      magnet,\n      ...this.getEventArgs(e, x, y),\n    })\n  }\n\n  onMagnetContextMenu(\n    e: Dom.ContextMenuEvent,\n    magnet: Element,\n    x: number,\n    y: number,\n  ) {\n    this.notify('node:magnet:contextmenu', {\n      magnet,\n      ...this.getEventArgs(e, x, y),\n    })\n  }\n\n  onMagnetMouseDown(\n    e: Dom.MouseDownEvent,\n    magnet: Element,\n    x: number,\n    y: number,\n  ) {\n    this.startMagnetDragging(e, x, y)\n  }\n\n  onCustomEvent(e: Dom.MouseDownEvent, name: string, x: number, y: number) {\n    this.notify('node:customevent', { name, ...this.getEventArgs(e, x, y) })\n    super.onCustomEvent(e, name, x, y)\n  }\n\n  protected prepareEmbedding(e: Dom.MouseMoveEvent) {\n    const graph = this.graph\n    const data = this.getEventData<EventData.MovingTargetNode>(e)\n    const node = data.cell || this.cell\n    const view = graph.findViewByCell(node)\n    const localPoint = graph.snapToGrid(e.clientX, e.clientY)\n\n    this.notify('node:embed', {\n      e,\n      node,\n      view,\n      cell: node,\n      x: localPoint.x,\n      y: localPoint.y,\n      currentParent: node.getParent(),\n    })\n  }\n\n  processEmbedding(e: Dom.MouseMoveEvent, data: EventData.MovingTargetNode) {\n    const cell = data.cell || this.cell\n    const graph = data.graph || this.graph\n    const options = graph.options.embedding\n    const findParent = options.findParent\n\n    let candidates =\n      typeof findParent === 'function'\n        ? (\n            FunctionExt.call(findParent, graph, {\n              view: this,\n              node: this.cell,\n            }) as Cell[]\n          ).filter((c) => {\n            return (\n              Cell.isCell(c) &&\n              this.cell.id !== c.id &&\n              !c.isDescendantOf(this.cell)\n            )\n          })\n        : graph.model.getNodesUnderNode(cell, {\n            by: findParent as Rectangle.KeyPoint,\n          })\n\n    // Picks the node with the highest `z` index\n    if (options.frontOnly) {\n      if (candidates.length > 0) {\n        const zIndexMap = ArrayExt.groupBy(candidates, 'zIndex')\n        const maxZIndex = ArrayExt.max(\n          Object.keys(zIndexMap).map((z) => parseInt(z, 10)),\n        )\n        if (maxZIndex) {\n          candidates = zIndexMap[maxZIndex]\n        }\n      }\n    }\n\n    // Filter the nodes which is invisiable\n    candidates = candidates.filter((candidate) => candidate.visible)\n\n    let newCandidateView = null\n    const prevCandidateView = data.candidateEmbedView\n    const validateEmbeding = options.validate\n    for (let i = candidates.length - 1; i >= 0; i -= 1) {\n      const candidate = candidates[i]\n\n      if (prevCandidateView && prevCandidateView.cell.id === candidate.id) {\n        // candidate remains the same\n        newCandidateView = prevCandidateView\n        break\n      } else {\n        const view = candidate.findView(graph) as NodeView\n        if (\n          validateEmbeding &&\n          FunctionExt.call(validateEmbeding, graph, {\n            child: this.cell,\n            parent: view.cell,\n            childView: this,\n            parentView: view,\n          })\n        ) {\n          // flip to the new candidate\n          newCandidateView = view\n          break\n        }\n      }\n    }\n\n    this.clearEmbedding(data)\n    if (newCandidateView) {\n      newCandidateView.highlight(null, { type: 'embedding' })\n    }\n    data.candidateEmbedView = newCandidateView\n\n    const localPoint = graph.snapToGrid(e.clientX, e.clientY)\n    this.notify('node:embedding', {\n      e,\n      cell,\n      node: cell,\n      view: graph.findViewByCell(cell),\n      x: localPoint.x,\n      y: localPoint.y,\n      currentParent: cell.getParent(),\n      candidateParent: newCandidateView ? newCandidateView.cell : null,\n    })\n  }\n\n  clearEmbedding(data: EventData.MovingTargetNode) {\n    const candidateView = data.candidateEmbedView\n    if (candidateView) {\n      candidateView.unhighlight(null, { type: 'embedding' })\n      data.candidateEmbedView = null\n    }\n  }\n\n  finalizeEmbedding(e: Dom.MouseUpEvent, data: EventData.MovingTargetNode) {\n    this.graph.startBatch('embedding')\n    const cell = data.cell || this.cell\n    const graph = data.graph || this.graph\n    const view = graph.findViewByCell(cell)\n    const parent = cell.getParent()\n    const candidateView = data.candidateEmbedView\n    if (candidateView) {\n      // Candidate view is chosen to become the parent of the node.\n      candidateView.unhighlight(null, { type: 'embedding' })\n      data.candidateEmbedView = null\n      if (parent == null || parent.id !== candidateView.cell.id) {\n        candidateView.cell.insertChild(cell, undefined, { ui: true })\n      }\n    } else if (parent) {\n      parent.unembed(cell, { ui: true })\n    }\n\n    graph.model.getConnectedEdges(cell, { deep: true }).forEach((edge) => {\n      edge.updateParent({ ui: true })\n    })\n\n    if (view && candidateView) {\n      const localPoint = graph.snapToGrid(e.clientX, e.clientY)\n      view.notify('node:embedded', {\n        e,\n        cell,\n        x: localPoint.x,\n        y: localPoint.y,\n        node: cell,\n        view: graph.findViewByCell(cell),\n        previousParent: parent,\n        currentParent: cell.getParent(),\n      })\n    }\n\n    this.graph.stopBatch('embedding')\n  }\n\n  getDelegatedView() {\n    let cell = this.cell\n    let view: NodeView = this // eslint-disable-line\n\n    while (view) {\n      if (cell.isEdge()) {\n        break\n      }\n      if (!cell.hasParent() || view.can('stopDelegateOnDragging')) {\n        return view\n      }\n      cell = cell.getParent() as Entity\n      view = this.graph.findViewByCell(cell) as NodeView\n    }\n\n    return null\n  }\n\n  protected validateMagnet(\n    cellView: CellView,\n    magnet: Element,\n    e: Dom.MouseDownEvent | Dom.MouseEnterEvent,\n  ) {\n    if (magnet.getAttribute('magnet') !== 'passive') {\n      const validate = this.graph.options.connecting.validateMagnet\n      if (validate) {\n        return FunctionExt.call(validate, this.graph, {\n          e,\n          magnet,\n          view: cellView,\n          cell: cellView.cell,\n        })\n      }\n      return true\n    }\n    return false\n  }\n\n  protected startMagnetDragging(e: Dom.MouseDownEvent, x: number, y: number) {\n    if (!this.can('magnetConnectable')) {\n      return\n    }\n\n    e.stopPropagation()\n\n    const magnet = e.currentTarget\n    const graph = this.graph\n\n    this.setEventData<Partial<EventData.Magnet>>(e, {\n      targetMagnet: magnet,\n    })\n\n    if (this.validateMagnet(this, magnet, e)) {\n      if (graph.options.magnetThreshold <= 0) {\n        this.startConnectting(e, magnet, x, y)\n      }\n\n      this.setEventData<Partial<EventData.Magnet>>(e, {\n        action: 'magnet',\n      })\n      this.stopPropagation(e)\n    } else {\n      this.onMouseDown(e, x, y)\n    }\n\n    graph.view.delegateDragEvents(e, this)\n  }\n\n  protected startConnectting(\n    e: Dom.MouseDownEvent,\n    magnet: Element,\n    x: number,\n    y: number,\n  ) {\n    this.graph.model.startBatch('add-edge')\n    const edgeView = this.createEdgeFromMagnet(magnet, x, y)\n    edgeView.setEventData(\n      e,\n      edgeView.prepareArrowheadDragging('target', {\n        x,\n        y,\n        isNewEdge: true,\n        fallbackAction: 'remove',\n      }),\n    )\n    this.setEventData<Partial<EventData.Magnet>>(e, { edgeView })\n    edgeView.notifyMouseDown(e, x, y)\n  }\n\n  protected getDefaultEdge(sourceView: CellView, sourceMagnet: Element) {\n    let edge: Edge | undefined | null | void\n\n    const create = this.graph.options.connecting.createEdge\n    if (create) {\n      edge = FunctionExt.call(create, this.graph, {\n        sourceMagnet,\n        sourceView,\n        sourceCell: sourceView.cell,\n      })\n    }\n\n    return edge as Edge\n  }\n\n  protected createEdgeFromMagnet(magnet: Element, x: number, y: number) {\n    const graph = this.graph\n    const model = graph.model\n    const edge = this.getDefaultEdge(this, magnet)\n\n    edge.setSource({\n      ...edge.getSource(),\n      ...this.getEdgeTerminal(magnet, x, y, edge, 'source'),\n    })\n    edge.setTarget({ ...edge.getTarget(), x, y })\n    edge.addTo(model, { async: false, ui: true })\n\n    return edge.findView(graph) as EdgeView\n  }\n\n  protected dragMagnet(e: Dom.MouseMoveEvent, x: number, y: number) {\n    const data = this.getEventData<EventData.Magnet>(e)\n    const edgeView = data.edgeView\n    if (edgeView) {\n      edgeView.onMouseMove(e, x, y)\n      this.autoScrollGraph(e.clientX, e.clientY)\n    } else {\n      const graph = this.graph\n      const magnetThreshold = graph.options.magnetThreshold as any\n      const currentTarget = this.getEventTarget(e)\n      const targetMagnet = data.targetMagnet\n\n      // magnetThreshold when the pointer leaves the magnet\n      if (magnetThreshold === 'onleave') {\n        if (\n          targetMagnet === currentTarget ||\n          targetMagnet.contains(currentTarget)\n        ) {\n          return\n        }\n        // eslint-disable-next-line no-lonely-if\n      } else {\n        // magnetThreshold defined as a number of movements\n        if (graph.view.getMouseMovedCount(e) <= magnetThreshold) {\n          return\n        }\n      }\n      this.startConnectting(e as any, targetMagnet, x, y)\n    }\n  }\n\n  protected stopMagnetDragging(e: Dom.MouseUpEvent, x: number, y: number) {\n    const data = this.eventData<EventData.Magnet>(e)\n    const edgeView = data.edgeView\n    if (edgeView) {\n      edgeView.onMouseUp(e, x, y)\n      this.graph.model.stopBatch('add-edge')\n    }\n  }\n\n  protected notifyUnhandledMouseDown(\n    e: Dom.MouseDownEvent,\n    x: number,\n    y: number,\n  ) {\n    this.notify('node:unhandled:mousedown', {\n      e,\n      x,\n      y,\n      view: this,\n      cell: this.cell,\n      node: this.cell,\n    })\n  }\n\n  protected notifyNodeMove<Key extends keyof NodeView.EventArgs>(\n    name: Key,\n    e: Dom.MouseMoveEvent | Dom.MouseUpEvent,\n    x: number,\n    y: number,\n    cell: Cell,\n  ) {\n    let cells = [cell]\n\n    const selection = this.graph.getPlugin<any>('selection')\n    if (selection && selection.isSelectionMovable()) {\n      const selectedCells = selection.getSelectedCells()\n      if (selectedCells.includes(cell)) {\n        cells = selectedCells.filter((c: Cell) => c.isNode())\n      }\n    }\n\n    cells.forEach((c: Cell) => {\n      this.notify(name, {\n        e,\n        x,\n        y,\n        cell: c,\n        node: c,\n        view: c.findView(this.graph),\n      })\n    })\n  }\n\n  protected getRestrictArea(view?: NodeView): Rectangle.RectangleLike | null {\n    const restrict = this.graph.options.translating.restrict\n    const area =\n      typeof restrict === 'function'\n        ? FunctionExt.call(restrict, this.graph, view!)\n        : restrict\n\n    if (typeof area === 'number') {\n      return this.graph.transform.getGraphArea().inflate(area)\n    }\n\n    if (area === true) {\n      return this.graph.transform.getGraphArea()\n    }\n\n    return area || null\n  }\n\n  protected startNodeDragging(e: Dom.MouseDownEvent, x: number, y: number) {\n    const targetView = this.getDelegatedView()\n    if (targetView == null || !targetView.can('nodeMovable')) {\n      return this.notifyUnhandledMouseDown(e, x, y)\n    }\n\n    this.setEventData<EventData.Moving>(e, {\n      targetView,\n      action: 'move',\n    })\n\n    const position = Point.create(targetView.cell.getPosition())\n    targetView.setEventData<EventData.MovingTargetNode>(e, {\n      moving: false,\n      offset: position.diff(x, y),\n      restrict: this.getRestrictArea(targetView),\n    })\n  }\n\n  protected dragNode(e: Dom.MouseMoveEvent, x: number, y: number) {\n    const node = this.cell\n    const graph = this.graph\n    const gridSize = graph.getGridSize()\n    const data = this.getEventData<EventData.MovingTargetNode>(e)\n    const offset = data.offset\n    const restrict = data.restrict\n\n    if (!data.moving) {\n      data.moving = true\n      this.addClass('node-moving')\n      this.notifyNodeMove('node:move', e, x, y, this.cell)\n    }\n\n    this.autoScrollGraph(e.clientX, e.clientY)\n\n    const posX = GeometryUtil.snapToGrid(x + offset.x, gridSize)\n    const posY = GeometryUtil.snapToGrid(y + offset.y, gridSize)\n    node.setPosition(posX, posY, {\n      restrict,\n      deep: true,\n      ui: true,\n    })\n\n    if (graph.options.embedding.enabled) {\n      if (!data.embedding) {\n        this.prepareEmbedding(e)\n        data.embedding = true\n      }\n      this.processEmbedding(e, data)\n    }\n  }\n\n  protected stopNodeDragging(e: Dom.MouseUpEvent, x: number, y: number) {\n    const data = this.getEventData<EventData.MovingTargetNode>(e)\n    if (data.embedding) {\n      this.finalizeEmbedding(e, data)\n    }\n\n    if (data.moving) {\n      this.removeClass('node-moving')\n      this.notifyNodeMove('node:moved', e, x, y, this.cell)\n    }\n\n    data.moving = false\n    data.embedding = false\n  }\n\n  // eslint-disable-next-line\n  protected autoScrollGraph(x: number, y: number) {\n    const scroller = this.graph.getPlugin<any>('scroller')\n    if (scroller) {\n      scroller.autoScroll(x, y)\n    }\n  }\n\n  // #endregion\n}\n\nexport namespace NodeView {\n  export interface Options extends CellView.Options {}\n\n  export interface PortCache {\n    portElement: Element\n    portSelectors?: Markup.Selectors | null\n    portLabelElement?: Element\n    portLabelSelectors?: Markup.Selectors | null\n    portContentElement?: Element\n    portContentSelectors?: Markup.Selectors | null\n  }\n}\n\nexport namespace NodeView {\n  interface MagnetEventArgs {\n    magnet: Element\n  }\n  export interface MouseEventArgs<E> {\n    e: E\n    node: Node\n    cell: Node\n    view: NodeView\n    port?: string\n  }\n  export interface PositionEventArgs<E>\n    extends MouseEventArgs<E>,\n      CellView.PositionEventArgs {}\n\n  export interface TranslateEventArgs<E> extends PositionEventArgs<E> {}\n\n  export interface ResizeEventArgs<E> extends PositionEventArgs<E> {}\n\n  export interface RotateEventArgs<E> extends PositionEventArgs<E> {}\n\n  export interface EventArgs {\n    'node:click': PositionEventArgs<Dom.ClickEvent>\n    'node:dblclick': PositionEventArgs<Dom.DoubleClickEvent>\n    'node:contextmenu': PositionEventArgs<Dom.ContextMenuEvent>\n    'node:mousedown': PositionEventArgs<Dom.MouseDownEvent>\n    'node:mousemove': PositionEventArgs<Dom.MouseMoveEvent>\n    'node:mouseup': PositionEventArgs<Dom.MouseUpEvent>\n    'node:mouseover': MouseEventArgs<Dom.MouseOverEvent>\n    'node:mouseout': MouseEventArgs<Dom.MouseOutEvent>\n    'node:mouseenter': MouseEventArgs<Dom.MouseEnterEvent>\n    'node:mouseleave': MouseEventArgs<Dom.MouseLeaveEvent>\n    'node:mousewheel': PositionEventArgs<Dom.EventObject> &\n      CellView.MouseDeltaEventArgs\n\n    'node:port:click': PositionEventArgs<Dom.ClickEvent>\n    'node:port:dblclick': PositionEventArgs<Dom.DoubleClickEvent>\n    'node:port:contextmenu': PositionEventArgs<Dom.ContextMenuEvent>\n    'node:port:mousedown': PositionEventArgs<Dom.MouseDownEvent>\n    'node:port:mousemove': PositionEventArgs<Dom.MouseMoveEvent>\n    'node:port:mouseup': PositionEventArgs<Dom.MouseUpEvent>\n    'node:port:mouseover': MouseEventArgs<Dom.MouseOverEvent>\n    'node:port:mouseout': MouseEventArgs<Dom.MouseOutEvent>\n    'node:port:mouseenter': MouseEventArgs<Dom.MouseEnterEvent>\n    'node:port:mouseleave': MouseEventArgs<Dom.MouseLeaveEvent>\n\n    'node:customevent': PositionEventArgs<Dom.MouseDownEvent> & {\n      name: string\n    }\n\n    'node:unhandled:mousedown': PositionEventArgs<Dom.MouseDownEvent>\n\n    'node:highlight': {\n      magnet: Element\n      view: NodeView\n      node: Node\n      cell: Node\n      options: CellView.HighlightOptions\n    }\n    'node:unhighlight': EventArgs['node:highlight']\n\n    'node:magnet:click': PositionEventArgs<Dom.MouseUpEvent> & MagnetEventArgs\n    'node:magnet:dblclick': PositionEventArgs<Dom.DoubleClickEvent> &\n      MagnetEventArgs\n    'node:magnet:contextmenu': PositionEventArgs<Dom.ContextMenuEvent> &\n      MagnetEventArgs\n\n    'node:move': TranslateEventArgs<Dom.MouseMoveEvent>\n    'node:moving': TranslateEventArgs<Dom.MouseMoveEvent>\n    'node:moved': TranslateEventArgs<Dom.MouseUpEvent>\n\n    'node:embed': PositionEventArgs<Dom.MouseMoveEvent> & {\n      currentParent: Node | null\n    }\n    'node:embedding': PositionEventArgs<Dom.MouseMoveEvent> & {\n      currentParent: Node | null\n      candidateParent: Node | null\n    }\n    'node:embedded': PositionEventArgs<Dom.MouseUpEvent> & {\n      currentParent: Node | null\n      previousParent: Node | null\n    }\n  }\n}\n\nexport namespace NodeView {\n  export const toStringTag = `X6.${NodeView.name}`\n\n  export function isNodeView(instance: any): instance is NodeView {\n    if (instance == null) {\n      return false\n    }\n\n    if (instance instanceof NodeView) {\n      return true\n    }\n\n    const tag = instance[Symbol.toStringTag]\n    const view = instance as NodeView\n\n    if (\n      (tag == null || tag === toStringTag) &&\n      typeof view.isNodeView === 'function' &&\n      typeof view.isEdgeView === 'function' &&\n      typeof view.confirmUpdate === 'function' &&\n      typeof view.update === 'function' &&\n      typeof view.findPortElem === 'function' &&\n      typeof view.resize === 'function' &&\n      typeof view.rotate === 'function' &&\n      typeof view.translate === 'function'\n    ) {\n      return true\n    }\n\n    return false\n  }\n}\n\nnamespace EventData {\n  export type Mousemove = Moving | Magnet\n\n  export interface Magnet {\n    action: 'magnet'\n    targetMagnet: Element\n    edgeView?: EdgeView\n  }\n\n  export interface Moving {\n    action: 'move'\n    targetView: NodeView\n  }\n\n  export interface MovingTargetNode {\n    moving: boolean\n    offset: Point.PointLike\n    restrict?: Rectangle.RectangleLike | null\n    embedding?: boolean\n    candidateEmbedView?: NodeView | null\n    cell?: Node\n    graph?: Graph\n  }\n}\n\nNodeView.config({\n  isSvgElement: true,\n  priority: 0,\n  bootstrap: ['render'],\n  actions: {\n    view: ['render'],\n    markup: ['render'],\n    attrs: ['update'],\n    size: ['resize', 'ports', 'tools'],\n    angle: ['rotate', 'tools'],\n    position: ['translate', 'tools'],\n    ports: ['ports'],\n    tools: ['tools'],\n  },\n})\n\nNodeView.registry.register('node', NodeView, true)\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}