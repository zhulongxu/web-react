{"ast":null,"code":"import { ObjectExt } from '../object';\nimport { mergeAttrs } from '../dom/attr';\nexport function annotate(t, annotations, opt = {}) {\n  const offset = opt.offset || 0;\n  const compacted = [];\n  const ret = [];\n  let curr;\n  let prev;\n  let batch = null;\n  for (let i = 0; i < t.length; i += 1) {\n    curr = ret[i] = t[i];\n    for (let j = 0, jj = annotations.length; j < jj; j += 1) {\n      const annotation = annotations[j];\n      const start = annotation.start + offset;\n      const end = annotation.end + offset;\n      if (i >= start && i < end) {\n        if (typeof curr === 'string') {\n          curr = ret[i] = {\n            t: t[i],\n            attrs: annotation.attrs\n          };\n        } else {\n          curr.attrs = mergeAttrs(mergeAttrs({}, curr.attrs), annotation.attrs);\n        }\n        if (opt.includeAnnotationIndices) {\n          if (curr.annotations == null) {\n            curr.annotations = [];\n          }\n          curr.annotations.push(j);\n        }\n      }\n    }\n    prev = ret[i - 1];\n    if (!prev) {\n      batch = curr;\n    } else if (ObjectExt.isObject(curr) && ObjectExt.isObject(prev)) {\n      batch = batch;\n      // Both previous item and the current one are annotations.\n      // If the attributes didn't change, merge the text.\n      if (JSON.stringify(curr.attrs) === JSON.stringify(prev.attrs)) {\n        batch.t += curr.t;\n      } else {\n        compacted.push(batch);\n        batch = curr;\n      }\n    } else if (ObjectExt.isObject(curr)) {\n      // Previous item was a string, current item is an annotation.\n      batch = batch;\n      compacted.push(batch);\n      batch = curr;\n    } else if (ObjectExt.isObject(prev)) {\n      // Previous item was an annotation, current item is a string.\n      batch = batch;\n      compacted.push(batch);\n      batch = curr;\n    } else {\n      // Both previous and current item are strings.\n      batch = (batch || '') + curr;\n    }\n  }\n  if (batch != null) {\n    compacted.push(batch);\n  }\n  return compacted;\n}\nexport function findAnnotationsAtIndex(annotations, index) {\n  return annotations ? annotations.filter(a => a.start < index && index <= a.end) : [];\n}\nexport function findAnnotationsBetweenIndexes(annotations, start, end) {\n  return annotations ? annotations.filter(a => start >= a.start && start < a.end || end > a.start && end <= a.end || a.start >= start && a.end < end) : [];\n}\nexport function shiftAnnotations(annotations, index, offset) {\n  if (annotations) {\n    annotations.forEach(a => {\n      if (a.start < index && a.end >= index) {\n        a.end += offset;\n      } else if (a.start >= index) {\n        a.start += offset;\n        a.end += offset;\n      }\n    });\n  }\n  return annotations;\n}","map":{"version":3,"names":["ObjectExt","mergeAttrs","annotate","t","annotations","opt","offset","compacted","ret","curr","prev","batch","i","length","j","jj","annotation","start","end","attrs","includeAnnotationIndices","push","isObject","JSON","stringify","findAnnotationsAtIndex","index","filter","a","findAnnotationsBetweenIndexes","shiftAnnotations","forEach"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/src/text/annotate.ts"],"sourcesContent":["import { ObjectExt } from '../object'\nimport { Attributes, mergeAttrs } from '../dom/attr'\n\nexport interface Annotation {\n  start: number\n  end: number\n  attrs: Attributes\n}\n\nexport interface AnnotatedItem {\n  t: string\n  attrs: Attributes\n  annotations?: number[]\n}\n\nexport function annotate(\n  t: string,\n  annotations: Annotation[],\n  opt: { offset?: number; includeAnnotationIndices?: boolean } = {},\n) {\n  const offset = opt.offset || 0\n  const compacted: (string | AnnotatedItem)[] = []\n  const ret: (string | AnnotatedItem)[] = []\n  let curr: string | AnnotatedItem\n  let prev: string | AnnotatedItem\n  let batch: string | AnnotatedItem | null = null\n\n  for (let i = 0; i < t.length; i += 1) {\n    curr = ret[i] = t[i]\n\n    for (let j = 0, jj = annotations.length; j < jj; j += 1) {\n      const annotation = annotations[j]\n      const start = annotation.start + offset\n      const end = annotation.end + offset\n\n      if (i >= start && i < end) {\n        if (typeof curr === 'string') {\n          curr = ret[i] = {\n            t: t[i],\n            attrs: annotation.attrs,\n          } as AnnotatedItem\n        } else {\n          curr.attrs = mergeAttrs(mergeAttrs({}, curr.attrs), annotation.attrs)\n        }\n\n        if (opt.includeAnnotationIndices) {\n          if (curr.annotations == null) {\n            curr.annotations = []\n          }\n          curr.annotations.push(j)\n        }\n      }\n    }\n\n    prev = ret[i - 1]\n\n    if (!prev) {\n      batch = curr\n    } else if (ObjectExt.isObject(curr) && ObjectExt.isObject(prev)) {\n      batch = batch as AnnotatedItem\n      // Both previous item and the current one are annotations.\n      // If the attributes didn't change, merge the text.\n      if (JSON.stringify(curr.attrs) === JSON.stringify(prev.attrs)) {\n        batch.t += curr.t\n      } else {\n        compacted.push(batch)\n        batch = curr\n      }\n    } else if (ObjectExt.isObject(curr)) {\n      // Previous item was a string, current item is an annotation.\n      batch = batch as string\n      compacted.push(batch)\n      batch = curr\n    } else if (ObjectExt.isObject(prev)) {\n      // Previous item was an annotation, current item is a string.\n      batch = batch as AnnotatedItem\n      compacted.push(batch)\n      batch = curr\n    } else {\n      // Both previous and current item are strings.\n      batch = (batch || '') + curr\n    }\n  }\n\n  if (batch != null) {\n    compacted.push(batch)\n  }\n\n  return compacted\n}\n\nexport function findAnnotationsAtIndex(\n  annotations: Annotation[],\n  index: number,\n) {\n  return annotations\n    ? annotations.filter((a) => a.start < index && index <= a.end)\n    : []\n}\n\nexport function findAnnotationsBetweenIndexes(\n  annotations: Annotation[],\n  start: number,\n  end: number,\n) {\n  return annotations\n    ? annotations.filter(\n        (a) =>\n          (start >= a.start && start < a.end) ||\n          (end > a.start && end <= a.end) ||\n          (a.start >= start && a.end < end),\n      )\n    : []\n}\n\nexport function shiftAnnotations(\n  annotations: Annotation[],\n  index: number,\n  offset: number,\n) {\n  if (annotations) {\n    annotations.forEach((a) => {\n      if (a.start < index && a.end >= index) {\n        a.end += offset\n      } else if (a.start >= index) {\n        a.start += offset\n        a.end += offset\n      }\n    })\n  }\n\n  return annotations\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}