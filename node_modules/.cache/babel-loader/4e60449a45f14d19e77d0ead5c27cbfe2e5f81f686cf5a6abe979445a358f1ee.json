{"ast":null,"code":"import { GeometryUtil } from '../util';\nimport * as PathUtil from './util';\nimport { Line } from '../line';\nimport { Point } from '../point';\nimport { Curve } from '../curve';\nimport { Polyline } from '../polyline';\nimport { Rectangle } from '../rectangle';\nimport { Geometry } from '../geometry';\nimport { Close } from './close';\nimport { LineTo } from './lineto';\nimport { MoveTo } from './moveto';\nimport { CurveTo } from './curveto';\nimport { normalizePathData } from './normalize';\nexport class Path extends Geometry {\n  constructor(args) {\n    super();\n    this.PRECISION = 3;\n    this.segments = [];\n    if (Array.isArray(args)) {\n      if (Line.isLine(args[0]) || Curve.isCurve(args[0])) {\n        let previousObj = null;\n        const arr = args;\n        arr.forEach((o, i) => {\n          if (i === 0) {\n            this.appendSegment(Path.createSegment('M', o.start));\n          }\n          if (previousObj != null && !previousObj.end.equals(o.start)) {\n            this.appendSegment(Path.createSegment('M', o.start));\n          }\n          if (Line.isLine(o)) {\n            this.appendSegment(Path.createSegment('L', o.end));\n          } else if (Curve.isCurve(o)) {\n            this.appendSegment(Path.createSegment('C', o.controlPoint1, o.controlPoint2, o.end));\n          }\n          previousObj = o;\n        });\n      } else {\n        const arr = args;\n        arr.forEach(s => {\n          if (s.isSegment) {\n            this.appendSegment(s);\n          }\n        });\n      }\n    } else if (args != null) {\n      if (Line.isLine(args)) {\n        this.appendSegment(Path.createSegment('M', args.start));\n        this.appendSegment(Path.createSegment('L', args.end));\n      } else if (Curve.isCurve(args)) {\n        this.appendSegment(Path.createSegment('M', args.start));\n        this.appendSegment(Path.createSegment('C', args.controlPoint1, args.controlPoint2, args.end));\n      } else if (Polyline.isPolyline(args)) {\n        if (args.points && args.points.length) {\n          args.points.forEach((point, index) => {\n            const segment = index === 0 ? Path.createSegment('M', point) : Path.createSegment('L', point);\n            this.appendSegment(segment);\n          });\n        }\n      } else if (args.isSegment) {\n        this.appendSegment(args);\n      }\n    }\n  }\n  get start() {\n    const segments = this.segments;\n    const count = segments.length;\n    if (count === 0) {\n      return null;\n    }\n    for (let i = 0; i < count; i += 1) {\n      const segment = segments[i];\n      if (segment.isVisible) {\n        return segment.start;\n      }\n    }\n    // if no visible segment, return last segment end point\n    return segments[count - 1].end;\n  }\n  get end() {\n    const segments = this.segments;\n    const count = segments.length;\n    if (count === 0) {\n      return null;\n    }\n    for (let i = count - 1; i >= 0; i -= 1) {\n      const segment = segments[i];\n      if (segment.isVisible) {\n        return segment.end;\n      }\n    }\n    // if no visible segment, return last segment end point\n    return segments[count - 1].end;\n  }\n  moveTo(...args) {\n    return this.appendSegment(MoveTo.create.call(null, ...args));\n  }\n  lineTo(...args) {\n    return this.appendSegment(LineTo.create.call(null, ...args));\n  }\n  curveTo(...args) {\n    return this.appendSegment(CurveTo.create.call(null, ...args));\n  }\n  arcTo(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX, endY) {\n    const start = this.end || new Point();\n    const points = typeof endX === 'number' ? PathUtil.arcToCurves(start.x, start.y, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX, endY) : PathUtil.arcToCurves(start.x, start.y, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX.x, endX.y);\n    if (points != null) {\n      for (let i = 0, ii = points.length; i < ii; i += 6) {\n        this.curveTo(points[i], points[i + 1], points[i + 2], points[i + 3], points[i + 4], points[i + 5]);\n      }\n    }\n    return this;\n  }\n  quadTo(x1, y1, x, y) {\n    const start = this.end || new Point();\n    const data = ['M', start.x, start.y];\n    if (typeof x1 === 'number') {\n      data.push('Q', x1, y1, x, y);\n    } else {\n      const p = y1;\n      data.push(`Q`, x1.x, x1.y, p.x, p.y);\n    }\n    const path = Path.parse(data.join(' '));\n    this.appendSegment(path.segments.slice(1));\n    return this;\n  }\n  close() {\n    return this.appendSegment(Close.create());\n  }\n  drawPoints(points, options = {}) {\n    const raw = PathUtil.drawPoints(points, options);\n    const sub = Path.parse(raw);\n    if (sub && sub.segments) {\n      this.appendSegment(sub.segments);\n    }\n  }\n  bbox() {\n    const segments = this.segments;\n    const count = segments.length;\n    if (count === 0) {\n      return null;\n    }\n    let bbox;\n    for (let i = 0; i < count; i += 1) {\n      const segment = segments[i];\n      if (segment.isVisible) {\n        const segmentBBox = segment.bbox();\n        if (segmentBBox != null) {\n          bbox = bbox ? bbox.union(segmentBBox) : segmentBBox;\n        }\n      }\n    }\n    if (bbox != null) {\n      return bbox;\n    }\n    // if the path has only invisible elements, return end point of last segment\n    const lastSegment = segments[count - 1];\n    return new Rectangle(lastSegment.end.x, lastSegment.end.y, 0, 0);\n  }\n  appendSegment(seg) {\n    const count = this.segments.length;\n    let previousSegment = count !== 0 ? this.segments[count - 1] : null;\n    let currentSegment;\n    const nextSegment = null;\n    if (Array.isArray(seg)) {\n      for (let i = 0, ii = seg.length; i < ii; i += 1) {\n        const segment = seg[i];\n        currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);\n        this.segments.push(currentSegment);\n        previousSegment = currentSegment;\n      }\n    } else if (seg != null && seg.isSegment) {\n      currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);\n      this.segments.push(currentSegment);\n    }\n    return this;\n  }\n  insertSegment(index, seg) {\n    const count = this.segments.length;\n    if (index < 0) {\n      index = count + index + 1; // eslint-disable-line\n    }\n    if (index > count || index < 0) {\n      throw new Error('Index out of range.');\n    }\n    let currentSegment;\n    let previousSegment = null;\n    let nextSegment = null;\n    if (count !== 0) {\n      if (index >= 1) {\n        previousSegment = this.segments[index - 1];\n        nextSegment = previousSegment.nextSegment;\n      } else {\n        previousSegment = null;\n        nextSegment = this.segments[0];\n      }\n    }\n    if (!Array.isArray(seg)) {\n      currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);\n      this.segments.splice(index, 0, currentSegment);\n    } else {\n      for (let i = 0, ii = seg.length; i < ii; i += 1) {\n        const segment = seg[i];\n        currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);\n        this.segments.splice(index + i, 0, currentSegment);\n        previousSegment = currentSegment;\n      }\n    }\n    return this;\n  }\n  removeSegment(index) {\n    const idx = this.fixIndex(index);\n    const removedSegment = this.segments.splice(idx, 1)[0];\n    const previousSegment = removedSegment.previousSegment;\n    const nextSegment = removedSegment.nextSegment;\n    // link the previous and next segments together (if present)\n    if (previousSegment) {\n      previousSegment.nextSegment = nextSegment;\n    }\n    if (nextSegment) {\n      nextSegment.previousSegment = previousSegment;\n    }\n    if (removedSegment.isSubpathStart && nextSegment) {\n      this.updateSubpathStartSegment(nextSegment);\n    }\n    return removedSegment;\n  }\n  replaceSegment(index, seg) {\n    const idx = this.fixIndex(index);\n    let currentSegment;\n    const replacedSegment = this.segments[idx];\n    let previousSegment = replacedSegment.previousSegment;\n    const nextSegment = replacedSegment.nextSegment;\n    let updateSubpathStart = replacedSegment.isSubpathStart;\n    if (!Array.isArray(seg)) {\n      currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);\n      this.segments.splice(idx, 1, currentSegment);\n      if (updateSubpathStart && currentSegment.isSubpathStart) {\n        // already updated by `prepareSegment`\n        updateSubpathStart = false;\n      }\n    } else {\n      this.segments.splice(index, 1);\n      for (let i = 0, ii = seg.length; i < ii; i += 1) {\n        const segment = seg[i];\n        currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);\n        this.segments.splice(index + i, 0, currentSegment);\n        previousSegment = currentSegment;\n        if (updateSubpathStart && currentSegment.isSubpathStart) {\n          updateSubpathStart = false;\n        }\n      }\n    }\n    if (updateSubpathStart && nextSegment) {\n      this.updateSubpathStartSegment(nextSegment);\n    }\n  }\n  getSegment(index) {\n    const idx = this.fixIndex(index);\n    return this.segments[idx];\n  }\n  fixIndex(index) {\n    const length = this.segments.length;\n    if (length === 0) {\n      throw new Error('Path has no segments.');\n    }\n    let i = index;\n    while (i < 0) {\n      i = length + i;\n    }\n    if (i >= length || i < 0) {\n      throw new Error('Index out of range.');\n    }\n    return i;\n  }\n  segmentAt(ratio, options = {}) {\n    const index = this.segmentIndexAt(ratio, options);\n    if (!index) {\n      return null;\n    }\n    return this.getSegment(index);\n  }\n  segmentAtLength(length, options = {}) {\n    const index = this.segmentIndexAtLength(length, options);\n    if (!index) return null;\n    return this.getSegment(index);\n  }\n  segmentIndexAt(ratio, options = {}) {\n    if (this.segments.length === 0) {\n      return null;\n    }\n    const rate = GeometryUtil.clamp(ratio, 0, 1);\n    const opt = this.getOptions(options);\n    const len = this.length(opt);\n    const length = len * rate;\n    return this.segmentIndexAtLength(length, opt);\n  }\n  segmentIndexAtLength(length, options = {}) {\n    const count = this.segments.length;\n    if (count === 0) {\n      return null;\n    }\n    let fromStart = true;\n    if (length < 0) {\n      fromStart = false;\n      length = -length; // eslint-disable-line\n    }\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = this.getSubdivisions(options);\n    let memo = 0;\n    let lastVisibleIndex = null;\n    for (let i = 0; i < count; i += 1) {\n      const index = fromStart ? i : count - 1 - i;\n      const segment = this.segments[index];\n      const subdivisions = segmentSubdivisions[index];\n      const len = segment.length({\n        precision,\n        subdivisions\n      });\n      if (segment.isVisible) {\n        if (length <= memo + len) {\n          return index;\n        }\n        lastVisibleIndex = index;\n      }\n      memo += len;\n    }\n    // If length requested is higher than the length of the path, return\n    // last visible segment index. If no visible segment, return null.\n    return lastVisibleIndex;\n  }\n  getSegmentSubdivisions(options = {}) {\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = [];\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const segment = this.segments[i];\n      const subdivisions = segment.getSubdivisions({\n        precision\n      });\n      segmentSubdivisions.push(subdivisions);\n    }\n    return segmentSubdivisions;\n  }\n  updateSubpathStartSegment(segment) {\n    let previous = segment.previousSegment;\n    let current = segment;\n    while (current && !current.isSubpathStart) {\n      // assign previous segment's subpath start segment to this segment\n      if (previous != null) {\n        current.subpathStartSegment = previous.subpathStartSegment;\n      } else {\n        current.subpathStartSegment = null;\n      }\n      previous = current;\n      current = current.nextSegment;\n    }\n  }\n  prepareSegment(segment, previousSegment, nextSegment) {\n    segment.previousSegment = previousSegment;\n    segment.nextSegment = nextSegment;\n    if (previousSegment != null) {\n      previousSegment.nextSegment = segment;\n    }\n    if (nextSegment != null) {\n      nextSegment.previousSegment = segment;\n    }\n    let updateSubpathStart = segment;\n    if (segment.isSubpathStart) {\n      // move to\n      segment.subpathStartSegment = segment;\n      updateSubpathStart = nextSegment;\n    }\n    // assign previous segment's subpath start (or self if it is a subpath start) to subsequent segments\n    if (updateSubpathStart != null) {\n      this.updateSubpathStartSegment(updateSubpathStart);\n    }\n    return segment;\n  }\n  closestPoint(p, options = {}) {\n    const t = this.closestPointT(p, options);\n    if (!t) {\n      return null;\n    }\n    return this.pointAtT(t);\n  }\n  closestPointLength(p, options = {}) {\n    const opts = this.getOptions(options);\n    const t = this.closestPointT(p, opts);\n    if (!t) {\n      return 0;\n    }\n    return this.lengthAtT(t, opts);\n  }\n  closestPointNormalizedLength(p, options = {}) {\n    const opts = this.getOptions(options);\n    const cpLength = this.closestPointLength(p, opts);\n    if (cpLength === 0) {\n      return 0;\n    }\n    const length = this.length(opts);\n    if (length === 0) {\n      return 0;\n    }\n    return cpLength / length;\n  }\n  closestPointT(p, options = {}) {\n    if (this.segments.length === 0) {\n      return null;\n    }\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = this.getSubdivisions(options);\n    let closestPointT;\n    let minSquaredDistance = Infinity;\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const segment = this.segments[i];\n      const subdivisions = segmentSubdivisions[i];\n      if (segment.isVisible) {\n        const segmentClosestPointT = segment.closestPointT(p, {\n          precision,\n          subdivisions\n        });\n        const segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n        const squaredDistance = GeometryUtil.squaredLength(segmentClosestPoint, p);\n        if (squaredDistance < minSquaredDistance) {\n          closestPointT = {\n            segmentIndex: i,\n            value: segmentClosestPointT\n          };\n          minSquaredDistance = squaredDistance;\n        }\n      }\n    }\n    if (closestPointT) {\n      return closestPointT;\n    }\n    return {\n      segmentIndex: this.segments.length - 1,\n      value: 1\n    };\n  }\n  closestPointTangent(p, options = {}) {\n    if (this.segments.length === 0) {\n      return null;\n    }\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = this.getSubdivisions(options);\n    let closestPointTangent;\n    let minSquaredDistance = Infinity;\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const segment = this.segments[i];\n      const subdivisions = segmentSubdivisions[i];\n      if (segment.isDifferentiable()) {\n        const segmentClosestPointT = segment.closestPointT(p, {\n          precision,\n          subdivisions\n        });\n        const segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n        const squaredDistance = GeometryUtil.squaredLength(segmentClosestPoint, p);\n        if (squaredDistance < minSquaredDistance) {\n          closestPointTangent = segment.tangentAtT(segmentClosestPointT);\n          minSquaredDistance = squaredDistance;\n        }\n      }\n    }\n    if (closestPointTangent) {\n      return closestPointTangent;\n    }\n    return null;\n  }\n  containsPoint(p, options = {}) {\n    const polylines = this.toPolylines(options);\n    if (!polylines) {\n      return false;\n    }\n    let numIntersections = 0;\n    for (let i = 0, ii = polylines.length; i < ii; i += 1) {\n      const polyline = polylines[i];\n      if (polyline.containsPoint(p)) {\n        numIntersections += 1;\n      }\n    }\n    // returns `true` for odd numbers of intersections (even-odd algorithm)\n    return numIntersections % 2 === 1;\n  }\n  pointAt(ratio, options = {}) {\n    if (this.segments.length === 0) {\n      return null;\n    }\n    if (ratio <= 0) {\n      return this.start.clone();\n    }\n    if (ratio >= 1) {\n      return this.end.clone();\n    }\n    const opts = this.getOptions(options);\n    const pathLength = this.length(opts);\n    const length = pathLength * ratio;\n    return this.pointAtLength(length, opts);\n  }\n  pointAtLength(length, options = {}) {\n    if (this.segments.length === 0) {\n      return null;\n    }\n    if (length === 0) {\n      return this.start.clone();\n    }\n    let fromStart = true;\n    if (length < 0) {\n      fromStart = false;\n      length = -length; // eslint-disable-line\n    }\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = this.getSubdivisions(options);\n    let lastVisibleSegment;\n    let memo = 0;\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const index = fromStart ? i : ii - 1 - i;\n      const segment = this.segments[index];\n      const subdivisions = segmentSubdivisions[index];\n      const d = segment.length({\n        precision,\n        subdivisions\n      });\n      if (segment.isVisible) {\n        if (length <= memo + d) {\n          return segment.pointAtLength((fromStart ? 1 : -1) * (length - memo), {\n            precision,\n            subdivisions\n          });\n        }\n        lastVisibleSegment = segment;\n      }\n      memo += d;\n    }\n    // if length requested is higher than the length of the path,\n    // return last visible segment endpoint\n    if (lastVisibleSegment) {\n      return fromStart ? lastVisibleSegment.end : lastVisibleSegment.start;\n    }\n    // if no visible segment, return last segment end point\n    const lastSegment = this.segments[this.segments.length - 1];\n    return lastSegment.end.clone();\n  }\n  pointAtT(t) {\n    const segments = this.segments;\n    const numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n    const segmentIndex = t.segmentIndex;\n    if (segmentIndex < 0) return segments[0].pointAtT(0);\n    if (segmentIndex >= numSegments) {\n      return segments[numSegments - 1].pointAtT(1);\n    }\n    const tValue = GeometryUtil.clamp(t.value, 0, 1);\n    return segments[segmentIndex].pointAtT(tValue);\n  }\n  divideAt(ratio, options = {}) {\n    if (this.segments.length === 0) {\n      return null;\n    }\n    const rate = GeometryUtil.clamp(ratio, 0, 1);\n    const opts = this.getOptions(options);\n    const len = this.length(opts);\n    const length = len * rate;\n    return this.divideAtLength(length, opts);\n  }\n  divideAtLength(length, options = {}) {\n    if (this.segments.length === 0) {\n      return null;\n    }\n    let fromStart = true;\n    if (length < 0) {\n      fromStart = false;\n      length = -length; // eslint-disable-line\n    }\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = this.getSubdivisions(options);\n    let memo = 0;\n    let divided;\n    let dividedSegmentIndex;\n    let lastValidSegment;\n    let lastValidSegmentIndex;\n    let t;\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const index = fromStart ? i : ii - 1 - i;\n      const segment = this.getSegment(index);\n      const subdivisions = segmentSubdivisions[index];\n      const opts = {\n        precision,\n        subdivisions\n      };\n      const len = segment.length(opts);\n      if (segment.isDifferentiable()) {\n        lastValidSegment = segment;\n        lastValidSegmentIndex = index;\n        if (length <= memo + len) {\n          dividedSegmentIndex = index;\n          divided = segment.divideAtLength((fromStart ? 1 : -1) * (length - memo), opts);\n          break;\n        }\n      }\n      memo += len;\n    }\n    if (!lastValidSegment) {\n      return null;\n    }\n    if (!divided) {\n      dividedSegmentIndex = lastValidSegmentIndex;\n      t = fromStart ? 1 : 0;\n      divided = lastValidSegment.divideAtT(t);\n    }\n    // create a copy of this path and replace the identified segment with its two divided parts:\n    const pathCopy = this.clone();\n    const index = dividedSegmentIndex;\n    pathCopy.replaceSegment(index, divided);\n    const divisionStartIndex = index;\n    let divisionMidIndex = index + 1;\n    let divisionEndIndex = index + 2;\n    // do not insert the part if it looks like a point\n    if (!divided[0].isDifferentiable()) {\n      pathCopy.removeSegment(divisionStartIndex);\n      divisionMidIndex -= 1;\n      divisionEndIndex -= 1;\n    }\n    // insert a Moveto segment to ensure secondPath will be valid:\n    const movetoEnd = pathCopy.getSegment(divisionMidIndex).start;\n    pathCopy.insertSegment(divisionMidIndex, Path.createSegment('M', movetoEnd));\n    divisionEndIndex += 1;\n    // do not insert the part if it looks like a point\n    if (!divided[1].isDifferentiable()) {\n      pathCopy.removeSegment(divisionEndIndex - 1);\n      divisionEndIndex -= 1;\n    }\n    // ensure that Closepath segments in secondPath will be assigned correct subpathStartSegment:\n    const secondPathSegmentIndexConversion = divisionEndIndex - divisionStartIndex - 1;\n    for (let i = divisionEndIndex, ii = pathCopy.segments.length; i < ii; i += 1) {\n      const originalSegment = this.getSegment(i - secondPathSegmentIndexConversion);\n      const segment = pathCopy.getSegment(i);\n      if (segment.type === 'Z' && !originalSegment.subpathStartSegment.end.equals(segment.subpathStartSegment.end)) {\n        // pathCopy segment's subpathStartSegment is different from original segment's one\n        // convert this Closepath segment to a Lineto and replace it in pathCopy\n        const convertedSegment = Path.createSegment('L', originalSegment.end);\n        pathCopy.replaceSegment(i, convertedSegment);\n      }\n    }\n    // distribute pathCopy segments into two paths and return those:\n    const firstPath = new Path(pathCopy.segments.slice(0, divisionMidIndex));\n    const secondPath = new Path(pathCopy.segments.slice(divisionMidIndex));\n    return [firstPath, secondPath];\n  }\n  intersectsWithLine(line, options = {}) {\n    const polylines = this.toPolylines(options);\n    if (polylines == null) {\n      return null;\n    }\n    let intersections = null;\n    for (let i = 0, ii = polylines.length; i < ii; i += 1) {\n      const polyline = polylines[i];\n      const intersection = line.intersect(polyline);\n      if (intersection) {\n        if (intersections == null) {\n          intersections = [];\n        }\n        if (Array.isArray(intersection)) {\n          intersections.push(...intersection);\n        } else {\n          intersections.push(intersection);\n        }\n      }\n    }\n    return intersections;\n  }\n  isDifferentiable() {\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const segment = this.segments[i];\n      if (segment.isDifferentiable()) {\n        return true;\n      }\n    }\n    return false;\n  }\n  isValid() {\n    const segments = this.segments;\n    const isValid = segments.length === 0 || segments[0].type === 'M';\n    return isValid;\n  }\n  length(options = {}) {\n    if (this.segments.length === 0) {\n      return 0;\n    }\n    const segmentSubdivisions = this.getSubdivisions(options);\n    let length = 0;\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const segment = this.segments[i];\n      const subdivisions = segmentSubdivisions[i];\n      length += segment.length({\n        subdivisions\n      });\n    }\n    return length;\n  }\n  lengthAtT(t, options = {}) {\n    const count = this.segments.length;\n    if (count === 0) {\n      return 0;\n    }\n    let segmentIndex = t.segmentIndex;\n    if (segmentIndex < 0) {\n      return 0;\n    }\n    let tValue = GeometryUtil.clamp(t.value, 0, 1);\n    if (segmentIndex >= count) {\n      segmentIndex = count - 1;\n      tValue = 1;\n    }\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = this.getSubdivisions(options);\n    let length = 0;\n    for (let i = 0; i < segmentIndex; i += 1) {\n      const segment = this.segments[i];\n      const subdivisions = segmentSubdivisions[i];\n      length += segment.length({\n        precision,\n        subdivisions\n      });\n    }\n    const segment = this.segments[segmentIndex];\n    const subdivisions = segmentSubdivisions[segmentIndex];\n    length += segment.lengthAtT(tValue, {\n      precision,\n      subdivisions\n    });\n    return length;\n  }\n  tangentAt(ratio, options = {}) {\n    if (this.segments.length === 0) {\n      return null;\n    }\n    const rate = GeometryUtil.clamp(ratio, 0, 1);\n    const opts = this.getOptions(options);\n    const len = this.length(opts);\n    const length = len * rate;\n    return this.tangentAtLength(length, opts);\n  }\n  tangentAtLength(length, options = {}) {\n    if (this.segments.length === 0) {\n      return null;\n    }\n    let fromStart = true;\n    if (length < 0) {\n      fromStart = false;\n      length = -length; // eslint-disable-line\n    }\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = this.getSubdivisions(options);\n    let lastValidSegment;\n    let memo = 0;\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const index = fromStart ? i : ii - 1 - i;\n      const segment = this.segments[index];\n      const subdivisions = segmentSubdivisions[index];\n      const len = segment.length({\n        precision,\n        subdivisions\n      });\n      if (segment.isDifferentiable()) {\n        if (length <= memo + len) {\n          return segment.tangentAtLength((fromStart ? 1 : -1) * (length - memo), {\n            precision,\n            subdivisions\n          });\n        }\n        lastValidSegment = segment;\n      }\n      memo += len;\n    }\n    // if length requested is higher than the length of the path, return tangent of endpoint of last valid segment\n    if (lastValidSegment) {\n      const t = fromStart ? 1 : 0;\n      return lastValidSegment.tangentAtT(t);\n    }\n    // if no valid segment, return null\n    return null;\n  }\n  tangentAtT(t) {\n    const count = this.segments.length;\n    if (count === 0) {\n      return null;\n    }\n    const segmentIndex = t.segmentIndex;\n    if (segmentIndex < 0) {\n      return this.segments[0].tangentAtT(0);\n    }\n    if (segmentIndex >= count) {\n      return this.segments[count - 1].tangentAtT(1);\n    }\n    const tValue = GeometryUtil.clamp(t.value, 0, 1);\n    return this.segments[segmentIndex].tangentAtT(tValue);\n  }\n  getPrecision(options = {}) {\n    return options.precision == null ? this.PRECISION : options.precision;\n  }\n  getSubdivisions(options = {}) {\n    if (options.segmentSubdivisions == null) {\n      const precision = this.getPrecision(options);\n      return this.getSegmentSubdivisions({\n        precision\n      });\n    }\n    return options.segmentSubdivisions;\n  }\n  getOptions(options = {}) {\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = this.getSubdivisions(options);\n    return {\n      precision,\n      segmentSubdivisions\n    };\n  }\n  toPoints(options = {}) {\n    const segments = this.segments;\n    const count = segments.length;\n    if (count === 0) {\n      return null;\n    }\n    const segmentSubdivisions = this.getSubdivisions(options);\n    const points = [];\n    let partialPoints = [];\n    for (let i = 0; i < count; i += 1) {\n      const segment = segments[i];\n      if (segment.isVisible) {\n        const divisions = segmentSubdivisions[i];\n        if (divisions.length > 0) {\n          // eslint-disable-next-line no-loop-func\n          divisions.forEach(c => partialPoints.push(c.start));\n        } else {\n          partialPoints.push(segment.start);\n        }\n      } else if (partialPoints.length > 0) {\n        partialPoints.push(segments[i - 1].end);\n        points.push(partialPoints);\n        partialPoints = [];\n      }\n    }\n    if (partialPoints.length > 0) {\n      partialPoints.push(this.end);\n      points.push(partialPoints);\n    }\n    return points;\n  }\n  toPolylines(options = {}) {\n    const points = this.toPoints(options);\n    if (!points) {\n      return null;\n    }\n    return points.map(arr => new Polyline(arr));\n  }\n  scale(sx, sy, origin) {\n    this.segments.forEach(s => s.scale(sx, sy, origin));\n    return this;\n  }\n  rotate(angle, origin) {\n    this.segments.forEach(segment => segment.rotate(angle, origin));\n    return this;\n  }\n  translate(tx, ty) {\n    if (typeof tx === 'number') {\n      this.segments.forEach(s => s.translate(tx, ty));\n    } else {\n      this.segments.forEach(s => s.translate(tx));\n    }\n    return this;\n  }\n  clone() {\n    const path = new Path();\n    this.segments.forEach(s => path.appendSegment(s.clone()));\n    return path;\n  }\n  equals(p) {\n    if (p == null) {\n      return false;\n    }\n    const segments = this.segments;\n    const otherSegments = p.segments;\n    const count = segments.length;\n    if (otherSegments.length !== count) {\n      return false;\n    }\n    for (let i = 0; i < count; i += 1) {\n      const a = segments[i];\n      const b = otherSegments[i];\n      if (a.type !== b.type || !a.equals(b)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  toJSON() {\n    return this.segments.map(s => s.toJSON());\n  }\n  serialize() {\n    if (!this.isValid()) {\n      throw new Error('Invalid path segments.');\n    }\n    return this.segments.map(s => s.serialize()).join(' ');\n  }\n  toString() {\n    return this.serialize();\n  }\n}\n(function (Path) {\n  function isPath(instance) {\n    return instance != null && instance instanceof Path;\n  }\n  Path.isPath = isPath;\n})(Path || (Path = {}));\n(function (Path) {\n  function parse(pathData) {\n    if (!pathData) {\n      return new Path();\n    }\n    const path = new Path();\n    const commandRe = /(?:[a-zA-Z] *)(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)? *,? *)|(?:-?\\.\\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\\d|-|\\.)/g;\n    const commands = Path.normalize(pathData).match(commandRe);\n    if (commands != null) {\n      for (let i = 0, ii = commands.length; i < ii; i += 1) {\n        const command = commands[i];\n        const argRe = /(?:[a-zA-Z])|(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)?))|(?:(?:-?\\.\\d+))/g;\n        const args = command.match(argRe); // [type, coordinate1, coordinate2...]\n        if (args != null) {\n          const type = args[0];\n          const coords = args.slice(1).map(a => +a);\n          const segment = createSegment.call(null, type, ...coords);\n          path.appendSegment(segment);\n        }\n      }\n    }\n    return path;\n  }\n  Path.parse = parse;\n  function createSegment(type, ...args) {\n    if (type === 'M') {\n      return MoveTo.create.call(null, ...args);\n    }\n    if (type === 'L') {\n      return LineTo.create.call(null, ...args);\n    }\n    if (type === 'C') {\n      return CurveTo.create.call(null, ...args);\n    }\n    if (type === 'z' || type === 'Z') {\n      return Close.create();\n    }\n    throw new Error(`Invalid path segment type \"${type}\"`);\n  }\n  Path.createSegment = createSegment;\n})(Path || (Path = {}));\n(function (Path) {\n  Path.normalize = normalizePathData;\n  Path.isValid = PathUtil.isValid;\n  Path.drawArc = PathUtil.drawArc;\n  Path.drawPoints = PathUtil.drawPoints;\n  Path.arcToCurves = PathUtil.arcToCurves;\n})(Path || (Path = {}));","map":{"version":3,"names":["GeometryUtil","PathUtil","Line","Point","Curve","Polyline","Rectangle","Geometry","Close","LineTo","MoveTo","CurveTo","normalizePathData","Path","constructor","args","PRECISION","segments","Array","isArray","isLine","isCurve","previousObj","arr","forEach","o","i","appendSegment","createSegment","start","end","equals","controlPoint1","controlPoint2","s","isSegment","isPolyline","points","length","point","index","segment","count","isVisible","moveTo","create","call","lineTo","curveTo","arcTo","rx","ry","xAxisRotation","largeArcFlag","sweepFlag","endX","endY","arcToCurves","x","y","ii","quadTo","x1","y1","data","push","p","path","parse","join","slice","close","drawPoints","options","raw","sub","bbox","segmentBBox","union","lastSegment","seg","previousSegment","currentSegment","nextSegment","prepareSegment","insertSegment","Error","splice","removeSegment","idx","fixIndex","removedSegment","isSubpathStart","updateSubpathStartSegment","replaceSegment","replacedSegment","updateSubpathStart","getSegment","segmentAt","ratio","segmentIndexAt","segmentAtLength","segmentIndexAtLength","rate","clamp","opt","getOptions","len","fromStart","precision","getPrecision","segmentSubdivisions","getSubdivisions","memo","lastVisibleIndex","subdivisions","getSegmentSubdivisions","previous","current","subpathStartSegment","closestPoint","t","closestPointT","pointAtT","closestPointLength","opts","lengthAtT","closestPointNormalizedLength","cpLength","minSquaredDistance","Infinity","segmentClosestPointT","segmentClosestPoint","squaredDistance","squaredLength","segmentIndex","value","closestPointTangent","isDifferentiable","tangentAtT","containsPoint","polylines","toPolylines","numIntersections","polyline","pointAt","clone","pathLength","pointAtLength","lastVisibleSegment","d","numSegments","tValue","divideAt","divideAtLength","divided","dividedSegmentIndex","lastValidSegment","lastValidSegmentIndex","divideAtT","pathCopy","divisionStartIndex","divisionMidIndex","divisionEndIndex","movetoEnd","secondPathSegmentIndexConversion","originalSegment","type","convertedSegment","firstPath","secondPath","intersectsWithLine","line","intersections","intersection","intersect","isValid","tangentAt","tangentAtLength","toPoints","partialPoints","divisions","c","map","scale","sx","sy","origin","rotate","angle","translate","tx","ty","otherSegments","a","b","toJSON","serialize","toString","isPath","instance","pathData","commandRe","commands","normalize","match","command","argRe","coords","drawArc"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6-geometry@2.0.5/node_modules/@antv/x6-geometry/src/path/path.ts"],"sourcesContent":["import { GeometryUtil } from '../util'\nimport * as PathUtil from './util'\nimport { Line } from '../line'\nimport { Point } from '../point'\nimport { Curve } from '../curve'\nimport { Polyline } from '../polyline'\nimport { Rectangle } from '../rectangle'\nimport { Geometry } from '../geometry'\nimport { Close } from './close'\nimport { LineTo } from './lineto'\nimport { MoveTo } from './moveto'\nimport { CurveTo } from './curveto'\nimport { normalizePathData } from './normalize'\nimport { Segment } from './segment'\n\nexport class Path extends Geometry {\n  protected readonly PRECISION: number = 3\n  public segments: Segment[]\n\n  constructor()\n  constructor(line: Line)\n  constructor(curve: Curve)\n  constructor(polyline: Polyline)\n  constructor(segment: Segment)\n  constructor(segments: Segment[])\n  constructor(lines: Line[])\n  constructor(curves: Curve[])\n  constructor(\n    args?: Line | Curve | Polyline | Segment | Segment[] | Line[] | Curve[],\n  ) {\n    super()\n    this.segments = []\n    if (Array.isArray(args)) {\n      if (Line.isLine(args[0]) || Curve.isCurve(args[0])) {\n        let previousObj: Line | Curve | null = null\n        const arr = args as Line[] | Curve[]\n        arr.forEach((o: Line | Curve, i: number) => {\n          if (i === 0) {\n            this.appendSegment(Path.createSegment('M', o.start))\n          }\n          if (previousObj != null && !previousObj.end.equals(o.start)) {\n            this.appendSegment(Path.createSegment('M', o.start))\n          }\n\n          if (Line.isLine(o)) {\n            this.appendSegment(Path.createSegment('L', o.end))\n          } else if (Curve.isCurve(o)) {\n            this.appendSegment(\n              Path.createSegment('C', o.controlPoint1, o.controlPoint2, o.end),\n            )\n          }\n\n          previousObj = o\n        })\n      } else {\n        const arr = args as Segment[]\n        arr.forEach((s) => {\n          if (s.isSegment) {\n            this.appendSegment(s)\n          }\n        })\n      }\n    } else if (args != null) {\n      if (Line.isLine(args)) {\n        this.appendSegment(Path.createSegment('M', args.start))\n        this.appendSegment(Path.createSegment('L', args.end))\n      } else if (Curve.isCurve(args)) {\n        this.appendSegment(Path.createSegment('M', args.start))\n        this.appendSegment(\n          Path.createSegment(\n            'C',\n            args.controlPoint1,\n            args.controlPoint2,\n            args.end,\n          ),\n        )\n      } else if (Polyline.isPolyline(args)) {\n        if (args.points && args.points.length) {\n          args.points.forEach((point, index) => {\n            const segment =\n              index === 0\n                ? Path.createSegment('M', point)\n                : Path.createSegment('L', point)\n            this.appendSegment(segment)\n          })\n        }\n      } else if (args.isSegment) {\n        this.appendSegment(args)\n      }\n    }\n  }\n\n  get start() {\n    const segments = this.segments\n    const count = segments.length\n    if (count === 0) {\n      return null\n    }\n\n    for (let i = 0; i < count; i += 1) {\n      const segment = segments[i]\n      if (segment.isVisible) {\n        return segment.start\n      }\n    }\n\n    // if no visible segment, return last segment end point\n    return segments[count - 1].end\n  }\n\n  get end() {\n    const segments = this.segments\n    const count = segments.length\n    if (count === 0) {\n      return null\n    }\n\n    for (let i = count - 1; i >= 0; i -= 1) {\n      const segment = segments[i]\n      if (segment.isVisible) {\n        return segment.end\n      }\n    }\n\n    // if no visible segment, return last segment end point\n    return segments[count - 1].end\n  }\n\n  moveTo(x: number, y: number): this\n  moveTo(point: Point.PointLike): this\n  moveTo(line: Line): this\n  moveTo(curve: Curve): this\n  moveTo(point: Point.PointLike, ...points: Point.PointLike[]): this\n  moveTo(x: number, y: number, ...coords: number[]): this\n  moveTo(...args: any[]) {\n    return this.appendSegment(MoveTo.create.call(null, ...args))\n  }\n\n  lineTo(x: number, y: number): this\n  lineTo(point: Point.PointLike): this\n  lineTo(line: Line): this\n  lineTo(x: number, y: number, ...coords: number[]): this\n  lineTo(point: Point.PointLike, ...points: Point.PointLike[]): this\n  lineTo(...args: any[]) {\n    return this.appendSegment(LineTo.create.call(null, ...args))\n  }\n\n  curveTo(\n    x0: number,\n    y0: number,\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n  ): this\n  curveTo(\n    x0: number,\n    y0: number,\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    ...coords: number[]\n  ): this\n  curveTo(p1: Point.PointLike, p2: Point.PointLike, p3: Point.PointLike): this\n  curveTo(\n    p1: Point.PointLike,\n    p2: Point.PointLike,\n    p3: Point.PointLike,\n    ...points: Point.PointLike[]\n  ): this\n  curveTo(...args: any[]) {\n    return this.appendSegment(CurveTo.create.call(null, ...args))\n  }\n\n  arcTo(\n    rx: number,\n    ry: number,\n    xAxisRotation: number,\n    largeArcFlag: 0 | 1,\n    sweepFlag: 0 | 1,\n    endX: number,\n    endY: number,\n  ): this\n  arcTo(\n    rx: number,\n    ry: number,\n    xAxisRotation: number,\n    largeArcFlag: 0 | 1,\n    sweepFlag: 0 | 1,\n    endPoint: Point.PointLike,\n  ): this\n  arcTo(\n    rx: number,\n    ry: number,\n    xAxisRotation: number,\n    largeArcFlag: 0 | 1,\n    sweepFlag: 0 | 1,\n    endX: number | Point.PointLike,\n    endY?: number,\n  ) {\n    const start = this.end || new Point()\n    const points =\n      typeof endX === 'number'\n        ? PathUtil.arcToCurves(\n            start.x,\n            start.y,\n            rx,\n            ry,\n            xAxisRotation,\n            largeArcFlag,\n            sweepFlag,\n            endX,\n            endY as number,\n          )\n        : PathUtil.arcToCurves(\n            start.x,\n            start.y,\n            rx,\n            ry,\n            xAxisRotation,\n            largeArcFlag,\n            sweepFlag,\n            endX.x,\n            endX.y,\n          )\n\n    if (points != null) {\n      for (let i = 0, ii = points.length; i < ii; i += 6) {\n        this.curveTo(\n          points[i],\n          points[i + 1],\n          points[i + 2],\n          points[i + 3],\n          points[i + 4],\n          points[i + 5],\n        )\n      }\n    }\n    return this\n  }\n\n  quadTo(controlPoint: Point.PointLike, endPoint: Point.PointLike): this\n  quadTo(\n    controlPointX: number,\n    controlPointY: number,\n    endPointX: number,\n    endPointY: number,\n  ): this\n  quadTo(\n    x1: number | Point.PointLike,\n    y1: number | Point.PointLike,\n    x?: number,\n    y?: number,\n  ) {\n    const start = this.end || new Point()\n    const data = ['M', start.x, start.y]\n    if (typeof x1 === 'number') {\n      data.push('Q', x1, y1 as number, x as number, y as number)\n    } else {\n      const p = y1 as Point.PointLike\n      data.push(`Q`, x1.x, x1.y, p.x, p.y)\n    }\n    const path = Path.parse(data.join(' '))\n    this.appendSegment(path.segments.slice(1))\n    return this\n  }\n\n  close() {\n    return this.appendSegment(Close.create())\n  }\n\n  drawPoints(\n    points: (Point.PointLike | Point.PointData)[],\n    options: PathUtil.DrawPointsOptions = {},\n  ) {\n    const raw = PathUtil.drawPoints(points, options)\n    const sub = Path.parse(raw)\n    if (sub && sub.segments) {\n      this.appendSegment(sub.segments)\n    }\n  }\n\n  bbox() {\n    const segments = this.segments\n    const count = segments.length\n    if (count === 0) {\n      return null\n    }\n\n    let bbox\n    for (let i = 0; i < count; i += 1) {\n      const segment = segments[i]\n      if (segment.isVisible) {\n        const segmentBBox = segment.bbox()\n        if (segmentBBox != null) {\n          bbox = bbox ? bbox.union(segmentBBox) : segmentBBox\n        }\n      }\n    }\n\n    if (bbox != null) {\n      return bbox\n    }\n\n    // if the path has only invisible elements, return end point of last segment\n    const lastSegment = segments[count - 1]\n    return new Rectangle(lastSegment.end.x, lastSegment.end.y, 0, 0)\n  }\n\n  appendSegment(seg: Segment | Segment[]) {\n    const count = this.segments.length\n    let previousSegment = count !== 0 ? this.segments[count - 1] : null\n    let currentSegment\n    const nextSegment = null\n\n    if (Array.isArray(seg)) {\n      for (let i = 0, ii = seg.length; i < ii; i += 1) {\n        const segment = seg[i]\n        currentSegment = this.prepareSegment(\n          segment,\n          previousSegment,\n          nextSegment,\n        )\n        this.segments.push(currentSegment)\n        previousSegment = currentSegment\n      }\n    } else if (seg != null && seg.isSegment) {\n      currentSegment = this.prepareSegment(seg, previousSegment, nextSegment)\n      this.segments.push(currentSegment)\n    }\n    return this\n  }\n\n  insertSegment(index: number, seg: Segment | Segment[]) {\n    const count = this.segments.length\n    if (index < 0) {\n      index = count + index + 1 // eslint-disable-line\n    }\n\n    if (index > count || index < 0) {\n      throw new Error('Index out of range.')\n    }\n\n    let currentSegment\n    let previousSegment = null\n    let nextSegment = null\n\n    if (count !== 0) {\n      if (index >= 1) {\n        previousSegment = this.segments[index - 1]\n        nextSegment = previousSegment.nextSegment\n      } else {\n        previousSegment = null\n        nextSegment = this.segments[0]\n      }\n    }\n\n    if (!Array.isArray(seg)) {\n      currentSegment = this.prepareSegment(seg, previousSegment, nextSegment)\n      this.segments.splice(index, 0, currentSegment)\n    } else {\n      for (let i = 0, ii = seg.length; i < ii; i += 1) {\n        const segment = seg[i]\n        currentSegment = this.prepareSegment(\n          segment,\n          previousSegment,\n          nextSegment,\n        )\n        this.segments.splice(index + i, 0, currentSegment)\n        previousSegment = currentSegment\n      }\n    }\n    return this\n  }\n\n  removeSegment(index: number) {\n    const idx = this.fixIndex(index)\n    const removedSegment = this.segments.splice(idx, 1)[0]\n    const previousSegment = removedSegment.previousSegment\n    const nextSegment = removedSegment.nextSegment\n\n    // link the previous and next segments together (if present)\n    if (previousSegment) {\n      previousSegment.nextSegment = nextSegment\n    }\n\n    if (nextSegment) {\n      nextSegment.previousSegment = previousSegment\n    }\n\n    if (removedSegment.isSubpathStart && nextSegment) {\n      this.updateSubpathStartSegment(nextSegment)\n    }\n    return removedSegment\n  }\n\n  replaceSegment(index: number, seg: Segment | Segment[]) {\n    const idx = this.fixIndex(index)\n\n    let currentSegment\n    const replacedSegment = this.segments[idx]\n    let previousSegment = replacedSegment.previousSegment\n    const nextSegment = replacedSegment.nextSegment\n\n    let updateSubpathStart = replacedSegment.isSubpathStart\n\n    if (!Array.isArray(seg)) {\n      currentSegment = this.prepareSegment(seg, previousSegment, nextSegment)\n      this.segments.splice(idx, 1, currentSegment)\n      if (updateSubpathStart && currentSegment.isSubpathStart) {\n        // already updated by `prepareSegment`\n        updateSubpathStart = false\n      }\n    } else {\n      this.segments.splice(index, 1)\n\n      for (let i = 0, ii = seg.length; i < ii; i += 1) {\n        const segment = seg[i]\n        currentSegment = this.prepareSegment(\n          segment,\n          previousSegment,\n          nextSegment,\n        )\n        this.segments.splice(index + i, 0, currentSegment)\n        previousSegment = currentSegment\n\n        if (updateSubpathStart && currentSegment.isSubpathStart) {\n          updateSubpathStart = false\n        }\n      }\n    }\n\n    if (updateSubpathStart && nextSegment) {\n      this.updateSubpathStartSegment(nextSegment)\n    }\n  }\n\n  getSegment(index: number) {\n    const idx = this.fixIndex(index)\n    return this.segments[idx]\n  }\n\n  protected fixIndex(index: number) {\n    const length = this.segments.length\n\n    if (length === 0) {\n      throw new Error('Path has no segments.')\n    }\n\n    let i = index\n    while (i < 0) {\n      i = length + i\n    }\n\n    if (i >= length || i < 0) {\n      throw new Error('Index out of range.')\n    }\n\n    return i\n  }\n\n  segmentAt(ratio: number, options: Path.Options = {}) {\n    const index = this.segmentIndexAt(ratio, options)\n    if (!index) {\n      return null\n    }\n\n    return this.getSegment(index)\n  }\n\n  segmentAtLength(length: number, options: Path.Options = {}) {\n    const index = this.segmentIndexAtLength(length, options)\n    if (!index) return null\n\n    return this.getSegment(index)\n  }\n\n  segmentIndexAt(ratio: number, options: Path.Options = {}) {\n    if (this.segments.length === 0) {\n      return null\n    }\n\n    const rate = GeometryUtil.clamp(ratio, 0, 1)\n    const opt = this.getOptions(options)\n    const len = this.length(opt)\n    const length = len * rate\n    return this.segmentIndexAtLength(length, opt)\n  }\n\n  segmentIndexAtLength(length: number, options: Path.Options = {}) {\n    const count = this.segments.length\n    if (count === 0) {\n      return null\n    }\n\n    let fromStart = true\n    if (length < 0) {\n      fromStart = false\n      length = -length // eslint-disable-line\n    }\n\n    const precision = this.getPrecision(options)\n    const segmentSubdivisions = this.getSubdivisions(options)\n\n    let memo = 0\n    let lastVisibleIndex = null\n\n    for (let i = 0; i < count; i += 1) {\n      const index = fromStart ? i : count - 1 - i\n\n      const segment = this.segments[index]\n      const subdivisions = segmentSubdivisions[index]\n      const len = segment.length({ precision, subdivisions })\n\n      if (segment.isVisible) {\n        if (length <= memo + len) {\n          return index\n        }\n        lastVisibleIndex = index\n      }\n\n      memo += len\n    }\n\n    // If length requested is higher than the length of the path, return\n    // last visible segment index. If no visible segment, return null.\n    return lastVisibleIndex\n  }\n\n  getSegmentSubdivisions(options: Path.Options = {}): Segment[][] {\n    const precision = this.getPrecision(options)\n    const segmentSubdivisions = []\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const segment = this.segments[i]\n      const subdivisions = segment.getSubdivisions({ precision })\n      segmentSubdivisions.push(subdivisions)\n    }\n\n    return segmentSubdivisions\n  }\n\n  protected updateSubpathStartSegment(segment: Segment) {\n    let previous = segment.previousSegment\n    let current: Segment | null = segment\n\n    while (current && !current.isSubpathStart) {\n      // assign previous segment's subpath start segment to this segment\n      if (previous != null) {\n        current.subpathStartSegment = previous.subpathStartSegment\n      } else {\n        current.subpathStartSegment = null\n      }\n\n      previous = current\n      current = current.nextSegment\n    }\n  }\n\n  protected prepareSegment(\n    segment: Segment,\n    previousSegment: Segment | null,\n    nextSegment: Segment | null,\n  ) {\n    segment.previousSegment = previousSegment\n    segment.nextSegment = nextSegment\n\n    if (previousSegment != null) {\n      previousSegment.nextSegment = segment\n    }\n\n    if (nextSegment != null) {\n      nextSegment.previousSegment = segment\n    }\n\n    let updateSubpathStart: Segment | null = segment\n    if (segment.isSubpathStart) {\n      // move to\n      segment.subpathStartSegment = segment\n      updateSubpathStart = nextSegment\n    }\n\n    // assign previous segment's subpath start (or self if it is a subpath start) to subsequent segments\n    if (updateSubpathStart != null) {\n      this.updateSubpathStartSegment(updateSubpathStart)\n    }\n\n    return segment\n  }\n\n  closestPoint(p: Point.PointLike, options: Path.Options = {}) {\n    const t = this.closestPointT(p, options)\n    if (!t) {\n      return null\n    }\n\n    return this.pointAtT(t)\n  }\n\n  closestPointLength(p: Point.PointLike, options: Path.Options = {}) {\n    const opts = this.getOptions(options)\n    const t = this.closestPointT(p, opts)\n    if (!t) {\n      return 0\n    }\n\n    return this.lengthAtT(t, opts)\n  }\n\n  closestPointNormalizedLength(p: Point.PointLike, options: Path.Options = {}) {\n    const opts = this.getOptions(options)\n    const cpLength = this.closestPointLength(p, opts)\n    if (cpLength === 0) {\n      return 0\n    }\n\n    const length = this.length(opts)\n    if (length === 0) {\n      return 0\n    }\n\n    return cpLength / length\n  }\n\n  closestPointT(p: Point.PointLike, options: Path.Options = {}) {\n    if (this.segments.length === 0) {\n      return null\n    }\n\n    const precision = this.getPrecision(options)\n    const segmentSubdivisions = this.getSubdivisions(options)\n\n    let closestPointT\n    let minSquaredDistance = Infinity\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const segment = this.segments[i]\n      const subdivisions = segmentSubdivisions[i]\n\n      if (segment.isVisible) {\n        const segmentClosestPointT = segment.closestPointT(p, {\n          precision,\n          subdivisions,\n        })\n        const segmentClosestPoint = segment.pointAtT(segmentClosestPointT)\n        const squaredDistance = GeometryUtil.squaredLength(\n          segmentClosestPoint,\n          p,\n        )\n\n        if (squaredDistance < minSquaredDistance) {\n          closestPointT = { segmentIndex: i, value: segmentClosestPointT }\n          minSquaredDistance = squaredDistance\n        }\n      }\n    }\n\n    if (closestPointT) {\n      return closestPointT\n    }\n\n    return { segmentIndex: this.segments.length - 1, value: 1 }\n  }\n\n  closestPointTangent(p: Point.PointLike, options: Path.Options = {}) {\n    if (this.segments.length === 0) {\n      return null\n    }\n\n    const precision = this.getPrecision(options)\n    const segmentSubdivisions = this.getSubdivisions(options)\n\n    let closestPointTangent\n    let minSquaredDistance = Infinity\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const segment = this.segments[i]\n      const subdivisions = segmentSubdivisions[i]\n\n      if (segment.isDifferentiable()) {\n        const segmentClosestPointT = segment.closestPointT(p, {\n          precision,\n          subdivisions,\n        })\n        const segmentClosestPoint = segment.pointAtT(segmentClosestPointT)\n        const squaredDistance = GeometryUtil.squaredLength(\n          segmentClosestPoint,\n          p,\n        )\n\n        if (squaredDistance < minSquaredDistance) {\n          closestPointTangent = segment.tangentAtT(segmentClosestPointT)\n          minSquaredDistance = squaredDistance\n        }\n      }\n    }\n\n    if (closestPointTangent) {\n      return closestPointTangent\n    }\n\n    return null\n  }\n\n  containsPoint(p: Point.PointLike, options: Path.Options = {}) {\n    const polylines = this.toPolylines(options)\n    if (!polylines) {\n      return false\n    }\n\n    let numIntersections = 0\n    for (let i = 0, ii = polylines.length; i < ii; i += 1) {\n      const polyline = polylines[i]\n      if (polyline.containsPoint(p)) {\n        numIntersections += 1\n      }\n    }\n\n    // returns `true` for odd numbers of intersections (even-odd algorithm)\n    return numIntersections % 2 === 1\n  }\n\n  pointAt(ratio: number, options: Path.Options = {}) {\n    if (this.segments.length === 0) {\n      return null\n    }\n\n    if (ratio <= 0) {\n      return this.start!.clone()\n    }\n\n    if (ratio >= 1) {\n      return this.end!.clone()\n    }\n\n    const opts = this.getOptions(options)\n    const pathLength = this.length(opts)\n    const length = pathLength * ratio\n\n    return this.pointAtLength(length, opts)\n  }\n\n  pointAtLength(length: number, options: Path.Options = {}) {\n    if (this.segments.length === 0) {\n      return null\n    }\n\n    if (length === 0) {\n      return this.start!.clone()\n    }\n\n    let fromStart = true\n    if (length < 0) {\n      fromStart = false\n      length = -length // eslint-disable-line\n    }\n\n    const precision = this.getPrecision(options)\n    const segmentSubdivisions = this.getSubdivisions(options)\n\n    let lastVisibleSegment\n    let memo = 0\n\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const index = fromStart ? i : ii - 1 - i\n\n      const segment = this.segments[index]\n      const subdivisions = segmentSubdivisions[index]\n      const d = segment.length({\n        precision,\n        subdivisions,\n      })\n\n      if (segment.isVisible) {\n        if (length <= memo + d) {\n          return segment.pointAtLength((fromStart ? 1 : -1) * (length - memo), {\n            precision,\n            subdivisions,\n          })\n        }\n\n        lastVisibleSegment = segment\n      }\n\n      memo += d\n    }\n\n    // if length requested is higher than the length of the path,\n    // return last visible segment endpoint\n    if (lastVisibleSegment) {\n      return fromStart ? lastVisibleSegment.end : lastVisibleSegment.start\n    }\n\n    // if no visible segment, return last segment end point\n    const lastSegment = this.segments[this.segments.length - 1]\n    return lastSegment.end.clone()\n  }\n\n  pointAtT(t: { segmentIndex: number; value: number }) {\n    const segments = this.segments\n    const numSegments = segments.length\n    if (numSegments === 0) return null // if segments is an empty array\n\n    const segmentIndex = t.segmentIndex\n    if (segmentIndex < 0) return segments[0].pointAtT(0)\n    if (segmentIndex >= numSegments) {\n      return segments[numSegments - 1].pointAtT(1)\n    }\n\n    const tValue = GeometryUtil.clamp(t.value, 0, 1)\n    return segments[segmentIndex].pointAtT(tValue)\n  }\n\n  divideAt(ratio: number, options: Path.Options = {}) {\n    if (this.segments.length === 0) {\n      return null\n    }\n\n    const rate = GeometryUtil.clamp(ratio, 0, 1)\n    const opts = this.getOptions(options)\n    const len = this.length(opts)\n    const length = len * rate\n    return this.divideAtLength(length, opts)\n  }\n\n  divideAtLength(length: number, options: Path.Options = {}) {\n    if (this.segments.length === 0) {\n      return null\n    }\n\n    let fromStart = true\n    if (length < 0) {\n      fromStart = false\n      length = -length // eslint-disable-line\n    }\n\n    const precision = this.getPrecision(options)\n    const segmentSubdivisions = this.getSubdivisions(options)\n\n    let memo = 0\n    let divided\n    let dividedSegmentIndex\n    let lastValidSegment\n    let lastValidSegmentIndex\n    let t\n\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const index = fromStart ? i : ii - 1 - i\n      const segment = this.getSegment(index)\n      const subdivisions = segmentSubdivisions[index]\n      const opts = { precision, subdivisions }\n      const len = segment.length(opts)\n\n      if (segment.isDifferentiable()) {\n        lastValidSegment = segment\n        lastValidSegmentIndex = index\n\n        if (length <= memo + len) {\n          dividedSegmentIndex = index\n          divided = segment.divideAtLength(\n            (fromStart ? 1 : -1) * (length - memo),\n            opts,\n          )\n          break\n        }\n      }\n\n      memo += len\n    }\n\n    if (!lastValidSegment) {\n      return null\n    }\n\n    if (!divided) {\n      dividedSegmentIndex = lastValidSegmentIndex\n      t = fromStart ? 1 : 0\n      divided = lastValidSegment.divideAtT(t)\n    }\n\n    // create a copy of this path and replace the identified segment with its two divided parts:\n\n    const pathCopy = this.clone()\n    const index = dividedSegmentIndex as number\n    pathCopy.replaceSegment(index, divided)\n\n    const divisionStartIndex = index\n    let divisionMidIndex = index + 1\n    let divisionEndIndex = index + 2\n\n    // do not insert the part if it looks like a point\n    if (!divided[0].isDifferentiable()) {\n      pathCopy.removeSegment(divisionStartIndex)\n      divisionMidIndex -= 1\n      divisionEndIndex -= 1\n    }\n\n    // insert a Moveto segment to ensure secondPath will be valid:\n    const movetoEnd = pathCopy.getSegment(divisionMidIndex).start\n    pathCopy.insertSegment(divisionMidIndex, Path.createSegment('M', movetoEnd))\n    divisionEndIndex += 1\n\n    // do not insert the part if it looks like a point\n    if (!divided[1].isDifferentiable()) {\n      pathCopy.removeSegment(divisionEndIndex - 1)\n      divisionEndIndex -= 1\n    }\n\n    // ensure that Closepath segments in secondPath will be assigned correct subpathStartSegment:\n\n    const secondPathSegmentIndexConversion =\n      divisionEndIndex - divisionStartIndex - 1\n\n    for (\n      let i = divisionEndIndex, ii = pathCopy.segments.length;\n      i < ii;\n      i += 1\n    ) {\n      const originalSegment = this.getSegment(\n        i - secondPathSegmentIndexConversion,\n      )\n      const segment = pathCopy.getSegment(i)\n\n      if (\n        segment.type === 'Z' &&\n        !originalSegment.subpathStartSegment!.end.equals(\n          segment.subpathStartSegment!.end,\n        )\n      ) {\n        // pathCopy segment's subpathStartSegment is different from original segment's one\n        // convert this Closepath segment to a Lineto and replace it in pathCopy\n        const convertedSegment = Path.createSegment('L', originalSegment.end)\n        pathCopy.replaceSegment(i, convertedSegment)\n      }\n    }\n\n    // distribute pathCopy segments into two paths and return those:\n    const firstPath = new Path(pathCopy.segments.slice(0, divisionMidIndex))\n    const secondPath = new Path(pathCopy.segments.slice(divisionMidIndex))\n\n    return [firstPath, secondPath]\n  }\n\n  intersectsWithLine(line: Line, options: Path.Options = {}) {\n    const polylines = this.toPolylines(options)\n    if (polylines == null) {\n      return null\n    }\n\n    let intersections: Point[] | null = null\n    for (let i = 0, ii = polylines.length; i < ii; i += 1) {\n      const polyline = polylines[i]\n      const intersection = line.intersect(polyline)\n      if (intersection) {\n        if (intersections == null) {\n          intersections = []\n        }\n        if (Array.isArray(intersection)) {\n          intersections.push(...intersection)\n        } else {\n          intersections.push(intersection)\n        }\n      }\n    }\n\n    return intersections\n  }\n\n  isDifferentiable() {\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const segment = this.segments[i]\n      if (segment.isDifferentiable()) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  isValid() {\n    const segments = this.segments\n    const isValid = segments.length === 0 || segments[0].type === 'M'\n    return isValid\n  }\n\n  length(options: Path.Options = {}) {\n    if (this.segments.length === 0) {\n      return 0\n    }\n\n    const segmentSubdivisions = this.getSubdivisions(options)\n\n    let length = 0\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const segment = this.segments[i]\n      const subdivisions = segmentSubdivisions[i]\n      length += segment.length({ subdivisions })\n    }\n\n    return length\n  }\n\n  lengthAtT(\n    t: { segmentIndex: number; value: number },\n    options: Path.Options = {},\n  ) {\n    const count = this.segments.length\n    if (count === 0) {\n      return 0\n    }\n\n    let segmentIndex = t.segmentIndex\n    if (segmentIndex < 0) {\n      return 0\n    }\n\n    let tValue = GeometryUtil.clamp(t.value, 0, 1)\n    if (segmentIndex >= count) {\n      segmentIndex = count - 1\n      tValue = 1\n    }\n\n    const precision = this.getPrecision(options)\n    const segmentSubdivisions = this.getSubdivisions(options)\n\n    let length = 0\n    for (let i = 0; i < segmentIndex; i += 1) {\n      const segment = this.segments[i]\n      const subdivisions = segmentSubdivisions[i]\n      length += segment.length({ precision, subdivisions })\n    }\n\n    const segment = this.segments[segmentIndex]\n    const subdivisions = segmentSubdivisions[segmentIndex]\n    length += segment.lengthAtT(tValue, { precision, subdivisions })\n\n    return length\n  }\n\n  tangentAt(ratio: number, options: Path.Options = {}) {\n    if (this.segments.length === 0) {\n      return null\n    }\n\n    const rate = GeometryUtil.clamp(ratio, 0, 1)\n    const opts = this.getOptions(options)\n    const len = this.length(opts)\n    const length = len * rate\n    return this.tangentAtLength(length, opts)\n  }\n\n  tangentAtLength(length: number, options: Path.Options = {}) {\n    if (this.segments.length === 0) {\n      return null\n    }\n\n    let fromStart = true\n    if (length < 0) {\n      fromStart = false\n      length = -length // eslint-disable-line\n    }\n\n    const precision = this.getPrecision(options)\n    const segmentSubdivisions = this.getSubdivisions(options)\n\n    let lastValidSegment\n    let memo = 0\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const index = fromStart ? i : ii - 1 - i\n      const segment = this.segments[index]\n      const subdivisions = segmentSubdivisions[index]\n      const len = segment.length({ precision, subdivisions })\n\n      if (segment.isDifferentiable()) {\n        if (length <= memo + len) {\n          return segment.tangentAtLength(\n            (fromStart ? 1 : -1) * (length - memo),\n            {\n              precision,\n              subdivisions,\n            },\n          )\n        }\n\n        lastValidSegment = segment\n      }\n\n      memo += len\n    }\n\n    // if length requested is higher than the length of the path, return tangent of endpoint of last valid segment\n    if (lastValidSegment) {\n      const t = fromStart ? 1 : 0\n      return lastValidSegment.tangentAtT(t)\n    }\n\n    // if no valid segment, return null\n    return null\n  }\n\n  tangentAtT(t: { segmentIndex: number; value: number }) {\n    const count = this.segments.length\n    if (count === 0) {\n      return null\n    }\n\n    const segmentIndex = t.segmentIndex\n    if (segmentIndex < 0) {\n      return this.segments[0].tangentAtT(0)\n    }\n\n    if (segmentIndex >= count) {\n      return this.segments[count - 1].tangentAtT(1)\n    }\n\n    const tValue = GeometryUtil.clamp(t.value, 0, 1)\n    return this.segments[segmentIndex].tangentAtT(tValue)\n  }\n\n  protected getPrecision(options: Path.Options = {}) {\n    return options.precision == null ? this.PRECISION : options.precision\n  }\n\n  protected getSubdivisions(options: Path.Options = {}) {\n    if (options.segmentSubdivisions == null) {\n      const precision = this.getPrecision(options)\n      return this.getSegmentSubdivisions({ precision })\n    }\n    return options.segmentSubdivisions\n  }\n\n  protected getOptions(options: Path.Options = {}) {\n    const precision = this.getPrecision(options)\n    const segmentSubdivisions = this.getSubdivisions(options)\n    return { precision, segmentSubdivisions }\n  }\n\n  toPoints(options: Path.Options = {}) {\n    const segments = this.segments\n    const count = segments.length\n    if (count === 0) {\n      return null\n    }\n\n    const segmentSubdivisions = this.getSubdivisions(options)\n    const points = []\n    let partialPoints = []\n\n    for (let i = 0; i < count; i += 1) {\n      const segment = segments[i]\n      if (segment.isVisible) {\n        const divisions = segmentSubdivisions[i]\n        if (divisions.length > 0) {\n          // eslint-disable-next-line no-loop-func\n          divisions.forEach((c) => partialPoints.push(c.start))\n        } else {\n          partialPoints.push(segment.start)\n        }\n      } else if (partialPoints.length > 0) {\n        partialPoints.push(segments[i - 1].end)\n        points.push(partialPoints)\n        partialPoints = []\n      }\n    }\n\n    if (partialPoints.length > 0) {\n      partialPoints.push(this.end!)\n      points.push(partialPoints)\n    }\n\n    return points\n  }\n\n  toPolylines(options: Path.Options = {}) {\n    const points = this.toPoints(options)\n    if (!points) {\n      return null\n    }\n\n    return points.map((arr) => new Polyline(arr))\n  }\n\n  scale(sx: number, sy: number, origin?: Point.PointLike) {\n    this.segments.forEach((s) => s.scale(sx, sy, origin))\n    return this\n  }\n\n  rotate(angle: number, origin?: Point.PointLike | Point.PointData) {\n    this.segments.forEach((segment) => segment.rotate(angle, origin))\n    return this\n  }\n\n  translate(tx: number, ty: number): this\n  translate(p: Point.PointLike): this\n  translate(tx: number | Point.PointLike, ty?: number) {\n    if (typeof tx === 'number') {\n      this.segments.forEach((s) => s.translate(tx, ty as number))\n    } else {\n      this.segments.forEach((s) => s.translate(tx))\n    }\n    return this\n  }\n\n  clone() {\n    const path = new Path()\n    this.segments.forEach((s) => path.appendSegment(s.clone()))\n    return path\n  }\n\n  equals(p: Path) {\n    if (p == null) {\n      return false\n    }\n\n    const segments = this.segments\n    const otherSegments = p.segments\n\n    const count = segments.length\n    if (otherSegments.length !== count) {\n      return false\n    }\n\n    for (let i = 0; i < count; i += 1) {\n      const a = segments[i]\n      const b = otherSegments[i]\n      if (a.type !== b.type || !a.equals(b)) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  toJSON() {\n    return this.segments.map((s) => s.toJSON())\n  }\n\n  serialize() {\n    if (!this.isValid()) {\n      throw new Error('Invalid path segments.')\n    }\n\n    return this.segments.map((s) => s.serialize()).join(' ')\n  }\n\n  toString() {\n    return this.serialize()\n  }\n}\n\nexport namespace Path {\n  export function isPath(instance: any): instance is Path {\n    return instance != null && instance instanceof Path\n  }\n}\n\nexport namespace Path {\n  export interface Options {\n    precision?: number | null\n    segmentSubdivisions?: Segment[][] | null\n  }\n}\n\nexport namespace Path {\n  export function parse(pathData: string) {\n    if (!pathData) {\n      return new Path()\n    }\n\n    const path = new Path()\n    const commandRe =\n      /(?:[a-zA-Z] *)(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)? *,? *)|(?:-?\\.\\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\\d|-|\\.)/g\n    const commands = normalize(pathData).match(commandRe)\n    if (commands != null) {\n      for (let i = 0, ii = commands.length; i < ii; i += 1) {\n        const command = commands[i]\n        const argRe =\n          /(?:[a-zA-Z])|(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)?))|(?:(?:-?\\.\\d+))/g\n        const args = command.match(argRe) // [type, coordinate1, coordinate2...]\n        if (args != null) {\n          const type = args[0]\n          const coords = args.slice(1).map((a) => +a)\n          const segment = createSegment.call(null, type, ...coords)\n          path.appendSegment(segment)\n        }\n      }\n    }\n\n    return path\n  }\n\n  export function createSegment(type: 'M', x: number, y: number): MoveTo\n  export function createSegment(type: 'M', point: Point.PointLike): MoveTo\n  export function createSegment(type: 'M', line: Line): MoveTo\n  export function createSegment(type: 'M', curve: Curve): MoveTo\n  export function createSegment(\n    type: 'M',\n    point: Point.PointLike,\n    ...points: Point.PointLike[]\n  ): Segment[]\n  export function createSegment(\n    type: 'M',\n    x: number,\n    y: number,\n    ...coords: number[]\n  ): Segment[]\n  export function createSegment(type: 'L', x: number, y: number): LineTo\n  export function createSegment(type: 'L', point: Point.PointLike): LineTo\n  export function createSegment(type: 'L', line: Line): LineTo\n  export function createSegment(\n    type: 'L',\n    point: Point.PointLike,\n    ...points: Point.PointLike[]\n  ): LineTo[]\n  export function createSegment(\n    type: 'L',\n    x: number,\n    y: number,\n    ...coords: number[]\n  ): LineTo[]\n  export function createSegment(\n    type: 'C',\n    x0: number,\n    y0: number,\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n  ): CurveTo\n  export function createSegment(\n    type: 'C',\n    x0: number,\n    y0: number,\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    ...coords: number[]\n  ): CurveTo[]\n  export function createSegment(\n    type: 'C',\n    p1: Point.PointLike,\n    p2: Point.PointLike,\n    p3: Point.PointLike,\n  ): CurveTo\n  export function createSegment(\n    type: 'C',\n    p1: Point.PointLike,\n    p2: Point.PointLike,\n    p3: Point.PointLike,\n    ...points: Point.PointLike[]\n  ): CurveTo[]\n  export function createSegment(type: 'Z' | 'z'): Close\n  export function createSegment(\n    type: 'M' | 'L' | 'C' | 'Z' | 'z',\n    ...args: any[]\n  ):\n    | MoveTo\n    | MoveTo[]\n    | LineTo\n    | LineTo[]\n    | CurveTo\n    | CurveTo[]\n    | Close\n    | Segment\n    | Segment[] {\n    if (type === 'M') {\n      return MoveTo.create.call(null, ...args)\n    }\n\n    if (type === 'L') {\n      return LineTo.create.call(null, ...args)\n    }\n\n    if (type === 'C') {\n      return CurveTo.create.call(null, ...args)\n    }\n\n    if (type === 'z' || type === 'Z') {\n      return Close.create()\n    }\n\n    throw new Error(`Invalid path segment type \"${type}\"`)\n  }\n}\n\nexport namespace Path {\n  export const normalize = normalizePathData\n  export const isValid = PathUtil.isValid\n  export const drawArc = PathUtil.drawArc\n  export const drawPoints = PathUtil.drawPoints\n  export const arcToCurves = PathUtil.arcToCurves\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}