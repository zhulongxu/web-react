{"ast":null,"code":"import { hasClass } from './class';\nlet idCounter = 0;\nexport function uniqueId() {\n  idCounter += 1;\n  return `v${idCounter}`;\n}\nexport function ensureId(elem) {\n  if (elem.id == null || elem.id === '') {\n    elem.id = uniqueId();\n  }\n  return elem.id;\n}\n/**\n * Returns true if object is an instance of SVGGraphicsElement.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement\n */\nexport function isSVGGraphicsElement(elem) {\n  if (elem == null) {\n    return false;\n  }\n  return typeof elem.getScreenCTM === 'function' && elem instanceof SVGElement;\n}\nexport const ns = {\n  svg: 'http://www.w3.org/2000/svg',\n  xmlns: 'http://www.w3.org/2000/xmlns/',\n  xml: 'http://www.w3.org/XML/1998/namespace',\n  xlink: 'http://www.w3.org/1999/xlink',\n  xhtml: 'http://www.w3.org/1999/xhtml'\n};\nexport const svgVersion = '1.1';\nexport function createElement(tagName, doc = document) {\n  return doc.createElement(tagName);\n}\nexport function createElementNS(tagName, namespaceURI = ns.xhtml, doc = document) {\n  return doc.createElementNS(namespaceURI, tagName);\n}\nexport function createSvgElement(tagName, doc = document) {\n  return createElementNS(tagName, ns.svg, doc);\n}\nexport function createSvgDocument(content) {\n  if (content) {\n    const xml = `<svg xmlns=\"${ns.svg}\" xmlns:xlink=\"${ns.xlink}\" version=\"${svgVersion}\">${content}</svg>`; // lgtm[js/html-constructed-from-input]\n    const {\n      documentElement\n    } = parseXML(xml, {\n      async: false\n    });\n    return documentElement;\n  }\n  const svg = document.createElementNS(ns.svg, 'svg');\n  svg.setAttributeNS(ns.xmlns, 'xmlns:xlink', ns.xlink);\n  svg.setAttribute('version', svgVersion);\n  return svg;\n}\nexport function parseXML(data, options = {}) {\n  let xml;\n  try {\n    const parser = new DOMParser();\n    if (options.async != null) {\n      const instance = parser;\n      instance.async = options.async;\n    }\n    xml = parser.parseFromString(data, options.mimeType || 'text/xml');\n  } catch (error) {\n    xml = undefined;\n  }\n  if (!xml || xml.getElementsByTagName('parsererror').length) {\n    throw new Error(`Invalid XML: ${data}`);\n  }\n  return xml;\n}\nexport function tagName(node, lowercase = true) {\n  const nodeName = node.nodeName;\n  return lowercase ? nodeName.toLowerCase() : nodeName.toUpperCase();\n}\nexport function index(elem) {\n  let index = 0;\n  let node = elem.previousSibling;\n  while (node) {\n    if (node.nodeType === 1) {\n      index += 1;\n    }\n    node = node.previousSibling;\n  }\n  return index;\n}\nexport function find(elem, selector) {\n  return elem.querySelectorAll(selector);\n}\nexport function findOne(elem, selector) {\n  return elem.querySelector(selector);\n}\nexport function findParentByClass(elem, className, terminator) {\n  const ownerSVGElement = elem.ownerSVGElement;\n  let node = elem.parentNode;\n  while (node && node !== terminator && node !== ownerSVGElement) {\n    if (hasClass(node, className)) {\n      return node;\n    }\n    node = node.parentNode;\n  }\n  return null;\n}\nexport function contains(parent, child) {\n  const bup = child && child.parentNode;\n  return parent === bup || !!(bup && bup.nodeType === 1 && parent.compareDocumentPosition(bup) & 16) // eslint-disable-line no-bitwise\n  ;\n}\nexport function remove(elem) {\n  if (elem) {\n    const elems = Array.isArray(elem) ? elem : [elem];\n    elems.forEach(item => {\n      if (item.parentNode) {\n        item.parentNode.removeChild(item);\n      }\n    });\n  }\n}\nexport function empty(elem) {\n  while (elem.firstChild) {\n    elem.removeChild(elem.firstChild);\n  }\n}\nexport function append(elem, elems) {\n  const arr = Array.isArray(elems) ? elems : [elems];\n  arr.forEach(child => {\n    if (child != null) {\n      elem.appendChild(child);\n    }\n  });\n}\nexport function prepend(elem, elems) {\n  const child = elem.firstChild;\n  return child ? before(child, elems) : append(elem, elems);\n}\nexport function before(elem, elems) {\n  const parent = elem.parentNode;\n  if (parent) {\n    const arr = Array.isArray(elems) ? elems : [elems];\n    arr.forEach(child => {\n      if (child != null) {\n        parent.insertBefore(child, elem);\n      }\n    });\n  }\n}\nexport function after(elem, elems) {\n  const parent = elem.parentNode;\n  if (parent) {\n    const arr = Array.isArray(elems) ? elems : [elems];\n    arr.forEach(child => {\n      if (child != null) {\n        parent.insertBefore(child, elem.nextSibling);\n      }\n    });\n  }\n}\nexport function appendTo(elem, target) {\n  if (target != null) {\n    target.appendChild(elem);\n  }\n}\nexport function isElement(x) {\n  return !!x && x.nodeType === 1;\n}\n// Determines whether a node is an HTML node\nexport function isHTMLElement(elem) {\n  try {\n    // Using W3 DOM2 (works for FF, Opera and Chrome)\n    return elem instanceof HTMLElement;\n  } catch (e) {\n    // Browsers not supporting W3 DOM2 don't have HTMLElement and\n    // an exception is thrown and we end up here. Testing some\n    // properties that all elements have (works on IE7)\n    return typeof elem === 'object' && elem.nodeType === 1 && typeof elem.style === 'object' && typeof elem.ownerDocument === 'object';\n  }\n}\nexport function children(parent, className) {\n  const matched = [];\n  let elem = parent.firstChild;\n  for (; elem; elem = elem.nextSibling) {\n    if (elem.nodeType === 1) {\n      if (!className || hasClass(elem, className)) {\n        matched.push(elem);\n      }\n    }\n  }\n  return matched;\n}","map":{"version":3,"names":["hasClass","idCounter","uniqueId","ensureId","elem","id","isSVGGraphicsElement","getScreenCTM","SVGElement","ns","svg","xmlns","xml","xlink","xhtml","svgVersion","createElement","tagName","doc","document","createElementNS","namespaceURI","createSvgElement","createSvgDocument","content","documentElement","parseXML","async","setAttributeNS","setAttribute","data","options","parser","DOMParser","instance","parseFromString","mimeType","error","undefined","getElementsByTagName","length","Error","node","lowercase","nodeName","toLowerCase","toUpperCase","index","previousSibling","nodeType","find","selector","querySelectorAll","findOne","querySelector","findParentByClass","className","terminator","ownerSVGElement","parentNode","contains","parent","child","bup","compareDocumentPosition","remove","elems","Array","isArray","forEach","item","removeChild","empty","firstChild","append","arr","appendChild","prepend","before","insertBefore","after","nextSibling","appendTo","target","isElement","x","isHTMLElement","HTMLElement","e","style","ownerDocument","children","matched","push"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/src/dom/elem.ts"],"sourcesContent":["import { hasClass } from './class'\n\nlet idCounter = 0\nexport function uniqueId() {\n  idCounter += 1\n  return `v${idCounter}`\n}\n\nexport function ensureId(elem: Element) {\n  if (elem.id == null || elem.id === '') {\n    elem.id = uniqueId()\n  }\n  return elem.id\n}\n\n/**\n * Returns true if object is an instance of SVGGraphicsElement.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement\n */\nexport function isSVGGraphicsElement(\n  elem?: any | null,\n): elem is SVGGraphicsElement {\n  if (elem == null) {\n    return false\n  }\n\n  return typeof elem.getScreenCTM === 'function' && elem instanceof SVGElement\n}\n\nexport const ns = {\n  svg: 'http://www.w3.org/2000/svg',\n  xmlns: 'http://www.w3.org/2000/xmlns/',\n  xml: 'http://www.w3.org/XML/1998/namespace',\n  xlink: 'http://www.w3.org/1999/xlink',\n  xhtml: 'http://www.w3.org/1999/xhtml',\n}\n\nexport const svgVersion = '1.1'\n\nexport function createElement<T extends Element>(\n  tagName: string,\n  doc: Document = document,\n): T {\n  return doc.createElement(tagName) as any as T\n}\n\nexport function createElementNS<T extends Element>(\n  tagName: string,\n  namespaceURI: string = ns.xhtml,\n  doc: Document = document,\n): T {\n  return doc.createElementNS(namespaceURI, tagName) as any as T\n}\n\nexport function createSvgElement<T extends SVGElement>(\n  tagName: string,\n  doc: Document = document,\n): T {\n  return createElementNS<SVGElement>(tagName, ns.svg, doc) as T\n}\n\nexport function createSvgDocument(content?: string) {\n  if (content) {\n    const xml = `<svg xmlns=\"${ns.svg}\" xmlns:xlink=\"${ns.xlink}\" version=\"${svgVersion}\">${content}</svg>` // lgtm[js/html-constructed-from-input]\n    const { documentElement } = parseXML(xml, { async: false })\n    return documentElement as any as SVGSVGElement\n  }\n\n  const svg = document.createElementNS(ns.svg, 'svg')\n  svg.setAttributeNS(ns.xmlns, 'xmlns:xlink', ns.xlink)\n  svg.setAttribute('version', svgVersion)\n  return svg as SVGSVGElement\n}\n\nexport function parseXML(\n  data: string,\n  options: {\n    async?: boolean\n    mimeType?:\n      | 'text/html'\n      | 'text/xml'\n      | 'application/xml'\n      | 'application/xhtml+xml'\n      | 'image/svg+xml'\n  } = {},\n) {\n  let xml\n\n  try {\n    const parser = new DOMParser()\n    if (options.async != null) {\n      const instance = parser as any\n      instance.async = options.async\n    }\n    xml = parser.parseFromString(data, options.mimeType || 'text/xml')\n  } catch (error) {\n    xml = undefined\n  }\n\n  if (!xml || xml.getElementsByTagName('parsererror').length) {\n    throw new Error(`Invalid XML: ${data}`)\n  }\n\n  return xml\n}\n\nexport function tagName(node: Element, lowercase = true) {\n  const nodeName = node.nodeName\n  return lowercase ? nodeName.toLowerCase() : nodeName.toUpperCase()\n}\n\nexport function index(elem: Element) {\n  let index = 0\n  let node = elem.previousSibling\n  while (node) {\n    if (node.nodeType === 1) {\n      index += 1\n    }\n    node = node.previousSibling\n  }\n  return index\n}\n\nexport function find(elem: Element, selector: string) {\n  return elem.querySelectorAll(selector)\n}\n\nexport function findOne(elem: Element, selector: string) {\n  return elem.querySelector(selector)\n}\n\nexport function findParentByClass(\n  elem: Element,\n  className: string,\n  terminator?: Element,\n) {\n  const ownerSVGElement = (elem as SVGElement).ownerSVGElement\n  let node = elem.parentNode\n  while (node && node !== terminator && node !== ownerSVGElement) {\n    if (hasClass(node as Element, className)) {\n      return node\n    }\n    node = node.parentNode\n  }\n\n  return null\n}\n\nexport function contains(parent: Element, child: Element) {\n  const bup = child && child.parentNode\n  return (\n    parent === bup ||\n    !!(bup && bup.nodeType === 1 && parent.compareDocumentPosition(bup) & 16) // eslint-disable-line no-bitwise\n  )\n}\n\nexport function remove(elem: Element | Element[] | null) {\n  if (elem) {\n    const elems = Array.isArray(elem) ? elem : [elem]\n    elems.forEach((item) => {\n      if (item.parentNode) {\n        item.parentNode.removeChild(item)\n      }\n    })\n  }\n}\n\nexport function empty(elem: Element) {\n  while (elem.firstChild) {\n    elem.removeChild(elem.firstChild)\n  }\n}\n\nexport function append(\n  elem: Element,\n  elems: Element | DocumentFragment | (Element | DocumentFragment)[],\n) {\n  const arr = Array.isArray(elems) ? elems : [elems]\n  arr.forEach((child) => {\n    if (child != null) {\n      elem.appendChild(child)\n    }\n  })\n}\n\nexport function prepend(\n  elem: Element,\n  elems: Element | DocumentFragment | (Element | DocumentFragment)[],\n) {\n  const child = elem.firstChild\n  return child ? before(child as HTMLElement, elems) : append(elem, elems)\n}\n\nexport function before(\n  elem: Element,\n  elems: Element | DocumentFragment | (Element | DocumentFragment)[],\n) {\n  const parent = elem.parentNode\n  if (parent) {\n    const arr = Array.isArray(elems) ? elems : [elems]\n    arr.forEach((child) => {\n      if (child != null) {\n        parent.insertBefore(child, elem)\n      }\n    })\n  }\n}\n\nexport function after(\n  elem: Element,\n  elems: Element | DocumentFragment | (Element | DocumentFragment)[],\n) {\n  const parent = elem.parentNode\n  if (parent) {\n    const arr = Array.isArray(elems) ? elems : [elems]\n    arr.forEach((child) => {\n      if (child != null) {\n        parent.insertBefore(child, elem.nextSibling)\n      }\n    })\n  }\n}\n\nexport function appendTo(elem: Element, target: Element) {\n  if (target != null) {\n    target.appendChild(elem)\n  }\n}\n\nexport function isElement(x: any): x is HTMLElement {\n  return !!x && x.nodeType === 1\n}\n\n// Determines whether a node is an HTML node\nexport function isHTMLElement(elem: any): elem is HTMLElement {\n  try {\n    // Using W3 DOM2 (works for FF, Opera and Chrome)\n    return elem instanceof HTMLElement\n  } catch (e) {\n    // Browsers not supporting W3 DOM2 don't have HTMLElement and\n    // an exception is thrown and we end up here. Testing some\n    // properties that all elements have (works on IE7)\n    return (\n      typeof elem === 'object' &&\n      elem.nodeType === 1 &&\n      typeof elem.style === 'object' &&\n      typeof elem.ownerDocument === 'object'\n    )\n  }\n}\n\nexport function children(parent: Element, className?: string) {\n  const matched: Element[] = []\n  let elem = parent.firstChild\n\n  for (; elem; elem = elem.nextSibling) {\n    if (elem.nodeType === 1) {\n      if (!className || hasClass(elem as Element, className)) {\n        matched.push(elem as Element)\n      }\n    }\n  }\n\n  return matched\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}