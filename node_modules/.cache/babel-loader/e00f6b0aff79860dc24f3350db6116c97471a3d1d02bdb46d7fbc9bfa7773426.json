{"ast":null,"code":"import { Point, Path } from '@antv/x6-geometry';\nexport const rounded = function (sourcePoint, targetPoint, routePoints, options = {}) {\n  const path = new Path();\n  path.appendSegment(Path.createSegment('M', sourcePoint));\n  const f13 = 1 / 3;\n  const f23 = 2 / 3;\n  const radius = options.radius || 10;\n  let prevDistance;\n  let nextDistance;\n  for (let i = 0, ii = routePoints.length; i < ii; i += 1) {\n    const curr = Point.create(routePoints[i]);\n    const prev = routePoints[i - 1] || sourcePoint;\n    const next = routePoints[i + 1] || targetPoint;\n    prevDistance = nextDistance || curr.distance(prev) / 2;\n    nextDistance = curr.distance(next) / 2;\n    const startMove = -Math.min(radius, prevDistance);\n    const endMove = -Math.min(radius, nextDistance);\n    const roundedStart = curr.clone().move(prev, startMove).round();\n    const roundedEnd = curr.clone().move(next, endMove).round();\n    const control1 = new Point(f13 * roundedStart.x + f23 * curr.x, f23 * curr.y + f13 * roundedStart.y);\n    const control2 = new Point(f13 * roundedEnd.x + f23 * curr.x, f23 * curr.y + f13 * roundedEnd.y);\n    path.appendSegment(Path.createSegment('L', roundedStart));\n    path.appendSegment(Path.createSegment('C', control1, control2, roundedEnd));\n  }\n  path.appendSegment(Path.createSegment('L', targetPoint));\n  return options.raw ? path : path.serialize();\n};","map":{"version":3,"names":["Point","Path","rounded","sourcePoint","targetPoint","routePoints","options","path","appendSegment","createSegment","f13","f23","radius","prevDistance","nextDistance","i","ii","length","curr","create","prev","next","distance","startMove","Math","min","endMove","roundedStart","clone","move","round","roundedEnd","control1","x","y","control2","raw","serialize"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/src/registry/connector/rounded.ts"],"sourcesContent":["import { Point, Path } from '@antv/x6-geometry'\nimport { Connector } from './index'\n\nexport interface RoundedConnectorOptions extends Connector.BaseOptions {\n  radius?: number\n}\n\nexport const rounded: Connector.Definition<RoundedConnectorOptions> = function (\n  sourcePoint,\n  targetPoint,\n  routePoints,\n  options = {},\n) {\n  const path = new Path()\n\n  path.appendSegment(Path.createSegment('M', sourcePoint))\n\n  const f13 = 1 / 3\n  const f23 = 2 / 3\n  const radius = options.radius || 10\n\n  let prevDistance\n  let nextDistance\n  for (let i = 0, ii = routePoints.length; i < ii; i += 1) {\n    const curr = Point.create(routePoints[i])\n    const prev = routePoints[i - 1] || sourcePoint\n    const next = routePoints[i + 1] || targetPoint\n\n    prevDistance = nextDistance || curr.distance(prev) / 2\n    nextDistance = curr.distance(next) / 2\n\n    const startMove = -Math.min(radius, prevDistance)\n    const endMove = -Math.min(radius, nextDistance)\n\n    const roundedStart = curr.clone().move(prev, startMove).round()\n    const roundedEnd = curr.clone().move(next, endMove).round()\n\n    const control1 = new Point(\n      f13 * roundedStart.x + f23 * curr.x,\n      f23 * curr.y + f13 * roundedStart.y,\n    )\n    const control2 = new Point(\n      f13 * roundedEnd.x + f23 * curr.x,\n      f23 * curr.y + f13 * roundedEnd.y,\n    )\n\n    path.appendSegment(Path.createSegment('L', roundedStart))\n    path.appendSegment(Path.createSegment('C', control1, control2, roundedEnd))\n  }\n\n  path.appendSegment(Path.createSegment('L', targetPoint))\n\n  return options.raw ? path : path.serialize()\n}\n"],"mappings":"AAAA,SAASA,KAAK,EAAEC,IAAI,QAAQ,mBAAmB;AAO/C,OAAO,MAAMC,OAAO,GAAkD,SAAAA,CACpEC,WAAW,EACXC,WAAW,EACXC,WAAW,EACXC,OAAO,GAAG,EAAE;EAEZ,MAAMC,IAAI,GAAG,IAAIN,IAAI,EAAE;EAEvBM,IAAI,CAACC,aAAa,CAACP,IAAI,CAACQ,aAAa,CAAC,GAAG,EAAEN,WAAW,CAAC,CAAC;EAExD,MAAMO,GAAG,GAAG,CAAC,GAAG,CAAC;EACjB,MAAMC,GAAG,GAAG,CAAC,GAAG,CAAC;EACjB,MAAMC,MAAM,GAAGN,OAAO,CAACM,MAAM,IAAI,EAAE;EAEnC,IAAIC,YAAY;EAChB,IAAIC,YAAY;EAChB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGX,WAAW,CAACY,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAED,CAAC,IAAI,CAAC,EAAE;IACvD,MAAMG,IAAI,GAAGlB,KAAK,CAACmB,MAAM,CAACd,WAAW,CAACU,CAAC,CAAC,CAAC;IACzC,MAAMK,IAAI,GAAGf,WAAW,CAACU,CAAC,GAAG,CAAC,CAAC,IAAIZ,WAAW;IAC9C,MAAMkB,IAAI,GAAGhB,WAAW,CAACU,CAAC,GAAG,CAAC,CAAC,IAAIX,WAAW;IAE9CS,YAAY,GAAGC,YAAY,IAAII,IAAI,CAACI,QAAQ,CAACF,IAAI,CAAC,GAAG,CAAC;IACtDN,YAAY,GAAGI,IAAI,CAACI,QAAQ,CAACD,IAAI,CAAC,GAAG,CAAC;IAEtC,MAAME,SAAS,GAAG,CAACC,IAAI,CAACC,GAAG,CAACb,MAAM,EAAEC,YAAY,CAAC;IACjD,MAAMa,OAAO,GAAG,CAACF,IAAI,CAACC,GAAG,CAACb,MAAM,EAAEE,YAAY,CAAC;IAE/C,MAAMa,YAAY,GAAGT,IAAI,CAACU,KAAK,EAAE,CAACC,IAAI,CAACT,IAAI,EAAEG,SAAS,CAAC,CAACO,KAAK,EAAE;IAC/D,MAAMC,UAAU,GAAGb,IAAI,CAACU,KAAK,EAAE,CAACC,IAAI,CAACR,IAAI,EAAEK,OAAO,CAAC,CAACI,KAAK,EAAE;IAE3D,MAAME,QAAQ,GAAG,IAAIhC,KAAK,CACxBU,GAAG,GAAGiB,YAAY,CAACM,CAAC,GAAGtB,GAAG,GAAGO,IAAI,CAACe,CAAC,EACnCtB,GAAG,GAAGO,IAAI,CAACgB,CAAC,GAAGxB,GAAG,GAAGiB,YAAY,CAACO,CAAC,CACpC;IACD,MAAMC,QAAQ,GAAG,IAAInC,KAAK,CACxBU,GAAG,GAAGqB,UAAU,CAACE,CAAC,GAAGtB,GAAG,GAAGO,IAAI,CAACe,CAAC,EACjCtB,GAAG,GAAGO,IAAI,CAACgB,CAAC,GAAGxB,GAAG,GAAGqB,UAAU,CAACG,CAAC,CAClC;IAED3B,IAAI,CAACC,aAAa,CAACP,IAAI,CAACQ,aAAa,CAAC,GAAG,EAAEkB,YAAY,CAAC,CAAC;IACzDpB,IAAI,CAACC,aAAa,CAACP,IAAI,CAACQ,aAAa,CAAC,GAAG,EAAEuB,QAAQ,EAAEG,QAAQ,EAAEJ,UAAU,CAAC,CAAC;;EAG7ExB,IAAI,CAACC,aAAa,CAACP,IAAI,CAACQ,aAAa,CAAC,GAAG,EAAEL,WAAW,CAAC,CAAC;EAExD,OAAOE,OAAO,CAAC8B,GAAG,GAAG7B,IAAI,GAAGA,IAAI,CAAC8B,SAAS,EAAE;AAC9C,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}