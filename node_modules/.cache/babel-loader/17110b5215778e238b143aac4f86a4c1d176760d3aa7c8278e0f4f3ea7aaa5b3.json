{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { Rectangle, Polyline, Point, Angle, Path, Line } from '@antv/x6-geometry';\nimport { ObjectExt, NumberExt, FunctionExt, Dom, Vector } from '@antv/x6-common';\nimport { Router, Connector, NodeAnchor, EdgeAnchor, ConnectionPoint } from '../registry';\nimport { Edge } from '../model/edge';\nimport { CellView } from './cell';\nimport { NodeView } from './node';\nexport class EdgeView extends CellView {\n  constructor() {\n    super(...arguments);\n    this.POINT_ROUNDING = 2;\n    this.labelDestroyFn = {};\n    // #endregion\n  }\n  get [Symbol.toStringTag]() {\n    return EdgeView.toStringTag;\n  }\n  getContainerClassName() {\n    return [super.getContainerClassName(), this.prefixClassName('edge')].join(' ');\n  }\n  get sourceBBox() {\n    const sourceView = this.sourceView;\n    if (!sourceView) {\n      const sourceDef = this.cell.getSource();\n      return new Rectangle(sourceDef.x, sourceDef.y);\n    }\n    const sourceMagnet = this.sourceMagnet;\n    if (sourceView.isEdgeElement(sourceMagnet)) {\n      return new Rectangle(this.sourceAnchor.x, this.sourceAnchor.y);\n    }\n    return sourceView.getBBoxOfElement(sourceMagnet || sourceView.container);\n  }\n  get targetBBox() {\n    const targetView = this.targetView;\n    if (!targetView) {\n      const targetDef = this.cell.getTarget();\n      return new Rectangle(targetDef.x, targetDef.y);\n    }\n    const targetMagnet = this.targetMagnet;\n    if (targetView.isEdgeElement(targetMagnet)) {\n      return new Rectangle(this.targetAnchor.x, this.targetAnchor.y);\n    }\n    return targetView.getBBoxOfElement(targetMagnet || targetView.container);\n  }\n  isEdgeView() {\n    return true;\n  }\n  confirmUpdate(flag, options = {}) {\n    let ref = flag;\n    if (this.hasAction(ref, 'source')) {\n      if (!this.updateTerminalProperties('source')) {\n        return ref;\n      }\n      ref = this.removeAction(ref, 'source');\n    }\n    if (this.hasAction(ref, 'target')) {\n      if (!this.updateTerminalProperties('target')) {\n        return ref;\n      }\n      ref = this.removeAction(ref, 'target');\n    }\n    if (this.hasAction(ref, 'render')) {\n      this.render();\n      ref = this.removeAction(ref, ['render', 'update', 'labels', 'tools']);\n      return ref;\n    }\n    ref = this.handleAction(ref, 'update', () => this.update(options));\n    ref = this.handleAction(ref, 'labels', () => this.onLabelsChange(options));\n    ref = this.handleAction(ref, 'tools', () => this.renderTools());\n    return ref;\n  }\n  // #region render\n  render() {\n    this.empty();\n    this.renderMarkup();\n    this.labelContainer = null;\n    this.renderLabels();\n    this.update();\n    this.renderTools();\n    return this;\n  }\n  renderMarkup() {\n    const markup = this.cell.markup;\n    if (markup) {\n      if (typeof markup === 'string') {\n        throw new TypeError('Not support string markup.');\n      }\n      return this.renderJSONMarkup(markup);\n    }\n    throw new TypeError('Invalid edge markup.');\n  }\n  renderJSONMarkup(markup) {\n    const ret = this.parseJSONMarkup(markup, this.container);\n    this.selectors = ret.selectors;\n    this.container.append(ret.fragment);\n  }\n  customizeLabels() {\n    if (this.labelContainer) {\n      const edge = this.cell;\n      const labels = edge.labels;\n      for (let i = 0, n = labels.length; i < n; i += 1) {\n        const label = labels[i];\n        const container = this.labelCache[i];\n        const selectors = this.labelSelectors[i];\n        const onEdgeLabelRendered = this.graph.options.onEdgeLabelRendered;\n        if (onEdgeLabelRendered) {\n          const fn = onEdgeLabelRendered({\n            edge,\n            label,\n            container,\n            selectors\n          });\n          if (fn) {\n            this.labelDestroyFn[i] = fn;\n          }\n        }\n      }\n    }\n  }\n  destroyCustomizeLabels() {\n    const labels = this.cell.labels;\n    if (this.labelCache && this.labelSelectors && this.labelDestroyFn) {\n      for (let i = 0, n = labels.length; i < n; i += 1) {\n        const fn = this.labelDestroyFn[i];\n        const container = this.labelCache[i];\n        const selectors = this.labelSelectors[i];\n        if (fn && container && selectors) {\n          fn({\n            edge: this.cell,\n            label: labels[i],\n            container,\n            selectors\n          });\n        }\n      }\n    }\n    this.labelDestroyFn = {};\n  }\n  renderLabels() {\n    const edge = this.cell;\n    const labels = edge.getLabels();\n    const count = labels.length;\n    let container = this.labelContainer;\n    this.labelCache = {};\n    this.labelSelectors = {};\n    if (count <= 0) {\n      if (container && container.parentNode) {\n        container.parentNode.removeChild(container);\n      }\n      return this;\n    }\n    if (container) {\n      this.empty(container);\n    } else {\n      container = Dom.createSvgElement('g');\n      this.addClass(this.prefixClassName('edge-labels'), container);\n      this.labelContainer = container;\n    }\n    for (let i = 0, ii = labels.length; i < ii; i += 1) {\n      const label = labels[i];\n      const normalized = this.normalizeLabelMarkup(this.parseLabelMarkup(label.markup));\n      let labelNode;\n      let selectors;\n      if (normalized) {\n        labelNode = normalized.node;\n        selectors = normalized.selectors;\n      } else {\n        const defaultLabel = edge.getDefaultLabel();\n        const normalized = this.normalizeLabelMarkup(this.parseLabelMarkup(defaultLabel.markup));\n        labelNode = normalized.node;\n        selectors = normalized.selectors;\n      }\n      labelNode.setAttribute('data-index', `${i}`);\n      container.appendChild(labelNode);\n      const rootSelector = this.rootSelector;\n      if (selectors[rootSelector]) {\n        throw new Error('Ambiguous label root selector.');\n      }\n      selectors[rootSelector] = labelNode;\n      this.labelCache[i] = labelNode;\n      this.labelSelectors[i] = selectors;\n    }\n    if (container.parentNode == null) {\n      this.container.appendChild(container);\n    }\n    this.updateLabels();\n    this.customizeLabels();\n    return this;\n  }\n  onLabelsChange(options = {}) {\n    this.destroyCustomizeLabels();\n    if (this.shouldRerenderLabels(options)) {\n      this.renderLabels();\n    } else {\n      this.updateLabels();\n    }\n    this.updateLabelPositions();\n  }\n  shouldRerenderLabels(options = {}) {\n    const previousLabels = this.cell.previous('labels');\n    if (previousLabels == null) {\n      return true;\n    }\n    // Here is an optimization for cases when we know, that change does\n    // not require re-rendering of all labels.\n    if ('propertyPathArray' in options && 'propertyValue' in options) {\n      // The label is setting by `prop()` method\n      const pathArray = options.propertyPathArray || [];\n      const pathLength = pathArray.length;\n      if (pathLength > 1) {\n        // We are changing a single label here e.g. 'labels/0/position'\n        const index = pathArray[1];\n        if (previousLabels[index]) {\n          if (pathLength === 2) {\n            // We are changing the entire label. Need to check if the\n            // markup is also being changed.\n            return typeof options.propertyValue === 'object' && ObjectExt.has(options.propertyValue, 'markup');\n          }\n          // We are changing a label property but not the markup\n          if (pathArray[2] !== 'markup') {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  }\n  parseLabelMarkup(markup) {\n    if (markup) {\n      if (typeof markup === 'string') {\n        return this.parseLabelStringMarkup(markup);\n      }\n      return this.parseJSONMarkup(markup);\n    }\n    return null;\n  }\n  parseLabelStringMarkup(labelMarkup) {\n    const children = Vector.createVectors(labelMarkup);\n    const fragment = document.createDocumentFragment();\n    for (let i = 0, n = children.length; i < n; i += 1) {\n      const currentChild = children[i].node;\n      fragment.appendChild(currentChild);\n    }\n    return {\n      fragment,\n      selectors: {}\n    };\n  }\n  normalizeLabelMarkup(markup) {\n    if (markup == null) {\n      return;\n    }\n    const fragment = markup.fragment;\n    if (!(fragment instanceof DocumentFragment) || !fragment.hasChildNodes()) {\n      throw new Error('Invalid label markup.');\n    }\n    let vel;\n    const childNodes = fragment.childNodes;\n    if (childNodes.length > 1 || childNodes[0].nodeName.toUpperCase() !== 'G') {\n      vel = Vector.create('g').append(fragment);\n    } else {\n      vel = Vector.create(childNodes[0]);\n    }\n    vel.addClass(this.prefixClassName('edge-label'));\n    return {\n      node: vel.node,\n      selectors: markup.selectors\n    };\n  }\n  updateLabels() {\n    if (this.labelContainer) {\n      const edge = this.cell;\n      const labels = edge.labels;\n      const canLabelMove = this.can('edgeLabelMovable');\n      const defaultLabel = edge.getDefaultLabel();\n      for (let i = 0, n = labels.length; i < n; i += 1) {\n        const elem = this.labelCache[i];\n        const selectors = this.labelSelectors[i];\n        elem.setAttribute('cursor', canLabelMove ? 'move' : 'default');\n        const label = labels[i];\n        const attrs = ObjectExt.merge({}, defaultLabel.attrs, label.attrs);\n        this.updateAttrs(elem, attrs, {\n          selectors,\n          rootBBox: label.size ? Rectangle.fromSize(label.size) : undefined\n        });\n      }\n    }\n  }\n  renderTools() {\n    const tools = this.cell.getTools();\n    this.addTools(tools);\n    return this;\n  }\n  // #endregion\n  // #region updating\n  update(options = {}) {\n    this.cleanCache();\n    this.updateConnection(options);\n    const _a = this.cell.getAttrs(),\n      {\n        text\n      } = _a,\n      attrs = __rest(_a, [\"text\"]);\n    if (attrs != null) {\n      this.updateAttrs(this.container, attrs, {\n        selectors: this.selectors\n      });\n    }\n    this.updateLabelPositions();\n    this.updateTools(options);\n    return this;\n  }\n  removeRedundantLinearVertices(options = {}) {\n    const edge = this.cell;\n    const vertices = edge.getVertices();\n    const routePoints = [this.sourceAnchor, ...vertices, this.targetAnchor];\n    const rawCount = routePoints.length;\n    // Puts the route points into a polyline and try to simplify.\n    const polyline = new Polyline(routePoints);\n    polyline.simplify({\n      threshold: 0.01\n    });\n    const simplifiedPoints = polyline.points.map(point => point.toJSON());\n    const simplifiedCount = simplifiedPoints.length;\n    // If simplification did not remove any redundant vertices.\n    if (rawCount === simplifiedCount) {\n      return 0;\n    }\n    // Sets simplified polyline points as edge vertices.\n    // Removes first and last polyline points again (source/target anchors).\n    edge.setVertices(simplifiedPoints.slice(1, simplifiedCount - 1), options);\n    return rawCount - simplifiedCount;\n  }\n  getTerminalView(type) {\n    switch (type) {\n      case 'source':\n        return this.sourceView || null;\n      case 'target':\n        return this.targetView || null;\n      default:\n        throw new Error(`Unknown terminal type '${type}'`);\n    }\n  }\n  getTerminalAnchor(type) {\n    switch (type) {\n      case 'source':\n        return Point.create(this.sourceAnchor);\n      case 'target':\n        return Point.create(this.targetAnchor);\n      default:\n        throw new Error(`Unknown terminal type '${type}'`);\n    }\n  }\n  getTerminalConnectionPoint(type) {\n    switch (type) {\n      case 'source':\n        return Point.create(this.sourcePoint);\n      case 'target':\n        return Point.create(this.targetPoint);\n      default:\n        throw new Error(`Unknown terminal type '${type}'`);\n    }\n  }\n  getTerminalMagnet(type, options = {}) {\n    switch (type) {\n      case 'source':\n        {\n          if (options.raw) {\n            return this.sourceMagnet;\n          }\n          const sourceView = this.sourceView;\n          if (!sourceView) {\n            return null;\n          }\n          return this.sourceMagnet || sourceView.container;\n        }\n      case 'target':\n        {\n          if (options.raw) {\n            return this.targetMagnet;\n          }\n          const targetView = this.targetView;\n          if (!targetView) {\n            return null;\n          }\n          return this.targetMagnet || targetView.container;\n        }\n      default:\n        {\n          throw new Error(`Unknown terminal type '${type}'`);\n        }\n    }\n  }\n  updateConnection(options = {}) {\n    const edge = this.cell;\n    // The edge is being translated by an ancestor that will shift\n    // source, target and vertices by an equal distance.\n    // todo isFragmentDescendantOf is invalid\n    if (options.translateBy && edge.isFragmentDescendantOf(options.translateBy)) {\n      const tx = options.tx || 0;\n      const ty = options.ty || 0;\n      this.routePoints = new Polyline(this.routePoints).translate(tx, ty).points;\n      this.translateConnectionPoints(tx, ty);\n      this.path.translate(tx, ty);\n    } else {\n      const vertices = edge.getVertices();\n      // 1. Find anchor points\n      const anchors = this.findAnchors(vertices);\n      this.sourceAnchor = anchors.source;\n      this.targetAnchor = anchors.target;\n      // 2. Find route points\n      this.routePoints = this.findRoutePoints(vertices);\n      // 3. Find connection points\n      const connectionPoints = this.findConnectionPoints(this.routePoints, this.sourceAnchor, this.targetAnchor);\n      this.sourcePoint = connectionPoints.source;\n      this.targetPoint = connectionPoints.target;\n      // 4. Find Marker Connection Point\n      const markerPoints = this.findMarkerPoints(this.routePoints, this.sourcePoint, this.targetPoint);\n      // 5. Make path\n      this.path = this.findPath(this.routePoints, markerPoints.source || this.sourcePoint, markerPoints.target || this.targetPoint);\n    }\n    this.cleanCache();\n  }\n  findAnchors(vertices) {\n    const edge = this.cell;\n    const source = edge.source;\n    const target = edge.target;\n    const firstVertex = vertices[0];\n    const lastVertex = vertices[vertices.length - 1];\n    if (target.priority && !source.priority) {\n      // Reversed order\n      return this.findAnchorsOrdered('target', lastVertex, 'source', firstVertex);\n    }\n    // Usual order\n    return this.findAnchorsOrdered('source', firstVertex, 'target', lastVertex);\n  }\n  findAnchorsOrdered(firstType, firstPoint, secondType, secondPoint) {\n    let firstAnchor;\n    let secondAnchor;\n    const edge = this.cell;\n    const firstTerminal = edge[firstType];\n    const secondTerminal = edge[secondType];\n    const firstView = this.getTerminalView(firstType);\n    const secondView = this.getTerminalView(secondType);\n    const firstMagnet = this.getTerminalMagnet(firstType);\n    const secondMagnet = this.getTerminalMagnet(secondType);\n    if (firstView) {\n      let firstRef;\n      if (firstPoint) {\n        firstRef = Point.create(firstPoint);\n      } else if (secondView) {\n        firstRef = secondMagnet;\n      } else {\n        firstRef = Point.create(secondTerminal);\n      }\n      firstAnchor = this.getAnchor(firstTerminal.anchor, firstView, firstMagnet, firstRef, firstType);\n    } else {\n      firstAnchor = Point.create(firstTerminal);\n    }\n    if (secondView) {\n      const secondRef = Point.create(secondPoint || firstAnchor);\n      secondAnchor = this.getAnchor(secondTerminal.anchor, secondView, secondMagnet, secondRef, secondType);\n    } else {\n      secondAnchor = Point.isPointLike(secondTerminal) ? Point.create(secondTerminal) : new Point();\n    }\n    return {\n      [firstType]: firstAnchor,\n      [secondType]: secondAnchor\n    };\n  }\n  getAnchor(def, cellView, magnet, ref, terminalType) {\n    const isEdge = cellView.isEdgeElement(magnet);\n    const connecting = this.graph.options.connecting;\n    let config = typeof def === 'string' ? {\n      name: def\n    } : def;\n    if (!config) {\n      const defaults = isEdge ? (terminalType === 'source' ? connecting.sourceEdgeAnchor : connecting.targetEdgeAnchor) || connecting.edgeAnchor : (terminalType === 'source' ? connecting.sourceAnchor : connecting.targetAnchor) || connecting.anchor;\n      config = typeof defaults === 'string' ? {\n        name: defaults\n      } : defaults;\n    }\n    if (!config) {\n      throw new Error(`Anchor should be specified.`);\n    }\n    let anchor;\n    const name = config.name;\n    if (isEdge) {\n      const fn = EdgeAnchor.registry.get(name);\n      if (typeof fn !== 'function') {\n        return EdgeAnchor.registry.onNotFound(name);\n      }\n      anchor = FunctionExt.call(fn, this, cellView, magnet, ref, config.args || {}, terminalType);\n    } else {\n      const fn = NodeAnchor.registry.get(name);\n      if (typeof fn !== 'function') {\n        return NodeAnchor.registry.onNotFound(name);\n      }\n      anchor = FunctionExt.call(fn, this, cellView, magnet, ref, config.args || {}, terminalType);\n    }\n    return anchor ? anchor.round(this.POINT_ROUNDING) : new Point();\n  }\n  findRoutePoints(vertices = []) {\n    const defaultRouter = this.graph.options.connecting.router || Router.presets.normal;\n    const router = this.cell.getRouter() || defaultRouter;\n    let routePoints;\n    if (typeof router === 'function') {\n      routePoints = FunctionExt.call(router, this, vertices, {}, this);\n    } else {\n      const name = typeof router === 'string' ? router : router.name;\n      const args = typeof router === 'string' ? {} : router.args || {};\n      const fn = name ? Router.registry.get(name) : Router.presets.normal;\n      if (typeof fn !== 'function') {\n        return Router.registry.onNotFound(name);\n      }\n      routePoints = FunctionExt.call(fn, this, vertices, args, this);\n    }\n    return routePoints == null ? vertices.map(p => Point.create(p)) : routePoints.map(p => Point.create(p));\n  }\n  findConnectionPoints(routePoints, sourceAnchor, targetAnchor) {\n    const edge = this.cell;\n    const connecting = this.graph.options.connecting;\n    const sourceTerminal = edge.getSource();\n    const targetTerminal = edge.getTarget();\n    const sourceView = this.sourceView;\n    const targetView = this.targetView;\n    const firstRoutePoint = routePoints[0];\n    const lastRoutePoint = routePoints[routePoints.length - 1];\n    // source\n    let sourcePoint;\n    if (sourceView && !sourceView.isEdgeElement(this.sourceMagnet)) {\n      const sourceMagnet = this.sourceMagnet || sourceView.container;\n      const sourcePointRef = firstRoutePoint || targetAnchor;\n      const sourceLine = new Line(sourcePointRef, sourceAnchor);\n      const connectionPointDef = sourceTerminal.connectionPoint || connecting.sourceConnectionPoint || connecting.connectionPoint;\n      sourcePoint = this.getConnectionPoint(connectionPointDef, sourceView, sourceMagnet, sourceLine, 'source');\n    } else {\n      sourcePoint = sourceAnchor;\n    }\n    // target\n    let targetPoint;\n    if (targetView && !targetView.isEdgeElement(this.targetMagnet)) {\n      const targetMagnet = this.targetMagnet || targetView.container;\n      const targetConnectionPointDef = targetTerminal.connectionPoint || connecting.targetConnectionPoint || connecting.connectionPoint;\n      const targetPointRef = lastRoutePoint || sourceAnchor;\n      const targetLine = new Line(targetPointRef, targetAnchor);\n      targetPoint = this.getConnectionPoint(targetConnectionPointDef, targetView, targetMagnet, targetLine, 'target');\n    } else {\n      targetPoint = targetAnchor;\n    }\n    return {\n      source: sourcePoint,\n      target: targetPoint\n    };\n  }\n  getConnectionPoint(def, view, magnet, line, endType) {\n    const anchor = line.end;\n    if (def == null) {\n      return anchor;\n    }\n    const name = typeof def === 'string' ? def : def.name;\n    const args = typeof def === 'string' ? {} : def.args;\n    const fn = ConnectionPoint.registry.get(name);\n    if (typeof fn !== 'function') {\n      return ConnectionPoint.registry.onNotFound(name);\n    }\n    const connectionPoint = FunctionExt.call(fn, this, line, view, magnet, args || {}, endType);\n    return connectionPoint ? connectionPoint.round(this.POINT_ROUNDING) : anchor;\n  }\n  findMarkerPoints(routePoints, sourcePoint, targetPoint) {\n    const getLineWidth = type => {\n      const attrs = this.cell.getAttrs();\n      const keys = Object.keys(attrs);\n      for (let i = 0, l = keys.length; i < l; i += 1) {\n        const attr = attrs[keys[i]];\n        if (attr[`${type}Marker`] || attr[`${type}-marker`]) {\n          const strokeWidth = attr.strokeWidth || attr['stroke-width'];\n          if (strokeWidth) {\n            return parseFloat(strokeWidth);\n          }\n          break;\n        }\n      }\n      return null;\n    };\n    const firstRoutePoint = routePoints[0];\n    const lastRoutePoint = routePoints[routePoints.length - 1];\n    let sourceMarkerPoint;\n    let targetMarkerPoint;\n    const sourceStrokeWidth = getLineWidth('source');\n    if (sourceStrokeWidth) {\n      sourceMarkerPoint = sourcePoint.clone().move(firstRoutePoint || targetPoint, -sourceStrokeWidth);\n    }\n    const targetStrokeWidth = getLineWidth('target');\n    if (targetStrokeWidth) {\n      targetMarkerPoint = targetPoint.clone().move(lastRoutePoint || sourcePoint, -targetStrokeWidth);\n    }\n    this.sourceMarkerPoint = sourceMarkerPoint || sourcePoint.clone();\n    this.targetMarkerPoint = targetMarkerPoint || targetPoint.clone();\n    return {\n      source: sourceMarkerPoint,\n      target: targetMarkerPoint\n    };\n  }\n  findPath(routePoints, sourcePoint, targetPoint) {\n    const def = this.cell.getConnector() || this.graph.options.connecting.connector;\n    let name;\n    let args;\n    let fn;\n    if (typeof def === 'string') {\n      name = def;\n    } else {\n      name = def.name;\n      args = def.args;\n    }\n    if (name) {\n      const method = Connector.registry.get(name);\n      if (typeof method !== 'function') {\n        return Connector.registry.onNotFound(name);\n      }\n      fn = method;\n    } else {\n      fn = Connector.presets.normal;\n    }\n    const path = FunctionExt.call(fn, this, sourcePoint, targetPoint, routePoints, Object.assign(Object.assign({}, args), {\n      raw: true\n    }), this);\n    return typeof path === 'string' ? Path.parse(path) : path;\n  }\n  translateConnectionPoints(tx, ty) {\n    this.sourcePoint.translate(tx, ty);\n    this.targetPoint.translate(tx, ty);\n    this.sourceAnchor.translate(tx, ty);\n    this.targetAnchor.translate(tx, ty);\n    this.sourceMarkerPoint.translate(tx, ty);\n    this.targetMarkerPoint.translate(tx, ty);\n  }\n  updateLabelPositions() {\n    if (this.labelContainer == null) {\n      return this;\n    }\n    const path = this.path;\n    if (!path) {\n      return this;\n    }\n    const edge = this.cell;\n    const labels = edge.getLabels();\n    if (labels.length === 0) {\n      return this;\n    }\n    const defaultLabel = edge.getDefaultLabel();\n    const defaultPosition = this.normalizeLabelPosition(defaultLabel.position);\n    for (let i = 0, ii = labels.length; i < ii; i += 1) {\n      const label = labels[i];\n      const labelNode = this.labelCache[i];\n      if (!labelNode) {\n        continue;\n      }\n      const labelPosition = this.normalizeLabelPosition(label.position);\n      const pos = ObjectExt.merge({}, defaultPosition, labelPosition);\n      const matrix = this.getLabelTransformationMatrix(pos);\n      labelNode.setAttribute('transform', Dom.matrixToTransformString(matrix));\n    }\n    return this;\n  }\n  updateTerminalProperties(type) {\n    const edge = this.cell;\n    const graph = this.graph;\n    const terminal = edge[type];\n    const nodeId = terminal && terminal.cell;\n    const viewKey = `${type}View`;\n    // terminal is a point\n    if (!nodeId) {\n      this[viewKey] = null;\n      this.updateTerminalMagnet(type);\n      return true;\n    }\n    const terminalCell = graph.getCellById(nodeId);\n    if (!terminalCell) {\n      throw new Error(`Edge's ${type} node with id \"${nodeId}\" not exists`);\n    }\n    const endView = terminalCell.findView(graph);\n    if (!endView) {\n      return false;\n    }\n    this[viewKey] = endView;\n    this.updateTerminalMagnet(type);\n    return true;\n  }\n  updateTerminalMagnet(type) {\n    const propName = `${type}Magnet`;\n    const terminalView = this.getTerminalView(type);\n    if (terminalView) {\n      let magnet = terminalView.getMagnetFromEdgeTerminal(this.cell[type]);\n      if (magnet === terminalView.container) {\n        magnet = null;\n      }\n      this[propName] = magnet;\n    } else {\n      this[propName] = null;\n    }\n  }\n  getLabelPositionAngle(idx) {\n    const label = this.cell.getLabelAt(idx);\n    if (label && label.position && typeof label.position === 'object') {\n      return label.position.angle || 0;\n    }\n    return 0;\n  }\n  getLabelPositionArgs(idx) {\n    const label = this.cell.getLabelAt(idx);\n    if (label && label.position && typeof label.position === 'object') {\n      return label.position.options;\n    }\n  }\n  getDefaultLabelPositionArgs() {\n    const defaultLabel = this.cell.getDefaultLabel();\n    if (defaultLabel && defaultLabel.position && typeof defaultLabel.position === 'object') {\n      return defaultLabel.position.options;\n    }\n  }\n  mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs) {\n    if (labelPositionArgs === null) {\n      return null;\n    }\n    if (labelPositionArgs === undefined) {\n      if (defaultLabelPositionArgs === null) {\n        return null;\n      }\n      return defaultLabelPositionArgs;\n    }\n    return ObjectExt.merge({}, defaultLabelPositionArgs, labelPositionArgs);\n  }\n  // #endregion\n  getConnection() {\n    return this.path != null ? this.path.clone() : null;\n  }\n  getConnectionPathData() {\n    if (this.path == null) {\n      return '';\n    }\n    const cache = this.cache.pathCache;\n    if (!ObjectExt.has(cache, 'data')) {\n      cache.data = this.path.serialize();\n    }\n    return cache.data || '';\n  }\n  getConnectionSubdivisions() {\n    if (this.path == null) {\n      return null;\n    }\n    const cache = this.cache.pathCache;\n    if (!ObjectExt.has(cache, 'segmentSubdivisions')) {\n      cache.segmentSubdivisions = this.path.getSegmentSubdivisions();\n    }\n    return cache.segmentSubdivisions;\n  }\n  getConnectionLength() {\n    if (this.path == null) {\n      return 0;\n    }\n    const cache = this.cache.pathCache;\n    if (!ObjectExt.has(cache, 'length')) {\n      cache.length = this.path.length({\n        segmentSubdivisions: this.getConnectionSubdivisions()\n      });\n    }\n    return cache.length;\n  }\n  getPointAtLength(length) {\n    if (this.path == null) {\n      return null;\n    }\n    return this.path.pointAtLength(length, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  }\n  getPointAtRatio(ratio) {\n    if (this.path == null) {\n      return null;\n    }\n    if (NumberExt.isPercentage(ratio)) {\n      // eslint-disable-next-line\n      ratio = parseFloat(ratio) / 100;\n    }\n    return this.path.pointAt(ratio, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  }\n  getTangentAtLength(length) {\n    if (this.path == null) {\n      return null;\n    }\n    return this.path.tangentAtLength(length, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  }\n  getTangentAtRatio(ratio) {\n    if (this.path == null) {\n      return null;\n    }\n    return this.path.tangentAt(ratio, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  }\n  getClosestPoint(point) {\n    if (this.path == null) {\n      return null;\n    }\n    return this.path.closestPoint(point, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  }\n  getClosestPointLength(point) {\n    if (this.path == null) {\n      return null;\n    }\n    return this.path.closestPointLength(point, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  }\n  getClosestPointRatio(point) {\n    if (this.path == null) {\n      return null;\n    }\n    return this.path.closestPointNormalizedLength(point, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  }\n  getLabelPosition(x, y, p3, p4) {\n    const pos = {\n      distance: 0\n    };\n    // normalize data from the two possible signatures\n    let angle = 0;\n    let options;\n    if (typeof p3 === 'number') {\n      angle = p3;\n      options = p4;\n    } else {\n      options = p3;\n    }\n    if (options != null) {\n      pos.options = options;\n    }\n    // identify distance/offset settings\n    const isOffsetAbsolute = options && options.absoluteOffset;\n    const isDistanceRelative = !(options && options.absoluteDistance);\n    const isDistanceAbsoluteReverse = options && options.absoluteDistance && options.reverseDistance;\n    // find closest point t\n    const path = this.path;\n    const pathOptions = {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    };\n    const labelPoint = new Point(x, y);\n    const t = path.closestPointT(labelPoint, pathOptions);\n    // distance\n    const totalLength = this.getConnectionLength() || 0;\n    let labelDistance = path.lengthAtT(t, pathOptions);\n    if (isDistanceRelative) {\n      labelDistance = totalLength > 0 ? labelDistance / totalLength : 0;\n    }\n    if (isDistanceAbsoluteReverse) {\n      // fix for end point (-0 => 1)\n      labelDistance = -1 * (totalLength - labelDistance) || 1;\n    }\n    pos.distance = labelDistance;\n    // offset\n    // use absolute offset if:\n    // - options.absoluteOffset is true,\n    // - options.absoluteOffset is not true but there is no tangent\n    let tangent;\n    if (!isOffsetAbsolute) tangent = path.tangentAtT(t);\n    let labelOffset;\n    if (tangent) {\n      labelOffset = tangent.pointOffset(labelPoint);\n    } else {\n      const closestPoint = path.pointAtT(t);\n      const labelOffsetDiff = labelPoint.diff(closestPoint);\n      labelOffset = {\n        x: labelOffsetDiff.x,\n        y: labelOffsetDiff.y\n      };\n    }\n    pos.offset = labelOffset;\n    pos.angle = angle;\n    return pos;\n  }\n  normalizeLabelPosition(pos) {\n    if (typeof pos === 'number') {\n      return {\n        distance: pos\n      };\n    }\n    return pos;\n  }\n  getLabelTransformationMatrix(labelPosition) {\n    const pos = this.normalizeLabelPosition(labelPosition);\n    const options = pos.options || {};\n    const labelAngle = pos.angle || 0;\n    const labelDistance = pos.distance;\n    const isDistanceRelative = labelDistance > 0 && labelDistance <= 1;\n    let labelOffset = 0;\n    const offsetCoord = {\n      x: 0,\n      y: 0\n    };\n    const offset = pos.offset;\n    if (offset) {\n      if (typeof offset === 'number') {\n        labelOffset = offset;\n      } else {\n        if (offset.x != null) {\n          offsetCoord.x = offset.x;\n        }\n        if (offset.y != null) {\n          offsetCoord.y = offset.y;\n        }\n      }\n    }\n    const isOffsetAbsolute = offsetCoord.x !== 0 || offsetCoord.y !== 0 || labelOffset === 0;\n    const isKeepGradient = options.keepGradient;\n    const isEnsureLegibility = options.ensureLegibility;\n    const path = this.path;\n    const pathOpt = {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    };\n    const distance = isDistanceRelative ? labelDistance * this.getConnectionLength() : labelDistance;\n    const tangent = path.tangentAtLength(distance, pathOpt);\n    let translation;\n    let angle = labelAngle;\n    if (tangent) {\n      if (isOffsetAbsolute) {\n        translation = tangent.start;\n        translation.translate(offsetCoord);\n      } else {\n        const normal = tangent.clone();\n        normal.rotate(-90, tangent.start);\n        normal.setLength(labelOffset);\n        translation = normal.end;\n      }\n      if (isKeepGradient) {\n        angle = tangent.angle() + labelAngle;\n        if (isEnsureLegibility) {\n          angle = Angle.normalize((angle + 90) % 180 - 90);\n        }\n      }\n    } else {\n      // fallback - the connection has zero length\n      translation = path.start;\n      if (isOffsetAbsolute) {\n        translation.translate(offsetCoord);\n      }\n    }\n    return Dom.createSVGMatrix().translate(translation.x, translation.y).rotate(angle);\n  }\n  getVertexIndex(x, y) {\n    const edge = this.cell;\n    const vertices = edge.getVertices();\n    const vertexLength = this.getClosestPointLength(new Point(x, y));\n    let index = 0;\n    if (vertexLength != null) {\n      for (const ii = vertices.length; index < ii; index += 1) {\n        const currentVertex = vertices[index];\n        const currentLength = this.getClosestPointLength(currentVertex);\n        if (currentLength != null && vertexLength < currentLength) {\n          break;\n        }\n      }\n    }\n    return index;\n  }\n  getEventArgs(e, x, y) {\n    const view = this; // eslint-disable-line\n    const edge = view.cell;\n    const cell = edge;\n    if (x == null || y == null) {\n      return {\n        e,\n        view,\n        edge,\n        cell\n      };\n    }\n    return {\n      e,\n      x,\n      y,\n      view,\n      edge,\n      cell\n    };\n  }\n  notifyUnhandledMouseDown(e, x, y) {\n    this.notify('edge:unhandled:mousedown', {\n      e,\n      x,\n      y,\n      view: this,\n      cell: this.cell,\n      edge: this.cell\n    });\n  }\n  notifyMouseDown(e, x, y) {\n    super.onMouseDown(e, x, y);\n    this.notify('edge:mousedown', this.getEventArgs(e, x, y));\n  }\n  notifyMouseMove(e, x, y) {\n    super.onMouseMove(e, x, y);\n    this.notify('edge:mousemove', this.getEventArgs(e, x, y));\n  }\n  notifyMouseUp(e, x, y) {\n    super.onMouseUp(e, x, y);\n    this.notify('edge:mouseup', this.getEventArgs(e, x, y));\n  }\n  onClick(e, x, y) {\n    super.onClick(e, x, y);\n    this.notify('edge:click', this.getEventArgs(e, x, y));\n  }\n  onDblClick(e, x, y) {\n    super.onDblClick(e, x, y);\n    this.notify('edge:dblclick', this.getEventArgs(e, x, y));\n  }\n  onContextMenu(e, x, y) {\n    super.onContextMenu(e, x, y);\n    this.notify('edge:contextmenu', this.getEventArgs(e, x, y));\n  }\n  onMouseDown(e, x, y) {\n    this.notifyMouseDown(e, x, y);\n    this.startEdgeDragging(e, x, y);\n  }\n  onMouseMove(e, x, y) {\n    const data = this.getEventData(e);\n    switch (data.action) {\n      case 'drag-label':\n        {\n          this.dragLabel(e, x, y);\n          break;\n        }\n      case 'drag-arrowhead':\n        {\n          this.dragArrowhead(e, x, y);\n          break;\n        }\n      case 'drag-edge':\n        {\n          this.dragEdge(e, x, y);\n          break;\n        }\n      default:\n        break;\n    }\n    this.notifyMouseMove(e, x, y);\n    return data;\n  }\n  onMouseUp(e, x, y) {\n    const data = this.getEventData(e);\n    switch (data.action) {\n      case 'drag-label':\n        {\n          this.stopLabelDragging(e, x, y);\n          break;\n        }\n      case 'drag-arrowhead':\n        {\n          this.stopArrowheadDragging(e, x, y);\n          break;\n        }\n      case 'drag-edge':\n        {\n          this.stopEdgeDragging(e, x, y);\n          break;\n        }\n      default:\n        break;\n    }\n    this.notifyMouseUp(e, x, y);\n    this.checkMouseleave(e);\n    return data;\n  }\n  onMouseOver(e) {\n    super.onMouseOver(e);\n    this.notify('edge:mouseover', this.getEventArgs(e));\n  }\n  onMouseOut(e) {\n    super.onMouseOut(e);\n    this.notify('edge:mouseout', this.getEventArgs(e));\n  }\n  onMouseEnter(e) {\n    super.onMouseEnter(e);\n    this.notify('edge:mouseenter', this.getEventArgs(e));\n  }\n  onMouseLeave(e) {\n    super.onMouseLeave(e);\n    this.notify('edge:mouseleave', this.getEventArgs(e));\n  }\n  onMouseWheel(e, x, y, delta) {\n    super.onMouseWheel(e, x, y, delta);\n    this.notify('edge:mousewheel', Object.assign({\n      delta\n    }, this.getEventArgs(e, x, y)));\n  }\n  onCustomEvent(e, name, x, y) {\n    // For default edge tool\n    const tool = Dom.findParentByClass(e.target, 'edge-tool', this.container);\n    if (tool) {\n      e.stopPropagation(); // no further action to be executed\n      if (this.can('useEdgeTools')) {\n        if (name === 'edge:remove') {\n          this.cell.remove({\n            ui: true\n          });\n          return;\n        }\n        this.notify('edge:customevent', Object.assign({\n          name\n        }, this.getEventArgs(e, x, y)));\n      }\n      this.notifyMouseDown(e, x, y);\n    } else {\n      this.notify('edge:customevent', Object.assign({\n        name\n      }, this.getEventArgs(e, x, y)));\n      super.onCustomEvent(e, name, x, y);\n    }\n  }\n  onLabelMouseDown(e, x, y) {\n    this.notifyMouseDown(e, x, y);\n    this.startLabelDragging(e, x, y);\n    const stopPropagation = this.getEventData(e).stopPropagation;\n    if (stopPropagation) {\n      e.stopPropagation();\n    }\n  }\n  // #region drag edge\n  startEdgeDragging(e, x, y) {\n    if (!this.can('edgeMovable')) {\n      this.notifyUnhandledMouseDown(e, x, y);\n      return;\n    }\n    this.setEventData(e, {\n      x,\n      y,\n      moving: false,\n      action: 'drag-edge'\n    });\n  }\n  dragEdge(e, x, y) {\n    const data = this.getEventData(e);\n    if (!data.moving) {\n      data.moving = true;\n      this.addClass('edge-moving');\n      this.notify('edge:move', {\n        e,\n        x,\n        y,\n        view: this,\n        cell: this.cell,\n        edge: this.cell\n      });\n    }\n    this.cell.translate(x - data.x, y - data.y, {\n      ui: true\n    });\n    this.setEventData(e, {\n      x,\n      y\n    });\n    this.notify('edge:moving', {\n      e,\n      x,\n      y,\n      view: this,\n      cell: this.cell,\n      edge: this.cell\n    });\n  }\n  stopEdgeDragging(e, x, y) {\n    const data = this.getEventData(e);\n    if (data.moving) {\n      this.removeClass('edge-moving');\n      this.notify('edge:moved', {\n        e,\n        x,\n        y,\n        view: this,\n        cell: this.cell,\n        edge: this.cell\n      });\n    }\n    data.moving = false;\n  }\n  // #endregion\n  // #region drag arrowhead\n  prepareArrowheadDragging(type, options) {\n    const magnet = this.getTerminalMagnet(type);\n    const data = {\n      action: 'drag-arrowhead',\n      x: options.x,\n      y: options.y,\n      isNewEdge: options.isNewEdge === true,\n      terminalType: type,\n      initialMagnet: magnet,\n      initialTerminal: ObjectExt.clone(this.cell[type]),\n      fallbackAction: options.fallbackAction || 'revert',\n      getValidateConnectionArgs: this.createValidateConnectionArgs(type),\n      options: options.options\n    };\n    this.beforeArrowheadDragging(data);\n    return data;\n  }\n  createValidateConnectionArgs(type) {\n    const args = [];\n    args[4] = type;\n    args[5] = this;\n    let opposite;\n    let i = 0;\n    let j = 0;\n    if (type === 'source') {\n      i = 2;\n      opposite = 'target';\n    } else {\n      j = 2;\n      opposite = 'source';\n    }\n    const terminal = this.cell[opposite];\n    const cellId = terminal.cell;\n    if (cellId) {\n      let magnet;\n      const view = args[i] = this.graph.findViewByCell(cellId);\n      if (view) {\n        magnet = view.getMagnetFromEdgeTerminal(terminal);\n        if (magnet === view.container) {\n          magnet = undefined;\n        }\n      }\n      args[i + 1] = magnet;\n    }\n    return (cellView, magnet) => {\n      args[j] = cellView;\n      args[j + 1] = cellView.container === magnet ? undefined : magnet;\n      return args;\n    };\n  }\n  beforeArrowheadDragging(data) {\n    data.zIndex = this.cell.zIndex;\n    this.cell.toFront();\n    const style = this.container.style;\n    data.pointerEvents = style.pointerEvents;\n    style.pointerEvents = 'none';\n    if (this.graph.options.connecting.highlight) {\n      this.highlightAvailableMagnets(data);\n    }\n  }\n  afterArrowheadDragging(data) {\n    if (data.zIndex != null) {\n      this.cell.setZIndex(data.zIndex, {\n        ui: true\n      });\n      data.zIndex = null;\n    }\n    const container = this.container;\n    container.style.pointerEvents = data.pointerEvents || '';\n    if (this.graph.options.connecting.highlight) {\n      this.unhighlightAvailableMagnets(data);\n    }\n  }\n  validateConnection(sourceView, sourceMagnet, targetView, targetMagnet, terminalType, edgeView, candidateTerminal) {\n    const options = this.graph.options.connecting;\n    const allowLoop = options.allowLoop;\n    const allowNode = options.allowNode;\n    const allowEdge = options.allowEdge;\n    const allowPort = options.allowPort;\n    const allowMulti = options.allowMulti;\n    const validate = options.validateConnection;\n    const edge = edgeView ? edgeView.cell : null;\n    const terminalView = terminalType === 'target' ? targetView : sourceView;\n    const terminalMagnet = terminalType === 'target' ? targetMagnet : sourceMagnet;\n    let valid = true;\n    const doValidate = validate => {\n      const sourcePort = terminalType === 'source' ? candidateTerminal ? candidateTerminal.port : null : edge ? edge.getSourcePortId() : null;\n      const targetPort = terminalType === 'target' ? candidateTerminal ? candidateTerminal.port : null : edge ? edge.getTargetPortId() : null;\n      return FunctionExt.call(validate, this.graph, {\n        edge,\n        edgeView,\n        sourceView,\n        targetView,\n        sourcePort,\n        targetPort,\n        sourceMagnet,\n        targetMagnet,\n        sourceCell: sourceView ? sourceView.cell : null,\n        targetCell: targetView ? targetView.cell : null,\n        type: terminalType\n      });\n    };\n    if (allowLoop != null) {\n      if (typeof allowLoop === 'boolean') {\n        if (!allowLoop && sourceView === targetView) {\n          valid = false;\n        }\n      } else {\n        valid = doValidate(allowLoop);\n      }\n    }\n    if (valid && allowPort != null) {\n      if (typeof allowPort === 'boolean') {\n        if (!allowPort && terminalMagnet) {\n          valid = false;\n        }\n      } else {\n        valid = doValidate(allowPort);\n      }\n    }\n    if (valid && allowEdge != null) {\n      if (typeof allowEdge === 'boolean') {\n        if (!allowEdge && EdgeView.isEdgeView(terminalView)) {\n          valid = false;\n        }\n      } else {\n        valid = doValidate(allowEdge);\n      }\n    }\n    // When judging nodes, the influence of the ports should be excluded,\n    // because the ports and nodes have the same terminalView\n    if (valid && allowNode != null && terminalMagnet == null) {\n      if (typeof allowNode === 'boolean') {\n        if (!allowNode && NodeView.isNodeView(terminalView)) {\n          valid = false;\n        }\n      } else {\n        valid = doValidate(allowNode);\n      }\n    }\n    if (valid && allowMulti != null && edgeView) {\n      const edge = edgeView.cell;\n      const source = terminalType === 'source' ? candidateTerminal : edge.getSource();\n      const target = terminalType === 'target' ? candidateTerminal : edge.getTarget();\n      const terminalCell = candidateTerminal ? this.graph.getCellById(candidateTerminal.cell) : null;\n      if (source && target && source.cell && target.cell && terminalCell) {\n        if (typeof allowMulti === 'function') {\n          valid = doValidate(allowMulti);\n        } else {\n          const connectedEdges = this.graph.model.getConnectedEdges(terminalCell, {\n            outgoing: terminalType === 'source',\n            incoming: terminalType === 'target'\n          });\n          if (connectedEdges.length) {\n            if (allowMulti === 'withPort') {\n              const exist = connectedEdges.some(link => {\n                const s = link.getSource();\n                const t = link.getTarget();\n                return s && t && s.cell === source.cell && t.cell === target.cell && s.port != null && s.port === source.port && t.port != null && t.port === target.port;\n              });\n              if (exist) {\n                valid = false;\n              }\n            } else if (!allowMulti) {\n              const exist = connectedEdges.some(link => {\n                const s = link.getSource();\n                const t = link.getTarget();\n                return s && t && s.cell === source.cell && t.cell === target.cell;\n              });\n              if (exist) {\n                valid = false;\n              }\n            }\n          }\n        }\n      }\n    }\n    if (valid && validate != null) {\n      valid = doValidate(validate);\n    }\n    return valid;\n  }\n  allowConnectToBlank(edge) {\n    const graph = this.graph;\n    const options = graph.options.connecting;\n    const allowBlank = options.allowBlank;\n    if (typeof allowBlank !== 'function') {\n      return !!allowBlank;\n    }\n    const edgeView = graph.findViewByCell(edge);\n    const sourceCell = edge.getSourceCell();\n    const targetCell = edge.getTargetCell();\n    const sourceView = graph.findViewByCell(sourceCell);\n    const targetView = graph.findViewByCell(targetCell);\n    return FunctionExt.call(allowBlank, graph, {\n      edge,\n      edgeView,\n      sourceCell,\n      targetCell,\n      sourceView,\n      targetView,\n      sourcePort: edge.getSourcePortId(),\n      targetPort: edge.getTargetPortId(),\n      sourceMagnet: edgeView.sourceMagnet,\n      targetMagnet: edgeView.targetMagnet\n    });\n  }\n  validateEdge(edge, type, initialTerminal) {\n    const graph = this.graph;\n    if (!this.allowConnectToBlank(edge)) {\n      const sourceId = edge.getSourceCellId();\n      const targetId = edge.getTargetCellId();\n      if (!(sourceId && targetId)) {\n        return false;\n      }\n    }\n    const validate = graph.options.connecting.validateEdge;\n    if (validate) {\n      return FunctionExt.call(validate, graph, {\n        edge,\n        type,\n        previous: initialTerminal\n      });\n    }\n    return true;\n  }\n  arrowheadDragging(target, x, y, data) {\n    data.x = x;\n    data.y = y;\n    // Checking views right under the pointer\n    if (data.currentTarget !== target) {\n      // Unhighlight the previous view under pointer if there was one.\n      if (data.currentMagnet && data.currentView) {\n        data.currentView.unhighlight(data.currentMagnet, {\n          type: 'magnetAdsorbed'\n        });\n      }\n      data.currentView = this.graph.findViewByElem(target);\n      if (data.currentView) {\n        // If we found a view that is under the pointer, we need to find\n        // the closest magnet based on the real target element of the event.\n        data.currentMagnet = data.currentView.findMagnet(target);\n        if (data.currentMagnet && this.validateConnection(...data.getValidateConnectionArgs(data.currentView, data.currentMagnet), data.currentView.getEdgeTerminal(data.currentMagnet, x, y, this.cell, data.terminalType))) {\n          data.currentView.highlight(data.currentMagnet, {\n            type: 'magnetAdsorbed'\n          });\n        } else {\n          // This type of connection is not valid. Disregard this magnet.\n          data.currentMagnet = null;\n        }\n      } else {\n        // Make sure we'll unset previous magnet.\n        data.currentMagnet = null;\n      }\n    }\n    data.currentTarget = target;\n    this.cell.prop(data.terminalType, {\n      x,\n      y\n    }, Object.assign(Object.assign({}, data.options), {\n      ui: true\n    }));\n  }\n  arrowheadDragged(data, x, y) {\n    const view = data.currentView;\n    const magnet = data.currentMagnet;\n    if (!magnet || !view) {\n      return;\n    }\n    view.unhighlight(magnet, {\n      type: 'magnetAdsorbed'\n    });\n    const type = data.terminalType;\n    const terminal = view.getEdgeTerminal(magnet, x, y, this.cell, type);\n    this.cell.setTerminal(type, terminal, {\n      ui: true\n    });\n  }\n  snapArrowhead(x, y, data) {\n    const graph = this.graph;\n    const {\n      snap,\n      allowEdge\n    } = graph.options.connecting;\n    const radius = typeof snap === 'object' && snap.radius || 50;\n    const anchor = typeof snap === 'object' && snap.anchor || 'center';\n    const views = graph.renderer.findViewsInArea({\n      x: x - radius,\n      y: y - radius,\n      width: 2 * radius,\n      height: 2 * radius\n    }, {\n      nodeOnly: true\n    });\n    if (allowEdge) {\n      const edgeViews = graph.renderer.findEdgeViewsFromPoint({\n        x,\n        y\n      }, radius).filter(view => {\n        return view !== this;\n      });\n      views.push(...edgeViews);\n    }\n    const prevView = data.closestView || null;\n    const prevMagnet = data.closestMagnet || null;\n    data.closestView = null;\n    data.closestMagnet = null;\n    let distance;\n    let minDistance = Number.MAX_SAFE_INTEGER;\n    const pos = new Point(x, y);\n    views.forEach(view => {\n      if (view.container.getAttribute('magnet') !== 'false') {\n        if (view.isNodeView()) {\n          distance = anchor === 'center' ? view.cell.getBBox().getCenter().distance(pos) : view.cell.getBBox().getNearestPointToPoint(pos).distance(pos);\n        } else if (view.isEdgeView()) {\n          const point = view.getClosestPoint(pos);\n          if (point) {\n            distance = point.distance(pos);\n          } else {\n            distance = Number.MAX_SAFE_INTEGER;\n          }\n        }\n        if (distance < radius && distance < minDistance) {\n          if (prevMagnet === view.container || this.validateConnection(...data.getValidateConnectionArgs(view, null), view.getEdgeTerminal(view.container, x, y, this.cell, data.terminalType))) {\n            minDistance = distance;\n            data.closestView = view;\n            data.closestMagnet = view.container;\n          }\n        }\n      }\n      view.container.querySelectorAll('[magnet]').forEach(magnet => {\n        if (magnet.getAttribute('magnet') !== 'false') {\n          const bbox = view.getBBoxOfElement(magnet);\n          distance = pos.distance(bbox.getCenter());\n          if (distance < radius && distance < minDistance) {\n            if (prevMagnet === magnet || this.validateConnection(...data.getValidateConnectionArgs(view, magnet), view.getEdgeTerminal(magnet, x, y, this.cell, data.terminalType))) {\n              minDistance = distance;\n              data.closestView = view;\n              data.closestMagnet = magnet;\n            }\n          }\n        }\n      });\n    });\n    let terminal;\n    const type = data.terminalType;\n    const closestView = data.closestView;\n    const closestMagnet = data.closestMagnet;\n    const changed = prevMagnet !== closestMagnet;\n    if (prevView && changed) {\n      prevView.unhighlight(prevMagnet, {\n        type: 'magnetAdsorbed'\n      });\n    }\n    if (closestView) {\n      if (!changed) {\n        return;\n      }\n      closestView.highlight(closestMagnet, {\n        type: 'magnetAdsorbed'\n      });\n      terminal = closestView.getEdgeTerminal(closestMagnet, x, y, this.cell, type);\n    } else {\n      terminal = {\n        x,\n        y\n      };\n    }\n    this.cell.setTerminal(type, terminal, {}, Object.assign(Object.assign({}, data.options), {\n      ui: true\n    }));\n  }\n  snapArrowheadEnd(data) {\n    // Finish off link snapping.\n    // Everything except view unhighlighting was already done on pointermove.\n    const closestView = data.closestView;\n    const closestMagnet = data.closestMagnet;\n    if (closestView && closestMagnet) {\n      closestView.unhighlight(closestMagnet, {\n        type: 'magnetAdsorbed'\n      });\n      data.currentMagnet = closestView.findMagnet(closestMagnet);\n    }\n    data.closestView = null;\n    data.closestMagnet = null;\n  }\n  finishEmbedding(data) {\n    // Resets parent of the edge if embedding is enabled\n    if (this.graph.options.embedding.enabled && this.cell.updateParent()) {\n      // Make sure we don't reverse to the original 'z' index\n      data.zIndex = null;\n    }\n  }\n  fallbackConnection(data) {\n    switch (data.fallbackAction) {\n      case 'remove':\n        this.cell.remove({\n          ui: true\n        });\n        break;\n      case 'revert':\n      default:\n        this.cell.prop(data.terminalType, data.initialTerminal, {\n          ui: true\n        });\n        break;\n    }\n  }\n  notifyConnectionEvent(data, e) {\n    const terminalType = data.terminalType;\n    const initialTerminal = data.initialTerminal;\n    const currentTerminal = this.cell[terminalType];\n    const changed = currentTerminal && !Edge.equalTerminals(initialTerminal, currentTerminal);\n    if (changed) {\n      const graph = this.graph;\n      const previous = initialTerminal;\n      const previousCell = previous.cell ? graph.getCellById(previous.cell) : null;\n      const previousPort = previous.port;\n      const previousView = previousCell ? graph.findViewByCell(previousCell) : null;\n      const previousPoint = previousCell || data.isNewEdge ? null : Point.create(initialTerminal).toJSON();\n      const current = currentTerminal;\n      const currentCell = current.cell ? graph.getCellById(current.cell) : null;\n      const currentPort = current.port;\n      const currentView = currentCell ? graph.findViewByCell(currentCell) : null;\n      const currentPoint = currentCell ? null : Point.create(currentTerminal).toJSON();\n      this.notify('edge:connected', {\n        e,\n        previousCell,\n        previousPort,\n        previousView,\n        previousPoint,\n        currentCell,\n        currentView,\n        currentPort,\n        currentPoint,\n        previousMagnet: data.initialMagnet,\n        currentMagnet: data.currentMagnet,\n        edge: this.cell,\n        view: this,\n        type: terminalType,\n        isNew: data.isNewEdge\n      });\n    }\n  }\n  highlightAvailableMagnets(data) {\n    const graph = this.graph;\n    const cells = graph.model.getCells();\n    data.marked = {};\n    for (let i = 0, ii = cells.length; i < ii; i += 1) {\n      const view = graph.findViewByCell(cells[i]);\n      // Prevent highlighting new edge\n      // Close https://github.com/antvis/X6/issues/2853\n      if (!view || view.cell.id === this.cell.id) {\n        continue;\n      }\n      const magnets = Array.prototype.slice.call(view.container.querySelectorAll('[magnet]'));\n      if (view.container.getAttribute('magnet') !== 'false') {\n        magnets.push(view.container);\n      }\n      const availableMagnets = magnets.filter(magnet => this.validateConnection(...data.getValidateConnectionArgs(view, magnet), view.getEdgeTerminal(magnet, data.x, data.y, this.cell, data.terminalType)));\n      if (availableMagnets.length > 0) {\n        // highlight all available magnets\n        for (let j = 0, jj = availableMagnets.length; j < jj; j += 1) {\n          view.highlight(availableMagnets[j], {\n            type: 'magnetAvailable'\n          });\n        }\n        // highlight the entire view\n        view.highlight(null, {\n          type: 'nodeAvailable'\n        });\n        data.marked[view.cell.id] = availableMagnets;\n      }\n    }\n  }\n  unhighlightAvailableMagnets(data) {\n    const marked = data.marked || {};\n    Object.keys(marked).forEach(id => {\n      const view = this.graph.findViewByCell(id);\n      if (view) {\n        const magnets = marked[id];\n        magnets.forEach(magnet => {\n          view.unhighlight(magnet, {\n            type: 'magnetAvailable'\n          });\n        });\n        view.unhighlight(null, {\n          type: 'nodeAvailable'\n        });\n      }\n    });\n    data.marked = null;\n  }\n  startArrowheadDragging(e, x, y) {\n    if (!this.can('arrowheadMovable')) {\n      this.notifyUnhandledMouseDown(e, x, y);\n      return;\n    }\n    const elem = e.target;\n    const type = elem.getAttribute('data-terminal');\n    const data = this.prepareArrowheadDragging(type, {\n      x,\n      y\n    });\n    this.setEventData(e, data);\n  }\n  dragArrowhead(e, x, y) {\n    const data = this.getEventData(e);\n    if (this.graph.options.connecting.snap) {\n      this.snapArrowhead(x, y, data);\n    } else {\n      this.arrowheadDragging(this.getEventTarget(e), x, y, data);\n    }\n  }\n  stopArrowheadDragging(e, x, y) {\n    const graph = this.graph;\n    const data = this.getEventData(e);\n    if (graph.options.connecting.snap) {\n      this.snapArrowheadEnd(data);\n    } else {\n      this.arrowheadDragged(data, x, y);\n    }\n    const valid = this.validateEdge(this.cell, data.terminalType, data.initialTerminal);\n    if (valid) {\n      this.finishEmbedding(data);\n      this.notifyConnectionEvent(data, e);\n    } else {\n      // If the changed edge is not allowed, revert to its previous state.\n      this.fallbackConnection(data);\n    }\n    this.afterArrowheadDragging(data);\n  }\n  // #endregion\n  // #region drag lable\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  startLabelDragging(e, x, y) {\n    if (this.can('edgeLabelMovable')) {\n      const target = e.currentTarget;\n      const index = parseInt(target.getAttribute('data-index'), 10);\n      const positionAngle = this.getLabelPositionAngle(index);\n      const labelPositionArgs = this.getLabelPositionArgs(index);\n      const defaultLabelPositionArgs = this.getDefaultLabelPositionArgs();\n      const positionArgs = this.mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);\n      this.setEventData(e, {\n        index,\n        positionAngle,\n        positionArgs,\n        stopPropagation: true,\n        action: 'drag-label'\n      });\n    } else {\n      // If labels can't be dragged no default action is triggered.\n      this.setEventData(e, {\n        stopPropagation: true\n      });\n    }\n    this.graph.view.delegateDragEvents(e, this);\n  }\n  dragLabel(e, x, y) {\n    const data = this.getEventData(e);\n    const originLabel = this.cell.getLabelAt(data.index);\n    const label = ObjectExt.merge({}, originLabel, {\n      position: this.getLabelPosition(x, y, data.positionAngle, data.positionArgs)\n    });\n    this.cell.setLabelAt(data.index, label);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  stopLabelDragging(e, x, y) {}\n}\n(function (EdgeView) {\n  EdgeView.toStringTag = `X6.${EdgeView.name}`;\n  function isEdgeView(instance) {\n    if (instance == null) {\n      return false;\n    }\n    if (instance instanceof EdgeView) {\n      return true;\n    }\n    const tag = instance[Symbol.toStringTag];\n    const view = instance;\n    if ((tag == null || tag === EdgeView.toStringTag) && typeof view.isNodeView === 'function' && typeof view.isEdgeView === 'function' && typeof view.confirmUpdate === 'function' && typeof view.update === 'function' && typeof view.getConnection === 'function') {\n      return true;\n    }\n    return false;\n  }\n  EdgeView.isEdgeView = isEdgeView;\n})(EdgeView || (EdgeView = {}));\nEdgeView.config({\n  isSvgElement: true,\n  priority: 1,\n  bootstrap: ['render', 'source', 'target'],\n  actions: {\n    view: ['render'],\n    markup: ['render'],\n    attrs: ['update'],\n    source: ['source', 'update'],\n    target: ['target', 'update'],\n    router: ['update'],\n    connector: ['update'],\n    labels: ['labels'],\n    defaultLabel: ['labels'],\n    tools: ['tools'],\n    vertices: ['vertices', 'update']\n  }\n});\nEdgeView.registry.register('edge', EdgeView, true);","map":{"version":3,"names":["Rectangle","Polyline","Point","Angle","Path","Line","ObjectExt","NumberExt","FunctionExt","Dom","Vector","Router","Connector","NodeAnchor","EdgeAnchor","ConnectionPoint","Edge","CellView","NodeView","EdgeView","constructor","POINT_ROUNDING","labelDestroyFn","Symbol","toStringTag","getContainerClassName","prefixClassName","join","sourceBBox","sourceView","sourceDef","cell","getSource","x","y","sourceMagnet","isEdgeElement","sourceAnchor","getBBoxOfElement","container","targetBBox","targetView","targetDef","getTarget","targetMagnet","targetAnchor","isEdgeView","confirmUpdate","flag","options","ref","hasAction","updateTerminalProperties","removeAction","render","handleAction","update","onLabelsChange","renderTools","empty","renderMarkup","labelContainer","renderLabels","markup","TypeError","renderJSONMarkup","ret","parseJSONMarkup","selectors","append","fragment","customizeLabels","edge","labels","i","n","length","label","labelCache","labelSelectors","onEdgeLabelRendered","graph","fn","destroyCustomizeLabels","getLabels","count","parentNode","removeChild","createSvgElement","addClass","ii","normalized","normalizeLabelMarkup","parseLabelMarkup","labelNode","node","defaultLabel","getDefaultLabel","setAttribute","appendChild","rootSelector","Error","updateLabels","shouldRerenderLabels","updateLabelPositions","previousLabels","previous","pathArray","propertyPathArray","pathLength","index","propertyValue","has","parseLabelStringMarkup","labelMarkup","children","createVectors","document","createDocumentFragment","currentChild","DocumentFragment","hasChildNodes","vel","childNodes","nodeName","toUpperCase","create","canLabelMove","can","elem","attrs","merge","updateAttrs","rootBBox","size","fromSize","undefined","tools","getTools","addTools","cleanCache","updateConnection","_a","getAttrs","text","__rest","updateTools","removeRedundantLinearVertices","vertices","getVertices","routePoints","rawCount","polyline","simplify","threshold","simplifiedPoints","points","map","point","toJSON","simplifiedCount","setVertices","slice","getTerminalView","type","getTerminalAnchor","getTerminalConnectionPoint","sourcePoint","targetPoint","getTerminalMagnet","raw","translateBy","isFragmentDescendantOf","tx","ty","translate","translateConnectionPoints","path","anchors","findAnchors","source","target","findRoutePoints","connectionPoints","findConnectionPoints","markerPoints","findMarkerPoints","findPath","firstVertex","lastVertex","priority","findAnchorsOrdered","firstType","firstPoint","secondType","secondPoint","firstAnchor","secondAnchor","firstTerminal","secondTerminal","firstView","secondView","firstMagnet","secondMagnet","firstRef","getAnchor","anchor","secondRef","isPointLike","def","cellView","magnet","terminalType","isEdge","connecting","config","name","defaults","sourceEdgeAnchor","targetEdgeAnchor","edgeAnchor","registry","get","onNotFound","call","args","round","defaultRouter","router","presets","normal","getRouter","p","sourceTerminal","targetTerminal","firstRoutePoint","lastRoutePoint","sourcePointRef","sourceLine","connectionPointDef","connectionPoint","sourceConnectionPoint","getConnectionPoint","targetConnectionPointDef","targetConnectionPoint","targetPointRef","targetLine","view","line","endType","end","getLineWidth","keys","Object","l","attr","strokeWidth","parseFloat","sourceMarkerPoint","targetMarkerPoint","sourceStrokeWidth","clone","move","targetStrokeWidth","getConnector","connector","method","assign","parse","defaultPosition","normalizeLabelPosition","position","labelPosition","pos","matrix","getLabelTransformationMatrix","matrixToTransformString","terminal","nodeId","viewKey","updateTerminalMagnet","terminalCell","getCellById","endView","findView","propName","terminalView","getMagnetFromEdgeTerminal","getLabelPositionAngle","idx","getLabelAt","angle","getLabelPositionArgs","getDefaultLabelPositionArgs","mergeLabelPositionArgs","labelPositionArgs","defaultLabelPositionArgs","getConnection","getConnectionPathData","cache","pathCache","data","serialize","getConnectionSubdivisions","segmentSubdivisions","getSegmentSubdivisions","getConnectionLength","getPointAtLength","pointAtLength","getPointAtRatio","ratio","isPercentage","pointAt","getTangentAtLength","tangentAtLength","getTangentAtRatio","tangentAt","getClosestPoint","closestPoint","getClosestPointLength","closestPointLength","getClosestPointRatio","closestPointNormalizedLength","getLabelPosition","p3","p4","distance","isOffsetAbsolute","absoluteOffset","isDistanceRelative","absoluteDistance","isDistanceAbsoluteReverse","reverseDistance","pathOptions","labelPoint","t","closestPointT","totalLength","labelDistance","lengthAtT","tangent","tangentAtT","labelOffset","pointOffset","pointAtT","labelOffsetDiff","diff","offset","labelAngle","offsetCoord","isKeepGradient","keepGradient","isEnsureLegibility","ensureLegibility","pathOpt","translation","start","rotate","setLength","normalize","createSVGMatrix","getVertexIndex","vertexLength","currentVertex","currentLength","getEventArgs","e","notifyUnhandledMouseDown","notify","notifyMouseDown","onMouseDown","notifyMouseMove","onMouseMove","notifyMouseUp","onMouseUp","onClick","onDblClick","onContextMenu","startEdgeDragging","getEventData","action","dragLabel","dragArrowhead","dragEdge","stopLabelDragging","stopArrowheadDragging","stopEdgeDragging","checkMouseleave","onMouseOver","onMouseOut","onMouseEnter","onMouseLeave","onMouseWheel","delta","onCustomEvent","tool","findParentByClass","stopPropagation","remove","ui","onLabelMouseDown","startLabelDragging","setEventData","moving","removeClass","prepareArrowheadDragging","isNewEdge","initialMagnet","initialTerminal","fallbackAction","getValidateConnectionArgs","createValidateConnectionArgs","beforeArrowheadDragging","opposite","j","cellId","findViewByCell","zIndex","toFront","style","pointerEvents","highlight","highlightAvailableMagnets","afterArrowheadDragging","setZIndex","unhighlightAvailableMagnets","validateConnection","edgeView","candidateTerminal","allowLoop","allowNode","allowEdge","allowPort","allowMulti","validate","terminalMagnet","valid","doValidate","sourcePort","port","getSourcePortId","targetPort","getTargetPortId","sourceCell","targetCell","isNodeView","connectedEdges","model","getConnectedEdges","outgoing","incoming","exist","some","link","s","allowConnectToBlank","allowBlank","getSourceCell","getTargetCell","validateEdge","sourceId","getSourceCellId","targetId","getTargetCellId","arrowheadDragging","currentTarget","currentMagnet","currentView","unhighlight","findViewByElem","findMagnet","getEdgeTerminal","prop","arrowheadDragged","setTerminal","snapArrowhead","snap","radius","views","renderer","findViewsInArea","width","height","nodeOnly","edgeViews","findEdgeViewsFromPoint","filter","push","prevView","closestView","prevMagnet","closestMagnet","minDistance","Number","MAX_SAFE_INTEGER","forEach","getAttribute","getBBox","getCenter","getNearestPointToPoint","querySelectorAll","bbox","changed","snapArrowheadEnd","finishEmbedding","embedding","enabled","updateParent","fallbackConnection","notifyConnectionEvent","currentTerminal","equalTerminals","previousCell","previousPort","previousView","previousPoint","current","currentCell","currentPort","currentPoint","previousMagnet","isNew","cells","getCells","marked","id","magnets","Array","prototype","availableMagnets","jj","startArrowheadDragging","getEventTarget","parseInt","positionAngle","positionArgs","delegateDragEvents","originLabel","setLabelAt","instance","tag","isSvgElement","bootstrap","actions","register"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/src/view/edge.ts"],"sourcesContent":["import {\n  Rectangle,\n  Polyline,\n  Point,\n  Angle,\n  Path,\n  Line,\n} from '@antv/x6-geometry'\nimport {\n  ObjectExt,\n  NumberExt,\n  FunctionExt,\n  Dom,\n  Vector,\n  KeyValue,\n} from '@antv/x6-common'\nimport {\n  Router,\n  Connector,\n  NodeAnchor,\n  EdgeAnchor,\n  ConnectionPoint,\n} from '../registry'\nimport { Cell } from '../model/cell'\nimport { Edge } from '../model/edge'\nimport { Markup } from './markup'\nimport { CellView } from './cell'\nimport { NodeView } from './node'\nimport { ToolsView } from './tool'\nimport { Graph } from '../graph'\nimport { Options as GraphOptions } from '../graph/options'\n\nexport class EdgeView<\n  Entity extends Edge = Edge,\n  Options extends EdgeView.Options = EdgeView.Options,\n> extends CellView<Entity, Options> {\n  protected readonly POINT_ROUNDING = 2\n  public path: Path\n  public routePoints: Point[]\n  public sourceAnchor: Point\n  public targetAnchor: Point\n  public sourcePoint: Point\n  public targetPoint: Point\n  public sourceMarkerPoint: Point\n  public targetMarkerPoint: Point\n  public sourceView: CellView | null\n  public targetView: CellView | null\n  public sourceMagnet: Element | null\n  public targetMagnet: Element | null\n\n  protected labelContainer: Element | null\n  protected labelCache: { [index: number]: Element }\n  protected labelSelectors: { [index: number]: Markup.Selectors }\n  protected labelDestroyFn: {\n    [index: number]: (args: GraphOptions.OnEdgeLabelRenderedArgs) => void\n  } = {}\n\n  protected get [Symbol.toStringTag]() {\n    return EdgeView.toStringTag\n  }\n\n  protected getContainerClassName() {\n    return [super.getContainerClassName(), this.prefixClassName('edge')].join(\n      ' ',\n    )\n  }\n\n  get sourceBBox() {\n    const sourceView = this.sourceView\n    if (!sourceView) {\n      const sourceDef = this.cell.getSource() as Edge.TerminalPointData\n      return new Rectangle(sourceDef.x, sourceDef.y)\n    }\n    const sourceMagnet = this.sourceMagnet\n    if (sourceView.isEdgeElement(sourceMagnet)) {\n      return new Rectangle(this.sourceAnchor.x, this.sourceAnchor.y)\n    }\n    return sourceView.getBBoxOfElement(sourceMagnet || sourceView.container)\n  }\n\n  get targetBBox() {\n    const targetView = this.targetView\n    if (!targetView) {\n      const targetDef = this.cell.getTarget() as Edge.TerminalPointData\n      return new Rectangle(targetDef.x, targetDef.y)\n    }\n    const targetMagnet = this.targetMagnet\n    if (targetView.isEdgeElement(targetMagnet)) {\n      return new Rectangle(this.targetAnchor.x, this.targetAnchor.y)\n    }\n    return targetView.getBBoxOfElement(targetMagnet || targetView.container)\n  }\n\n  isEdgeView(): this is EdgeView {\n    return true\n  }\n\n  confirmUpdate(flag: number, options: any = {}) {\n    let ref = flag\n    if (this.hasAction(ref, 'source')) {\n      if (!this.updateTerminalProperties('source')) {\n        return ref\n      }\n      ref = this.removeAction(ref, 'source')\n    }\n\n    if (this.hasAction(ref, 'target')) {\n      if (!this.updateTerminalProperties('target')) {\n        return ref\n      }\n      ref = this.removeAction(ref, 'target')\n    }\n\n    if (this.hasAction(ref, 'render')) {\n      this.render()\n      ref = this.removeAction(ref, ['render', 'update', 'labels', 'tools'])\n      return ref\n    }\n    ref = this.handleAction(ref, 'update', () => this.update(options))\n    ref = this.handleAction(ref, 'labels', () => this.onLabelsChange(options))\n    ref = this.handleAction(ref, 'tools', () => this.renderTools())\n\n    return ref\n  }\n\n  // #region render\n  render() {\n    this.empty()\n\n    this.renderMarkup()\n\n    this.labelContainer = null\n    this.renderLabels()\n\n    this.update()\n    this.renderTools()\n\n    return this\n  }\n\n  protected renderMarkup() {\n    const markup = this.cell.markup\n    if (markup) {\n      if (typeof markup === 'string') {\n        throw new TypeError('Not support string markup.')\n      }\n      return this.renderJSONMarkup(markup)\n    }\n    throw new TypeError('Invalid edge markup.')\n  }\n\n  protected renderJSONMarkup(markup: Markup.JSONMarkup | Markup.JSONMarkup[]) {\n    const ret = this.parseJSONMarkup(markup, this.container)\n    this.selectors = ret.selectors\n    this.container.append(ret.fragment)\n  }\n\n  protected customizeLabels() {\n    if (this.labelContainer) {\n      const edge = this.cell\n      const labels = edge.labels\n      for (let i = 0, n = labels.length; i < n; i += 1) {\n        const label = labels[i]\n        const container = this.labelCache[i]\n        const selectors = this.labelSelectors[i]\n        const onEdgeLabelRendered = this.graph.options.onEdgeLabelRendered\n        if (onEdgeLabelRendered) {\n          const fn = onEdgeLabelRendered({\n            edge,\n            label,\n            container,\n            selectors,\n          })\n          if (fn) {\n            this.labelDestroyFn[i] = fn\n          }\n        }\n      }\n    }\n  }\n\n  protected destroyCustomizeLabels() {\n    const labels = this.cell.labels\n\n    if (this.labelCache && this.labelSelectors && this.labelDestroyFn) {\n      for (let i = 0, n = labels.length; i < n; i += 1) {\n        const fn = this.labelDestroyFn[i]\n        const container = this.labelCache[i]\n        const selectors = this.labelSelectors[i]\n        if (fn && container && selectors) {\n          fn({\n            edge: this.cell,\n            label: labels[i],\n            container,\n            selectors,\n          })\n        }\n      }\n    }\n\n    this.labelDestroyFn = {}\n  }\n\n  protected renderLabels() {\n    const edge = this.cell\n    const labels = edge.getLabels()\n    const count = labels.length\n    let container = this.labelContainer\n\n    this.labelCache = {}\n    this.labelSelectors = {}\n\n    if (count <= 0) {\n      if (container && container.parentNode) {\n        container.parentNode.removeChild(container)\n      }\n      return this\n    }\n\n    if (container) {\n      this.empty(container)\n    } else {\n      container = Dom.createSvgElement('g')\n      this.addClass(this.prefixClassName('edge-labels'), container)\n      this.labelContainer = container\n    }\n\n    for (let i = 0, ii = labels.length; i < ii; i += 1) {\n      const label = labels[i]\n      const normalized = this.normalizeLabelMarkup(\n        this.parseLabelMarkup(label.markup),\n      )\n      let labelNode\n      let selectors\n      if (normalized) {\n        labelNode = normalized.node\n        selectors = normalized.selectors\n      } else {\n        const defaultLabel = edge.getDefaultLabel()\n        const normalized = this.normalizeLabelMarkup(\n          this.parseLabelMarkup(defaultLabel.markup),\n        )!\n\n        labelNode = normalized.node\n        selectors = normalized.selectors\n      }\n\n      labelNode.setAttribute('data-index', `${i}`)\n      container.appendChild(labelNode)\n\n      const rootSelector = this.rootSelector\n      if (selectors[rootSelector]) {\n        throw new Error('Ambiguous label root selector.')\n      }\n      selectors[rootSelector] = labelNode\n\n      this.labelCache[i] = labelNode\n      this.labelSelectors[i] = selectors\n    }\n\n    if (container.parentNode == null) {\n      this.container.appendChild(container)\n    }\n\n    this.updateLabels()\n    this.customizeLabels()\n\n    return this\n  }\n\n  onLabelsChange(options: any = {}) {\n    this.destroyCustomizeLabels()\n\n    if (this.shouldRerenderLabels(options)) {\n      this.renderLabels()\n    } else {\n      this.updateLabels()\n    }\n\n    this.updateLabelPositions()\n  }\n\n  protected shouldRerenderLabels(options: any = {}) {\n    const previousLabels = this.cell.previous('labels')\n    if (previousLabels == null) {\n      return true\n    }\n\n    // Here is an optimization for cases when we know, that change does\n    // not require re-rendering of all labels.\n    if ('propertyPathArray' in options && 'propertyValue' in options) {\n      // The label is setting by `prop()` method\n      const pathArray = options.propertyPathArray || []\n      const pathLength = pathArray.length\n      if (pathLength > 1) {\n        // We are changing a single label here e.g. 'labels/0/position'\n        const index = pathArray[1]\n        if (previousLabels[index]) {\n          if (pathLength === 2) {\n            // We are changing the entire label. Need to check if the\n            // markup is also being changed.\n            return (\n              typeof options.propertyValue === 'object' &&\n              ObjectExt.has(options.propertyValue, 'markup')\n            )\n          }\n\n          // We are changing a label property but not the markup\n          if (pathArray[2] !== 'markup') {\n            return false\n          }\n        }\n      }\n    }\n\n    return true\n  }\n\n  protected parseLabelMarkup(markup?: Markup) {\n    if (markup) {\n      if (typeof markup === 'string') {\n        return this.parseLabelStringMarkup(markup)\n      }\n      return this.parseJSONMarkup(markup)\n    }\n\n    return null\n  }\n\n  protected parseLabelStringMarkup(labelMarkup: string) {\n    const children = Vector.createVectors(labelMarkup)\n    const fragment = document.createDocumentFragment()\n    for (let i = 0, n = children.length; i < n; i += 1) {\n      const currentChild = children[i].node\n      fragment.appendChild(currentChild)\n    }\n\n    return { fragment, selectors: {} }\n  }\n\n  protected normalizeLabelMarkup(\n    markup?: {\n      fragment: DocumentFragment\n      selectors: Markup.Selectors\n    } | null,\n  ) {\n    if (markup == null) {\n      return\n    }\n\n    const fragment = markup.fragment\n    if (!(fragment instanceof DocumentFragment) || !fragment.hasChildNodes()) {\n      throw new Error('Invalid label markup.')\n    }\n\n    let vel\n    const childNodes = fragment.childNodes\n    if (childNodes.length > 1 || childNodes[0].nodeName.toUpperCase() !== 'G') {\n      vel = Vector.create('g').append(fragment)\n    } else {\n      vel = Vector.create(childNodes[0] as SVGElement)\n    }\n\n    vel.addClass(this.prefixClassName('edge-label'))\n\n    return {\n      node: vel.node,\n      selectors: markup.selectors,\n    }\n  }\n\n  protected updateLabels() {\n    if (this.labelContainer) {\n      const edge = this.cell\n      const labels = edge.labels\n      const canLabelMove = this.can('edgeLabelMovable')\n      const defaultLabel = edge.getDefaultLabel()\n\n      for (let i = 0, n = labels.length; i < n; i += 1) {\n        const elem = this.labelCache[i]\n        const selectors = this.labelSelectors[i]\n\n        elem.setAttribute('cursor', canLabelMove ? 'move' : 'default')\n\n        const label = labels[i]\n        const attrs = ObjectExt.merge({}, defaultLabel.attrs, label.attrs)\n        this.updateAttrs(elem, attrs, {\n          selectors,\n          rootBBox: label.size ? Rectangle.fromSize(label.size) : undefined,\n        })\n      }\n    }\n  }\n\n  protected renderTools() {\n    const tools = this.cell.getTools()\n    this.addTools(tools as ToolsView.Options)\n    return this\n  }\n\n  // #endregion\n\n  // #region updating\n\n  update(options: any = {}) {\n    this.cleanCache()\n    this.updateConnection(options)\n\n    const { text, ...attrs } = this.cell.getAttrs()\n    if (attrs != null) {\n      this.updateAttrs(this.container, attrs, {\n        selectors: this.selectors,\n      })\n    }\n\n    this.updateLabelPositions()\n    this.updateTools(options)\n\n    return this\n  }\n\n  removeRedundantLinearVertices(options: Edge.SetOptions = {}) {\n    const edge = this.cell\n    const vertices = edge.getVertices()\n    const routePoints = [this.sourceAnchor, ...vertices, this.targetAnchor]\n    const rawCount = routePoints.length\n\n    // Puts the route points into a polyline and try to simplify.\n    const polyline = new Polyline(routePoints)\n    polyline.simplify({ threshold: 0.01 })\n    const simplifiedPoints = polyline.points.map((point) => point.toJSON())\n    const simplifiedCount = simplifiedPoints.length\n\n    // If simplification did not remove any redundant vertices.\n    if (rawCount === simplifiedCount) {\n      return 0\n    }\n\n    // Sets simplified polyline points as edge vertices.\n    // Removes first and last polyline points again (source/target anchors).\n    edge.setVertices(simplifiedPoints.slice(1, simplifiedCount - 1), options)\n    return rawCount - simplifiedCount\n  }\n\n  getTerminalView(type: Edge.TerminalType) {\n    switch (type) {\n      case 'source':\n        return this.sourceView || null\n      case 'target':\n        return this.targetView || null\n      default:\n        throw new Error(`Unknown terminal type '${type}'`)\n    }\n  }\n\n  getTerminalAnchor(type: Edge.TerminalType) {\n    switch (type) {\n      case 'source':\n        return Point.create(this.sourceAnchor)\n      case 'target':\n        return Point.create(this.targetAnchor)\n      default:\n        throw new Error(`Unknown terminal type '${type}'`)\n    }\n  }\n\n  getTerminalConnectionPoint(type: Edge.TerminalType) {\n    switch (type) {\n      case 'source':\n        return Point.create(this.sourcePoint)\n      case 'target':\n        return Point.create(this.targetPoint)\n      default:\n        throw new Error(`Unknown terminal type '${type}'`)\n    }\n  }\n\n  getTerminalMagnet(type: Edge.TerminalType, options: { raw?: boolean } = {}) {\n    switch (type) {\n      case 'source': {\n        if (options.raw) {\n          return this.sourceMagnet\n        }\n        const sourceView = this.sourceView\n        if (!sourceView) {\n          return null\n        }\n        return this.sourceMagnet || sourceView.container\n      }\n      case 'target': {\n        if (options.raw) {\n          return this.targetMagnet\n        }\n        const targetView = this.targetView\n        if (!targetView) {\n          return null\n        }\n        return this.targetMagnet || targetView.container\n      }\n      default: {\n        throw new Error(`Unknown terminal type '${type}'`)\n      }\n    }\n  }\n\n  updateConnection(options: any = {}) {\n    const edge = this.cell\n\n    // The edge is being translated by an ancestor that will shift\n    // source, target and vertices by an equal distance.\n    // todo isFragmentDescendantOf is invalid\n    if (\n      options.translateBy &&\n      edge.isFragmentDescendantOf(options.translateBy)\n    ) {\n      const tx = options.tx || 0\n      const ty = options.ty || 0\n      this.routePoints = new Polyline(this.routePoints).translate(tx, ty).points\n      this.translateConnectionPoints(tx, ty)\n      this.path.translate(tx, ty)\n    } else {\n      const vertices = edge.getVertices()\n\n      // 1. Find anchor points\n      const anchors = this.findAnchors(vertices)\n      this.sourceAnchor = anchors.source\n      this.targetAnchor = anchors.target\n\n      // 2. Find route points\n      this.routePoints = this.findRoutePoints(vertices)\n\n      // 3. Find connection points\n      const connectionPoints = this.findConnectionPoints(\n        this.routePoints,\n        this.sourceAnchor,\n        this.targetAnchor,\n      )\n      this.sourcePoint = connectionPoints.source\n      this.targetPoint = connectionPoints.target\n\n      // 4. Find Marker Connection Point\n      const markerPoints = this.findMarkerPoints(\n        this.routePoints,\n        this.sourcePoint,\n        this.targetPoint,\n      )\n\n      // 5. Make path\n      this.path = this.findPath(\n        this.routePoints,\n        markerPoints.source || this.sourcePoint,\n        markerPoints.target || this.targetPoint,\n      )\n    }\n\n    this.cleanCache()\n  }\n\n  protected findAnchors(vertices: Point.PointLike[]) {\n    const edge = this.cell\n    const source = edge.source as Edge.TerminalCellData\n    const target = edge.target as Edge.TerminalCellData\n    const firstVertex = vertices[0]\n    const lastVertex = vertices[vertices.length - 1]\n\n    if (target.priority && !source.priority) {\n      // Reversed order\n      return this.findAnchorsOrdered(\n        'target',\n        lastVertex,\n        'source',\n        firstVertex,\n      )\n    }\n\n    // Usual order\n    return this.findAnchorsOrdered('source', firstVertex, 'target', lastVertex)\n  }\n\n  protected findAnchorsOrdered(\n    firstType: Edge.TerminalType,\n    firstPoint: Point.PointLike,\n    secondType: Edge.TerminalType,\n    secondPoint: Point.PointLike,\n  ) {\n    let firstAnchor: Point\n    let secondAnchor: Point\n\n    const edge = this.cell\n    const firstTerminal = edge[firstType]\n    const secondTerminal = edge[secondType]\n    const firstView = this.getTerminalView(firstType)\n    const secondView = this.getTerminalView(secondType)\n    const firstMagnet = this.getTerminalMagnet(firstType)\n    const secondMagnet = this.getTerminalMagnet(secondType)\n\n    if (firstView) {\n      let firstRef\n      if (firstPoint) {\n        firstRef = Point.create(firstPoint)\n      } else if (secondView) {\n        firstRef = secondMagnet\n      } else {\n        firstRef = Point.create(secondTerminal as Edge.TerminalPointData)\n      }\n\n      firstAnchor = this.getAnchor(\n        (firstTerminal as Edge.SetCellTerminalArgs).anchor,\n        firstView,\n        firstMagnet,\n        firstRef,\n        firstType,\n      )\n    } else {\n      firstAnchor = Point.create(firstTerminal as Edge.TerminalPointData)\n    }\n\n    if (secondView) {\n      const secondRef = Point.create(secondPoint || firstAnchor)\n      secondAnchor = this.getAnchor(\n        (secondTerminal as Edge.SetCellTerminalArgs).anchor,\n        secondView,\n        secondMagnet,\n        secondRef,\n        secondType,\n      )\n    } else {\n      secondAnchor = Point.isPointLike(secondTerminal)\n        ? Point.create(secondTerminal)\n        : new Point()\n    }\n\n    return {\n      [firstType]: firstAnchor,\n      [secondType]: secondAnchor,\n    }\n  }\n\n  protected getAnchor(\n    def: NodeAnchor.ManaualItem | string | undefined,\n    cellView: CellView,\n    magnet: Element | null,\n    ref: Point | Element | null,\n    terminalType: Edge.TerminalType,\n  ): Point {\n    const isEdge = cellView.isEdgeElement(magnet)\n    const connecting = this.graph.options.connecting\n    let config = typeof def === 'string' ? { name: def } : def\n    if (!config) {\n      const defaults = isEdge\n        ? (terminalType === 'source'\n            ? connecting.sourceEdgeAnchor\n            : connecting.targetEdgeAnchor) || connecting.edgeAnchor\n        : (terminalType === 'source'\n            ? connecting.sourceAnchor\n            : connecting.targetAnchor) || connecting.anchor\n\n      config = typeof defaults === 'string' ? { name: defaults } : defaults\n    }\n\n    if (!config) {\n      throw new Error(`Anchor should be specified.`)\n    }\n\n    let anchor\n\n    const name = config.name\n    if (isEdge) {\n      const fn = EdgeAnchor.registry.get(name)\n      if (typeof fn !== 'function') {\n        return EdgeAnchor.registry.onNotFound(name)\n      }\n      anchor = FunctionExt.call(\n        fn,\n        this,\n        cellView as EdgeView,\n        magnet as SVGElement,\n        ref as Point.PointLike,\n        config.args || {},\n        terminalType,\n      )\n    } else {\n      const fn = NodeAnchor.registry.get(name)\n      if (typeof fn !== 'function') {\n        return NodeAnchor.registry.onNotFound(name)\n      }\n\n      anchor = FunctionExt.call(\n        fn,\n        this,\n        cellView as NodeView,\n        magnet as SVGElement,\n        ref as Point.PointLike,\n        config.args || {},\n        terminalType,\n      )\n    }\n\n    return anchor ? anchor.round(this.POINT_ROUNDING) : new Point()\n  }\n\n  protected findRoutePoints(vertices: Point.PointLike[] = []): Point[] {\n    const defaultRouter =\n      this.graph.options.connecting.router || Router.presets.normal\n    const router = this.cell.getRouter() || defaultRouter\n    let routePoints\n\n    if (typeof router === 'function') {\n      routePoints = FunctionExt.call(\n        router as Router.Definition<any>,\n        this,\n        vertices,\n        {},\n        this,\n      )\n    } else {\n      const name = typeof router === 'string' ? router : router.name\n      const args = typeof router === 'string' ? {} : router.args || {}\n      const fn = name ? Router.registry.get(name) : Router.presets.normal\n      if (typeof fn !== 'function') {\n        return Router.registry.onNotFound(name!)\n      }\n\n      routePoints = FunctionExt.call(fn, this, vertices, args, this)\n    }\n\n    return routePoints == null\n      ? vertices.map((p) => Point.create(p))\n      : routePoints.map((p) => Point.create(p))\n  }\n\n  protected findConnectionPoints(\n    routePoints: Point[],\n    sourceAnchor: Point,\n    targetAnchor: Point,\n  ) {\n    const edge = this.cell\n    const connecting = this.graph.options.connecting\n    const sourceTerminal = edge.getSource()\n    const targetTerminal = edge.getTarget()\n    const sourceView = this.sourceView\n    const targetView = this.targetView\n    const firstRoutePoint = routePoints[0]\n    const lastRoutePoint = routePoints[routePoints.length - 1]\n\n    // source\n    let sourcePoint\n    if (sourceView && !sourceView.isEdgeElement(this.sourceMagnet)) {\n      const sourceMagnet = this.sourceMagnet || sourceView.container\n      const sourcePointRef = firstRoutePoint || targetAnchor\n      const sourceLine = new Line(sourcePointRef, sourceAnchor)\n      const connectionPointDef =\n        sourceTerminal.connectionPoint ||\n        connecting.sourceConnectionPoint ||\n        connecting.connectionPoint\n      sourcePoint = this.getConnectionPoint(\n        connectionPointDef,\n        sourceView,\n        sourceMagnet,\n        sourceLine,\n        'source',\n      )\n    } else {\n      sourcePoint = sourceAnchor\n    }\n\n    // target\n    let targetPoint\n    if (targetView && !targetView.isEdgeElement(this.targetMagnet)) {\n      const targetMagnet = this.targetMagnet || targetView.container\n      const targetConnectionPointDef =\n        targetTerminal.connectionPoint ||\n        connecting.targetConnectionPoint ||\n        connecting.connectionPoint\n      const targetPointRef = lastRoutePoint || sourceAnchor\n      const targetLine = new Line(targetPointRef, targetAnchor)\n      targetPoint = this.getConnectionPoint(\n        targetConnectionPointDef,\n        targetView,\n        targetMagnet,\n        targetLine,\n        'target',\n      )\n    } else {\n      targetPoint = targetAnchor\n    }\n\n    return {\n      source: sourcePoint,\n      target: targetPoint,\n    }\n  }\n\n  protected getConnectionPoint(\n    def: string | ConnectionPoint.ManaualItem | undefined,\n    view: CellView,\n    magnet: Element,\n    line: Line,\n    endType: Edge.TerminalType,\n  ) {\n    const anchor = line.end\n    if (def == null) {\n      return anchor\n    }\n\n    const name = typeof def === 'string' ? def : def.name\n    const args = typeof def === 'string' ? {} : def.args\n    const fn = ConnectionPoint.registry.get(name)\n    if (typeof fn !== 'function') {\n      return ConnectionPoint.registry.onNotFound(name)\n    }\n\n    const connectionPoint = FunctionExt.call(\n      fn,\n      this,\n      line,\n      view,\n      magnet as SVGElement,\n      args || {},\n      endType,\n    )\n\n    return connectionPoint ? connectionPoint.round(this.POINT_ROUNDING) : anchor\n  }\n\n  protected findMarkerPoints(\n    routePoints: Point[],\n    sourcePoint: Point,\n    targetPoint: Point,\n  ) {\n    const getLineWidth = (type: Edge.TerminalType) => {\n      const attrs = this.cell.getAttrs()\n      const keys = Object.keys(attrs)\n      for (let i = 0, l = keys.length; i < l; i += 1) {\n        const attr = attrs[keys[i]]\n        if (attr[`${type}Marker`] || attr[`${type}-marker`]) {\n          const strokeWidth =\n            (attr.strokeWidth as string) || (attr['stroke-width'] as string)\n          if (strokeWidth) {\n            return parseFloat(strokeWidth)\n          }\n          break\n        }\n      }\n      return null\n    }\n\n    const firstRoutePoint = routePoints[0]\n    const lastRoutePoint = routePoints[routePoints.length - 1]\n    let sourceMarkerPoint\n    let targetMarkerPoint\n\n    const sourceStrokeWidth = getLineWidth('source')\n    if (sourceStrokeWidth) {\n      sourceMarkerPoint = sourcePoint\n        .clone()\n        .move(firstRoutePoint || targetPoint, -sourceStrokeWidth)\n    }\n\n    const targetStrokeWidth = getLineWidth('target')\n    if (targetStrokeWidth) {\n      targetMarkerPoint = targetPoint\n        .clone()\n        .move(lastRoutePoint || sourcePoint, -targetStrokeWidth)\n    }\n\n    this.sourceMarkerPoint = sourceMarkerPoint || sourcePoint.clone()\n    this.targetMarkerPoint = targetMarkerPoint || targetPoint.clone()\n\n    return {\n      source: sourceMarkerPoint,\n      target: targetMarkerPoint,\n    }\n  }\n\n  protected findPath(\n    routePoints: Point[],\n    sourcePoint: Point,\n    targetPoint: Point,\n  ): Path {\n    const def =\n      this.cell.getConnector() || this.graph.options.connecting.connector\n\n    let name: string | undefined\n    let args: Connector.BaseOptions | undefined\n    let fn: Connector.Definition\n\n    if (typeof def === 'string') {\n      name = def\n    } else {\n      name = def.name\n      args = def.args\n    }\n\n    if (name) {\n      const method = Connector.registry.get(name)\n      if (typeof method !== 'function') {\n        return Connector.registry.onNotFound(name)\n      }\n      fn = method\n    } else {\n      fn = Connector.presets.normal\n    }\n\n    const path = FunctionExt.call(\n      fn,\n      this,\n      sourcePoint,\n      targetPoint,\n      routePoints,\n      { ...args, raw: true },\n      this,\n    )\n\n    return typeof path === 'string' ? Path.parse(path) : path\n  }\n\n  protected translateConnectionPoints(tx: number, ty: number) {\n    this.sourcePoint.translate(tx, ty)\n    this.targetPoint.translate(tx, ty)\n    this.sourceAnchor.translate(tx, ty)\n    this.targetAnchor.translate(tx, ty)\n    this.sourceMarkerPoint.translate(tx, ty)\n    this.targetMarkerPoint.translate(tx, ty)\n  }\n\n  updateLabelPositions() {\n    if (this.labelContainer == null) {\n      return this\n    }\n\n    const path = this.path\n    if (!path) {\n      return this\n    }\n\n    const edge = this.cell\n    const labels = edge.getLabels()\n    if (labels.length === 0) {\n      return this\n    }\n\n    const defaultLabel = edge.getDefaultLabel()\n    const defaultPosition = this.normalizeLabelPosition(\n      defaultLabel.position as Edge.LabelPosition,\n    )\n\n    for (let i = 0, ii = labels.length; i < ii; i += 1) {\n      const label = labels[i]\n      const labelNode = this.labelCache[i]\n\n      if (!labelNode) {\n        continue\n      }\n\n      const labelPosition = this.normalizeLabelPosition(\n        label.position as Edge.LabelPosition,\n      )\n      const pos = ObjectExt.merge({}, defaultPosition, labelPosition)\n      const matrix = this.getLabelTransformationMatrix(pos)\n      labelNode.setAttribute('transform', Dom.matrixToTransformString(matrix))\n    }\n\n    return this\n  }\n\n  updateTerminalProperties(type: Edge.TerminalType) {\n    const edge = this.cell\n    const graph = this.graph\n    const terminal = edge[type]\n    const nodeId = terminal && (terminal as Edge.TerminalCellData).cell\n    const viewKey = `${type}View` as 'sourceView' | 'targetView'\n\n    // terminal is a point\n    if (!nodeId) {\n      this[viewKey] = null\n      this.updateTerminalMagnet(type)\n      return true\n    }\n\n    const terminalCell = graph.getCellById(nodeId)\n    if (!terminalCell) {\n      throw new Error(`Edge's ${type} node with id \"${nodeId}\" not exists`)\n    }\n\n    const endView = terminalCell.findView(graph)\n    if (!endView) {\n      return false\n    }\n\n    this[viewKey] = endView\n    this.updateTerminalMagnet(type)\n    return true\n  }\n\n  updateTerminalMagnet(type: Edge.TerminalType) {\n    const propName = `${type}Magnet` as 'sourceMagnet' | 'targetMagnet'\n    const terminalView = this.getTerminalView(type)\n    if (terminalView) {\n      let magnet = terminalView.getMagnetFromEdgeTerminal(this.cell[type])\n      if (magnet === terminalView.container) {\n        magnet = null\n      }\n\n      this[propName] = magnet\n    } else {\n      this[propName] = null\n    }\n  }\n\n  protected getLabelPositionAngle(idx: number) {\n    const label = this.cell.getLabelAt(idx)\n    if (label && label.position && typeof label.position === 'object') {\n      return label.position.angle || 0\n    }\n    return 0\n  }\n\n  protected getLabelPositionArgs(idx: number) {\n    const label = this.cell.getLabelAt(idx)\n    if (label && label.position && typeof label.position === 'object') {\n      return label.position.options\n    }\n  }\n\n  protected getDefaultLabelPositionArgs() {\n    const defaultLabel = this.cell.getDefaultLabel()\n    if (\n      defaultLabel &&\n      defaultLabel.position &&\n      typeof defaultLabel.position === 'object'\n    ) {\n      return defaultLabel.position.options\n    }\n  }\n\n  protected mergeLabelPositionArgs(\n    labelPositionArgs?: Edge.LabelPositionOptions,\n    defaultLabelPositionArgs?: Edge.LabelPositionOptions,\n  ) {\n    if (labelPositionArgs === null) {\n      return null\n    }\n    if (labelPositionArgs === undefined) {\n      if (defaultLabelPositionArgs === null) {\n        return null\n      }\n      return defaultLabelPositionArgs\n    }\n\n    return ObjectExt.merge({}, defaultLabelPositionArgs, labelPositionArgs)\n  }\n\n  // #endregion\n\n  getConnection() {\n    return this.path != null ? this.path.clone() : null\n  }\n\n  getConnectionPathData() {\n    if (this.path == null) {\n      return ''\n    }\n\n    const cache = this.cache.pathCache\n    if (!ObjectExt.has(cache, 'data')) {\n      cache.data = this.path.serialize()\n    }\n    return cache.data || ''\n  }\n\n  getConnectionSubdivisions() {\n    if (this.path == null) {\n      return null\n    }\n\n    const cache = this.cache.pathCache\n    if (!ObjectExt.has(cache, 'segmentSubdivisions')) {\n      cache.segmentSubdivisions = this.path.getSegmentSubdivisions()\n    }\n    return cache.segmentSubdivisions\n  }\n\n  getConnectionLength() {\n    if (this.path == null) {\n      return 0\n    }\n\n    const cache = this.cache.pathCache\n    if (!ObjectExt.has(cache, 'length')) {\n      cache.length = this.path.length({\n        segmentSubdivisions: this.getConnectionSubdivisions(),\n      })\n    }\n    return cache.length\n  }\n\n  getPointAtLength(length: number) {\n    if (this.path == null) {\n      return null\n    }\n\n    return this.path.pointAtLength(length, {\n      segmentSubdivisions: this.getConnectionSubdivisions(),\n    })\n  }\n\n  getPointAtRatio(ratio: number) {\n    if (this.path == null) {\n      return null\n    }\n\n    if (NumberExt.isPercentage(ratio)) {\n      // eslint-disable-next-line\n      ratio = parseFloat(ratio) / 100\n    }\n\n    return this.path.pointAt(ratio, {\n      segmentSubdivisions: this.getConnectionSubdivisions(),\n    })\n  }\n\n  getTangentAtLength(length: number) {\n    if (this.path == null) {\n      return null\n    }\n\n    return this.path.tangentAtLength(length, {\n      segmentSubdivisions: this.getConnectionSubdivisions(),\n    })\n  }\n\n  getTangentAtRatio(ratio: number) {\n    if (this.path == null) {\n      return null\n    }\n\n    return this.path.tangentAt(ratio, {\n      segmentSubdivisions: this.getConnectionSubdivisions(),\n    })\n  }\n\n  getClosestPoint(point: Point.PointLike) {\n    if (this.path == null) {\n      return null\n    }\n\n    return this.path.closestPoint(point, {\n      segmentSubdivisions: this.getConnectionSubdivisions(),\n    })\n  }\n\n  getClosestPointLength(point: Point.PointLike) {\n    if (this.path == null) {\n      return null\n    }\n\n    return this.path.closestPointLength(point, {\n      segmentSubdivisions: this.getConnectionSubdivisions(),\n    })\n  }\n\n  getClosestPointRatio(point: Point.PointLike) {\n    if (this.path == null) {\n      return null\n    }\n\n    return this.path.closestPointNormalizedLength(point, {\n      segmentSubdivisions: this.getConnectionSubdivisions(),\n    })\n  }\n\n  getLabelPosition(\n    x: number,\n    y: number,\n    options?: Edge.LabelPositionOptions | null,\n  ): Edge.LabelPositionObject\n  getLabelPosition(\n    x: number,\n    y: number,\n    angle: number,\n    options?: Edge.LabelPositionOptions | null,\n  ): Edge.LabelPositionObject\n  getLabelPosition(\n    x: number,\n    y: number,\n    p3?: number | Edge.LabelPositionOptions | null,\n    p4?: Edge.LabelPositionOptions | null,\n  ): Edge.LabelPositionObject {\n    const pos: Edge.LabelPositionObject = { distance: 0 }\n\n    // normalize data from the two possible signatures\n    let angle = 0\n    let options\n    if (typeof p3 === 'number') {\n      angle = p3\n      options = p4\n    } else {\n      options = p3\n    }\n\n    if (options != null) {\n      pos.options = options\n    }\n\n    // identify distance/offset settings\n    const isOffsetAbsolute = options && options.absoluteOffset\n    const isDistanceRelative = !(options && options.absoluteDistance)\n    const isDistanceAbsoluteReverse =\n      options && options.absoluteDistance && options.reverseDistance\n\n    // find closest point t\n    const path = this.path\n    const pathOptions = {\n      segmentSubdivisions: this.getConnectionSubdivisions(),\n    }\n\n    const labelPoint = new Point(x, y)\n    const t = path.closestPointT(labelPoint, pathOptions)!\n\n    // distance\n    const totalLength = this.getConnectionLength() || 0\n    let labelDistance = path.lengthAtT(t, pathOptions)\n    if (isDistanceRelative) {\n      labelDistance = totalLength > 0 ? labelDistance / totalLength : 0\n    }\n\n    if (isDistanceAbsoluteReverse) {\n      // fix for end point (-0 => 1)\n      labelDistance = -1 * (totalLength - labelDistance) || 1\n    }\n    pos.distance = labelDistance\n\n    // offset\n    // use absolute offset if:\n    // - options.absoluteOffset is true,\n    // - options.absoluteOffset is not true but there is no tangent\n    let tangent\n    if (!isOffsetAbsolute) tangent = path.tangentAtT(t)\n    let labelOffset\n    if (tangent) {\n      labelOffset = tangent.pointOffset(labelPoint)\n    } else {\n      const closestPoint = path.pointAtT(t)!\n      const labelOffsetDiff = labelPoint.diff(closestPoint)\n      labelOffset = { x: labelOffsetDiff.x, y: labelOffsetDiff.y }\n    }\n\n    pos.offset = labelOffset\n    pos.angle = angle\n\n    return pos\n  }\n\n  protected normalizeLabelPosition(): undefined\n  protected normalizeLabelPosition(\n    pos: Edge.LabelPosition,\n  ): Edge.LabelPositionObject\n  protected normalizeLabelPosition(\n    pos?: Edge.LabelPosition,\n  ): Edge.LabelPositionObject | undefined {\n    if (typeof pos === 'number') {\n      return { distance: pos }\n    }\n\n    return pos\n  }\n\n  protected getLabelTransformationMatrix(labelPosition: Edge.LabelPosition) {\n    const pos = this.normalizeLabelPosition(labelPosition)\n    const options = pos.options || {}\n    const labelAngle = pos.angle || 0\n    const labelDistance = pos.distance\n    const isDistanceRelative = labelDistance > 0 && labelDistance <= 1\n\n    let labelOffset = 0\n    const offsetCoord = { x: 0, y: 0 }\n    const offset = pos.offset\n    if (offset) {\n      if (typeof offset === 'number') {\n        labelOffset = offset\n      } else {\n        if (offset.x != null) {\n          offsetCoord.x = offset.x\n        }\n        if (offset.y != null) {\n          offsetCoord.y = offset.y\n        }\n      }\n    }\n\n    const isOffsetAbsolute =\n      offsetCoord.x !== 0 || offsetCoord.y !== 0 || labelOffset === 0\n\n    const isKeepGradient = options.keepGradient\n    const isEnsureLegibility = options.ensureLegibility\n\n    const path = this.path\n    const pathOpt = { segmentSubdivisions: this.getConnectionSubdivisions() }\n\n    const distance = isDistanceRelative\n      ? labelDistance * this.getConnectionLength()!\n      : labelDistance\n    const tangent = path.tangentAtLength(distance, pathOpt)\n\n    let translation\n    let angle = labelAngle\n    if (tangent) {\n      if (isOffsetAbsolute) {\n        translation = tangent.start\n        translation.translate(offsetCoord)\n      } else {\n        const normal = tangent.clone()\n        normal.rotate(-90, tangent.start)\n        normal.setLength(labelOffset)\n        translation = normal.end\n      }\n      if (isKeepGradient) {\n        angle = tangent.angle() + labelAngle\n        if (isEnsureLegibility) {\n          angle = Angle.normalize(((angle + 90) % 180) - 90)\n        }\n      }\n    } else {\n      // fallback - the connection has zero length\n      translation = path.start!\n      if (isOffsetAbsolute) {\n        translation.translate(offsetCoord)\n      }\n    }\n\n    return Dom.createSVGMatrix()\n      .translate(translation.x, translation.y)\n      .rotate(angle)\n  }\n\n  getVertexIndex(x: number, y: number) {\n    const edge = this.cell\n    const vertices = edge.getVertices()\n    const vertexLength = this.getClosestPointLength(new Point(x, y))\n\n    let index = 0\n\n    if (vertexLength != null) {\n      for (const ii = vertices.length; index < ii; index += 1) {\n        const currentVertex = vertices[index]\n        const currentLength = this.getClosestPointLength(currentVertex)\n        if (currentLength != null && vertexLength < currentLength) {\n          break\n        }\n      }\n    }\n\n    return index\n  }\n\n  // #region events\n\n  protected getEventArgs<E>(e: E): EdgeView.MouseEventArgs<E>\n  protected getEventArgs<E>(\n    e: E,\n    x: number,\n    y: number,\n  ): EdgeView.PositionEventArgs<E>\n  protected getEventArgs<E>(e: E, x?: number, y?: number) {\n    const view = this // eslint-disable-line\n    const edge = view.cell\n    const cell = edge\n    if (x == null || y == null) {\n      return { e, view, edge, cell } as EdgeView.MouseEventArgs<E>\n    }\n    return { e, x, y, view, edge, cell } as EdgeView.PositionEventArgs<E>\n  }\n\n  protected notifyUnhandledMouseDown(\n    e: Dom.MouseDownEvent,\n    x: number,\n    y: number,\n  ) {\n    this.notify('edge:unhandled:mousedown', {\n      e,\n      x,\n      y,\n      view: this,\n      cell: this.cell,\n      edge: this.cell,\n    })\n  }\n\n  notifyMouseDown(e: Dom.MouseDownEvent, x: number, y: number) {\n    super.onMouseDown(e, x, y)\n    this.notify('edge:mousedown', this.getEventArgs(e, x, y))\n  }\n\n  notifyMouseMove(e: Dom.MouseMoveEvent, x: number, y: number) {\n    super.onMouseMove(e, x, y)\n    this.notify('edge:mousemove', this.getEventArgs(e, x, y))\n  }\n\n  notifyMouseUp(e: Dom.MouseUpEvent, x: number, y: number) {\n    super.onMouseUp(e, x, y)\n    this.notify('edge:mouseup', this.getEventArgs(e, x, y))\n  }\n\n  onClick(e: Dom.ClickEvent, x: number, y: number) {\n    super.onClick(e, x, y)\n    this.notify('edge:click', this.getEventArgs(e, x, y))\n  }\n\n  onDblClick(e: Dom.DoubleClickEvent, x: number, y: number) {\n    super.onDblClick(e, x, y)\n    this.notify('edge:dblclick', this.getEventArgs(e, x, y))\n  }\n\n  onContextMenu(e: Dom.ContextMenuEvent, x: number, y: number) {\n    super.onContextMenu(e, x, y)\n    this.notify('edge:contextmenu', this.getEventArgs(e, x, y))\n  }\n\n  onMouseDown(e: Dom.MouseDownEvent, x: number, y: number) {\n    this.notifyMouseDown(e, x, y)\n    this.startEdgeDragging(e, x, y)\n  }\n\n  onMouseMove(e: Dom.MouseMoveEvent, x: number, y: number) {\n    const data = this.getEventData(e)\n    switch (data.action) {\n      case 'drag-label': {\n        this.dragLabel(e, x, y)\n        break\n      }\n\n      case 'drag-arrowhead': {\n        this.dragArrowhead(e, x, y)\n        break\n      }\n\n      case 'drag-edge': {\n        this.dragEdge(e, x, y)\n        break\n      }\n\n      default:\n        break\n    }\n\n    this.notifyMouseMove(e, x, y)\n    return data\n  }\n\n  onMouseUp(e: Dom.MouseUpEvent, x: number, y: number) {\n    const data = this.getEventData(e)\n    switch (data.action) {\n      case 'drag-label': {\n        this.stopLabelDragging(e, x, y)\n        break\n      }\n\n      case 'drag-arrowhead': {\n        this.stopArrowheadDragging(e, x, y)\n        break\n      }\n\n      case 'drag-edge': {\n        this.stopEdgeDragging(e, x, y)\n        break\n      }\n\n      default:\n        break\n    }\n\n    this.notifyMouseUp(e, x, y)\n    this.checkMouseleave(e)\n    return data\n  }\n\n  onMouseOver(e: Dom.MouseOverEvent) {\n    super.onMouseOver(e)\n    this.notify('edge:mouseover', this.getEventArgs(e))\n  }\n\n  onMouseOut(e: Dom.MouseOutEvent) {\n    super.onMouseOut(e)\n    this.notify('edge:mouseout', this.getEventArgs(e))\n  }\n\n  onMouseEnter(e: Dom.MouseEnterEvent) {\n    super.onMouseEnter(e)\n    this.notify('edge:mouseenter', this.getEventArgs(e))\n  }\n\n  onMouseLeave(e: Dom.MouseLeaveEvent) {\n    super.onMouseLeave(e)\n    this.notify('edge:mouseleave', this.getEventArgs(e))\n  }\n\n  onMouseWheel(e: Dom.EventObject, x: number, y: number, delta: number) {\n    super.onMouseWheel(e, x, y, delta)\n    this.notify('edge:mousewheel', {\n      delta,\n      ...this.getEventArgs(e, x, y),\n    })\n  }\n\n  onCustomEvent(e: Dom.MouseDownEvent, name: string, x: number, y: number) {\n    // For default edge tool\n    const tool = Dom.findParentByClass(e.target, 'edge-tool', this.container)\n    if (tool) {\n      e.stopPropagation() // no further action to be executed\n      if (this.can('useEdgeTools')) {\n        if (name === 'edge:remove') {\n          this.cell.remove({ ui: true })\n          return\n        }\n        this.notify('edge:customevent', { name, ...this.getEventArgs(e, x, y) })\n      }\n\n      this.notifyMouseDown(e as Dom.MouseDownEvent, x, y)\n    } else {\n      this.notify('edge:customevent', { name, ...this.getEventArgs(e, x, y) })\n      super.onCustomEvent(e, name, x, y)\n    }\n  }\n\n  onLabelMouseDown(e: Dom.MouseDownEvent, x: number, y: number) {\n    this.notifyMouseDown(e, x, y)\n    this.startLabelDragging(e, x, y)\n\n    const stopPropagation = this.getEventData(e).stopPropagation\n    if (stopPropagation) {\n      e.stopPropagation()\n    }\n  }\n\n  // #region drag edge\n\n  protected startEdgeDragging(e: Dom.MouseDownEvent, x: number, y: number) {\n    if (!this.can('edgeMovable')) {\n      this.notifyUnhandledMouseDown(e, x, y)\n      return\n    }\n\n    this.setEventData<EventData.EdgeDragging>(e, {\n      x,\n      y,\n      moving: false,\n      action: 'drag-edge',\n    })\n  }\n\n  protected dragEdge(e: Dom.MouseMoveEvent, x: number, y: number) {\n    const data = this.getEventData<EventData.EdgeDragging>(e)\n    if (!data.moving) {\n      data.moving = true\n      this.addClass('edge-moving')\n      this.notify('edge:move', {\n        e,\n        x,\n        y,\n        view: this,\n        cell: this.cell,\n        edge: this.cell,\n      })\n    }\n\n    this.cell.translate(x - data.x, y - data.y, { ui: true })\n    this.setEventData<Partial<EventData.EdgeDragging>>(e, { x, y })\n    this.notify('edge:moving', {\n      e,\n      x,\n      y,\n      view: this,\n      cell: this.cell,\n      edge: this.cell,\n    })\n  }\n\n  protected stopEdgeDragging(e: Dom.MouseUpEvent, x: number, y: number) {\n    const data = this.getEventData<EventData.EdgeDragging>(e)\n    if (data.moving) {\n      this.removeClass('edge-moving')\n      this.notify('edge:moved', {\n        e,\n        x,\n        y,\n        view: this,\n        cell: this.cell,\n        edge: this.cell,\n      })\n    }\n    data.moving = false\n  }\n\n  // #endregion\n\n  // #region drag arrowhead\n\n  prepareArrowheadDragging(\n    type: Edge.TerminalType,\n    options: {\n      x: number\n      y: number\n      options?: KeyValue\n      isNewEdge?: boolean\n      fallbackAction?: EventData.ArrowheadDragging['fallbackAction']\n    },\n  ) {\n    const magnet = this.getTerminalMagnet(type)\n    const data: EventData.ArrowheadDragging = {\n      action: 'drag-arrowhead',\n      x: options.x,\n      y: options.y,\n      isNewEdge: options.isNewEdge === true,\n      terminalType: type,\n      initialMagnet: magnet,\n      initialTerminal: ObjectExt.clone(this.cell[type]) as Edge.TerminalData,\n      fallbackAction: options.fallbackAction || 'revert',\n      getValidateConnectionArgs: this.createValidateConnectionArgs(type),\n      options: options.options,\n    }\n\n    this.beforeArrowheadDragging(data)\n\n    return data\n  }\n\n  protected createValidateConnectionArgs(type: Edge.TerminalType) {\n    const args: EventData.ValidateConnectionArgs = [] as any\n\n    args[4] = type\n    args[5] = this\n\n    let opposite: Edge.TerminalType\n    let i = 0\n    let j = 0\n\n    if (type === 'source') {\n      i = 2\n      opposite = 'target'\n    } else {\n      j = 2\n      opposite = 'source'\n    }\n\n    const terminal = this.cell[opposite]\n    const cellId = (terminal as Edge.TerminalCellData).cell\n    if (cellId) {\n      let magnet\n      const view = (args[i] = this.graph.findViewByCell(cellId))\n      if (view) {\n        magnet = view.getMagnetFromEdgeTerminal(terminal)\n        if (magnet === view.container) {\n          magnet = undefined\n        }\n      }\n      args[i + 1] = magnet\n    }\n\n    return (cellView: CellView, magnet: Element) => {\n      args[j] = cellView\n      args[j + 1] = cellView.container === magnet ? undefined : magnet\n      return args\n    }\n  }\n\n  protected beforeArrowheadDragging(data: EventData.ArrowheadDragging) {\n    data.zIndex = this.cell.zIndex\n    this.cell.toFront()\n\n    const style = (this.container as HTMLElement).style\n    data.pointerEvents = style.pointerEvents\n    style.pointerEvents = 'none'\n\n    if (this.graph.options.connecting.highlight) {\n      this.highlightAvailableMagnets(data)\n    }\n  }\n\n  protected afterArrowheadDragging(data: EventData.ArrowheadDragging) {\n    if (data.zIndex != null) {\n      this.cell.setZIndex(data.zIndex, { ui: true })\n      data.zIndex = null\n    }\n\n    const container = this.container as HTMLElement\n    container.style.pointerEvents = data.pointerEvents || ''\n\n    if (this.graph.options.connecting.highlight) {\n      this.unhighlightAvailableMagnets(data)\n    }\n  }\n\n  protected validateConnection(\n    sourceView: CellView | null | undefined,\n    sourceMagnet: Element | null | undefined,\n    targetView: CellView | null | undefined,\n    targetMagnet: Element | null | undefined,\n    terminalType: Edge.TerminalType,\n    edgeView?: EdgeView | null | undefined,\n    candidateTerminal?: Edge.TerminalCellData | null | undefined,\n  ) {\n    const options = this.graph.options.connecting\n    const allowLoop = options.allowLoop\n    const allowNode = options.allowNode\n    const allowEdge = options.allowEdge\n    const allowPort = options.allowPort\n    const allowMulti = options.allowMulti\n    const validate = options.validateConnection\n\n    const edge = edgeView ? edgeView.cell : null\n    const terminalView = terminalType === 'target' ? targetView : sourceView\n    const terminalMagnet =\n      terminalType === 'target' ? targetMagnet : sourceMagnet\n\n    let valid = true\n    const doValidate = (\n      validate: (\n        this: Graph,\n        args: GraphOptions.ValidateConnectionArgs,\n      ) => boolean,\n    ) => {\n      const sourcePort =\n        terminalType === 'source'\n          ? candidateTerminal\n            ? candidateTerminal.port\n            : null\n          : edge\n          ? edge.getSourcePortId()\n          : null\n      const targetPort =\n        terminalType === 'target'\n          ? candidateTerminal\n            ? candidateTerminal.port\n            : null\n          : edge\n          ? edge.getTargetPortId()\n          : null\n      return FunctionExt.call(validate, this.graph, {\n        edge,\n        edgeView,\n        sourceView,\n        targetView,\n        sourcePort,\n        targetPort,\n        sourceMagnet,\n        targetMagnet,\n        sourceCell: sourceView ? sourceView.cell : null,\n        targetCell: targetView ? targetView.cell : null,\n        type: terminalType,\n      })\n    }\n\n    if (allowLoop != null) {\n      if (typeof allowLoop === 'boolean') {\n        if (!allowLoop && sourceView === targetView) {\n          valid = false\n        }\n      } else {\n        valid = doValidate(allowLoop)\n      }\n    }\n\n    if (valid && allowPort != null) {\n      if (typeof allowPort === 'boolean') {\n        if (!allowPort && terminalMagnet) {\n          valid = false\n        }\n      } else {\n        valid = doValidate(allowPort)\n      }\n    }\n\n    if (valid && allowEdge != null) {\n      if (typeof allowEdge === 'boolean') {\n        if (!allowEdge && EdgeView.isEdgeView(terminalView)) {\n          valid = false\n        }\n      } else {\n        valid = doValidate(allowEdge)\n      }\n    }\n\n    // When judging nodes, the influence of the ports should be excluded,\n    // because the ports and nodes have the same terminalView\n    if (valid && allowNode != null && terminalMagnet == null) {\n      if (typeof allowNode === 'boolean') {\n        if (!allowNode && NodeView.isNodeView(terminalView)) {\n          valid = false\n        }\n      } else {\n        valid = doValidate(allowNode)\n      }\n    }\n\n    if (valid && allowMulti != null && edgeView) {\n      const edge = edgeView.cell\n      const source =\n        terminalType === 'source'\n          ? candidateTerminal\n          : (edge.getSource() as Edge.TerminalCellData)\n      const target =\n        terminalType === 'target'\n          ? candidateTerminal\n          : (edge.getTarget() as Edge.TerminalCellData)\n      const terminalCell = candidateTerminal\n        ? this.graph.getCellById(candidateTerminal.cell)\n        : null\n\n      if (source && target && source.cell && target.cell && terminalCell) {\n        if (typeof allowMulti === 'function') {\n          valid = doValidate(allowMulti)\n        } else {\n          const connectedEdges = this.graph.model.getConnectedEdges(\n            terminalCell,\n            {\n              outgoing: terminalType === 'source',\n              incoming: terminalType === 'target',\n            },\n          )\n          if (connectedEdges.length) {\n            if (allowMulti === 'withPort') {\n              const exist = connectedEdges.some((link) => {\n                const s = link.getSource() as Edge.TerminalCellData\n                const t = link.getTarget() as Edge.TerminalCellData\n                return (\n                  s &&\n                  t &&\n                  s.cell === source.cell &&\n                  t.cell === target.cell &&\n                  s.port != null &&\n                  s.port === source.port &&\n                  t.port != null &&\n                  t.port === target.port\n                )\n              })\n              if (exist) {\n                valid = false\n              }\n            } else if (!allowMulti) {\n              const exist = connectedEdges.some((link) => {\n                const s = link.getSource() as Edge.TerminalCellData\n                const t = link.getTarget() as Edge.TerminalCellData\n                return (\n                  s && t && s.cell === source.cell && t.cell === target.cell\n                )\n              })\n              if (exist) {\n                valid = false\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (valid && validate != null) {\n      valid = doValidate(validate)\n    }\n\n    return valid\n  }\n\n  protected allowConnectToBlank(edge: Edge) {\n    const graph = this.graph\n    const options = graph.options.connecting\n    const allowBlank = options.allowBlank\n\n    if (typeof allowBlank !== 'function') {\n      return !!allowBlank\n    }\n\n    const edgeView = graph.findViewByCell(edge) as EdgeView\n    const sourceCell = edge.getSourceCell()\n    const targetCell = edge.getTargetCell()\n    const sourceView = graph.findViewByCell(sourceCell)\n    const targetView = graph.findViewByCell(targetCell)\n    return FunctionExt.call(allowBlank, graph, {\n      edge,\n      edgeView,\n      sourceCell,\n      targetCell,\n      sourceView,\n      targetView,\n      sourcePort: edge.getSourcePortId(),\n      targetPort: edge.getTargetPortId(),\n      sourceMagnet: edgeView.sourceMagnet,\n      targetMagnet: edgeView.targetMagnet,\n    })\n  }\n\n  protected validateEdge(\n    edge: Edge,\n    type: Edge.TerminalType,\n    initialTerminal: Edge.TerminalData,\n  ) {\n    const graph = this.graph\n    if (!this.allowConnectToBlank(edge)) {\n      const sourceId = edge.getSourceCellId()\n      const targetId = edge.getTargetCellId()\n      if (!(sourceId && targetId)) {\n        return false\n      }\n    }\n\n    const validate = graph.options.connecting.validateEdge\n    if (validate) {\n      return FunctionExt.call(validate, graph, {\n        edge,\n        type,\n        previous: initialTerminal,\n      })\n    }\n\n    return true\n  }\n\n  protected arrowheadDragging(\n    target: Element,\n    x: number,\n    y: number,\n    data: EventData.ArrowheadDragging,\n  ) {\n    data.x = x\n    data.y = y\n\n    // Checking views right under the pointer\n    if (data.currentTarget !== target) {\n      // Unhighlight the previous view under pointer if there was one.\n      if (data.currentMagnet && data.currentView) {\n        data.currentView.unhighlight(data.currentMagnet, {\n          type: 'magnetAdsorbed',\n        })\n      }\n\n      data.currentView = this.graph.findViewByElem(target)\n      if (data.currentView) {\n        // If we found a view that is under the pointer, we need to find\n        // the closest magnet based on the real target element of the event.\n        data.currentMagnet = data.currentView.findMagnet(target)\n\n        if (\n          data.currentMagnet &&\n          this.validateConnection(\n            ...data.getValidateConnectionArgs(\n              data.currentView,\n              data.currentMagnet,\n            ),\n            data.currentView.getEdgeTerminal(\n              data.currentMagnet,\n              x,\n              y,\n              this.cell,\n              data.terminalType,\n            ),\n          )\n        ) {\n          data.currentView.highlight(data.currentMagnet, {\n            type: 'magnetAdsorbed',\n          })\n        } else {\n          // This type of connection is not valid. Disregard this magnet.\n          data.currentMagnet = null\n        }\n      } else {\n        // Make sure we'll unset previous magnet.\n        data.currentMagnet = null\n      }\n    }\n\n    data.currentTarget = target\n    this.cell.prop(data.terminalType, { x, y }, { ...data.options, ui: true })\n  }\n\n  protected arrowheadDragged(\n    data: EventData.ArrowheadDragging,\n    x: number,\n    y: number,\n  ) {\n    const view = data.currentView\n    const magnet = data.currentMagnet\n    if (!magnet || !view) {\n      return\n    }\n\n    view.unhighlight(magnet, { type: 'magnetAdsorbed' })\n\n    const type = data.terminalType\n    const terminal = view.getEdgeTerminal(magnet, x, y, this.cell, type)\n    this.cell.setTerminal(type, terminal, { ui: true })\n  }\n\n  protected snapArrowhead(\n    x: number,\n    y: number,\n    data: EventData.ArrowheadDragging,\n  ) {\n    const graph = this.graph\n    const { snap, allowEdge } = graph.options.connecting\n    const radius = (typeof snap === 'object' && snap.radius) || 50\n    const anchor = (typeof snap === 'object' && snap.anchor) || 'center'\n\n    const views = graph.renderer.findViewsInArea(\n      {\n        x: x - radius,\n        y: y - radius,\n        width: 2 * radius,\n        height: 2 * radius,\n      },\n      { nodeOnly: true },\n    )\n\n    if (allowEdge) {\n      const edgeViews = graph.renderer\n        .findEdgeViewsFromPoint({ x, y }, radius)\n        .filter((view) => {\n          return view !== this\n        })\n      views.push(...edgeViews)\n    }\n\n    const prevView = data.closestView || null\n    const prevMagnet = data.closestMagnet || null\n\n    data.closestView = null\n    data.closestMagnet = null\n\n    let distance: number\n    let minDistance = Number.MAX_SAFE_INTEGER\n    const pos = new Point(x, y)\n\n    views.forEach((view) => {\n      if (view.container.getAttribute('magnet') !== 'false') {\n        if (view.isNodeView()) {\n          distance =\n            anchor === 'center'\n              ? view.cell.getBBox().getCenter().distance(pos)\n              : view.cell.getBBox().getNearestPointToPoint(pos).distance(pos)\n        } else if (view.isEdgeView()) {\n          const point = view.getClosestPoint(pos)\n          if (point) {\n            distance = point.distance(pos)\n          } else {\n            distance = Number.MAX_SAFE_INTEGER\n          }\n        }\n\n        if (distance < radius && distance < minDistance) {\n          if (\n            prevMagnet === view.container ||\n            this.validateConnection(\n              ...data.getValidateConnectionArgs(view, null),\n              view.getEdgeTerminal(\n                view.container,\n                x,\n                y,\n                this.cell,\n                data.terminalType,\n              ),\n            )\n          ) {\n            minDistance = distance\n            data.closestView = view\n            data.closestMagnet = view.container\n          }\n        }\n      }\n\n      view.container.querySelectorAll('[magnet]').forEach((magnet) => {\n        if (magnet.getAttribute('magnet') !== 'false') {\n          const bbox = view.getBBoxOfElement(magnet)\n          distance = pos.distance(bbox.getCenter())\n          if (distance < radius && distance < minDistance) {\n            if (\n              prevMagnet === magnet ||\n              this.validateConnection(\n                ...data.getValidateConnectionArgs(view, magnet),\n                view.getEdgeTerminal(\n                  magnet,\n                  x,\n                  y,\n                  this.cell,\n                  data.terminalType,\n                ),\n              )\n            ) {\n              minDistance = distance\n              data.closestView = view\n              data.closestMagnet = magnet\n            }\n          }\n        }\n      })\n    })\n\n    let terminal\n    const type = data.terminalType\n    const closestView = data.closestView as any as CellView\n    const closestMagnet = data.closestMagnet as any as Element\n    const changed = prevMagnet !== closestMagnet\n\n    if (prevView && changed) {\n      prevView.unhighlight(prevMagnet, {\n        type: 'magnetAdsorbed',\n      })\n    }\n\n    if (closestView) {\n      if (!changed) {\n        return\n      }\n      closestView.highlight(closestMagnet, {\n        type: 'magnetAdsorbed',\n      })\n      terminal = closestView.getEdgeTerminal(\n        closestMagnet,\n        x,\n        y,\n        this.cell,\n        type,\n      )\n    } else {\n      terminal = { x, y }\n    }\n\n    this.cell.setTerminal(type, terminal, {}, { ...data.options, ui: true })\n  }\n\n  protected snapArrowheadEnd(data: EventData.ArrowheadDragging) {\n    // Finish off link snapping.\n    // Everything except view unhighlighting was already done on pointermove.\n    const closestView = data.closestView\n    const closestMagnet = data.closestMagnet\n    if (closestView && closestMagnet) {\n      closestView.unhighlight(closestMagnet, {\n        type: 'magnetAdsorbed',\n      })\n      data.currentMagnet = closestView.findMagnet(closestMagnet)\n    }\n\n    data.closestView = null\n    data.closestMagnet = null\n  }\n\n  protected finishEmbedding(data: EventData.ArrowheadDragging) {\n    // Resets parent of the edge if embedding is enabled\n    if (this.graph.options.embedding.enabled && this.cell.updateParent()) {\n      // Make sure we don't reverse to the original 'z' index\n      data.zIndex = null\n    }\n  }\n\n  protected fallbackConnection(data: EventData.ArrowheadDragging) {\n    switch (data.fallbackAction) {\n      case 'remove':\n        this.cell.remove({ ui: true })\n        break\n      case 'revert':\n      default:\n        this.cell.prop(data.terminalType, data.initialTerminal, {\n          ui: true,\n        })\n        break\n    }\n  }\n\n  protected notifyConnectionEvent(\n    data: EventData.ArrowheadDragging,\n    e: Dom.MouseUpEvent,\n  ) {\n    const terminalType = data.terminalType\n    const initialTerminal = data.initialTerminal\n    const currentTerminal = this.cell[terminalType]\n    const changed =\n      currentTerminal && !Edge.equalTerminals(initialTerminal, currentTerminal)\n\n    if (changed) {\n      const graph = this.graph\n      const previous = initialTerminal as Edge.TerminalCellData\n      const previousCell = previous.cell\n        ? graph.getCellById(previous.cell)\n        : null\n      const previousPort = previous.port\n      const previousView = previousCell\n        ? graph.findViewByCell(previousCell)\n        : null\n      const previousPoint =\n        previousCell || data.isNewEdge\n          ? null\n          : Point.create(initialTerminal as Edge.TerminalPointData).toJSON()\n\n      const current = currentTerminal as Edge.TerminalCellData\n      const currentCell = current.cell ? graph.getCellById(current.cell) : null\n      const currentPort = current.port\n      const currentView = currentCell ? graph.findViewByCell(currentCell) : null\n      const currentPoint = currentCell\n        ? null\n        : Point.create(currentTerminal as Edge.TerminalPointData).toJSON()\n\n      this.notify('edge:connected', {\n        e,\n        previousCell,\n        previousPort,\n        previousView,\n        previousPoint,\n        currentCell,\n        currentView,\n        currentPort,\n        currentPoint,\n        previousMagnet: data.initialMagnet,\n        currentMagnet: data.currentMagnet,\n        edge: this.cell,\n        view: this,\n        type: terminalType,\n        isNew: data.isNewEdge,\n      })\n    }\n  }\n\n  protected highlightAvailableMagnets(data: EventData.ArrowheadDragging) {\n    const graph = this.graph\n    const cells = graph.model.getCells()\n    data.marked = {}\n\n    for (let i = 0, ii = cells.length; i < ii; i += 1) {\n      const view = graph.findViewByCell(cells[i])\n\n      // Prevent highlighting new edge\n      // Close https://github.com/antvis/X6/issues/2853\n      if (!view || view.cell.id === this.cell.id) {\n        continue\n      }\n\n      const magnets: Element[] = Array.prototype.slice.call(\n        view.container.querySelectorAll('[magnet]'),\n      )\n\n      if (view.container.getAttribute('magnet') !== 'false') {\n        magnets.push(view.container)\n      }\n\n      const availableMagnets = magnets.filter((magnet) =>\n        this.validateConnection(\n          ...data.getValidateConnectionArgs(view, magnet),\n          view.getEdgeTerminal(\n            magnet,\n            data.x,\n            data.y,\n            this.cell,\n            data.terminalType,\n          ),\n        ),\n      )\n\n      if (availableMagnets.length > 0) {\n        // highlight all available magnets\n        for (let j = 0, jj = availableMagnets.length; j < jj; j += 1) {\n          view.highlight(availableMagnets[j], { type: 'magnetAvailable' })\n        }\n\n        // highlight the entire view\n        view.highlight(null, { type: 'nodeAvailable' })\n        data.marked[view.cell.id] = availableMagnets\n      }\n    }\n  }\n\n  protected unhighlightAvailableMagnets(data: EventData.ArrowheadDragging) {\n    const marked = data.marked || {}\n    Object.keys(marked).forEach((id) => {\n      const view = this.graph.findViewByCell(id)\n\n      if (view) {\n        const magnets = marked[id]\n        magnets.forEach((magnet) => {\n          view.unhighlight(magnet, { type: 'magnetAvailable' })\n        })\n\n        view.unhighlight(null, { type: 'nodeAvailable' })\n      }\n    })\n    data.marked = null\n  }\n\n  protected startArrowheadDragging(\n    e: Dom.MouseDownEvent,\n    x: number,\n    y: number,\n  ) {\n    if (!this.can('arrowheadMovable')) {\n      this.notifyUnhandledMouseDown(e, x, y)\n      return\n    }\n\n    const elem = e.target\n    const type = elem.getAttribute('data-terminal') as Edge.TerminalType\n    const data = this.prepareArrowheadDragging(type, { x, y })\n    this.setEventData<EventData.ArrowheadDragging>(e, data)\n  }\n\n  protected dragArrowhead(e: Dom.MouseMoveEvent, x: number, y: number) {\n    const data = this.getEventData<EventData.ArrowheadDragging>(e)\n    if (this.graph.options.connecting.snap) {\n      this.snapArrowhead(x, y, data)\n    } else {\n      this.arrowheadDragging(this.getEventTarget(e), x, y, data)\n    }\n  }\n\n  protected stopArrowheadDragging(e: Dom.MouseUpEvent, x: number, y: number) {\n    const graph = this.graph\n    const data = this.getEventData<EventData.ArrowheadDragging>(e)\n    if (graph.options.connecting.snap) {\n      this.snapArrowheadEnd(data)\n    } else {\n      this.arrowheadDragged(data, x, y)\n    }\n\n    const valid = this.validateEdge(\n      this.cell,\n      data.terminalType,\n      data.initialTerminal,\n    )\n\n    if (valid) {\n      this.finishEmbedding(data)\n      this.notifyConnectionEvent(data, e)\n    } else {\n      // If the changed edge is not allowed, revert to its previous state.\n      this.fallbackConnection(data)\n    }\n    this.afterArrowheadDragging(data)\n  }\n\n  // #endregion\n\n  // #region drag lable\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  startLabelDragging(e: Dom.MouseDownEvent, x: number, y: number) {\n    if (this.can('edgeLabelMovable')) {\n      const target = e.currentTarget\n      const index = parseInt(target.getAttribute('data-index'), 10)\n      const positionAngle = this.getLabelPositionAngle(index)\n      const labelPositionArgs = this.getLabelPositionArgs(index)\n      const defaultLabelPositionArgs = this.getDefaultLabelPositionArgs()\n      const positionArgs = this.mergeLabelPositionArgs(\n        labelPositionArgs,\n        defaultLabelPositionArgs,\n      )\n\n      this.setEventData<EventData.LabelDragging>(e, {\n        index,\n        positionAngle,\n        positionArgs,\n        stopPropagation: true,\n        action: 'drag-label',\n      })\n    } else {\n      // If labels can't be dragged no default action is triggered.\n      this.setEventData(e, { stopPropagation: true })\n    }\n\n    this.graph.view.delegateDragEvents(e, this)\n  }\n\n  dragLabel(e: Dom.MouseMoveEvent, x: number, y: number) {\n    const data = this.getEventData<EventData.LabelDragging>(e)\n    const originLabel = this.cell.getLabelAt(data.index)\n    const label = ObjectExt.merge({}, originLabel, {\n      position: this.getLabelPosition(\n        x,\n        y,\n        data.positionAngle,\n        data.positionArgs,\n      ),\n    })\n    this.cell.setLabelAt(data.index, label)\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  stopLabelDragging(e: Dom.MouseUpEvent, x: number, y: number) {}\n\n  // #endregion\n}\n\nexport namespace EdgeView {\n  export interface Options extends CellView.Options {}\n}\n\nexport namespace EdgeView {\n  export interface MouseEventArgs<E> {\n    e: E\n    edge: Edge\n    cell: Edge\n    view: EdgeView\n  }\n\n  export interface PositionEventArgs<E>\n    extends MouseEventArgs<E>,\n      CellView.PositionEventArgs {}\n\n  export interface EventArgs {\n    'edge:click': PositionEventArgs<Dom.ClickEvent>\n    'edge:dblclick': PositionEventArgs<Dom.DoubleClickEvent>\n    'edge:contextmenu': PositionEventArgs<Dom.ContextMenuEvent>\n    'edge:mousedown': PositionEventArgs<Dom.MouseDownEvent>\n    'edge:mousemove': PositionEventArgs<Dom.MouseMoveEvent>\n    'edge:mouseup': PositionEventArgs<Dom.MouseUpEvent>\n    'edge:mouseover': MouseEventArgs<Dom.MouseOverEvent>\n    'edge:mouseout': MouseEventArgs<Dom.MouseOutEvent>\n    'edge:mouseenter': MouseEventArgs<Dom.MouseEnterEvent>\n    'edge:mouseleave': MouseEventArgs<Dom.MouseLeaveEvent>\n    'edge:mousewheel': PositionEventArgs<Dom.EventObject> &\n      CellView.MouseDeltaEventArgs\n\n    'edge:customevent': EdgeView.PositionEventArgs<Dom.MouseDownEvent> & {\n      name: string\n    }\n\n    'edge:unhandled:mousedown': PositionEventArgs<Dom.MouseDownEvent>\n\n    'edge:connected': {\n      e: Dom.MouseUpEvent\n      edge: Edge\n      view: EdgeView\n      isNew: boolean\n      type: Edge.TerminalType\n      previousCell?: Cell | null\n      previousView?: CellView | null\n      previousPort?: string | null\n      previousPoint?: Point.PointLike | null\n      previousMagnet?: Element | null\n      currentCell?: Cell | null\n      currentView?: CellView | null\n      currentPort?: string | null\n      currentPoint?: Point.PointLike | null\n      currentMagnet?: Element | null\n    }\n\n    'edge:highlight': {\n      magnet: Element\n      view: EdgeView\n      edge: Edge\n      cell: Edge\n      options: CellView.HighlightOptions\n    }\n    'edge:unhighlight': EventArgs['edge:highlight']\n\n    'edge:move': PositionEventArgs<Dom.MouseMoveEvent>\n    'edge:moving': PositionEventArgs<Dom.MouseMoveEvent>\n    'edge:moved': PositionEventArgs<Dom.MouseUpEvent>\n  }\n}\n\nexport namespace EdgeView {\n  export const toStringTag = `X6.${EdgeView.name}`\n\n  export function isEdgeView(instance: any): instance is EdgeView {\n    if (instance == null) {\n      return false\n    }\n\n    if (instance instanceof EdgeView) {\n      return true\n    }\n\n    const tag = instance[Symbol.toStringTag]\n    const view = instance as EdgeView\n\n    if (\n      (tag == null || tag === toStringTag) &&\n      typeof view.isNodeView === 'function' &&\n      typeof view.isEdgeView === 'function' &&\n      typeof view.confirmUpdate === 'function' &&\n      typeof view.update === 'function' &&\n      typeof view.getConnection === 'function'\n    ) {\n      return true\n    }\n\n    return false\n  }\n}\n\nnamespace EventData {\n  export interface MousemoveEventData {}\n\n  export interface EdgeDragging {\n    action: 'drag-edge'\n    moving: boolean\n    x: number\n    y: number\n  }\n\n  export type ValidateConnectionArgs = [\n    CellView | null | undefined, // source view\n    Element | null | undefined, // source magnet\n    CellView | null | undefined, // target view\n    Element | null | undefined, // target magnet\n    Edge.TerminalType,\n    EdgeView,\n  ]\n\n  export interface ArrowheadDragging {\n    action: 'drag-arrowhead'\n    x: number\n    y: number\n    isNewEdge: boolean\n    terminalType: Edge.TerminalType\n    fallbackAction: 'remove' | 'revert'\n    initialMagnet: Element | null\n    initialTerminal: Edge.TerminalData\n    getValidateConnectionArgs: (\n      cellView: CellView,\n      magnet: Element | null,\n    ) => ValidateConnectionArgs\n    zIndex?: number | null\n    pointerEvents?: string | null\n    /**\n     * Current event target.\n     */\n    currentTarget?: Element\n    /**\n     * Current view under pointer.\n     */\n    currentView?: CellView | null\n    /**\n     * Current magnet under pointer.\n     */\n    currentMagnet?: Element | null\n    closestView?: CellView | null\n    closestMagnet?: Element | null\n    marked?: KeyValue<Element[]> | null\n    options?: KeyValue\n  }\n\n  export interface LabelDragging {\n    action: 'drag-label'\n    index: number\n    positionAngle: number\n    positionArgs?: Edge.LabelPositionOptions | null\n    stopPropagation: true\n  }\n}\n\nEdgeView.config<EdgeView.Options>({\n  isSvgElement: true,\n  priority: 1,\n  bootstrap: ['render', 'source', 'target'],\n  actions: {\n    view: ['render'],\n    markup: ['render'],\n    attrs: ['update'],\n    source: ['source', 'update'],\n    target: ['target', 'update'],\n    router: ['update'],\n    connector: ['update'],\n    labels: ['labels'],\n    defaultLabel: ['labels'],\n    tools: ['tools'],\n    vertices: ['vertices', 'update'],\n  },\n})\n\nEdgeView.registry.register('edge', EdgeView, true)\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}