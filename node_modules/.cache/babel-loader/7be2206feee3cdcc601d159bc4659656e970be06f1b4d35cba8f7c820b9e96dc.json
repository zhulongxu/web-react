{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { Point, Rectangle, Angle } from '@antv/x6-geometry';\nimport { StringExt, ObjectExt, NumberExt, Interp } from '@antv/x6-common';\nimport { Registry } from '../registry/registry';\nimport { Markup } from '../view/markup';\nimport { Cell } from './cell';\nimport { ShareRegistry } from './registry';\nimport { PortManager } from './port';\nexport class Node extends Cell {\n  get [Symbol.toStringTag]() {\n    return Node.toStringTag;\n  }\n  constructor(metadata = {}) {\n    super(metadata);\n    this.initPorts();\n  }\n  preprocess(metadata, ignoreIdCheck) {\n    const {\n        x,\n        y,\n        width,\n        height\n      } = metadata,\n      others = __rest(metadata, [\"x\", \"y\", \"width\", \"height\"]);\n    if (x != null || y != null) {\n      const position = others.position;\n      others.position = Object.assign(Object.assign({}, position), {\n        x: x != null ? x : position ? position.x : 0,\n        y: y != null ? y : position ? position.y : 0\n      });\n    }\n    if (width != null || height != null) {\n      const size = others.size;\n      others.size = Object.assign(Object.assign({}, size), {\n        width: width != null ? width : size ? size.width : 0,\n        height: height != null ? height : size ? size.height : 0\n      });\n    }\n    return super.preprocess(others, ignoreIdCheck);\n  }\n  isNode() {\n    return true;\n  }\n  size(width, height, options) {\n    if (width === undefined) {\n      return this.getSize();\n    }\n    if (typeof width === 'number') {\n      return this.setSize(width, height, options);\n    }\n    return this.setSize(width, height);\n  }\n  getSize() {\n    const size = this.store.get('size');\n    return size ? Object.assign({}, size) : {\n      width: 1,\n      height: 1\n    };\n  }\n  setSize(width, height, options) {\n    if (typeof width === 'object') {\n      this.resize(width.width, width.height, height);\n    } else {\n      this.resize(width, height, options);\n    }\n    return this;\n  }\n  resize(width, height, options = {}) {\n    this.startBatch('resize', options);\n    const direction = options.direction;\n    if (direction) {\n      const currentSize = this.getSize();\n      switch (direction) {\n        case 'left':\n        case 'right':\n          // Don't change height when resizing horizontally.\n          height = currentSize.height; // eslint-disable-line\n          break;\n        case 'top':\n        case 'bottom':\n          // Don't change width when resizing vertically.\n          width = currentSize.width; // eslint-disable-line\n          break;\n        default:\n          break;\n      }\n      const map = {\n        right: 0,\n        'top-right': 0,\n        top: 1,\n        'top-left': 1,\n        left: 2,\n        'bottom-left': 2,\n        bottom: 3,\n        'bottom-right': 3\n      };\n      let quadrant = map[direction];\n      const angle = Angle.normalize(this.getAngle() || 0);\n      if (options.absolute) {\n        // We are taking the node's rotation into account\n        quadrant += Math.floor((angle + 45) / 90);\n        quadrant %= 4;\n      }\n      // This is a rectangle in size of the un-rotated node.\n      const bbox = this.getBBox();\n      // Pick the corner point on the node, which meant to stay on its\n      // place before and after the rotation.\n      let fixedPoint;\n      if (quadrant === 0) {\n        fixedPoint = bbox.getBottomLeft();\n      } else if (quadrant === 1) {\n        fixedPoint = bbox.getCorner();\n      } else if (quadrant === 2) {\n        fixedPoint = bbox.getTopRight();\n      } else {\n        fixedPoint = bbox.getOrigin();\n      }\n      // Find an image of the previous indent point. This is the position,\n      // where is the point actually located on the screen.\n      const imageFixedPoint = fixedPoint.clone().rotate(-angle, bbox.getCenter());\n      // Every point on the element rotates around a circle with the centre of\n      // rotation in the middle of the element while the whole element is being\n      // rotated. That means that the distance from a point in the corner of\n      // the element (supposed its always rect) to the center of the element\n      // doesn't change during the rotation and therefore it equals to a\n      // distance on un-rotated element.\n      // We can find the distance as DISTANCE = (ELEMENTWIDTH/2)^2 + (ELEMENTHEIGHT/2)^2)^0.5.\n      const radius = Math.sqrt(width * width + height * height) / 2;\n      // Now we are looking for an angle between x-axis and the line starting\n      // at image of fixed point and ending at the center of the element.\n      // We call this angle `alpha`.\n      // The image of a fixed point is located in n-th quadrant. For each\n      // quadrant passed going anti-clockwise we have to add 90 degrees.\n      // Note that the first quadrant has index 0.\n      //\n      // 3 | 2\n      // --c-- Quadrant positions around the element's center `c`\n      // 0 | 1\n      //\n      let alpha = quadrant * Math.PI / 2;\n      // Add an angle between the beginning of the current quadrant (line\n      // parallel with x-axis or y-axis going through the center of the\n      // element) and line crossing the indent of the fixed point and the\n      // center of the element. This is the angle we need but on the\n      // un-rotated element.\n      alpha += Math.atan(quadrant % 2 === 0 ? height / width : width / height);\n      // Lastly we have to deduct the original angle the element was rotated\n      // by and that's it.\n      alpha -= Angle.toRad(angle);\n      // With this angle and distance we can easily calculate the centre of\n      // the un-rotated element.\n      // Note that fromPolar constructor accepts an angle in radians.\n      const center = Point.fromPolar(radius, alpha, imageFixedPoint);\n      // The top left corner on the un-rotated element has to be half a width\n      // on the left and half a height to the top from the center. This will\n      // be the origin of rectangle we were looking for.\n      const origin = center.clone().translate(width / -2, height / -2);\n      this.store.set('size', {\n        width,\n        height\n      }, options);\n      this.setPosition(origin.x, origin.y, options);\n    } else {\n      this.store.set('size', {\n        width,\n        height\n      }, options);\n    }\n    this.stopBatch('resize', options);\n    return this;\n  }\n  scale(sx, sy, origin, options = {}) {\n    const scaledBBox = this.getBBox().scale(sx, sy, origin == null ? undefined : origin);\n    this.startBatch('scale', options);\n    this.setPosition(scaledBBox.x, scaledBBox.y, options);\n    this.resize(scaledBBox.width, scaledBBox.height, options);\n    this.stopBatch('scale');\n    return this;\n  }\n  position(arg0, arg1, arg2) {\n    if (typeof arg0 === 'number') {\n      return this.setPosition(arg0, arg1, arg2);\n    }\n    return this.getPosition(arg0);\n  }\n  getPosition(options = {}) {\n    if (options.relative) {\n      const parent = this.getParent();\n      if (parent != null && parent.isNode()) {\n        const currentPosition = this.getPosition();\n        const parentPosition = parent.getPosition();\n        return {\n          x: currentPosition.x - parentPosition.x,\n          y: currentPosition.y - parentPosition.y\n        };\n      }\n    }\n    const pos = this.store.get('position');\n    return pos ? Object.assign({}, pos) : {\n      x: 0,\n      y: 0\n    };\n  }\n  setPosition(arg0, arg1, arg2 = {}) {\n    let x;\n    let y;\n    let options;\n    if (typeof arg0 === 'object') {\n      x = arg0.x;\n      y = arg0.y;\n      options = arg1 || {};\n    } else {\n      x = arg0;\n      y = arg1;\n      options = arg2 || {};\n    }\n    if (options.relative) {\n      const parent = this.getParent();\n      if (parent != null && parent.isNode()) {\n        const parentPosition = parent.getPosition();\n        x += parentPosition.x;\n        y += parentPosition.y;\n      }\n    }\n    if (options.deep) {\n      const currentPosition = this.getPosition();\n      this.translate(x - currentPosition.x, y - currentPosition.y, options);\n    } else {\n      this.store.set('position', {\n        x,\n        y\n      }, options);\n    }\n    return this;\n  }\n  translate(tx = 0, ty = 0, options = {}) {\n    if (tx === 0 && ty === 0) {\n      return this;\n    }\n    // Pass the initiator of the translation.\n    options.translateBy = options.translateBy || this.id;\n    const position = this.getPosition();\n    if (options.restrict != null && options.translateBy === this.id) {\n      // We are restricting the translation for the element itself only. We get\n      // the bounding box of the element including all its embeds.\n      // All embeds have to be translated the exact same way as the element.\n      const bbox = this.getBBox({\n        deep: true\n      });\n      const ra = options.restrict;\n      // - - - - - - - - - - - - -> ra.x + ra.width\n      // - - - -> position.x      |\n      // -> bbox.x\n      //                ▓▓▓▓▓▓▓   |\n      //         ░░░░░░░▓▓▓▓▓▓▓\n      //         ░░░░░░░░░        |\n      //   ▓▓▓▓▓▓▓▓░░░░░░░\n      //   ▓▓▓▓▓▓▓▓               |\n      //   <-dx->                     | restricted area right border\n      //         <-width->        |   ░ translated element\n      //   <- - bbox.width - ->       ▓ embedded element\n      const dx = position.x - bbox.x;\n      const dy = position.y - bbox.y;\n      // Find the maximal/minimal coordinates that the element can be translated\n      // while complies the restrictions.\n      const x = Math.max(ra.x + dx, Math.min(ra.x + ra.width + dx - bbox.width, position.x + tx));\n      const y = Math.max(ra.y + dy, Math.min(ra.y + ra.height + dy - bbox.height, position.y + ty));\n      // recalculate the translation taking the restrictions into account.\n      tx = x - position.x; // eslint-disable-line\n      ty = y - position.y; // eslint-disable-line\n    }\n    const translatedPosition = {\n      x: position.x + tx,\n      y: position.y + ty\n    };\n    // To find out by how much an element was translated in event\n    // 'change:position' handlers.\n    options.tx = tx;\n    options.ty = ty;\n    if (options.transition) {\n      if (typeof options.transition !== 'object') {\n        options.transition = {};\n      }\n      this.transition('position', translatedPosition, Object.assign(Object.assign({}, options.transition), {\n        interp: Interp.object\n      }));\n      this.eachChild(child => {\n        var _a;\n        const excluded = (_a = options.exclude) === null || _a === void 0 ? void 0 : _a.includes(child);\n        if (!excluded) {\n          child.translate(tx, ty, options);\n        }\n      });\n    } else {\n      this.startBatch('translate', options);\n      this.store.set('position', translatedPosition, options);\n      this.eachChild(child => {\n        var _a;\n        const excluded = (_a = options.exclude) === null || _a === void 0 ? void 0 : _a.includes(child);\n        if (!excluded) {\n          child.translate(tx, ty, options);\n        }\n      });\n      this.stopBatch('translate', options);\n    }\n    return this;\n  }\n  angle(val, options) {\n    if (val == null) {\n      return this.getAngle();\n    }\n    return this.rotate(val, options);\n  }\n  getAngle() {\n    return this.store.get('angle', 0);\n  }\n  rotate(angle, options = {}) {\n    const currentAngle = this.getAngle();\n    if (options.center) {\n      const size = this.getSize();\n      const position = this.getPosition();\n      const center = this.getBBox().getCenter();\n      center.rotate(currentAngle - angle, options.center);\n      const dx = center.x - size.width / 2 - position.x;\n      const dy = center.y - size.height / 2 - position.y;\n      this.startBatch('rotate', {\n        angle,\n        options\n      });\n      this.setPosition(position.x + dx, position.y + dy, options);\n      this.rotate(angle, Object.assign(Object.assign({}, options), {\n        center: null\n      }));\n      this.stopBatch('rotate');\n    } else {\n      this.store.set('angle', options.absolute ? angle : (currentAngle + angle) % 360, options);\n    }\n    return this;\n  }\n  // #endregion\n  // #region common\n  getBBox(options = {}) {\n    if (options.deep) {\n      const cells = this.getDescendants({\n        deep: true,\n        breadthFirst: true\n      });\n      cells.push(this);\n      return Cell.getCellsBBox(cells);\n    }\n    return Rectangle.fromPositionAndSize(this.getPosition(), this.getSize());\n  }\n  getConnectionPoint(edge, type) {\n    const bbox = this.getBBox();\n    const center = bbox.getCenter();\n    const terminal = edge.getTerminal(type);\n    if (terminal == null) {\n      return center;\n    }\n    const portId = terminal.port;\n    if (!portId || !this.hasPort(portId)) {\n      return center;\n    }\n    const port = this.getPort(portId);\n    if (!port || !port.group) {\n      return center;\n    }\n    const layouts = this.getPortsPosition(port.group);\n    const position = layouts[portId].position;\n    const portCenter = Point.create(position).translate(bbox.getOrigin());\n    const angle = this.getAngle();\n    if (angle) {\n      portCenter.rotate(-angle, center);\n    }\n    return portCenter;\n  }\n  /**\n   * Sets cell's size and position based on the children bbox and given padding.\n   */\n  fit(options = {}) {\n    const children = this.getChildren() || [];\n    const embeds = children.filter(cell => cell.isNode());\n    if (embeds.length === 0) {\n      return this;\n    }\n    this.startBatch('fit-embeds', options);\n    if (options.deep) {\n      embeds.forEach(cell => cell.fit(options));\n    }\n    let {\n      x,\n      y,\n      width,\n      height\n    } = Cell.getCellsBBox(embeds);\n    const padding = NumberExt.normalizeSides(options.padding);\n    x -= padding.left;\n    y -= padding.top;\n    width += padding.left + padding.right;\n    height += padding.bottom + padding.top;\n    this.store.set({\n      position: {\n        x,\n        y\n      },\n      size: {\n        width,\n        height\n      }\n    }, options);\n    this.stopBatch('fit-embeds');\n    return this;\n  }\n  // #endregion\n  // #region ports\n  get portContainerMarkup() {\n    return this.getPortContainerMarkup();\n  }\n  set portContainerMarkup(markup) {\n    this.setPortContainerMarkup(markup);\n  }\n  getDefaultPortContainerMarkup() {\n    return this.store.get('defaultPortContainerMarkup') || Markup.getPortContainerMarkup();\n  }\n  getPortContainerMarkup() {\n    return this.store.get('portContainerMarkup') || this.getDefaultPortContainerMarkup();\n  }\n  setPortContainerMarkup(markup, options = {}) {\n    this.store.set('portContainerMarkup', Markup.clone(markup), options);\n    return this;\n  }\n  get portMarkup() {\n    return this.getPortMarkup();\n  }\n  set portMarkup(markup) {\n    this.setPortMarkup(markup);\n  }\n  getDefaultPortMarkup() {\n    return this.store.get('defaultPortMarkup') || Markup.getPortMarkup();\n  }\n  getPortMarkup() {\n    return this.store.get('portMarkup') || this.getDefaultPortMarkup();\n  }\n  setPortMarkup(markup, options = {}) {\n    this.store.set('portMarkup', Markup.clone(markup), options);\n    return this;\n  }\n  get portLabelMarkup() {\n    return this.getPortLabelMarkup();\n  }\n  set portLabelMarkup(markup) {\n    this.setPortLabelMarkup(markup);\n  }\n  getDefaultPortLabelMarkup() {\n    return this.store.get('defaultPortLabelMarkup') || Markup.getPortLabelMarkup();\n  }\n  getPortLabelMarkup() {\n    return this.store.get('portLabelMarkup') || this.getDefaultPortLabelMarkup();\n  }\n  setPortLabelMarkup(markup, options = {}) {\n    this.store.set('portLabelMarkup', Markup.clone(markup), options);\n    return this;\n  }\n  get ports() {\n    const res = this.store.get('ports', {\n      items: []\n    });\n    if (res.items == null) {\n      res.items = [];\n    }\n    return res;\n  }\n  getPorts() {\n    return ObjectExt.cloneDeep(this.ports.items);\n  }\n  getPortsByGroup(groupName) {\n    return this.getPorts().filter(port => port.group === groupName);\n  }\n  getPort(portId) {\n    return ObjectExt.cloneDeep(this.ports.items.find(port => port.id && port.id === portId));\n  }\n  getPortAt(index) {\n    return this.ports.items[index] || null;\n  }\n  hasPorts() {\n    return this.ports.items.length > 0;\n  }\n  hasPort(portId) {\n    return this.getPortIndex(portId) !== -1;\n  }\n  getPortIndex(port) {\n    const portId = typeof port === 'string' ? port : port.id;\n    return portId != null ? this.ports.items.findIndex(item => item.id === portId) : -1;\n  }\n  getPortsPosition(groupName) {\n    const size = this.getSize();\n    const layouts = this.port.getPortsLayoutByGroup(groupName, new Rectangle(0, 0, size.width, size.height));\n    return layouts.reduce((memo, item) => {\n      const layout = item.portLayout;\n      memo[item.portId] = {\n        position: Object.assign({}, layout.position),\n        angle: layout.angle || 0\n      };\n      return memo;\n    }, {});\n  }\n  getPortProp(portId, path) {\n    return this.getPropByPath(this.prefixPortPath(portId, path));\n  }\n  setPortProp(portId, arg1, arg2, arg3) {\n    if (typeof arg1 === 'string' || Array.isArray(arg1)) {\n      const path = this.prefixPortPath(portId, arg1);\n      const value = arg2;\n      return this.setPropByPath(path, value, arg3);\n    }\n    const path = this.prefixPortPath(portId);\n    const value = arg1;\n    return this.setPropByPath(path, value, arg2);\n  }\n  removePortProp(portId, path, options) {\n    if (typeof path === 'string' || Array.isArray(path)) {\n      return this.removePropByPath(this.prefixPortPath(portId, path), options);\n    }\n    return this.removePropByPath(this.prefixPortPath(portId), path);\n  }\n  portProp(portId, path, value, options) {\n    if (path == null) {\n      return this.getPortProp(portId);\n    }\n    if (typeof path === 'string' || Array.isArray(path)) {\n      if (arguments.length === 2) {\n        return this.getPortProp(portId, path);\n      }\n      if (value == null) {\n        return this.removePortProp(portId, path, options);\n      }\n      return this.setPortProp(portId, path, value, options);\n    }\n    return this.setPortProp(portId, path, value);\n  }\n  prefixPortPath(portId, path) {\n    const index = this.getPortIndex(portId);\n    if (index === -1) {\n      throw new Error(`Unable to find port with id: \"${portId}\"`);\n    }\n    if (path == null || path === '') {\n      return ['ports', 'items', `${index}`];\n    }\n    if (Array.isArray(path)) {\n      return ['ports', 'items', `${index}`, ...path];\n    }\n    return `ports/items/${index}/${path}`;\n  }\n  addPort(port, options) {\n    const ports = [...this.ports.items];\n    ports.push(port);\n    this.setPropByPath('ports/items', ports, options);\n    return this;\n  }\n  addPorts(ports, options) {\n    this.setPropByPath('ports/items', [...this.ports.items, ...ports], options);\n    return this;\n  }\n  insertPort(index, port, options) {\n    const ports = [...this.ports.items];\n    ports.splice(index, 0, port);\n    this.setPropByPath('ports/items', ports, options);\n    return this;\n  }\n  removePort(port, options = {}) {\n    return this.removePortAt(this.getPortIndex(port), options);\n  }\n  removePortAt(index, options = {}) {\n    if (index >= 0) {\n      const ports = [...this.ports.items];\n      ports.splice(index, 1);\n      options.rewrite = true;\n      this.setPropByPath('ports/items', ports, options);\n    }\n    return this;\n  }\n  removePorts(portsForRemoval, opt) {\n    let options;\n    if (Array.isArray(portsForRemoval)) {\n      options = opt || {};\n      if (portsForRemoval.length) {\n        options.rewrite = true;\n        const currentPorts = [...this.ports.items];\n        const remainingPorts = currentPorts.filter(cp => !portsForRemoval.some(p => {\n          const id = typeof p === 'string' ? p : p.id;\n          return cp.id === id;\n        }));\n        this.setPropByPath('ports/items', remainingPorts, options);\n      }\n    } else {\n      options = portsForRemoval || {};\n      options.rewrite = true;\n      this.setPropByPath('ports/items', [], options);\n    }\n    return this;\n  }\n  getParsedPorts() {\n    return this.port.getPorts();\n  }\n  getParsedGroups() {\n    return this.port.groups;\n  }\n  getPortsLayoutByGroup(groupName, bbox) {\n    return this.port.getPortsLayoutByGroup(groupName, bbox);\n  }\n  initPorts() {\n    this.updatePortData();\n    this.on('change:ports', () => {\n      this.processRemovedPort();\n      this.updatePortData();\n    });\n  }\n  processRemovedPort() {\n    const current = this.ports;\n    const currentItemsMap = {};\n    current.items.forEach(item => {\n      if (item.id) {\n        currentItemsMap[item.id] = true;\n      }\n    });\n    const removed = {};\n    const previous = this.store.getPrevious('ports') || {\n      items: []\n    };\n    previous.items.forEach(item => {\n      if (item.id && !currentItemsMap[item.id]) {\n        removed[item.id] = true;\n      }\n    });\n    const model = this.model;\n    if (model && !ObjectExt.isEmpty(removed)) {\n      const incomings = model.getConnectedEdges(this, {\n        incoming: true\n      });\n      incomings.forEach(edge => {\n        const portId = edge.getTargetPortId();\n        if (portId && removed[portId]) {\n          edge.remove();\n        }\n      });\n      const outgoings = model.getConnectedEdges(this, {\n        outgoing: true\n      });\n      outgoings.forEach(edge => {\n        const portId = edge.getSourcePortId();\n        if (portId && removed[portId]) {\n          edge.remove();\n        }\n      });\n    }\n  }\n  validatePorts() {\n    const ids = {};\n    const errors = [];\n    this.ports.items.forEach(p => {\n      if (typeof p !== 'object') {\n        errors.push(`Invalid port ${p}.`);\n      }\n      if (p.id == null) {\n        p.id = this.generatePortId();\n      }\n      if (ids[p.id]) {\n        errors.push('Duplicitied port id.');\n      }\n      ids[p.id] = true;\n    });\n    return errors;\n  }\n  generatePortId() {\n    return StringExt.uuid();\n  }\n  updatePortData() {\n    const err = this.validatePorts();\n    if (err.length > 0) {\n      this.store.set('ports', this.store.getPrevious('ports'));\n      throw new Error(err.join(' '));\n    }\n    const prev = this.port ? this.port.getPorts() : null;\n    this.port = new PortManager(this.ports);\n    const curr = this.port.getPorts();\n    const added = prev ? curr.filter(item => {\n      if (!prev.find(prevPort => prevPort.id === item.id)) {\n        return item;\n      }\n      return null;\n    }) : [...curr];\n    const removed = prev ? prev.filter(item => {\n      if (!curr.find(curPort => curPort.id === item.id)) {\n        return item;\n      }\n      return null;\n    }) : [];\n    if (added.length > 0) {\n      this.notify('ports:added', {\n        added,\n        cell: this,\n        node: this\n      });\n    }\n    if (removed.length > 0) {\n      this.notify('ports:removed', {\n        removed,\n        cell: this,\n        node: this\n      });\n    }\n  }\n}\nNode.defaults = {\n  angle: 0,\n  position: {\n    x: 0,\n    y: 0\n  },\n  size: {\n    width: 1,\n    height: 1\n  }\n};\n(function (Node) {\n  Node.toStringTag = `X6.${Node.name}`;\n  function isNode(instance) {\n    if (instance == null) {\n      return false;\n    }\n    if (instance instanceof Node) {\n      return true;\n    }\n    const tag = instance[Symbol.toStringTag];\n    const node = instance;\n    if ((tag == null || tag === Node.toStringTag) && typeof node.isNode === 'function' && typeof node.isEdge === 'function' && typeof node.prop === 'function' && typeof node.attr === 'function' && typeof node.size === 'function' && typeof node.position === 'function') {\n      return true;\n    }\n    return false;\n  }\n  Node.isNode = isNode;\n})(Node || (Node = {}));\n(function (Node) {\n  Node.config({\n    propHooks(_a) {\n      var {\n          ports\n        } = _a,\n        metadata = __rest(_a, [\"ports\"]);\n      if (ports) {\n        metadata.ports = Array.isArray(ports) ? {\n          items: ports\n        } : ports;\n      }\n      return metadata;\n    }\n  });\n})(Node || (Node = {}));\n(function (Node) {\n  Node.registry = Registry.create({\n    type: 'node',\n    process(shape, options) {\n      if (ShareRegistry.exist(shape, true)) {\n        throw new Error(`Node with name '${shape}' was registered by anthor Edge`);\n      }\n      if (typeof options === 'function') {\n        options.config({\n          shape\n        });\n        return options;\n      }\n      let parent = Node;\n      const {\n          inherit\n        } = options,\n        config = __rest(options, [\"inherit\"]);\n      if (inherit) {\n        if (typeof inherit === 'string') {\n          const base = this.get(inherit);\n          if (base == null) {\n            this.onNotFound(inherit, 'inherited');\n          } else {\n            parent = base;\n          }\n        } else {\n          parent = inherit;\n        }\n      }\n      if (config.constructorName == null) {\n        config.constructorName = shape;\n      }\n      const ctor = parent.define.call(parent, config);\n      ctor.config({\n        shape\n      });\n      return ctor;\n    }\n  });\n  ShareRegistry.setNodeRegistry(Node.registry);\n})(Node || (Node = {}));\n(function (Node) {\n  let counter = 0;\n  function getClassName(name) {\n    if (name) {\n      return StringExt.pascalCase(name);\n    }\n    counter += 1;\n    return `CustomNode${counter}`;\n  }\n  function define(config) {\n    const {\n        constructorName,\n        overwrite\n      } = config,\n      others = __rest(config, [\"constructorName\", \"overwrite\"]);\n    const ctor = ObjectExt.createClass(getClassName(constructorName || others.shape), this);\n    ctor.config(others);\n    if (others.shape) {\n      Node.registry.register(others.shape, ctor, overwrite);\n    }\n    return ctor;\n  }\n  Node.define = define;\n  function create(options) {\n    const shape = options.shape || 'rect';\n    const Ctor = Node.registry.get(shape);\n    if (Ctor) {\n      return new Ctor(options);\n    }\n    return Node.registry.onNotFound(shape);\n  }\n  Node.create = create;\n})(Node || (Node = {}));","map":{"version":3,"names":["Point","Rectangle","Angle","StringExt","ObjectExt","NumberExt","Interp","Registry","Markup","Cell","ShareRegistry","PortManager","Node","Symbol","toStringTag","constructor","metadata","initPorts","preprocess","ignoreIdCheck","x","y","width","height","others","__rest","position","Object","assign","size","isNode","options","undefined","getSize","setSize","store","get","resize","startBatch","direction","currentSize","map","right","top","left","bottom","quadrant","angle","normalize","getAngle","absolute","Math","floor","bbox","getBBox","fixedPoint","getBottomLeft","getCorner","getTopRight","getOrigin","imageFixedPoint","clone","rotate","getCenter","radius","sqrt","alpha","PI","atan","toRad","center","fromPolar","origin","translate","set","setPosition","stopBatch","scale","sx","sy","scaledBBox","arg0","arg1","arg2","getPosition","relative","parent","getParent","currentPosition","parentPosition","pos","deep","tx","ty","translateBy","id","restrict","ra","dx","dy","max","min","translatedPosition","transition","interp","object","eachChild","child","excluded","_a","exclude","includes","val","currentAngle","cells","getDescendants","breadthFirst","push","getCellsBBox","fromPositionAndSize","getConnectionPoint","edge","type","terminal","getTerminal","portId","port","hasPort","getPort","group","layouts","getPortsPosition","portCenter","create","fit","children","getChildren","embeds","filter","cell","length","forEach","padding","normalizeSides","portContainerMarkup","getPortContainerMarkup","markup","setPortContainerMarkup","getDefaultPortContainerMarkup","portMarkup","getPortMarkup","setPortMarkup","getDefaultPortMarkup","portLabelMarkup","getPortLabelMarkup","setPortLabelMarkup","getDefaultPortLabelMarkup","ports","res","items","getPorts","cloneDeep","getPortsByGroup","groupName","find","getPortAt","index","hasPorts","getPortIndex","findIndex","item","getPortsLayoutByGroup","reduce","memo","layout","portLayout","getPortProp","path","getPropByPath","prefixPortPath","setPortProp","arg3","Array","isArray","value","setPropByPath","removePortProp","removePropByPath","portProp","arguments","Error","addPort","addPorts","insertPort","splice","removePort","removePortAt","rewrite","removePorts","portsForRemoval","opt","currentPorts","remainingPorts","cp","some","p","getParsedPorts","getParsedGroups","groups","updatePortData","on","processRemovedPort","current","currentItemsMap","removed","previous","getPrevious","model","isEmpty","incomings","getConnectedEdges","incoming","getTargetPortId","remove","outgoings","outgoing","getSourcePortId","validatePorts","ids","errors","generatePortId","uuid","err","join","prev","curr","added","prevPort","curPort","notify","node","defaults","name","instance","tag","isEdge","prop","attr","config","propHooks","registry","process","shape","exist","inherit","base","onNotFound","constructorName","ctor","define","call","setNodeRegistry","counter","getClassName","pascalCase","overwrite","createClass","register","Ctor"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/src/model/node.ts"],"sourcesContent":["import { Point, Rectangle, Angle } from '@antv/x6-geometry'\nimport {\n  StringExt,\n  ObjectExt,\n  NumberExt,\n  Size,\n  KeyValue,\n  Interp,\n} from '@antv/x6-common'\nimport { DeepPartial, Omit } from 'utility-types'\nimport { Registry } from '../registry/registry'\nimport { Markup } from '../view/markup'\nimport { Cell } from './cell'\nimport { Edge } from './edge'\nimport { Store } from './store'\nimport { ShareRegistry } from './registry'\nimport { PortManager } from './port'\nimport { Animation } from './animation'\n\nexport class Node<\n  Properties extends Node.Properties = Node.Properties,\n> extends Cell<Properties> {\n  protected static defaults: Node.Defaults = {\n    angle: 0,\n    position: { x: 0, y: 0 },\n    size: { width: 1, height: 1 },\n  }\n  protected readonly store: Store<Node.Properties>\n  protected port: PortManager\n\n  protected get [Symbol.toStringTag]() {\n    return Node.toStringTag\n  }\n\n  constructor(metadata: Node.Metadata = {}) {\n    super(metadata)\n    this.initPorts()\n  }\n\n  protected preprocess(\n    metadata: Node.Metadata,\n    ignoreIdCheck?: boolean,\n  ): Properties {\n    const { x, y, width, height, ...others } = metadata\n\n    if (x != null || y != null) {\n      const position = others.position\n      others.position = {\n        ...position,\n        x: x != null ? x : position ? position.x : 0,\n        y: y != null ? y : position ? position.y : 0,\n      }\n    }\n\n    if (width != null || height != null) {\n      const size = others.size\n      others.size = {\n        ...size,\n        width: width != null ? width : size ? size.width : 0,\n        height: height != null ? height : size ? size.height : 0,\n      }\n    }\n\n    return super.preprocess(others, ignoreIdCheck)\n  }\n\n  isNode(): this is Node {\n    return true\n  }\n\n  // #region size\n\n  size(): Size\n  size(size: Size, options?: Node.ResizeOptions): this\n  size(width: number, height: number, options?: Node.ResizeOptions): this\n  size(\n    width?: number | Size,\n    height?: number | Node.ResizeOptions,\n    options?: Node.ResizeOptions,\n  ) {\n    if (width === undefined) {\n      return this.getSize()\n    }\n\n    if (typeof width === 'number') {\n      return this.setSize(width, height as number, options)\n    }\n\n    return this.setSize(width, height as Node.ResizeOptions)\n  }\n\n  getSize() {\n    const size = this.store.get('size')\n    return size ? { ...size } : { width: 1, height: 1 }\n  }\n\n  setSize(size: Size, options?: Node.ResizeOptions): this\n  setSize(width: number, height: number, options?: Node.ResizeOptions): this\n  setSize(\n    width: number | Size,\n    height?: number | Node.ResizeOptions,\n    options?: Node.ResizeOptions,\n  ) {\n    if (typeof width === 'object') {\n      this.resize(width.width, width.height, height as Node.ResizeOptions)\n    } else {\n      this.resize(width, height as number, options)\n    }\n\n    return this\n  }\n\n  resize(width: number, height: number, options: Node.ResizeOptions = {}) {\n    this.startBatch('resize', options)\n    const direction = options.direction\n\n    if (direction) {\n      const currentSize = this.getSize()\n      switch (direction) {\n        case 'left':\n        case 'right':\n          // Don't change height when resizing horizontally.\n          height = currentSize.height // eslint-disable-line\n          break\n        case 'top':\n        case 'bottom':\n          // Don't change width when resizing vertically.\n          width = currentSize.width // eslint-disable-line\n          break\n        default:\n          break\n      }\n\n      const map: { [direction: string]: number } = {\n        right: 0,\n        'top-right': 0,\n        top: 1,\n        'top-left': 1,\n        left: 2,\n        'bottom-left': 2,\n        bottom: 3,\n        'bottom-right': 3,\n      }\n\n      let quadrant = map[direction]\n      const angle = Angle.normalize(this.getAngle() || 0)\n      if (options.absolute) {\n        // We are taking the node's rotation into account\n        quadrant += Math.floor((angle + 45) / 90)\n        quadrant %= 4\n      }\n\n      // This is a rectangle in size of the un-rotated node.\n      const bbox = this.getBBox()\n\n      // Pick the corner point on the node, which meant to stay on its\n      // place before and after the rotation.\n      let fixedPoint: Point\n      if (quadrant === 0) {\n        fixedPoint = bbox.getBottomLeft()\n      } else if (quadrant === 1) {\n        fixedPoint = bbox.getCorner()\n      } else if (quadrant === 2) {\n        fixedPoint = bbox.getTopRight()\n      } else {\n        fixedPoint = bbox.getOrigin()\n      }\n\n      // Find an image of the previous indent point. This is the position,\n      // where is the point actually located on the screen.\n      const imageFixedPoint = fixedPoint\n        .clone()\n        .rotate(-angle, bbox.getCenter())\n\n      // Every point on the element rotates around a circle with the centre of\n      // rotation in the middle of the element while the whole element is being\n      // rotated. That means that the distance from a point in the corner of\n      // the element (supposed its always rect) to the center of the element\n      // doesn't change during the rotation and therefore it equals to a\n      // distance on un-rotated element.\n      // We can find the distance as DISTANCE = (ELEMENTWIDTH/2)^2 + (ELEMENTHEIGHT/2)^2)^0.5.\n      const radius = Math.sqrt(width * width + height * height) / 2\n\n      // Now we are looking for an angle between x-axis and the line starting\n      // at image of fixed point and ending at the center of the element.\n      // We call this angle `alpha`.\n\n      // The image of a fixed point is located in n-th quadrant. For each\n      // quadrant passed going anti-clockwise we have to add 90 degrees.\n      // Note that the first quadrant has index 0.\n      //\n      // 3 | 2\n      // --c-- Quadrant positions around the element's center `c`\n      // 0 | 1\n      //\n      let alpha = (quadrant * Math.PI) / 2\n\n      // Add an angle between the beginning of the current quadrant (line\n      // parallel with x-axis or y-axis going through the center of the\n      // element) and line crossing the indent of the fixed point and the\n      // center of the element. This is the angle we need but on the\n      // un-rotated element.\n      alpha += Math.atan(quadrant % 2 === 0 ? height / width : width / height)\n\n      // Lastly we have to deduct the original angle the element was rotated\n      // by and that's it.\n      alpha -= Angle.toRad(angle)\n\n      // With this angle and distance we can easily calculate the centre of\n      // the un-rotated element.\n      // Note that fromPolar constructor accepts an angle in radians.\n      const center = Point.fromPolar(radius, alpha, imageFixedPoint)\n\n      // The top left corner on the un-rotated element has to be half a width\n      // on the left and half a height to the top from the center. This will\n      // be the origin of rectangle we were looking for.\n      const origin = center.clone().translate(width / -2, height / -2)\n\n      this.store.set('size', { width, height }, options)\n      this.setPosition(origin.x, origin.y, options)\n    } else {\n      this.store.set('size', { width, height }, options)\n    }\n\n    this.stopBatch('resize', options)\n\n    return this\n  }\n\n  scale(\n    sx: number,\n    sy: number,\n    origin?: Point.PointLike | null,\n    options: Node.SetOptions = {},\n  ) {\n    const scaledBBox = this.getBBox().scale(\n      sx,\n      sy,\n      origin == null ? undefined : origin,\n    )\n\n    this.startBatch('scale', options)\n    this.setPosition(scaledBBox.x, scaledBBox.y, options)\n    this.resize(scaledBBox.width, scaledBBox.height, options)\n    this.stopBatch('scale')\n    return this\n  }\n\n  // #endregion\n\n  // #region position\n\n  position(x: number, y: number, options?: Node.SetPositionOptions): this\n  position(options?: Node.GetPositionOptions): Point.PointLike\n  position(\n    arg0?: number | Node.GetPositionOptions,\n    arg1?: number,\n    arg2?: Node.SetPositionOptions,\n  ) {\n    if (typeof arg0 === 'number') {\n      return this.setPosition(arg0, arg1 as number, arg2)\n    }\n    return this.getPosition(arg0)\n  }\n\n  getPosition(options: Node.GetPositionOptions = {}): Point.PointLike {\n    if (options.relative) {\n      const parent = this.getParent()\n      if (parent != null && parent.isNode()) {\n        const currentPosition = this.getPosition()\n        const parentPosition = parent.getPosition()\n\n        return {\n          x: currentPosition.x - parentPosition.x,\n          y: currentPosition.y - parentPosition.y,\n        }\n      }\n    }\n\n    const pos = this.store.get('position')\n    return pos ? { ...pos } : { x: 0, y: 0 }\n  }\n\n  setPosition(\n    p: Point | Point.PointLike,\n    options?: Node.SetPositionOptions,\n  ): this\n  setPosition(x: number, y: number, options?: Node.SetPositionOptions): this\n  setPosition(\n    arg0: number | Point | Point.PointLike,\n    arg1?: number | Node.SetPositionOptions,\n    arg2: Node.SetPositionOptions = {},\n  ) {\n    let x: number\n    let y: number\n    let options: Node.SetPositionOptions\n\n    if (typeof arg0 === 'object') {\n      x = arg0.x\n      y = arg0.y\n      options = (arg1 as Node.SetPositionOptions) || {}\n    } else {\n      x = arg0\n      y = arg1 as number\n      options = arg2 || {}\n    }\n\n    if (options.relative) {\n      const parent = this.getParent() as Node\n      if (parent != null && parent.isNode()) {\n        const parentPosition = parent.getPosition()\n        x += parentPosition.x\n        y += parentPosition.y\n      }\n    }\n\n    if (options.deep) {\n      const currentPosition = this.getPosition()\n      this.translate(x - currentPosition.x, y - currentPosition.y, options)\n    } else {\n      this.store.set('position', { x, y }, options)\n    }\n\n    return this\n  }\n\n  translate(tx = 0, ty = 0, options: Node.TranslateOptions = {}) {\n    if (tx === 0 && ty === 0) {\n      return this\n    }\n\n    // Pass the initiator of the translation.\n    options.translateBy = options.translateBy || this.id\n\n    const position = this.getPosition()\n\n    if (options.restrict != null && options.translateBy === this.id) {\n      // We are restricting the translation for the element itself only. We get\n      // the bounding box of the element including all its embeds.\n      // All embeds have to be translated the exact same way as the element.\n      const bbox = this.getBBox({ deep: true })\n      const ra = options.restrict\n      // - - - - - - - - - - - - -> ra.x + ra.width\n      // - - - -> position.x      |\n      // -> bbox.x\n      //                ▓▓▓▓▓▓▓   |\n      //         ░░░░░░░▓▓▓▓▓▓▓\n      //         ░░░░░░░░░        |\n      //   ▓▓▓▓▓▓▓▓░░░░░░░\n      //   ▓▓▓▓▓▓▓▓               |\n      //   <-dx->                     | restricted area right border\n      //         <-width->        |   ░ translated element\n      //   <- - bbox.width - ->       ▓ embedded element\n      const dx = position.x - bbox.x\n      const dy = position.y - bbox.y\n      // Find the maximal/minimal coordinates that the element can be translated\n      // while complies the restrictions.\n      const x = Math.max(\n        ra.x + dx,\n        Math.min(ra.x + ra.width + dx - bbox.width, position.x + tx),\n      )\n      const y = Math.max(\n        ra.y + dy,\n        Math.min(ra.y + ra.height + dy - bbox.height, position.y + ty),\n      )\n\n      // recalculate the translation taking the restrictions into account.\n      tx = x - position.x // eslint-disable-line\n      ty = y - position.y // eslint-disable-line\n    }\n\n    const translatedPosition = {\n      x: position.x + tx,\n      y: position.y + ty,\n    }\n\n    // To find out by how much an element was translated in event\n    // 'change:position' handlers.\n    options.tx = tx\n    options.ty = ty\n\n    if (options.transition) {\n      if (typeof options.transition !== 'object') {\n        options.transition = {}\n      }\n\n      this.transition('position', translatedPosition, {\n        ...options.transition,\n        interp: Interp.object,\n      })\n      this.eachChild((child) => {\n        const excluded = options.exclude?.includes(child)\n        if (!excluded) {\n          child.translate(tx, ty, options)\n        }\n      })\n    } else {\n      this.startBatch('translate', options)\n      this.store.set('position', translatedPosition, options)\n      this.eachChild((child) => {\n        const excluded = options.exclude?.includes(child)\n        if (!excluded) {\n          child.translate(tx, ty, options)\n        }\n      })\n      this.stopBatch('translate', options)\n    }\n\n    return this\n  }\n\n  // #endregion\n\n  // #region angle\n\n  angle(): number\n  angle(val: number, options?: Node.RotateOptions): this\n  angle(val?: number, options?: Node.RotateOptions) {\n    if (val == null) {\n      return this.getAngle()\n    }\n    return this.rotate(val, options)\n  }\n\n  getAngle() {\n    return this.store.get('angle', 0)\n  }\n\n  rotate(angle: number, options: Node.RotateOptions = {}) {\n    const currentAngle = this.getAngle()\n    if (options.center) {\n      const size = this.getSize()\n      const position = this.getPosition()\n      const center = this.getBBox().getCenter()\n      center.rotate(currentAngle - angle, options.center)\n      const dx = center.x - size.width / 2 - position.x\n      const dy = center.y - size.height / 2 - position.y\n      this.startBatch('rotate', { angle, options })\n      this.setPosition(position.x + dx, position.y + dy, options)\n      this.rotate(angle, { ...options, center: null })\n      this.stopBatch('rotate')\n    } else {\n      this.store.set(\n        'angle',\n        options.absolute ? angle : (currentAngle + angle) % 360,\n        options,\n      )\n    }\n\n    return this\n  }\n\n  // #endregion\n\n  // #region common\n\n  getBBox(options: { deep?: boolean } = {}) {\n    if (options.deep) {\n      const cells = this.getDescendants({ deep: true, breadthFirst: true })\n      cells.push(this)\n      return Cell.getCellsBBox(cells)!\n    }\n\n    return Rectangle.fromPositionAndSize(this.getPosition(), this.getSize())\n  }\n\n  getConnectionPoint(edge: Edge, type: Edge.TerminalType) {\n    const bbox = this.getBBox()\n    const center = bbox.getCenter()\n    const terminal = edge.getTerminal(type) as Edge.TerminalCellData\n    if (terminal == null) {\n      return center\n    }\n\n    const portId = terminal.port\n    if (!portId || !this.hasPort(portId)) {\n      return center\n    }\n\n    const port = this.getPort(portId)\n    if (!port || !port.group) {\n      return center\n    }\n\n    const layouts = this.getPortsPosition(port.group)\n    const position = layouts[portId].position\n    const portCenter = Point.create(position).translate(bbox.getOrigin())\n\n    const angle = this.getAngle()\n    if (angle) {\n      portCenter.rotate(-angle, center)\n    }\n\n    return portCenter\n  }\n\n  /**\n   * Sets cell's size and position based on the children bbox and given padding.\n   */\n  fit(options: Node.FitEmbedsOptions = {}) {\n    const children = this.getChildren() || []\n    const embeds = children.filter((cell) => cell.isNode()) as Node[]\n    if (embeds.length === 0) {\n      return this\n    }\n\n    this.startBatch('fit-embeds', options)\n\n    if (options.deep) {\n      embeds.forEach((cell) => cell.fit(options))\n    }\n\n    let { x, y, width, height } = Cell.getCellsBBox(embeds)!\n    const padding = NumberExt.normalizeSides(options.padding)\n\n    x -= padding.left\n    y -= padding.top\n    width += padding.left + padding.right\n    height += padding.bottom + padding.top\n\n    this.store.set(\n      {\n        position: { x, y },\n        size: { width, height },\n      },\n      options,\n    )\n\n    this.stopBatch('fit-embeds')\n\n    return this\n  }\n\n  // #endregion\n\n  // #region ports\n\n  get portContainerMarkup() {\n    return this.getPortContainerMarkup()\n  }\n\n  set portContainerMarkup(markup: Markup) {\n    this.setPortContainerMarkup(markup)\n  }\n\n  getDefaultPortContainerMarkup() {\n    return (\n      this.store.get('defaultPortContainerMarkup') ||\n      Markup.getPortContainerMarkup()\n    )\n  }\n\n  getPortContainerMarkup() {\n    return (\n      this.store.get('portContainerMarkup') ||\n      this.getDefaultPortContainerMarkup()\n    )\n  }\n\n  setPortContainerMarkup(markup?: Markup, options: Node.SetOptions = {}) {\n    this.store.set('portContainerMarkup', Markup.clone(markup), options)\n    return this\n  }\n\n  get portMarkup() {\n    return this.getPortMarkup()\n  }\n\n  set portMarkup(markup: Markup) {\n    this.setPortMarkup(markup)\n  }\n\n  getDefaultPortMarkup() {\n    return this.store.get('defaultPortMarkup') || Markup.getPortMarkup()\n  }\n\n  getPortMarkup() {\n    return this.store.get('portMarkup') || this.getDefaultPortMarkup()\n  }\n\n  setPortMarkup(markup?: Markup, options: Node.SetOptions = {}) {\n    this.store.set('portMarkup', Markup.clone(markup), options)\n    return this\n  }\n\n  get portLabelMarkup() {\n    return this.getPortLabelMarkup()\n  }\n\n  set portLabelMarkup(markup: Markup) {\n    this.setPortLabelMarkup(markup)\n  }\n\n  getDefaultPortLabelMarkup() {\n    return (\n      this.store.get('defaultPortLabelMarkup') || Markup.getPortLabelMarkup()\n    )\n  }\n\n  getPortLabelMarkup() {\n    return this.store.get('portLabelMarkup') || this.getDefaultPortLabelMarkup()\n  }\n\n  setPortLabelMarkup(markup?: Markup, options: Node.SetOptions = {}) {\n    this.store.set('portLabelMarkup', Markup.clone(markup), options)\n    return this\n  }\n\n  get ports() {\n    const res = this.store.get<PortManager.Metadata>('ports', { items: [] })\n    if (res.items == null) {\n      res.items = []\n    }\n    return res\n  }\n\n  getPorts() {\n    return ObjectExt.cloneDeep(this.ports.items)\n  }\n\n  getPortsByGroup(groupName: string) {\n    return this.getPorts().filter((port) => port.group === groupName)\n  }\n\n  getPort(portId: string) {\n    return ObjectExt.cloneDeep(\n      this.ports.items.find((port) => port.id && port.id === portId),\n    )\n  }\n\n  getPortAt(index: number) {\n    return this.ports.items[index] || null\n  }\n\n  hasPorts() {\n    return this.ports.items.length > 0\n  }\n\n  hasPort(portId: string) {\n    return this.getPortIndex(portId) !== -1\n  }\n\n  getPortIndex(port: PortManager.PortMetadata | string) {\n    const portId = typeof port === 'string' ? port : port.id\n    return portId != null\n      ? this.ports.items.findIndex((item) => item.id === portId)\n      : -1\n  }\n\n  getPortsPosition(groupName: string) {\n    const size = this.getSize()\n    const layouts = this.port.getPortsLayoutByGroup(\n      groupName,\n      new Rectangle(0, 0, size.width, size.height),\n    )\n\n    return layouts.reduce<\n      KeyValue<{\n        position: Point.PointLike\n        angle: number\n      }>\n    >((memo, item) => {\n      const layout = item.portLayout\n      memo[item.portId] = {\n        position: { ...layout.position },\n        angle: layout.angle || 0,\n      }\n      return memo\n    }, {})\n  }\n\n  getPortProp(portId: string): PortManager.PortMetadata\n  getPortProp<T>(portId: string, path: string | string[]): T\n  getPortProp(portId: string, path?: string | string[]) {\n    return this.getPropByPath(this.prefixPortPath(portId, path))\n  }\n\n  setPortProp(\n    portId: string,\n    path: string | string[],\n    value: any,\n    options?: Node.SetOptions,\n  ): this\n  setPortProp(\n    portId: string,\n    value: DeepPartial<PortManager.PortMetadata>,\n    options?: Node.SetOptions,\n  ): this\n  setPortProp(\n    portId: string,\n    arg1: string | string[] | DeepPartial<PortManager.PortMetadata>,\n    arg2: any | Node.SetOptions,\n    arg3?: Node.SetOptions,\n  ) {\n    if (typeof arg1 === 'string' || Array.isArray(arg1)) {\n      const path = this.prefixPortPath(portId, arg1)\n      const value = arg2\n      return this.setPropByPath(path, value, arg3)\n    }\n\n    const path = this.prefixPortPath(portId)\n    const value = arg1 as DeepPartial<PortManager.PortMetadata>\n    return this.setPropByPath(path, value, arg2 as Node.SetOptions)\n  }\n\n  removePortProp(portId: string, options?: Node.SetOptions): this\n  removePortProp(\n    portId: string,\n    path: string | string[],\n    options?: Node.SetOptions,\n  ): this\n  removePortProp(\n    portId: string,\n    path?: string | string[] | Node.SetOptions,\n    options?: Node.SetOptions,\n  ) {\n    if (typeof path === 'string' || Array.isArray(path)) {\n      return this.removePropByPath(this.prefixPortPath(portId, path), options)\n    }\n    return this.removePropByPath(this.prefixPortPath(portId), path)\n  }\n\n  portProp(portId: string): PortManager.PortMetadata\n  portProp<T>(portId: string, path: string | string[]): T\n  portProp(\n    portId: string,\n    path: string | string[],\n    value: any,\n    options?: Node.SetOptions,\n  ): this\n  portProp(\n    portId: string,\n    value: DeepPartial<PortManager.PortMetadata>,\n    options?: Node.SetOptions,\n  ): this\n  portProp(\n    portId: string,\n    path?: string | string[] | DeepPartial<PortManager.PortMetadata>,\n    value?: any | Node.SetOptions,\n    options?: Node.SetOptions,\n  ) {\n    if (path == null) {\n      return this.getPortProp(portId)\n    }\n    if (typeof path === 'string' || Array.isArray(path)) {\n      if (arguments.length === 2) {\n        return this.getPortProp(portId, path)\n      }\n      if (value == null) {\n        return this.removePortProp(portId, path, options)\n      }\n      return this.setPortProp(\n        portId,\n        path,\n        value as DeepPartial<PortManager.PortMetadata>,\n        options,\n      )\n    }\n    return this.setPortProp(\n      portId,\n      path as DeepPartial<PortManager.PortMetadata>,\n      value as Node.SetOptions,\n    )\n  }\n\n  protected prefixPortPath(portId: string, path?: string | string[]) {\n    const index = this.getPortIndex(portId)\n    if (index === -1) {\n      throw new Error(`Unable to find port with id: \"${portId}\"`)\n    }\n\n    if (path == null || path === '') {\n      return ['ports', 'items', `${index}`]\n    }\n\n    if (Array.isArray(path)) {\n      return ['ports', 'items', `${index}`, ...path]\n    }\n\n    return `ports/items/${index}/${path}`\n  }\n\n  addPort(port: PortManager.PortMetadata, options?: Node.SetOptions) {\n    const ports = [...this.ports.items]\n    ports.push(port)\n    this.setPropByPath('ports/items', ports, options)\n    return this\n  }\n\n  addPorts(ports: PortManager.PortMetadata[], options?: Node.SetOptions) {\n    this.setPropByPath('ports/items', [...this.ports.items, ...ports], options)\n    return this\n  }\n\n  insertPort(\n    index: number,\n    port: PortManager.PortMetadata,\n    options?: Node.SetOptions,\n  ) {\n    const ports = [...this.ports.items]\n    ports.splice(index, 0, port)\n    this.setPropByPath('ports/items', ports, options)\n    return this\n  }\n\n  removePort(\n    port: PortManager.PortMetadata | string,\n    options: Node.SetOptions = {},\n  ) {\n    return this.removePortAt(this.getPortIndex(port), options)\n  }\n\n  removePortAt(index: number, options: Node.SetOptions = {}) {\n    if (index >= 0) {\n      const ports = [...this.ports.items]\n      ports.splice(index, 1)\n      options.rewrite = true\n      this.setPropByPath('ports/items', ports, options)\n    }\n    return this\n  }\n\n  removePorts(options?: Node.SetOptions): this\n  removePorts(\n    portsForRemoval: (PortManager.PortMetadata | string)[],\n    options?: Node.SetOptions,\n  ): this\n  removePorts(\n    portsForRemoval?: (PortManager.PortMetadata | string)[] | Node.SetOptions,\n    opt?: Node.SetOptions,\n  ) {\n    let options\n\n    if (Array.isArray(portsForRemoval)) {\n      options = opt || {}\n      if (portsForRemoval.length) {\n        options.rewrite = true\n        const currentPorts = [...this.ports.items]\n        const remainingPorts = currentPorts.filter(\n          (cp) =>\n            !portsForRemoval.some((p) => {\n              const id = typeof p === 'string' ? p : p.id\n              return cp.id === id\n            }),\n        )\n        this.setPropByPath('ports/items', remainingPorts, options)\n      }\n    } else {\n      options = portsForRemoval || {}\n      options.rewrite = true\n      this.setPropByPath('ports/items', [], options)\n    }\n\n    return this\n  }\n\n  getParsedPorts() {\n    return this.port.getPorts()\n  }\n\n  getParsedGroups() {\n    return this.port.groups\n  }\n\n  getPortsLayoutByGroup(groupName: string | undefined, bbox: Rectangle) {\n    return this.port.getPortsLayoutByGroup(groupName, bbox)\n  }\n\n  protected initPorts() {\n    this.updatePortData()\n    this.on('change:ports', () => {\n      this.processRemovedPort()\n      this.updatePortData()\n    })\n  }\n\n  protected processRemovedPort() {\n    const current = this.ports\n    const currentItemsMap: { [id: string]: boolean } = {}\n\n    current.items.forEach((item) => {\n      if (item.id) {\n        currentItemsMap[item.id] = true\n      }\n    })\n\n    const removed: { [id: string]: boolean } = {}\n    const previous = this.store.getPrevious<PortManager.Metadata>('ports') || {\n      items: [],\n    }\n\n    previous.items.forEach((item) => {\n      if (item.id && !currentItemsMap[item.id]) {\n        removed[item.id] = true\n      }\n    })\n\n    const model = this.model\n    if (model && !ObjectExt.isEmpty(removed)) {\n      const incomings = model.getConnectedEdges(this, { incoming: true })\n      incomings.forEach((edge) => {\n        const portId = edge.getTargetPortId()\n        if (portId && removed[portId]) {\n          edge.remove()\n        }\n      })\n      const outgoings = model.getConnectedEdges(this, { outgoing: true })\n      outgoings.forEach((edge) => {\n        const portId = edge.getSourcePortId()\n        if (portId && removed[portId]) {\n          edge.remove()\n        }\n      })\n    }\n  }\n\n  protected validatePorts() {\n    const ids: { [id: string]: boolean } = {}\n    const errors: string[] = []\n    this.ports.items.forEach((p) => {\n      if (typeof p !== 'object') {\n        errors.push(`Invalid port ${p}.`)\n      }\n\n      if (p.id == null) {\n        p.id = this.generatePortId()\n      }\n\n      if (ids[p.id]) {\n        errors.push('Duplicitied port id.')\n      }\n\n      ids[p.id] = true\n    })\n\n    return errors\n  }\n\n  protected generatePortId() {\n    return StringExt.uuid()\n  }\n\n  protected updatePortData() {\n    const err = this.validatePorts()\n\n    if (err.length > 0) {\n      this.store.set(\n        'ports',\n        this.store.getPrevious<PortManager.Metadata>('ports'),\n      )\n      throw new Error(err.join(' '))\n    }\n\n    const prev = this.port ? this.port.getPorts() : null\n    this.port = new PortManager(this.ports)\n    const curr = this.port.getPorts()\n\n    const added = prev\n      ? curr.filter((item) => {\n          if (!prev.find((prevPort) => prevPort.id === item.id)) {\n            return item\n          }\n          return null\n        })\n      : [...curr]\n\n    const removed = prev\n      ? prev.filter((item) => {\n          if (!curr.find((curPort) => curPort.id === item.id)) {\n            return item\n          }\n          return null\n        })\n      : []\n\n    if (added.length > 0) {\n      this.notify('ports:added', { added, cell: this, node: this })\n    }\n\n    if (removed.length > 0) {\n      this.notify('ports:removed', { removed, cell: this, node: this })\n    }\n  }\n\n  // #endregion\n}\n\nexport namespace Node {\n  interface Common extends Cell.Common {\n    size?: { width: number; height: number }\n    position?: { x: number; y: number }\n    angle?: number\n    ports?: Partial<PortManager.Metadata> | PortManager.PortMetadata[]\n    portContainerMarkup?: Markup\n    portMarkup?: Markup\n    portLabelMarkup?: Markup\n    defaultPortMarkup?: Markup\n    defaultPortLabelMarkup?: Markup\n    defaultPortContainerMarkup?: Markup\n  }\n\n  interface Boundary {\n    x?: number\n    y?: number\n    width?: number\n    height?: number\n  }\n\n  export interface Defaults extends Common, Cell.Defaults {}\n\n  export interface Metadata extends Common, Cell.Metadata, Boundary {}\n\n  export interface Properties\n    extends Common,\n      Omit<Cell.Metadata, 'tools'>,\n      Cell.Properties {}\n\n  export interface Config\n    extends Defaults,\n      Boundary,\n      Cell.Config<Metadata, Node> {}\n}\n\nexport namespace Node {\n  export interface SetOptions extends Cell.SetOptions {}\n\n  export interface GetPositionOptions {\n    relative?: boolean\n  }\n\n  export interface SetPositionOptions extends SetOptions {\n    deep?: boolean\n    relative?: boolean\n  }\n\n  export interface TranslateOptions extends Cell.TranslateOptions {\n    transition?: boolean | Animation.StartOptions<Point.PointLike>\n    restrict?: Rectangle.RectangleLike | null\n    exclude?: Cell[]\n  }\n\n  export interface RotateOptions extends SetOptions {\n    absolute?: boolean\n    center?: Point.PointLike | null\n  }\n\n  export type ResizeDirection =\n    | 'left'\n    | 'top'\n    | 'right'\n    | 'bottom'\n    | 'top-left'\n    | 'top-right'\n    | 'bottom-left'\n    | 'bottom-right'\n\n  export interface ResizeOptions extends SetOptions {\n    absolute?: boolean\n    direction?: ResizeDirection\n  }\n\n  export interface FitEmbedsOptions extends SetOptions {\n    deep?: boolean\n    padding?: NumberExt.SideOptions\n  }\n}\n\nexport namespace Node {\n  export const toStringTag = `X6.${Node.name}`\n\n  export function isNode(instance: any): instance is Node {\n    if (instance == null) {\n      return false\n    }\n\n    if (instance instanceof Node) {\n      return true\n    }\n\n    const tag = instance[Symbol.toStringTag]\n    const node = instance as Node\n\n    if (\n      (tag == null || tag === toStringTag) &&\n      typeof node.isNode === 'function' &&\n      typeof node.isEdge === 'function' &&\n      typeof node.prop === 'function' &&\n      typeof node.attr === 'function' &&\n      typeof node.size === 'function' &&\n      typeof node.position === 'function'\n    ) {\n      return true\n    }\n\n    return false\n  }\n}\n\nexport namespace Node {\n  Node.config<Node.Config>({\n    propHooks({ ports, ...metadata }) {\n      if (ports) {\n        metadata.ports = Array.isArray(ports) ? { items: ports } : ports\n      }\n      return metadata\n    },\n  })\n}\n\nexport namespace Node {\n  export const registry = Registry.create<\n    Definition,\n    never,\n    Config & { inherit?: string | Definition }\n  >({\n    type: 'node',\n    process(shape, options) {\n      if (ShareRegistry.exist(shape, true)) {\n        throw new Error(\n          `Node with name '${shape}' was registered by anthor Edge`,\n        )\n      }\n\n      if (typeof options === 'function') {\n        options.config({ shape })\n        return options\n      }\n\n      let parent = Node\n      const { inherit, ...config } = options\n      if (inherit) {\n        if (typeof inherit === 'string') {\n          const base = this.get(inherit)\n          if (base == null) {\n            this.onNotFound(inherit, 'inherited')\n          } else {\n            parent = base\n          }\n        } else {\n          parent = inherit\n        }\n      }\n\n      if (config.constructorName == null) {\n        config.constructorName = shape\n      }\n\n      const ctor: Definition = parent.define.call(parent, config)\n      ctor.config({ shape })\n      return ctor as any\n    },\n  })\n\n  ShareRegistry.setNodeRegistry(registry)\n}\n\nexport namespace Node {\n  type NodeClass = typeof Node\n\n  export interface Definition extends NodeClass {\n    new <T extends Properties = Properties>(metadata: T): Node\n  }\n\n  let counter = 0\n  function getClassName(name?: string) {\n    if (name) {\n      return StringExt.pascalCase(name)\n    }\n    counter += 1\n    return `CustomNode${counter}`\n  }\n\n  export function define(config: Config) {\n    const { constructorName, overwrite, ...others } = config\n    const ctor = ObjectExt.createClass<NodeClass>(\n      getClassName(constructorName || others.shape),\n      this as NodeClass,\n    )\n\n    ctor.config(others)\n\n    if (others.shape) {\n      registry.register(others.shape, ctor, overwrite)\n    }\n\n    return ctor\n  }\n\n  export function create(options: Metadata) {\n    const shape = options.shape || 'rect'\n    const Ctor = registry.get(shape)\n    if (Ctor) {\n      return new Ctor(options)\n    }\n    return registry.onNotFound(shape)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}