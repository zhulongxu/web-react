{"ast":null,"code":"import { Ellipse } from '@antv/x6-geometry';\nimport { toResult } from './util';\nexport const ellipse = (portsPositionArgs, elemBBox, groupPositionArgs) => {\n  const startAngle = groupPositionArgs.start || 0;\n  const stepAngle = groupPositionArgs.step || 20;\n  return ellipseLayout(portsPositionArgs, elemBBox, startAngle, (index, count) => (index + 0.5 - count / 2) * stepAngle);\n};\nexport const ellipseSpread = (portsPositionArgs, elemBBox, groupPositionArgs) => {\n  const startAngle = groupPositionArgs.start || 0;\n  const stepAngle = groupPositionArgs.step || 360 / portsPositionArgs.length;\n  return ellipseLayout(portsPositionArgs, elemBBox, startAngle, index => {\n    return index * stepAngle;\n  });\n};\nfunction ellipseLayout(portsPositionArgs, elemBBox, startAngle, stepFn) {\n  const center = elemBBox.getCenter();\n  const start = elemBBox.getTopCenter();\n  const ratio = elemBBox.width / elemBBox.height;\n  const ellipse = Ellipse.fromRect(elemBBox);\n  const count = portsPositionArgs.length;\n  return portsPositionArgs.map((item, index) => {\n    const angle = startAngle + stepFn(index, count);\n    const p = start.clone().rotate(-angle, center).scale(ratio, 1, center);\n    const theta = item.compensateRotate ? -ellipse.tangentTheta(p) : 0;\n    if (item.dx || item.dy) {\n      p.translate(item.dx || 0, item.dy || 0);\n    }\n    if (item.dr) {\n      p.move(center, item.dr);\n    }\n    return toResult(p.round(), theta, item);\n  });\n}","map":{"version":3,"names":["Ellipse","toResult","ellipse","portsPositionArgs","elemBBox","groupPositionArgs","startAngle","start","stepAngle","step","ellipseLayout","index","count","ellipseSpread","length","stepFn","center","getCenter","getTopCenter","ratio","width","height","fromRect","map","item","angle","p","clone","rotate","scale","theta","compensateRotate","tangentTheta","dx","dy","translate","dr","move","round"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/src/registry/port-layout/ellipse.ts"],"sourcesContent":["import { Rectangle, Ellipse } from '@antv/x6-geometry'\nimport { PortLayout } from './index'\nimport { toResult } from './util'\n\nexport interface EllipseArgs extends PortLayout.CommonArgs {\n  start?: number\n  step?: number\n  compensateRotate?: boolean\n  /**\n   * delta radius\n   */\n  dr?: number\n}\n\nexport const ellipse: PortLayout.Definition<EllipseArgs> = (\n  portsPositionArgs,\n  elemBBox,\n  groupPositionArgs,\n) => {\n  const startAngle = groupPositionArgs.start || 0\n  const stepAngle = groupPositionArgs.step || 20\n\n  return ellipseLayout(\n    portsPositionArgs,\n    elemBBox,\n    startAngle,\n    (index, count) => (index + 0.5 - count / 2) * stepAngle,\n  )\n}\n\nexport const ellipseSpread: PortLayout.Definition<EllipseArgs> = (\n  portsPositionArgs,\n  elemBBox,\n  groupPositionArgs,\n) => {\n  const startAngle = groupPositionArgs.start || 0\n  const stepAngle = groupPositionArgs.step || 360 / portsPositionArgs.length\n\n  return ellipseLayout(portsPositionArgs, elemBBox, startAngle, (index) => {\n    return index * stepAngle\n  })\n}\n\nfunction ellipseLayout(\n  portsPositionArgs: EllipseArgs[],\n  elemBBox: Rectangle,\n  startAngle: number,\n  stepFn: (index: number, count: number) => number,\n) {\n  const center = elemBBox.getCenter()\n  const start = elemBBox.getTopCenter()\n  const ratio = elemBBox.width / elemBBox.height\n  const ellipse = Ellipse.fromRect(elemBBox)\n  const count = portsPositionArgs.length\n\n  return portsPositionArgs.map((item, index) => {\n    const angle = startAngle + stepFn(index, count)\n    const p = start.clone().rotate(-angle, center).scale(ratio, 1, center)\n\n    const theta = item.compensateRotate ? -ellipse.tangentTheta(p) : 0\n\n    if (item.dx || item.dy) {\n      p.translate(item.dx || 0, item.dy || 0)\n    }\n\n    if (item.dr) {\n      p.move(center, item.dr)\n    }\n\n    return toResult(p.round(), theta, item)\n  })\n}\n"],"mappings":"AAAA,SAAoBA,OAAO,QAAQ,mBAAmB;AAEtD,SAASC,QAAQ,QAAQ,QAAQ;AAYjC,OAAO,MAAMC,OAAO,GAAuCA,CACzDC,iBAAiB,EACjBC,QAAQ,EACRC,iBAAiB,KACf;EACF,MAAMC,UAAU,GAAGD,iBAAiB,CAACE,KAAK,IAAI,CAAC;EAC/C,MAAMC,SAAS,GAAGH,iBAAiB,CAACI,IAAI,IAAI,EAAE;EAE9C,OAAOC,aAAa,CAClBP,iBAAiB,EACjBC,QAAQ,EACRE,UAAU,EACV,CAACK,KAAK,EAAEC,KAAK,KAAK,CAACD,KAAK,GAAG,GAAG,GAAGC,KAAK,GAAG,CAAC,IAAIJ,SAAS,CACxD;AACH,CAAC;AAED,OAAO,MAAMK,aAAa,GAAuCA,CAC/DV,iBAAiB,EACjBC,QAAQ,EACRC,iBAAiB,KACf;EACF,MAAMC,UAAU,GAAGD,iBAAiB,CAACE,KAAK,IAAI,CAAC;EAC/C,MAAMC,SAAS,GAAGH,iBAAiB,CAACI,IAAI,IAAI,GAAG,GAAGN,iBAAiB,CAACW,MAAM;EAE1E,OAAOJ,aAAa,CAACP,iBAAiB,EAAEC,QAAQ,EAAEE,UAAU,EAAGK,KAAK,IAAI;IACtE,OAAOA,KAAK,GAAGH,SAAS;EAC1B,CAAC,CAAC;AACJ,CAAC;AAED,SAASE,aAAaA,CACpBP,iBAAgC,EAChCC,QAAmB,EACnBE,UAAkB,EAClBS,MAAgD;EAEhD,MAAMC,MAAM,GAAGZ,QAAQ,CAACa,SAAS,EAAE;EACnC,MAAMV,KAAK,GAAGH,QAAQ,CAACc,YAAY,EAAE;EACrC,MAAMC,KAAK,GAAGf,QAAQ,CAACgB,KAAK,GAAGhB,QAAQ,CAACiB,MAAM;EAC9C,MAAMnB,OAAO,GAAGF,OAAO,CAACsB,QAAQ,CAAClB,QAAQ,CAAC;EAC1C,MAAMQ,KAAK,GAAGT,iBAAiB,CAACW,MAAM;EAEtC,OAAOX,iBAAiB,CAACoB,GAAG,CAAC,CAACC,IAAI,EAAEb,KAAK,KAAI;IAC3C,MAAMc,KAAK,GAAGnB,UAAU,GAAGS,MAAM,CAACJ,KAAK,EAAEC,KAAK,CAAC;IAC/C,MAAMc,CAAC,GAAGnB,KAAK,CAACoB,KAAK,EAAE,CAACC,MAAM,CAAC,CAACH,KAAK,EAAET,MAAM,CAAC,CAACa,KAAK,CAACV,KAAK,EAAE,CAAC,EAAEH,MAAM,CAAC;IAEtE,MAAMc,KAAK,GAAGN,IAAI,CAACO,gBAAgB,GAAG,CAAC7B,OAAO,CAAC8B,YAAY,CAACN,CAAC,CAAC,GAAG,CAAC;IAElE,IAAIF,IAAI,CAACS,EAAE,IAAIT,IAAI,CAACU,EAAE,EAAE;MACtBR,CAAC,CAACS,SAAS,CAACX,IAAI,CAACS,EAAE,IAAI,CAAC,EAAET,IAAI,CAACU,EAAE,IAAI,CAAC,CAAC;;IAGzC,IAAIV,IAAI,CAACY,EAAE,EAAE;MACXV,CAAC,CAACW,IAAI,CAACrB,MAAM,EAAEQ,IAAI,CAACY,EAAE,CAAC;;IAGzB,OAAOnC,QAAQ,CAACyB,CAAC,CAACY,KAAK,EAAE,EAAER,KAAK,EAAEN,IAAI,CAAC;EACzC,CAAC,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}