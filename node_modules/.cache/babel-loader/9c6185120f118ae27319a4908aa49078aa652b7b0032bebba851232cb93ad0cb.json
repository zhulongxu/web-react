{"ast":null,"code":"// @see: https://github.com/microsoft/TypeScript/blob/master/src/compiler/checker.ts\n/**\n * Given a name and a list of names that are not equal to the name, return a\n * spelling suggestion if there is one that is close enough. Names less than\n * length 3 only check for case-insensitive equality, not Levenshtein distance.\n *\n * - If there is a candidate that's the same except for case, return that.\n * - If there is a candidate that's within one edit of the name, return that.\n * - Otherwise, return the candidate with the smallest Levenshtein distance,\n *     except for candidates:\n *       * With no name\n *       * Whose length differs from the target name by more than 0.34 of the\n *         length of the name.\n *       * Whose levenshtein distance is more than 0.4 of the length of the\n *         name (0.4 allows 1 substitution/transposition for every 5 characters,\n *         and 1 insertion/deletion at 3 characters)\n */\nexport function getSpellingSuggestion(name, candidates, getName) {\n  const maximumLengthDifference = Math.min(2, Math.floor(name.length * 0.34));\n  // If the best result isn't better than this, don't bother.\n  let bestDistance = Math.floor(name.length * 0.4) + 1;\n  let bestCandidate;\n  let justCheckExactMatches = false;\n  const nameLowerCase = name.toLowerCase();\n  // eslint-disable-next-line\n  for (const candidate of candidates) {\n    const candidateName = getName(candidate);\n    if (candidateName !== undefined && Math.abs(candidateName.length - nameLowerCase.length) <= maximumLengthDifference) {\n      const candidateNameLowerCase = candidateName.toLowerCase();\n      if (candidateNameLowerCase === nameLowerCase) {\n        if (candidateName === name) {\n          continue;\n        }\n        return candidate;\n      }\n      if (justCheckExactMatches) {\n        continue;\n      }\n      if (candidateName.length < 3) {\n        // Don't bother, user would have noticed a\n        // 2-character name having an extra character.\n        continue;\n      }\n      // Only care about a result better than the best so far.\n      const distance = levenshteinWithMax(nameLowerCase, candidateNameLowerCase, bestDistance - 1);\n      if (distance === undefined) {\n        continue;\n      }\n      if (distance < 3) {\n        justCheckExactMatches = true;\n        bestCandidate = candidate;\n      } else {\n        // Debug.assert(distance < bestDistance)\n        bestDistance = distance;\n        bestCandidate = candidate;\n      }\n    }\n  }\n  return bestCandidate;\n}\nfunction levenshteinWithMax(s1, s2, max) {\n  let previous = new Array(s2.length + 1); // eslint-disable-line\n  let current = new Array(s2.length + 1); // eslint-disable-line\n  /** Represents any value > max. We don't care about the particular value. */\n  const big = max + 1;\n  for (let i = 0; i <= s2.length; i += 1) {\n    previous[i] = i;\n  }\n  for (let i = 1; i <= s1.length; i += 1) {\n    const c1 = s1.charCodeAt(i - 1);\n    const minJ = i > max ? i - max : 1;\n    const maxJ = s2.length > max + i ? max + i : s2.length;\n    current[0] = i;\n    /** Smallest value of the matrix in the ith column. */\n    let colMin = i;\n    for (let j = 1; j < minJ; j += 1) {\n      current[j] = big;\n    }\n    for (let j = minJ; j <= maxJ; j += 1) {\n      const dist = c1 === s2.charCodeAt(j - 1) ? previous[j - 1] : Math.min(/* delete */previous[j] + 1, /* insert */current[j - 1] + 1, /* substitute */previous[j - 1] + 2);\n      current[j] = dist;\n      colMin = Math.min(colMin, dist);\n    }\n    for (let j = maxJ + 1; j <= s2.length; j += 1) {\n      current[j] = big;\n    }\n    if (colMin > max) {\n      // Give up -- everything in this column is > max\n      // and it can't get better in future columns.\n      return undefined;\n    }\n    const temp = previous;\n    previous = current;\n    current = temp;\n  }\n  const res = previous[s2.length];\n  return res > max ? undefined : res;\n}","map":{"version":3,"names":["getSpellingSuggestion","name","candidates","getName","maximumLengthDifference","Math","min","floor","length","bestDistance","bestCandidate","justCheckExactMatches","nameLowerCase","toLowerCase","candidate","candidateName","undefined","abs","candidateNameLowerCase","distance","levenshteinWithMax","s1","s2","max","previous","Array","current","big","i","c1","charCodeAt","minJ","maxJ","colMin","j","dist","temp","res"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6-common@2.0.17/node_modules/@antv/x6-common/src/string/suggestion.ts"],"sourcesContent":["// @see: https://github.com/microsoft/TypeScript/blob/master/src/compiler/checker.ts\n\n/**\n * Given a name and a list of names that are not equal to the name, return a\n * spelling suggestion if there is one that is close enough. Names less than\n * length 3 only check for case-insensitive equality, not Levenshtein distance.\n *\n * - If there is a candidate that's the same except for case, return that.\n * - If there is a candidate that's within one edit of the name, return that.\n * - Otherwise, return the candidate with the smallest Levenshtein distance,\n *     except for candidates:\n *       * With no name\n *       * Whose length differs from the target name by more than 0.34 of the\n *         length of the name.\n *       * Whose levenshtein distance is more than 0.4 of the length of the\n *         name (0.4 allows 1 substitution/transposition for every 5 characters,\n *         and 1 insertion/deletion at 3 characters)\n */\nexport function getSpellingSuggestion<T>(\n  name: string,\n  candidates: T[],\n  getName: (candidate: T) => string | undefined,\n): T | undefined {\n  const maximumLengthDifference = Math.min(2, Math.floor(name.length * 0.34))\n  // If the best result isn't better than this, don't bother.\n  let bestDistance = Math.floor(name.length * 0.4) + 1\n  let bestCandidate: T | undefined\n  let justCheckExactMatches = false\n  const nameLowerCase = name.toLowerCase()\n\n  // eslint-disable-next-line\n  for (const candidate of candidates) {\n    const candidateName = getName(candidate)\n    if (\n      candidateName !== undefined &&\n      Math.abs(candidateName.length - nameLowerCase.length) <=\n        maximumLengthDifference\n    ) {\n      const candidateNameLowerCase = candidateName.toLowerCase()\n      if (candidateNameLowerCase === nameLowerCase) {\n        if (candidateName === name) {\n          continue\n        }\n        return candidate\n      }\n\n      if (justCheckExactMatches) {\n        continue\n      }\n\n      if (candidateName.length < 3) {\n        // Don't bother, user would have noticed a\n        // 2-character name having an extra character.\n        continue\n      }\n\n      // Only care about a result better than the best so far.\n      const distance = levenshteinWithMax(\n        nameLowerCase,\n        candidateNameLowerCase,\n        bestDistance - 1,\n      )\n\n      if (distance === undefined) {\n        continue\n      }\n\n      if (distance < 3) {\n        justCheckExactMatches = true\n        bestCandidate = candidate\n      } else {\n        // Debug.assert(distance < bestDistance)\n        bestDistance = distance\n        bestCandidate = candidate\n      }\n    }\n  }\n\n  return bestCandidate\n}\nfunction levenshteinWithMax(\n  s1: string,\n  s2: string,\n  max: number,\n): number | undefined {\n  let previous = new Array(s2.length + 1) // eslint-disable-line\n  let current = new Array(s2.length + 1) // eslint-disable-line\n  /** Represents any value > max. We don't care about the particular value. */\n  const big = max + 1\n\n  for (let i = 0; i <= s2.length; i += 1) {\n    previous[i] = i\n  }\n\n  for (let i = 1; i <= s1.length; i += 1) {\n    const c1 = s1.charCodeAt(i - 1)\n    const minJ = i > max ? i - max : 1\n    const maxJ = s2.length > max + i ? max + i : s2.length\n    current[0] = i\n    /** Smallest value of the matrix in the ith column. */\n    let colMin = i\n    for (let j = 1; j < minJ; j += 1) {\n      current[j] = big\n    }\n    for (let j = minJ; j <= maxJ; j += 1) {\n      const dist =\n        c1 === s2.charCodeAt(j - 1)\n          ? previous[j - 1]\n          : Math.min(\n              /* delete */ previous[j] + 1,\n              /* insert */ current[j - 1] + 1,\n              /* substitute */ previous[j - 1] + 2,\n            )\n      current[j] = dist\n      colMin = Math.min(colMin, dist)\n    }\n    for (let j = maxJ + 1; j <= s2.length; j += 1) {\n      current[j] = big\n    }\n    if (colMin > max) {\n      // Give up -- everything in this column is > max\n      // and it can't get better in future columns.\n      return undefined\n    }\n\n    const temp = previous\n    previous = current\n    current = temp\n  }\n\n  const res = previous[s2.length]\n  return res > max ? undefined : res\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}