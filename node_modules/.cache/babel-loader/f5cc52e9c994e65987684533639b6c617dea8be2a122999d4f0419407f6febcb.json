{"ast":null,"code":"import { FunctionExt } from '@antv/x6-common';\nimport { Point, Rectangle } from '@antv/x6-geometry';\nimport { SortedSet } from './sorted-set';\nimport { ObstacleMap } from './obstacle-map';\nimport * as util from './util';\nimport { resolveOptions } from './options';\n/**\n * Finds the route between two points (`from`, `to`).\n */\nfunction findRoute(edgeView, from, to, map, options) {\n  const precision = options.precision;\n  let sourceEndpoint;\n  let targetEndpoint;\n  if (Rectangle.isRectangle(from)) {\n    sourceEndpoint = util.round(util.getSourceEndpoint(edgeView, options).clone(), precision);\n  } else {\n    sourceEndpoint = util.round(from.clone(), precision);\n  }\n  if (Rectangle.isRectangle(to)) {\n    targetEndpoint = util.round(util.getTargetEndpoint(edgeView, options).clone(), precision);\n  } else {\n    targetEndpoint = util.round(to.clone(), precision);\n  }\n  // Get grid for this route.\n  const grid = util.getGrid(options.step, sourceEndpoint, targetEndpoint);\n  // Get pathfinding points.\n  // -----------------------\n  const startPoint = sourceEndpoint;\n  const endPoint = targetEndpoint;\n  let startPoints;\n  let endPoints;\n  if (Rectangle.isRectangle(from)) {\n    startPoints = util.getRectPoints(startPoint, from, options.startDirections, grid, options);\n  } else {\n    startPoints = [startPoint];\n  }\n  if (Rectangle.isRectangle(to)) {\n    endPoints = util.getRectPoints(targetEndpoint, to, options.endDirections, grid, options);\n  } else {\n    endPoints = [endPoint];\n  }\n  // take into account only accessible rect points (those not under obstacles)\n  startPoints = startPoints.filter(p => map.isAccessible(p));\n  endPoints = endPoints.filter(p => map.isAccessible(p));\n  // There is an accessible route point on both sides.\n  if (startPoints.length > 0 && endPoints.length > 0) {\n    const openSet = new SortedSet();\n    // Keeps the actual points for given nodes of the open set.\n    const points = {};\n    // Keeps the point that is immediate predecessor of given element.\n    const parents = {};\n    // Cost from start to a point along best known path.\n    const costs = {};\n    for (let i = 0, n = startPoints.length; i < n; i += 1) {\n      // startPoint is assumed to be aligned already\n      const startPoint = startPoints[i];\n      const key = util.getKey(startPoint);\n      openSet.add(key, util.getCost(startPoint, endPoints));\n      points[key] = startPoint;\n      costs[key] = 0;\n    }\n    const previousRouteDirectionAngle = options.previousDirectionAngle;\n    // undefined for first route\n    const isPathBeginning = previousRouteDirectionAngle === undefined;\n    // directions\n    let direction;\n    let directionChange;\n    const directions = util.getGridOffsets(grid, options);\n    const numDirections = directions.length;\n    const endPointsKeys = endPoints.reduce((res, endPoint) => {\n      const key = util.getKey(endPoint);\n      res.push(key);\n      return res;\n    }, []);\n    // main route finding loop\n    const sameStartEndPoints = Point.equalPoints(startPoints, endPoints);\n    let loopsRemaining = options.maxLoopCount;\n    while (!openSet.isEmpty() && loopsRemaining > 0) {\n      // Get the closest item and mark it CLOSED\n      const currentKey = openSet.pop();\n      const currentPoint = points[currentKey];\n      const currentParent = parents[currentKey];\n      const currentCost = costs[currentKey];\n      const isStartPoint = currentPoint.equals(startPoint);\n      const isRouteBeginning = currentParent == null;\n      let previousDirectionAngle;\n      if (!isRouteBeginning) {\n        previousDirectionAngle = util.getDirectionAngle(currentParent, currentPoint, numDirections, grid, options);\n      } else if (!isPathBeginning) {\n        // a vertex on the route\n        previousDirectionAngle = previousRouteDirectionAngle;\n      } else if (!isStartPoint) {\n        // beginning of route on the path\n        previousDirectionAngle = util.getDirectionAngle(startPoint, currentPoint, numDirections, grid, options);\n      } else {\n        previousDirectionAngle = null;\n      }\n      // Check if we reached any endpoint\n      const skipEndCheck = isRouteBeginning && sameStartEndPoints;\n      if (!skipEndCheck && endPointsKeys.indexOf(currentKey) >= 0) {\n        options.previousDirectionAngle = previousDirectionAngle;\n        return util.reconstructRoute(parents, points, currentPoint, startPoint, endPoint);\n      }\n      // Go over all possible directions and find neighbors\n      for (let i = 0; i < numDirections; i += 1) {\n        direction = directions[i];\n        const directionAngle = direction.angle;\n        directionChange = util.getDirectionChange(previousDirectionAngle, directionAngle);\n        // Don't use the point changed rapidly.\n        if (!(isPathBeginning && isStartPoint) && directionChange > options.maxDirectionChange) {\n          continue;\n        }\n        const neighborPoint = util.align(currentPoint.clone().translate(direction.gridOffsetX || 0, direction.gridOffsetY || 0), grid, precision);\n        const neighborKey = util.getKey(neighborPoint);\n        // Closed points were already evaluated.\n        if (openSet.isClose(neighborKey) || !map.isAccessible(neighborPoint)) {\n          continue;\n        }\n        // Neighbor is an end point.\n        if (endPointsKeys.indexOf(neighborKey) >= 0) {\n          const isEndPoint = neighborPoint.equals(endPoint);\n          if (!isEndPoint) {\n            const endDirectionAngle = util.getDirectionAngle(neighborPoint, endPoint, numDirections, grid, options);\n            const endDirectionChange = util.getDirectionChange(directionAngle, endDirectionAngle);\n            if (endDirectionChange > options.maxDirectionChange) {\n              continue;\n            }\n          }\n        }\n        // The current direction is ok.\n        // ----------------------------\n        const neighborCost = direction.cost;\n        const neighborPenalty = isStartPoint ? 0 : options.penalties[directionChange];\n        const costFromStart = currentCost + neighborCost + neighborPenalty;\n        // Neighbor point has not been processed yet or the cost of\n        // the path from start is lower than previously calculated.\n        if (!openSet.isOpen(neighborKey) || costFromStart < costs[neighborKey]) {\n          points[neighborKey] = neighborPoint;\n          parents[neighborKey] = currentPoint;\n          costs[neighborKey] = costFromStart;\n          openSet.add(neighborKey, costFromStart + util.getCost(neighborPoint, endPoints));\n        }\n      }\n      loopsRemaining -= 1;\n    }\n  }\n  if (options.fallbackRoute) {\n    return FunctionExt.call(options.fallbackRoute, this, startPoint, endPoint, options);\n  }\n  return null;\n}\nfunction snap(vertices, gridSize = 10) {\n  if (vertices.length <= 1) {\n    return vertices;\n  }\n  for (let i = 0, len = vertices.length; i < len - 1; i += 1) {\n    const first = vertices[i];\n    const second = vertices[i + 1];\n    if (first.x === second.x) {\n      const x = gridSize * Math.round(first.x / gridSize);\n      if (first.x !== x) {\n        first.x = x;\n        second.x = x;\n      }\n    } else if (first.y === second.y) {\n      const y = gridSize * Math.round(first.y / gridSize);\n      if (first.y !== y) {\n        first.y = y;\n        second.y = y;\n      }\n    }\n  }\n  return vertices;\n}\nexport const router = function (vertices, optionsRaw, edgeView) {\n  const options = resolveOptions(optionsRaw);\n  const sourceBBox = util.getSourceBBox(edgeView, options);\n  const targetBBox = util.getTargetBBox(edgeView, options);\n  const sourceEndpoint = util.getSourceEndpoint(edgeView, options);\n  // pathfinding\n  const map = new ObstacleMap(options).build(edgeView.graph.model, edgeView.cell);\n  const oldVertices = vertices.map(p => Point.create(p));\n  const newVertices = [];\n  // The origin of first route's grid, does not need snapping\n  let tailPoint = sourceEndpoint;\n  let from;\n  let to;\n  for (let i = 0, len = oldVertices.length; i <= len; i += 1) {\n    let partialRoute = null;\n    from = to || sourceBBox;\n    to = oldVertices[i];\n    // This is the last iteration\n    if (to == null) {\n      to = targetBBox;\n      // If the target is a point, we should use dragging route\n      // instead of main routing method if it has been provided.\n      const edge = edgeView.cell;\n      const isEndingAtPoint = edge.getSourceCellId() == null || edge.getTargetCellId() == null;\n      if (isEndingAtPoint && typeof options.draggingRouter === 'function') {\n        const dragFrom = from === sourceBBox ? sourceEndpoint : from;\n        const dragTo = to.getOrigin();\n        partialRoute = FunctionExt.call(options.draggingRouter, edgeView, dragFrom, dragTo, options);\n      }\n    }\n    // Find the partial route\n    if (partialRoute == null) {\n      partialRoute = findRoute(edgeView, from, to, map, options);\n    }\n    // Cannot found the partial route.\n    if (partialRoute === null) {\n      // eslint-next-line\n      console.warn(`Unable to execute manhattan algorithm, use orth instead`);\n      return FunctionExt.call(options.fallbackRouter, this, vertices, options, edgeView);\n    }\n    // Remove the first point if the previous partial route has\n    // the same point as last.\n    const leadPoint = partialRoute[0];\n    if (leadPoint && leadPoint.equals(tailPoint)) {\n      partialRoute.shift();\n    }\n    // Save tailPoint for next iteration\n    tailPoint = partialRoute[partialRoute.length - 1] || tailPoint;\n    newVertices.push(...partialRoute);\n  }\n  if (options.snapToGrid) {\n    return snap(newVertices, edgeView.graph.grid.getGridSize());\n  }\n  return newVertices;\n};","map":{"version":3,"names":["FunctionExt","Point","Rectangle","SortedSet","ObstacleMap","util","resolveOptions","findRoute","edgeView","from","to","map","options","precision","sourceEndpoint","targetEndpoint","isRectangle","round","getSourceEndpoint","clone","getTargetEndpoint","grid","getGrid","step","startPoint","endPoint","startPoints","endPoints","getRectPoints","startDirections","endDirections","filter","p","isAccessible","length","openSet","points","parents","costs","i","n","key","getKey","add","getCost","previousRouteDirectionAngle","previousDirectionAngle","isPathBeginning","undefined","direction","directionChange","directions","getGridOffsets","numDirections","endPointsKeys","reduce","res","push","sameStartEndPoints","equalPoints","loopsRemaining","maxLoopCount","isEmpty","currentKey","pop","currentPoint","currentParent","currentCost","isStartPoint","equals","isRouteBeginning","getDirectionAngle","skipEndCheck","indexOf","reconstructRoute","directionAngle","angle","getDirectionChange","maxDirectionChange","neighborPoint","align","translate","gridOffsetX","gridOffsetY","neighborKey","isClose","isEndPoint","endDirectionAngle","endDirectionChange","neighborCost","cost","neighborPenalty","penalties","costFromStart","isOpen","fallbackRoute","call","snap","vertices","gridSize","len","first","second","x","Math","y","router","optionsRaw","sourceBBox","getSourceBBox","targetBBox","getTargetBBox","build","graph","model","cell","oldVertices","create","newVertices","tailPoint","partialRoute","edge","isEndingAtPoint","getSourceCellId","getTargetCellId","draggingRouter","dragFrom","dragTo","getOrigin","console","warn","fallbackRouter","leadPoint","shift","snapToGrid","getGridSize"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/src/registry/router/manhattan/router.ts"],"sourcesContent":["import { FunctionExt, KeyValue } from '@antv/x6-common'\nimport { Point, Rectangle } from '@antv/x6-geometry'\nimport { EdgeView } from '../../../view'\nimport { Router } from '../index'\nimport { SortedSet } from './sorted-set'\nimport { ObstacleMap } from './obstacle-map'\nimport * as util from './util'\nimport {\n  resolveOptions,\n  ResolvedOptions,\n  ManhattanRouterOptions,\n} from './options'\n\n/**\n * Finds the route between two points (`from`, `to`).\n */\nfunction findRoute(\n  edgeView: EdgeView,\n  from: Point | Rectangle,\n  to: Point | Rectangle,\n  map: ObstacleMap,\n  options: ResolvedOptions,\n) {\n  const precision = options.precision\n\n  let sourceEndpoint\n  let targetEndpoint\n\n  if (Rectangle.isRectangle(from)) {\n    sourceEndpoint = util.round(\n      util.getSourceEndpoint(edgeView, options).clone(),\n      precision,\n    )\n  } else {\n    sourceEndpoint = util.round(from.clone(), precision)\n  }\n\n  if (Rectangle.isRectangle(to)) {\n    targetEndpoint = util.round(\n      util.getTargetEndpoint(edgeView, options).clone(),\n      precision,\n    )\n  } else {\n    targetEndpoint = util.round(to.clone(), precision)\n  }\n\n  // Get grid for this route.\n  const grid = util.getGrid(options.step, sourceEndpoint, targetEndpoint)\n\n  // Get pathfinding points.\n  // -----------------------\n\n  const startPoint = sourceEndpoint\n  const endPoint = targetEndpoint\n  let startPoints\n  let endPoints\n\n  if (Rectangle.isRectangle(from)) {\n    startPoints = util.getRectPoints(\n      startPoint,\n      from,\n      options.startDirections,\n      grid,\n      options,\n    )\n  } else {\n    startPoints = [startPoint]\n  }\n\n  if (Rectangle.isRectangle(to)) {\n    endPoints = util.getRectPoints(\n      targetEndpoint,\n      to,\n      options.endDirections,\n      grid,\n      options,\n    )\n  } else {\n    endPoints = [endPoint]\n  }\n\n  // take into account only accessible rect points (those not under obstacles)\n  startPoints = startPoints.filter((p) => map.isAccessible(p))\n  endPoints = endPoints.filter((p) => map.isAccessible(p))\n\n  // There is an accessible route point on both sides.\n  if (startPoints.length > 0 && endPoints.length > 0) {\n    const openSet = new SortedSet()\n    // Keeps the actual points for given nodes of the open set.\n    const points: KeyValue<Point> = {}\n    // Keeps the point that is immediate predecessor of given element.\n    const parents: KeyValue<Point> = {}\n    // Cost from start to a point along best known path.\n    const costs: KeyValue<number> = {}\n\n    for (let i = 0, n = startPoints.length; i < n; i += 1) {\n      // startPoint is assumed to be aligned already\n      const startPoint = startPoints[i]\n      const key = util.getKey(startPoint)\n      openSet.add(key, util.getCost(startPoint, endPoints))\n      points[key] = startPoint\n      costs[key] = 0\n    }\n\n    const previousRouteDirectionAngle = options.previousDirectionAngle\n    // undefined for first route\n    const isPathBeginning = previousRouteDirectionAngle === undefined\n\n    // directions\n    let direction\n    let directionChange\n    const directions = util.getGridOffsets(grid, options)\n    const numDirections = directions.length\n    const endPointsKeys = endPoints.reduce<string[]>((res, endPoint) => {\n      const key = util.getKey(endPoint)\n      res.push(key)\n      return res\n    }, [])\n\n    // main route finding loop\n    const sameStartEndPoints = Point.equalPoints(startPoints, endPoints)\n    let loopsRemaining = options.maxLoopCount\n    while (!openSet.isEmpty() && loopsRemaining > 0) {\n      // Get the closest item and mark it CLOSED\n      const currentKey = openSet.pop()!\n      const currentPoint = points[currentKey]\n      const currentParent = parents[currentKey]\n      const currentCost = costs[currentKey]\n\n      const isStartPoint = currentPoint.equals(startPoint)\n      const isRouteBeginning = currentParent == null\n\n      let previousDirectionAngle: number | null | undefined\n      if (!isRouteBeginning) {\n        previousDirectionAngle = util.getDirectionAngle(\n          currentParent,\n          currentPoint,\n          numDirections,\n          grid,\n          options,\n        )\n      } else if (!isPathBeginning) {\n        // a vertex on the route\n        previousDirectionAngle = previousRouteDirectionAngle\n      } else if (!isStartPoint) {\n        // beginning of route on the path\n        previousDirectionAngle = util.getDirectionAngle(\n          startPoint,\n          currentPoint,\n          numDirections,\n          grid,\n          options,\n        )\n      } else {\n        previousDirectionAngle = null\n      }\n\n      // Check if we reached any endpoint\n      const skipEndCheck = isRouteBeginning && sameStartEndPoints\n      if (!skipEndCheck && endPointsKeys.indexOf(currentKey) >= 0) {\n        options.previousDirectionAngle = previousDirectionAngle\n        return util.reconstructRoute(\n          parents,\n          points,\n          currentPoint,\n          startPoint,\n          endPoint,\n        )\n      }\n\n      // Go over all possible directions and find neighbors\n      for (let i = 0; i < numDirections; i += 1) {\n        direction = directions[i]\n\n        const directionAngle = direction.angle!\n        directionChange = util.getDirectionChange(\n          previousDirectionAngle!,\n          directionAngle,\n        )\n\n        // Don't use the point changed rapidly.\n        if (\n          !(isPathBeginning && isStartPoint) &&\n          directionChange > options.maxDirectionChange\n        ) {\n          continue\n        }\n\n        const neighborPoint = util.align(\n          currentPoint\n            .clone()\n            .translate(direction.gridOffsetX || 0, direction.gridOffsetY || 0),\n          grid,\n          precision,\n        )\n        const neighborKey = util.getKey(neighborPoint)\n\n        // Closed points were already evaluated.\n        if (openSet.isClose(neighborKey) || !map.isAccessible(neighborPoint)) {\n          continue\n        }\n\n        // Neighbor is an end point.\n        if (endPointsKeys.indexOf(neighborKey) >= 0) {\n          const isEndPoint = neighborPoint.equals(endPoint)\n          if (!isEndPoint) {\n            const endDirectionAngle = util.getDirectionAngle(\n              neighborPoint,\n              endPoint,\n              numDirections,\n              grid,\n              options,\n            )\n\n            const endDirectionChange = util.getDirectionChange(\n              directionAngle,\n              endDirectionAngle,\n            )\n\n            if (endDirectionChange > options.maxDirectionChange) {\n              continue\n            }\n          }\n        }\n\n        // The current direction is ok.\n        // ----------------------------\n\n        const neighborCost = direction.cost\n        const neighborPenalty = isStartPoint\n          ? 0\n          : options.penalties[directionChange]\n        const costFromStart = currentCost + neighborCost + neighborPenalty\n\n        // Neighbor point has not been processed yet or the cost of\n        // the path from start is lower than previously calculated.\n        if (\n          !openSet.isOpen(neighborKey) ||\n          costFromStart < costs[neighborKey]\n        ) {\n          points[neighborKey] = neighborPoint\n          parents[neighborKey] = currentPoint\n          costs[neighborKey] = costFromStart\n          openSet.add(\n            neighborKey,\n            costFromStart + util.getCost(neighborPoint, endPoints),\n          )\n        }\n      }\n\n      loopsRemaining -= 1\n    }\n  }\n\n  if (options.fallbackRoute) {\n    return FunctionExt.call(\n      options.fallbackRoute,\n      this,\n      startPoint,\n      endPoint,\n      options,\n    )\n  }\n\n  return null\n}\n\nfunction snap(vertices: Point[], gridSize = 10) {\n  if (vertices.length <= 1) {\n    return vertices\n  }\n\n  for (let i = 0, len = vertices.length; i < len - 1; i += 1) {\n    const first = vertices[i]\n    const second = vertices[i + 1]\n    if (first.x === second.x) {\n      const x = gridSize * Math.round(first.x / gridSize)\n      if (first.x !== x) {\n        first.x = x\n        second.x = x\n      }\n    } else if (first.y === second.y) {\n      const y = gridSize * Math.round(first.y / gridSize)\n      if (first.y !== y) {\n        first.y = y\n        second.y = y\n      }\n    }\n  }\n\n  return vertices\n}\n\nexport const router: Router.Definition<ManhattanRouterOptions> = function (\n  vertices,\n  optionsRaw,\n  edgeView,\n) {\n  const options = resolveOptions(optionsRaw)\n  const sourceBBox = util.getSourceBBox(edgeView, options)\n  const targetBBox = util.getTargetBBox(edgeView, options)\n  const sourceEndpoint = util.getSourceEndpoint(edgeView, options)\n\n  // pathfinding\n  const map = new ObstacleMap(options).build(\n    edgeView.graph.model,\n    edgeView.cell,\n  )\n\n  const oldVertices = vertices.map((p) => Point.create(p))\n  const newVertices: Point[] = []\n\n  // The origin of first route's grid, does not need snapping\n  let tailPoint = sourceEndpoint\n\n  let from\n  let to\n\n  for (let i = 0, len = oldVertices.length; i <= len; i += 1) {\n    let partialRoute: Point[] | null = null\n\n    from = to || sourceBBox\n    to = oldVertices[i]\n\n    // This is the last iteration\n    if (to == null) {\n      to = targetBBox\n\n      // If the target is a point, we should use dragging route\n      // instead of main routing method if it has been provided.\n      const edge = edgeView.cell\n      const isEndingAtPoint =\n        edge.getSourceCellId() == null || edge.getTargetCellId() == null\n\n      if (isEndingAtPoint && typeof options.draggingRouter === 'function') {\n        const dragFrom = from === sourceBBox ? sourceEndpoint : from\n        const dragTo = to.getOrigin()\n        partialRoute = FunctionExt.call(\n          options.draggingRouter,\n          edgeView,\n          dragFrom,\n          dragTo,\n          options,\n        )\n      }\n    }\n\n    // Find the partial route\n    if (partialRoute == null) {\n      partialRoute = findRoute(edgeView, from, to, map, options)\n    }\n\n    // Cannot found the partial route.\n    if (partialRoute === null) {\n      // eslint-next-line\n      console.warn(`Unable to execute manhattan algorithm, use orth instead`)\n\n      return FunctionExt.call(\n        options.fallbackRouter,\n        this,\n        vertices,\n        options,\n        edgeView,\n      )\n    }\n\n    // Remove the first point if the previous partial route has\n    // the same point as last.\n    const leadPoint = partialRoute[0]\n    if (leadPoint && leadPoint.equals(tailPoint)) {\n      partialRoute.shift()\n    }\n\n    // Save tailPoint for next iteration\n    tailPoint = partialRoute[partialRoute.length - 1] || tailPoint\n    newVertices.push(...partialRoute)\n  }\n\n  if (options.snapToGrid) {\n    return snap(newVertices, edgeView.graph.grid.getGridSize())\n  }\n\n  return newVertices\n}\n"],"mappings":"AAAA,SAASA,WAAW,QAAkB,iBAAiB;AACvD,SAASC,KAAK,EAAEC,SAAS,QAAQ,mBAAmB;AAGpD,SAASC,SAAS,QAAQ,cAAc;AACxC,SAASC,WAAW,QAAQ,gBAAgB;AAC5C,OAAO,KAAKC,IAAI,MAAM,QAAQ;AAC9B,SACEC,cAAc,QAGT,WAAW;AAElB;;;AAGA,SAASC,SAASA,CAChBC,QAAkB,EAClBC,IAAuB,EACvBC,EAAqB,EACrBC,GAAgB,EAChBC,OAAwB;EAExB,MAAMC,SAAS,GAAGD,OAAO,CAACC,SAAS;EAEnC,IAAIC,cAAc;EAClB,IAAIC,cAAc;EAElB,IAAIb,SAAS,CAACc,WAAW,CAACP,IAAI,CAAC,EAAE;IAC/BK,cAAc,GAAGT,IAAI,CAACY,KAAK,CACzBZ,IAAI,CAACa,iBAAiB,CAACV,QAAQ,EAAEI,OAAO,CAAC,CAACO,KAAK,EAAE,EACjDN,SAAS,CACV;GACF,MAAM;IACLC,cAAc,GAAGT,IAAI,CAACY,KAAK,CAACR,IAAI,CAACU,KAAK,EAAE,EAAEN,SAAS,CAAC;;EAGtD,IAAIX,SAAS,CAACc,WAAW,CAACN,EAAE,CAAC,EAAE;IAC7BK,cAAc,GAAGV,IAAI,CAACY,KAAK,CACzBZ,IAAI,CAACe,iBAAiB,CAACZ,QAAQ,EAAEI,OAAO,CAAC,CAACO,KAAK,EAAE,EACjDN,SAAS,CACV;GACF,MAAM;IACLE,cAAc,GAAGV,IAAI,CAACY,KAAK,CAACP,EAAE,CAACS,KAAK,EAAE,EAAEN,SAAS,CAAC;;EAGpD;EACA,MAAMQ,IAAI,GAAGhB,IAAI,CAACiB,OAAO,CAACV,OAAO,CAACW,IAAI,EAAET,cAAc,EAAEC,cAAc,CAAC;EAEvE;EACA;EAEA,MAAMS,UAAU,GAAGV,cAAc;EACjC,MAAMW,QAAQ,GAAGV,cAAc;EAC/B,IAAIW,WAAW;EACf,IAAIC,SAAS;EAEb,IAAIzB,SAAS,CAACc,WAAW,CAACP,IAAI,CAAC,EAAE;IAC/BiB,WAAW,GAAGrB,IAAI,CAACuB,aAAa,CAC9BJ,UAAU,EACVf,IAAI,EACJG,OAAO,CAACiB,eAAe,EACvBR,IAAI,EACJT,OAAO,CACR;GACF,MAAM;IACLc,WAAW,GAAG,CAACF,UAAU,CAAC;;EAG5B,IAAItB,SAAS,CAACc,WAAW,CAACN,EAAE,CAAC,EAAE;IAC7BiB,SAAS,GAAGtB,IAAI,CAACuB,aAAa,CAC5Bb,cAAc,EACdL,EAAE,EACFE,OAAO,CAACkB,aAAa,EACrBT,IAAI,EACJT,OAAO,CACR;GACF,MAAM;IACLe,SAAS,GAAG,CAACF,QAAQ,CAAC;;EAGxB;EACAC,WAAW,GAAGA,WAAW,CAACK,MAAM,CAAEC,CAAC,IAAKrB,GAAG,CAACsB,YAAY,CAACD,CAAC,CAAC,CAAC;EAC5DL,SAAS,GAAGA,SAAS,CAACI,MAAM,CAAEC,CAAC,IAAKrB,GAAG,CAACsB,YAAY,CAACD,CAAC,CAAC,CAAC;EAExD;EACA,IAAIN,WAAW,CAACQ,MAAM,GAAG,CAAC,IAAIP,SAAS,CAACO,MAAM,GAAG,CAAC,EAAE;IAClD,MAAMC,OAAO,GAAG,IAAIhC,SAAS,EAAE;IAC/B;IACA,MAAMiC,MAAM,GAAoB,EAAE;IAClC;IACA,MAAMC,OAAO,GAAoB,EAAE;IACnC;IACA,MAAMC,KAAK,GAAqB,EAAE;IAElC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGd,WAAW,CAACQ,MAAM,EAAEK,CAAC,GAAGC,CAAC,EAAED,CAAC,IAAI,CAAC,EAAE;MACrD;MACA,MAAMf,UAAU,GAAGE,WAAW,CAACa,CAAC,CAAC;MACjC,MAAME,GAAG,GAAGpC,IAAI,CAACqC,MAAM,CAAClB,UAAU,CAAC;MACnCW,OAAO,CAACQ,GAAG,CAACF,GAAG,EAAEpC,IAAI,CAACuC,OAAO,CAACpB,UAAU,EAAEG,SAAS,CAAC,CAAC;MACrDS,MAAM,CAACK,GAAG,CAAC,GAAGjB,UAAU;MACxBc,KAAK,CAACG,GAAG,CAAC,GAAG,CAAC;;IAGhB,MAAMI,2BAA2B,GAAGjC,OAAO,CAACkC,sBAAsB;IAClE;IACA,MAAMC,eAAe,GAAGF,2BAA2B,KAAKG,SAAS;IAEjE;IACA,IAAIC,SAAS;IACb,IAAIC,eAAe;IACnB,MAAMC,UAAU,GAAG9C,IAAI,CAAC+C,cAAc,CAAC/B,IAAI,EAAET,OAAO,CAAC;IACrD,MAAMyC,aAAa,GAAGF,UAAU,CAACjB,MAAM;IACvC,MAAMoB,aAAa,GAAG3B,SAAS,CAAC4B,MAAM,CAAW,CAACC,GAAG,EAAE/B,QAAQ,KAAI;MACjE,MAAMgB,GAAG,GAAGpC,IAAI,CAACqC,MAAM,CAACjB,QAAQ,CAAC;MACjC+B,GAAG,CAACC,IAAI,CAAChB,GAAG,CAAC;MACb,OAAOe,GAAG;IACZ,CAAC,EAAE,EAAE,CAAC;IAEN;IACA,MAAME,kBAAkB,GAAGzD,KAAK,CAAC0D,WAAW,CAACjC,WAAW,EAAEC,SAAS,CAAC;IACpE,IAAIiC,cAAc,GAAGhD,OAAO,CAACiD,YAAY;IACzC,OAAO,CAAC1B,OAAO,CAAC2B,OAAO,EAAE,IAAIF,cAAc,GAAG,CAAC,EAAE;MAC/C;MACA,MAAMG,UAAU,GAAG5B,OAAO,CAAC6B,GAAG,EAAG;MACjC,MAAMC,YAAY,GAAG7B,MAAM,CAAC2B,UAAU,CAAC;MACvC,MAAMG,aAAa,GAAG7B,OAAO,CAAC0B,UAAU,CAAC;MACzC,MAAMI,WAAW,GAAG7B,KAAK,CAACyB,UAAU,CAAC;MAErC,MAAMK,YAAY,GAAGH,YAAY,CAACI,MAAM,CAAC7C,UAAU,CAAC;MACpD,MAAM8C,gBAAgB,GAAGJ,aAAa,IAAI,IAAI;MAE9C,IAAIpB,sBAAiD;MACrD,IAAI,CAACwB,gBAAgB,EAAE;QACrBxB,sBAAsB,GAAGzC,IAAI,CAACkE,iBAAiB,CAC7CL,aAAa,EACbD,YAAY,EACZZ,aAAa,EACbhC,IAAI,EACJT,OAAO,CACR;OACF,MAAM,IAAI,CAACmC,eAAe,EAAE;QAC3B;QACAD,sBAAsB,GAAGD,2BAA2B;OACrD,MAAM,IAAI,CAACuB,YAAY,EAAE;QACxB;QACAtB,sBAAsB,GAAGzC,IAAI,CAACkE,iBAAiB,CAC7C/C,UAAU,EACVyC,YAAY,EACZZ,aAAa,EACbhC,IAAI,EACJT,OAAO,CACR;OACF,MAAM;QACLkC,sBAAsB,GAAG,IAAI;;MAG/B;MACA,MAAM0B,YAAY,GAAGF,gBAAgB,IAAIZ,kBAAkB;MAC3D,IAAI,CAACc,YAAY,IAAIlB,aAAa,CAACmB,OAAO,CAACV,UAAU,CAAC,IAAI,CAAC,EAAE;QAC3DnD,OAAO,CAACkC,sBAAsB,GAAGA,sBAAsB;QACvD,OAAOzC,IAAI,CAACqE,gBAAgB,CAC1BrC,OAAO,EACPD,MAAM,EACN6B,YAAY,EACZzC,UAAU,EACVC,QAAQ,CACT;;MAGH;MACA,KAAK,IAAIc,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGc,aAAa,EAAEd,CAAC,IAAI,CAAC,EAAE;QACzCU,SAAS,GAAGE,UAAU,CAACZ,CAAC,CAAC;QAEzB,MAAMoC,cAAc,GAAG1B,SAAS,CAAC2B,KAAM;QACvC1B,eAAe,GAAG7C,IAAI,CAACwE,kBAAkB,CACvC/B,sBAAuB,EACvB6B,cAAc,CACf;QAED;QACA,IACE,EAAE5B,eAAe,IAAIqB,YAAY,CAAC,IAClClB,eAAe,GAAGtC,OAAO,CAACkE,kBAAkB,EAC5C;UACA;;QAGF,MAAMC,aAAa,GAAG1E,IAAI,CAAC2E,KAAK,CAC9Bf,YAAY,CACT9C,KAAK,EAAE,CACP8D,SAAS,CAAChC,SAAS,CAACiC,WAAW,IAAI,CAAC,EAAEjC,SAAS,CAACkC,WAAW,IAAI,CAAC,CAAC,EACpE9D,IAAI,EACJR,SAAS,CACV;QACD,MAAMuE,WAAW,GAAG/E,IAAI,CAACqC,MAAM,CAACqC,aAAa,CAAC;QAE9C;QACA,IAAI5C,OAAO,CAACkD,OAAO,CAACD,WAAW,CAAC,IAAI,CAACzE,GAAG,CAACsB,YAAY,CAAC8C,aAAa,CAAC,EAAE;UACpE;;QAGF;QACA,IAAIzB,aAAa,CAACmB,OAAO,CAACW,WAAW,CAAC,IAAI,CAAC,EAAE;UAC3C,MAAME,UAAU,GAAGP,aAAa,CAACV,MAAM,CAAC5C,QAAQ,CAAC;UACjD,IAAI,CAAC6D,UAAU,EAAE;YACf,MAAMC,iBAAiB,GAAGlF,IAAI,CAACkE,iBAAiB,CAC9CQ,aAAa,EACbtD,QAAQ,EACR4B,aAAa,EACbhC,IAAI,EACJT,OAAO,CACR;YAED,MAAM4E,kBAAkB,GAAGnF,IAAI,CAACwE,kBAAkB,CAChDF,cAAc,EACdY,iBAAiB,CAClB;YAED,IAAIC,kBAAkB,GAAG5E,OAAO,CAACkE,kBAAkB,EAAE;cACnD;;;;QAKN;QACA;QAEA,MAAMW,YAAY,GAAGxC,SAAS,CAACyC,IAAI;QACnC,MAAMC,eAAe,GAAGvB,YAAY,GAChC,CAAC,GACDxD,OAAO,CAACgF,SAAS,CAAC1C,eAAe,CAAC;QACtC,MAAM2C,aAAa,GAAG1B,WAAW,GAAGsB,YAAY,GAAGE,eAAe;QAElE;QACA;QACA,IACE,CAACxD,OAAO,CAAC2D,MAAM,CAACV,WAAW,CAAC,IAC5BS,aAAa,GAAGvD,KAAK,CAAC8C,WAAW,CAAC,EAClC;UACAhD,MAAM,CAACgD,WAAW,CAAC,GAAGL,aAAa;UACnC1C,OAAO,CAAC+C,WAAW,CAAC,GAAGnB,YAAY;UACnC3B,KAAK,CAAC8C,WAAW,CAAC,GAAGS,aAAa;UAClC1D,OAAO,CAACQ,GAAG,CACTyC,WAAW,EACXS,aAAa,GAAGxF,IAAI,CAACuC,OAAO,CAACmC,aAAa,EAAEpD,SAAS,CAAC,CACvD;;;MAILiC,cAAc,IAAI,CAAC;;;EAIvB,IAAIhD,OAAO,CAACmF,aAAa,EAAE;IACzB,OAAO/F,WAAW,CAACgG,IAAI,CACrBpF,OAAO,CAACmF,aAAa,EACrB,IAAI,EACJvE,UAAU,EACVC,QAAQ,EACRb,OAAO,CACR;;EAGH,OAAO,IAAI;AACb;AAEA,SAASqF,IAAIA,CAACC,QAAiB,EAAEC,QAAQ,GAAG,EAAE;EAC5C,IAAID,QAAQ,CAAChE,MAAM,IAAI,CAAC,EAAE;IACxB,OAAOgE,QAAQ;;EAGjB,KAAK,IAAI3D,CAAC,GAAG,CAAC,EAAE6D,GAAG,GAAGF,QAAQ,CAAChE,MAAM,EAAEK,CAAC,GAAG6D,GAAG,GAAG,CAAC,EAAE7D,CAAC,IAAI,CAAC,EAAE;IAC1D,MAAM8D,KAAK,GAAGH,QAAQ,CAAC3D,CAAC,CAAC;IACzB,MAAM+D,MAAM,GAAGJ,QAAQ,CAAC3D,CAAC,GAAG,CAAC,CAAC;IAC9B,IAAI8D,KAAK,CAACE,CAAC,KAAKD,MAAM,CAACC,CAAC,EAAE;MACxB,MAAMA,CAAC,GAAGJ,QAAQ,GAAGK,IAAI,CAACvF,KAAK,CAACoF,KAAK,CAACE,CAAC,GAAGJ,QAAQ,CAAC;MACnD,IAAIE,KAAK,CAACE,CAAC,KAAKA,CAAC,EAAE;QACjBF,KAAK,CAACE,CAAC,GAAGA,CAAC;QACXD,MAAM,CAACC,CAAC,GAAGA,CAAC;;KAEf,MAAM,IAAIF,KAAK,CAACI,CAAC,KAAKH,MAAM,CAACG,CAAC,EAAE;MAC/B,MAAMA,CAAC,GAAGN,QAAQ,GAAGK,IAAI,CAACvF,KAAK,CAACoF,KAAK,CAACI,CAAC,GAAGN,QAAQ,CAAC;MACnD,IAAIE,KAAK,CAACI,CAAC,KAAKA,CAAC,EAAE;QACjBJ,KAAK,CAACI,CAAC,GAAGA,CAAC;QACXH,MAAM,CAACG,CAAC,GAAGA,CAAC;;;;EAKlB,OAAOP,QAAQ;AACjB;AAEA,OAAO,MAAMQ,MAAM,GAA8C,SAAAA,CAC/DR,QAAQ,EACRS,UAAU,EACVnG,QAAQ;EAER,MAAMI,OAAO,GAAGN,cAAc,CAACqG,UAAU,CAAC;EAC1C,MAAMC,UAAU,GAAGvG,IAAI,CAACwG,aAAa,CAACrG,QAAQ,EAAEI,OAAO,CAAC;EACxD,MAAMkG,UAAU,GAAGzG,IAAI,CAAC0G,aAAa,CAACvG,QAAQ,EAAEI,OAAO,CAAC;EACxD,MAAME,cAAc,GAAGT,IAAI,CAACa,iBAAiB,CAACV,QAAQ,EAAEI,OAAO,CAAC;EAEhE;EACA,MAAMD,GAAG,GAAG,IAAIP,WAAW,CAACQ,OAAO,CAAC,CAACoG,KAAK,CACxCxG,QAAQ,CAACyG,KAAK,CAACC,KAAK,EACpB1G,QAAQ,CAAC2G,IAAI,CACd;EAED,MAAMC,WAAW,GAAGlB,QAAQ,CAACvF,GAAG,CAAEqB,CAAC,IAAK/B,KAAK,CAACoH,MAAM,CAACrF,CAAC,CAAC,CAAC;EACxD,MAAMsF,WAAW,GAAY,EAAE;EAE/B;EACA,IAAIC,SAAS,GAAGzG,cAAc;EAE9B,IAAIL,IAAI;EACR,IAAIC,EAAE;EAEN,KAAK,IAAI6B,CAAC,GAAG,CAAC,EAAE6D,GAAG,GAAGgB,WAAW,CAAClF,MAAM,EAAEK,CAAC,IAAI6D,GAAG,EAAE7D,CAAC,IAAI,CAAC,EAAE;IAC1D,IAAIiF,YAAY,GAAmB,IAAI;IAEvC/G,IAAI,GAAGC,EAAE,IAAIkG,UAAU;IACvBlG,EAAE,GAAG0G,WAAW,CAAC7E,CAAC,CAAC;IAEnB;IACA,IAAI7B,EAAE,IAAI,IAAI,EAAE;MACdA,EAAE,GAAGoG,UAAU;MAEf;MACA;MACA,MAAMW,IAAI,GAAGjH,QAAQ,CAAC2G,IAAI;MAC1B,MAAMO,eAAe,GACnBD,IAAI,CAACE,eAAe,EAAE,IAAI,IAAI,IAAIF,IAAI,CAACG,eAAe,EAAE,IAAI,IAAI;MAElE,IAAIF,eAAe,IAAI,OAAO9G,OAAO,CAACiH,cAAc,KAAK,UAAU,EAAE;QACnE,MAAMC,QAAQ,GAAGrH,IAAI,KAAKmG,UAAU,GAAG9F,cAAc,GAAGL,IAAI;QAC5D,MAAMsH,MAAM,GAAGrH,EAAE,CAACsH,SAAS,EAAE;QAC7BR,YAAY,GAAGxH,WAAW,CAACgG,IAAI,CAC7BpF,OAAO,CAACiH,cAAc,EACtBrH,QAAQ,EACRsH,QAAQ,EACRC,MAAM,EACNnH,OAAO,CACR;;;IAIL;IACA,IAAI4G,YAAY,IAAI,IAAI,EAAE;MACxBA,YAAY,GAAGjH,SAAS,CAACC,QAAQ,EAAEC,IAAI,EAAEC,EAAE,EAAEC,GAAG,EAAEC,OAAO,CAAC;;IAG5D;IACA,IAAI4G,YAAY,KAAK,IAAI,EAAE;MACzB;MACAS,OAAO,CAACC,IAAI,CAAC,yDAAyD,CAAC;MAEvE,OAAOlI,WAAW,CAACgG,IAAI,CACrBpF,OAAO,CAACuH,cAAc,EACtB,IAAI,EACJjC,QAAQ,EACRtF,OAAO,EACPJ,QAAQ,CACT;;IAGH;IACA;IACA,MAAM4H,SAAS,GAAGZ,YAAY,CAAC,CAAC,CAAC;IACjC,IAAIY,SAAS,IAAIA,SAAS,CAAC/D,MAAM,CAACkD,SAAS,CAAC,EAAE;MAC5CC,YAAY,CAACa,KAAK,EAAE;;IAGtB;IACAd,SAAS,GAAGC,YAAY,CAACA,YAAY,CAACtF,MAAM,GAAG,CAAC,CAAC,IAAIqF,SAAS;IAC9DD,WAAW,CAAC7D,IAAI,CAAC,GAAG+D,YAAY,CAAC;;EAGnC,IAAI5G,OAAO,CAAC0H,UAAU,EAAE;IACtB,OAAOrC,IAAI,CAACqB,WAAW,EAAE9G,QAAQ,CAACyG,KAAK,CAAC5F,IAAI,CAACkH,WAAW,EAAE,CAAC;;EAG7D,OAAOjB,WAAW;AACpB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}