{"ast":null,"code":"/* eslint-disable no-underscore-dangle */\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { ArrayExt, StringExt, ObjectExt, FunctionExt, Basecoat } from '@antv/x6-common';\nimport { Rectangle, Point } from '@antv/x6-geometry';\nimport { Attr } from '../registry';\nimport { Store } from './store';\nimport { Animation } from './animation';\nexport class Cell extends Basecoat {\n  static config(presets) {\n    const {\n        markup,\n        propHooks,\n        attrHooks\n      } = presets,\n      others = __rest(presets, [\"markup\", \"propHooks\", \"attrHooks\"]);\n    if (markup != null) {\n      this.markup = markup;\n    }\n    if (propHooks) {\n      this.propHooks = this.propHooks.slice();\n      if (Array.isArray(propHooks)) {\n        this.propHooks.push(...propHooks);\n      } else if (typeof propHooks === 'function') {\n        this.propHooks.push(propHooks);\n      } else {\n        Object.values(propHooks).forEach(hook => {\n          if (typeof hook === 'function') {\n            this.propHooks.push(hook);\n          }\n        });\n      }\n    }\n    if (attrHooks) {\n      this.attrHooks = Object.assign(Object.assign({}, this.attrHooks), attrHooks);\n    }\n    this.defaults = ObjectExt.merge({}, this.defaults, others);\n  }\n  static getMarkup() {\n    return this.markup;\n  }\n  static getDefaults(raw) {\n    return raw ? this.defaults : ObjectExt.cloneDeep(this.defaults);\n  }\n  static getAttrHooks() {\n    return this.attrHooks;\n  }\n  static applyPropHooks(cell, metadata) {\n    return this.propHooks.reduce((memo, hook) => {\n      return hook ? FunctionExt.call(hook, cell, memo) : memo;\n    }, metadata);\n  }\n  // #endregion\n  get [Symbol.toStringTag]() {\n    return Cell.toStringTag;\n  }\n  constructor(metadata = {}) {\n    super();\n    const ctor = this.constructor;\n    const defaults = ctor.getDefaults(true);\n    const props = ObjectExt.merge({}, this.preprocess(defaults), this.preprocess(metadata));\n    this.id = props.id || StringExt.uuid();\n    this.store = new Store(props);\n    this.animation = new Animation(this);\n    this.setup();\n    this.init();\n    this.postprocess(metadata);\n  }\n  init() {}\n  // #region model\n  get model() {\n    return this._model;\n  }\n  set model(model) {\n    if (this._model !== model) {\n      this._model = model;\n    }\n  }\n  // #endregion\n  preprocess(metadata, ignoreIdCheck) {\n    const id = metadata.id;\n    const ctor = this.constructor;\n    const props = ctor.applyPropHooks(this, metadata);\n    if (id == null && ignoreIdCheck !== true) {\n      props.id = StringExt.uuid();\n    }\n    return props;\n  }\n  postprocess(metadata) {} // eslint-disable-line\n  setup() {\n    this.store.on('change:*', metadata => {\n      const {\n        key,\n        current,\n        previous,\n        options\n      } = metadata;\n      this.notify('change:*', {\n        key,\n        options,\n        current,\n        previous,\n        cell: this\n      });\n      this.notify(`change:${key}`, {\n        options,\n        current,\n        previous,\n        cell: this\n      });\n      const type = key;\n      if (type === 'source' || type === 'target') {\n        this.notify(`change:terminal`, {\n          type,\n          current,\n          previous,\n          options,\n          cell: this\n        });\n      }\n    });\n    this.store.on('changed', ({\n      options\n    }) => this.notify('changed', {\n      options,\n      cell: this\n    }));\n  }\n  notify(name, args) {\n    this.trigger(name, args);\n    const model = this.model;\n    if (model) {\n      model.notify(`cell:${name}`, args);\n      if (this.isNode()) {\n        model.notify(`node:${name}`, Object.assign(Object.assign({}, args), {\n          node: this\n        }));\n      } else if (this.isEdge()) {\n        model.notify(`edge:${name}`, Object.assign(Object.assign({}, args), {\n          edge: this\n        }));\n      }\n    }\n    return this;\n  }\n  isNode() {\n    return false;\n  }\n  isEdge() {\n    return false;\n  }\n  isSameStore(cell) {\n    return this.store === cell.store;\n  }\n  get view() {\n    return this.store.get('view');\n  }\n  get shape() {\n    return this.store.get('shape', '');\n  }\n  getProp(key, defaultValue) {\n    if (key == null) {\n      return this.store.get();\n    }\n    return this.store.get(key, defaultValue);\n  }\n  setProp(key, value, options) {\n    if (typeof key === 'string') {\n      this.store.set(key, value, options);\n    } else {\n      const props = this.preprocess(key, true);\n      this.store.set(ObjectExt.merge({}, this.getProp(), props), value);\n      this.postprocess(key);\n    }\n    return this;\n  }\n  removeProp(key, options) {\n    if (typeof key === 'string' || Array.isArray(key)) {\n      this.store.removeByPath(key, options);\n    } else {\n      this.store.remove(options);\n    }\n    return this;\n  }\n  hasChanged(key) {\n    return key == null ? this.store.hasChanged() : this.store.hasChanged(key);\n  }\n  getPropByPath(path) {\n    return this.store.getByPath(path);\n  }\n  setPropByPath(path, value, options = {}) {\n    if (this.model) {\n      // update inner reference\n      if (path === 'children') {\n        this._children = value ? value.map(id => this.model.getCell(id)).filter(child => child != null) : null;\n      } else if (path === 'parent') {\n        this._parent = value ? this.model.getCell(value) : null;\n      }\n    }\n    this.store.setByPath(path, value, options);\n    return this;\n  }\n  removePropByPath(path, options = {}) {\n    const paths = Array.isArray(path) ? path : path.split('/');\n    // Once a property is removed from the `attrs` the CellView will\n    // recognize a `dirty` flag and re-render itself in order to remove\n    // the attribute from SVGElement.\n    if (paths[0] === 'attrs') {\n      options.dirty = true;\n    }\n    this.store.removeByPath(paths, options);\n    return this;\n  }\n  prop(key, value, options) {\n    if (key == null) {\n      return this.getProp();\n    }\n    if (typeof key === 'string' || Array.isArray(key)) {\n      if (arguments.length === 1) {\n        return this.getPropByPath(key);\n      }\n      if (value == null) {\n        return this.removePropByPath(key, options || {});\n      }\n      return this.setPropByPath(key, value, options || {});\n    }\n    return this.setProp(key, value || {});\n  }\n  previous(name) {\n    return this.store.getPrevious(name);\n  }\n  // #endregion\n  // #region zIndex\n  get zIndex() {\n    return this.getZIndex();\n  }\n  set zIndex(z) {\n    if (z == null) {\n      this.removeZIndex();\n    } else {\n      this.setZIndex(z);\n    }\n  }\n  getZIndex() {\n    return this.store.get('zIndex');\n  }\n  setZIndex(z, options = {}) {\n    this.store.set('zIndex', z, options);\n    return this;\n  }\n  removeZIndex(options = {}) {\n    this.store.remove('zIndex', options);\n    return this;\n  }\n  toFront(options = {}) {\n    const model = this.model;\n    if (model) {\n      let z = model.getMaxZIndex();\n      let cells;\n      if (options.deep) {\n        cells = this.getDescendants({\n          deep: true,\n          breadthFirst: true\n        });\n        cells.unshift(this);\n      } else {\n        cells = [this];\n      }\n      z = z - cells.length + 1;\n      const count = model.total();\n      let changed = model.indexOf(this) !== count - cells.length;\n      if (!changed) {\n        changed = cells.some((cell, index) => cell.getZIndex() !== z + index);\n      }\n      if (changed) {\n        this.batchUpdate('to-front', () => {\n          z += cells.length;\n          cells.forEach((cell, index) => {\n            cell.setZIndex(z + index, options);\n          });\n        });\n      }\n    }\n    return this;\n  }\n  toBack(options = {}) {\n    const model = this.model;\n    if (model) {\n      let z = model.getMinZIndex();\n      let cells;\n      if (options.deep) {\n        cells = this.getDescendants({\n          deep: true,\n          breadthFirst: true\n        });\n        cells.unshift(this);\n      } else {\n        cells = [this];\n      }\n      let changed = model.indexOf(this) !== 0;\n      if (!changed) {\n        changed = cells.some((cell, index) => cell.getZIndex() !== z + index);\n      }\n      if (changed) {\n        this.batchUpdate('to-back', () => {\n          z -= cells.length;\n          cells.forEach((cell, index) => {\n            cell.setZIndex(z + index, options);\n          });\n        });\n      }\n    }\n    return this;\n  }\n  // #endregion\n  // #region markup\n  get markup() {\n    return this.getMarkup();\n  }\n  set markup(value) {\n    if (value == null) {\n      this.removeMarkup();\n    } else {\n      this.setMarkup(value);\n    }\n  }\n  getMarkup() {\n    let markup = this.store.get('markup');\n    if (markup == null) {\n      const ctor = this.constructor;\n      markup = ctor.getMarkup();\n    }\n    return markup;\n  }\n  setMarkup(markup, options = {}) {\n    this.store.set('markup', markup, options);\n    return this;\n  }\n  removeMarkup(options = {}) {\n    this.store.remove('markup', options);\n    return this;\n  }\n  // #endregion\n  // #region attrs\n  get attrs() {\n    return this.getAttrs();\n  }\n  set attrs(value) {\n    if (value == null) {\n      this.removeAttrs();\n    } else {\n      this.setAttrs(value);\n    }\n  }\n  getAttrs() {\n    const result = this.store.get('attrs');\n    return result ? Object.assign({}, result) : {};\n  }\n  setAttrs(attrs, options = {}) {\n    if (attrs == null) {\n      this.removeAttrs(options);\n    } else {\n      const set = attrs => this.store.set('attrs', attrs, options);\n      if (options.overwrite === true) {\n        set(attrs);\n      } else {\n        const prev = this.getAttrs();\n        if (options.deep === false) {\n          set(Object.assign(Object.assign({}, prev), attrs));\n        } else {\n          set(ObjectExt.merge({}, prev, attrs));\n        }\n      }\n    }\n    return this;\n  }\n  replaceAttrs(attrs, options = {}) {\n    return this.setAttrs(attrs, Object.assign(Object.assign({}, options), {\n      overwrite: true\n    }));\n  }\n  updateAttrs(attrs, options = {}) {\n    return this.setAttrs(attrs, Object.assign(Object.assign({}, options), {\n      deep: false\n    }));\n  }\n  removeAttrs(options = {}) {\n    this.store.remove('attrs', options);\n    return this;\n  }\n  getAttrDefinition(attrName) {\n    if (!attrName) {\n      return null;\n    }\n    const ctor = this.constructor;\n    const hooks = ctor.getAttrHooks() || {};\n    let definition = hooks[attrName] || Attr.registry.get(attrName);\n    if (!definition) {\n      const name = StringExt.camelCase(attrName);\n      definition = hooks[name] || Attr.registry.get(name);\n    }\n    return definition || null;\n  }\n  getAttrByPath(path) {\n    if (path == null || path === '') {\n      return this.getAttrs();\n    }\n    return this.getPropByPath(this.prefixAttrPath(path));\n  }\n  setAttrByPath(path, value, options = {}) {\n    this.setPropByPath(this.prefixAttrPath(path), value, options);\n    return this;\n  }\n  removeAttrByPath(path, options = {}) {\n    this.removePropByPath(this.prefixAttrPath(path), options);\n    return this;\n  }\n  prefixAttrPath(path) {\n    return Array.isArray(path) ? ['attrs'].concat(path) : `attrs/${path}`;\n  }\n  attr(path, value, options) {\n    if (path == null) {\n      return this.getAttrByPath();\n    }\n    if (typeof path === 'string' || Array.isArray(path)) {\n      if (arguments.length === 1) {\n        return this.getAttrByPath(path);\n      }\n      if (value == null) {\n        return this.removeAttrByPath(path, options || {});\n      }\n      return this.setAttrByPath(path, value, options || {});\n    }\n    return this.setAttrs(path, value || {});\n  }\n  // #endregion\n  // #region visible\n  get visible() {\n    return this.isVisible();\n  }\n  set visible(value) {\n    this.setVisible(value);\n  }\n  setVisible(visible, options = {}) {\n    this.store.set('visible', visible, options);\n    return this;\n  }\n  isVisible() {\n    return this.store.get('visible') !== false;\n  }\n  show(options = {}) {\n    if (!this.isVisible()) {\n      this.setVisible(true, options);\n    }\n    return this;\n  }\n  hide(options = {}) {\n    if (this.isVisible()) {\n      this.setVisible(false, options);\n    }\n    return this;\n  }\n  toggleVisible(isVisible, options = {}) {\n    const visible = typeof isVisible === 'boolean' ? isVisible : !this.isVisible();\n    const localOptions = typeof isVisible === 'boolean' ? options : isVisible;\n    if (visible) {\n      this.show(localOptions);\n    } else {\n      this.hide(localOptions);\n    }\n    return this;\n  }\n  // #endregion\n  // #region data\n  get data() {\n    return this.getData();\n  }\n  set data(val) {\n    this.setData(val);\n  }\n  getData() {\n    return this.store.get('data');\n  }\n  setData(data, options = {}) {\n    if (data == null) {\n      this.removeData(options);\n    } else {\n      const set = data => this.store.set('data', data, options);\n      if (options.overwrite === true) {\n        set(data);\n      } else {\n        const prev = this.getData();\n        if (options.deep === false) {\n          set(typeof data === 'object' ? Object.assign(Object.assign({}, prev), data) : data);\n        } else {\n          set(ObjectExt.merge({}, prev, data));\n        }\n      }\n    }\n    return this;\n  }\n  replaceData(data, options = {}) {\n    return this.setData(data, Object.assign(Object.assign({}, options), {\n      overwrite: true\n    }));\n  }\n  updateData(data, options = {}) {\n    return this.setData(data, Object.assign(Object.assign({}, options), {\n      deep: false\n    }));\n  }\n  removeData(options = {}) {\n    this.store.remove('data', options);\n    return this;\n  }\n  // #endregion\n  // #region parent children\n  get parent() {\n    return this.getParent();\n  }\n  get children() {\n    return this.getChildren();\n  }\n  getParentId() {\n    return this.store.get('parent');\n  }\n  getParent() {\n    const parentId = this.getParentId();\n    if (parentId && this.model) {\n      const parent = this.model.getCell(parentId);\n      this._parent = parent;\n      return parent;\n    }\n    return null;\n  }\n  getChildren() {\n    const childrenIds = this.store.get('children');\n    if (childrenIds && childrenIds.length && this.model) {\n      const children = childrenIds.map(id => {\n        var _a;\n        return (_a = this.model) === null || _a === void 0 ? void 0 : _a.getCell(id);\n      }).filter(cell => cell != null);\n      this._children = children;\n      return [...children];\n    }\n    return null;\n  }\n  hasParent() {\n    return this.parent != null;\n  }\n  isParentOf(child) {\n    return child != null && child.getParent() === this;\n  }\n  isChildOf(parent) {\n    return parent != null && this.getParent() === parent;\n  }\n  eachChild(iterator, context) {\n    if (this.children) {\n      this.children.forEach(iterator, context);\n    }\n    return this;\n  }\n  filterChild(filter, context) {\n    return this.children ? this.children.filter(filter, context) : [];\n  }\n  getChildCount() {\n    return this.children == null ? 0 : this.children.length;\n  }\n  getChildIndex(child) {\n    return this.children == null ? -1 : this.children.indexOf(child);\n  }\n  getChildAt(index) {\n    return this.children != null && index >= 0 ? this.children[index] : null;\n  }\n  getAncestors(options = {}) {\n    const ancestors = [];\n    let parent = this.getParent();\n    while (parent) {\n      ancestors.push(parent);\n      parent = options.deep !== false ? parent.getParent() : null;\n    }\n    return ancestors;\n  }\n  getDescendants(options = {}) {\n    if (options.deep !== false) {\n      // breadth first\n      if (options.breadthFirst) {\n        const cells = [];\n        const queue = this.getChildren() || [];\n        while (queue.length > 0) {\n          const parent = queue.shift();\n          const children = parent.getChildren();\n          cells.push(parent);\n          if (children) {\n            queue.push(...children);\n          }\n        }\n        return cells;\n      }\n      // depth first\n      {\n        const cells = this.getChildren() || [];\n        cells.forEach(cell => {\n          cells.push(...cell.getDescendants(options));\n        });\n        return cells;\n      }\n    }\n    return this.getChildren() || [];\n  }\n  isDescendantOf(ancestor, options = {}) {\n    if (ancestor == null) {\n      return false;\n    }\n    if (options.deep !== false) {\n      let current = this.getParent();\n      while (current) {\n        if (current === ancestor) {\n          return true;\n        }\n        current = current.getParent();\n      }\n      return false;\n    }\n    return this.isChildOf(ancestor);\n  }\n  isAncestorOf(descendant, options = {}) {\n    if (descendant == null) {\n      return false;\n    }\n    return descendant.isDescendantOf(this, options);\n  }\n  contains(cell) {\n    return this.isAncestorOf(cell);\n  }\n  getCommonAncestor(...cells) {\n    return Cell.getCommonAncestor(this, ...cells);\n  }\n  setParent(parent, options = {}) {\n    this._parent = parent;\n    if (parent) {\n      this.store.set('parent', parent.id, options);\n    } else {\n      this.store.remove('parent', options);\n    }\n    return this;\n  }\n  setChildren(children, options = {}) {\n    this._children = children;\n    if (children != null) {\n      this.store.set('children', children.map(child => child.id), options);\n    } else {\n      this.store.remove('children', options);\n    }\n    return this;\n  }\n  unembed(child, options = {}) {\n    const children = this.children;\n    if (children != null && child != null) {\n      const index = this.getChildIndex(child);\n      if (index !== -1) {\n        children.splice(index, 1);\n        child.setParent(null, options);\n        this.setChildren(children, options);\n      }\n    }\n    return this;\n  }\n  embed(child, options = {}) {\n    child.addTo(this, options);\n    return this;\n  }\n  addTo(target, options = {}) {\n    if (Cell.isCell(target)) {\n      target.addChild(this, options);\n    } else {\n      target.addCell(this, options);\n    }\n    return this;\n  }\n  insertTo(parent, index, options = {}) {\n    parent.insertChild(this, index, options);\n    return this;\n  }\n  addChild(child, options = {}) {\n    return this.insertChild(child, undefined, options);\n  }\n  insertChild(child, index, options = {}) {\n    if (child != null && child !== this) {\n      const oldParent = child.getParent();\n      const changed = this !== oldParent;\n      let pos = index;\n      if (pos == null) {\n        pos = this.getChildCount();\n        if (!changed) {\n          pos -= 1;\n        }\n      }\n      // remove from old parent\n      if (oldParent) {\n        const children = oldParent.getChildren();\n        if (children) {\n          const index = children.indexOf(child);\n          if (index >= 0) {\n            child.setParent(null, options);\n            children.splice(index, 1);\n            oldParent.setChildren(children, options);\n          }\n        }\n      }\n      let children = this.children;\n      if (children == null) {\n        children = [];\n        children.push(child);\n      } else {\n        children.splice(pos, 0, child);\n      }\n      child.setParent(this, options);\n      this.setChildren(children, options);\n      if (changed && this.model) {\n        const incomings = this.model.getIncomingEdges(this);\n        const outgoings = this.model.getOutgoingEdges(this);\n        if (incomings) {\n          incomings.forEach(edge => edge.updateParent(options));\n        }\n        if (outgoings) {\n          outgoings.forEach(edge => edge.updateParent(options));\n        }\n      }\n      if (this.model) {\n        this.model.addCell(child, options);\n      }\n    }\n    return this;\n  }\n  removeFromParent(options = {}) {\n    const parent = this.getParent();\n    if (parent != null) {\n      const index = parent.getChildIndex(this);\n      parent.removeChildAt(index, options);\n    }\n    return this;\n  }\n  removeChild(child, options = {}) {\n    const index = this.getChildIndex(child);\n    return this.removeChildAt(index, options);\n  }\n  removeChildAt(index, options = {}) {\n    const child = this.getChildAt(index);\n    const children = this.children;\n    if (children != null && child != null) {\n      this.unembed(child, options);\n      child.remove(options);\n    }\n    return child;\n  }\n  remove(options = {}) {\n    this.batchUpdate('remove', () => {\n      const parent = this.getParent();\n      if (parent) {\n        parent.removeChild(this, options);\n      }\n      if (options.deep !== false) {\n        this.eachChild(child => child.remove(options));\n      }\n      if (this.model) {\n        this.model.removeCell(this, options);\n      }\n    });\n    return this;\n  }\n  transition(path, target, options = {}, delim = '/') {\n    return this.animation.start(path, target, options, delim);\n  }\n  stopTransition(path, options, delim = '/') {\n    this.animation.stop(path, options, delim);\n    return this;\n  }\n  getTransitions() {\n    return this.animation.get();\n  }\n  // #endregion\n  // #region transform\n  // eslint-disable-next-line\n  translate(tx, ty, options) {\n    return this;\n  }\n  scale(sx,\n  // eslint-disable-line\n  sy,\n  // eslint-disable-line\n  origin,\n  // eslint-disable-line\n  options) {\n    return this;\n  }\n  addTools(items, obj, options) {\n    const toolItems = Array.isArray(items) ? items : [items];\n    const name = typeof obj === 'string' ? obj : null;\n    const config = typeof obj === 'object' ? obj : typeof options === 'object' ? options : {};\n    if (config.reset) {\n      return this.setTools({\n        name,\n        items: toolItems,\n        local: config.local\n      }, config);\n    }\n    let tools = ObjectExt.cloneDeep(this.getTools());\n    if (tools == null || name == null || tools.name === name) {\n      if (tools == null) {\n        tools = {};\n      }\n      if (!tools.items) {\n        tools.items = [];\n      }\n      tools.name = name;\n      tools.items = [...tools.items, ...toolItems];\n      return this.setTools(Object.assign({}, tools), config);\n    }\n  }\n  setTools(tools, options = {}) {\n    if (tools == null) {\n      this.removeTools();\n    } else {\n      this.store.set('tools', Cell.normalizeTools(tools), options);\n    }\n    return this;\n  }\n  getTools() {\n    return this.store.get('tools');\n  }\n  removeTools(options = {}) {\n    this.store.remove('tools', options);\n    return this;\n  }\n  hasTools(name) {\n    const tools = this.getTools();\n    if (tools == null) {\n      return false;\n    }\n    if (name == null) {\n      return true;\n    }\n    return tools.name === name;\n  }\n  hasTool(name) {\n    const tools = this.getTools();\n    if (tools == null) {\n      return false;\n    }\n    return tools.items.some(item => typeof item === 'string' ? item === name : item.name === name);\n  }\n  removeTool(nameOrIndex, options = {}) {\n    const tools = ObjectExt.cloneDeep(this.getTools());\n    if (tools) {\n      let updated = false;\n      const items = tools.items.slice();\n      const remove = index => {\n        items.splice(index, 1);\n        updated = true;\n      };\n      if (typeof nameOrIndex === 'number') {\n        remove(nameOrIndex);\n      } else {\n        for (let i = items.length - 1; i >= 0; i -= 1) {\n          const item = items[i];\n          const exist = typeof item === 'string' ? item === nameOrIndex : item.name === nameOrIndex;\n          if (exist) {\n            remove(i);\n          }\n        }\n      }\n      if (updated) {\n        tools.items = items;\n        this.setTools(tools, options);\n      }\n    }\n    return this;\n  }\n  // #endregion\n  // #region common\n  // eslint-disable-next-line\n  getBBox(options) {\n    return new Rectangle();\n  }\n  // eslint-disable-next-line\n  getConnectionPoint(edge, type) {\n    return new Point();\n  }\n  toJSON(options = {}) {\n    const props = Object.assign({}, this.store.get());\n    const toString = Object.prototype.toString;\n    const cellType = this.isNode() ? 'node' : this.isEdge() ? 'edge' : 'cell';\n    if (!props.shape) {\n      const ctor = this.constructor;\n      throw new Error(`Unable to serialize ${cellType} missing \"shape\" prop, check the ${cellType} \"${ctor.name || toString.call(ctor)}\"`);\n    }\n    const ctor = this.constructor;\n    const diff = options.diff === true;\n    const attrs = props.attrs || {};\n    const presets = ctor.getDefaults(true);\n    // When `options.diff` is `true`, we should process the custom options,\n    // such as `width`, `height` etc. to ensure the comparing work correctly.\n    const defaults = diff ? this.preprocess(presets, true) : presets;\n    const defaultAttrs = defaults.attrs || {};\n    const finalAttrs = {};\n    Object.entries(props).forEach(([key, val]) => {\n      if (val != null && !Array.isArray(val) && typeof val === 'object' && !ObjectExt.isPlainObject(val)) {\n        throw new Error(`Can only serialize ${cellType} with plain-object props, but got a \"${toString.call(val)}\" type of key \"${key}\" on ${cellType} \"${this.id}\"`);\n      }\n      if (key !== 'attrs' && key !== 'shape' && diff) {\n        const preset = defaults[key];\n        if (ObjectExt.isEqual(val, preset)) {\n          delete props[key];\n        }\n      }\n    });\n    Object.keys(attrs).forEach(key => {\n      const attr = attrs[key];\n      const defaultAttr = defaultAttrs[key];\n      Object.keys(attr).forEach(name => {\n        const value = attr[name];\n        const defaultValue = defaultAttr ? defaultAttr[name] : null;\n        if (value != null && typeof value === 'object' && !Array.isArray(value)) {\n          Object.keys(value).forEach(subName => {\n            const subValue = value[subName];\n            if (defaultAttr == null || defaultValue == null || !ObjectExt.isObject(defaultValue) || !ObjectExt.isEqual(defaultValue[subName], subValue)) {\n              if (finalAttrs[key] == null) {\n                finalAttrs[key] = {};\n              }\n              if (finalAttrs[key][name] == null) {\n                finalAttrs[key][name] = {};\n              }\n              const tmp = finalAttrs[key][name];\n              tmp[subName] = subValue;\n            }\n          });\n        } else if (defaultAttr == null || !ObjectExt.isEqual(defaultValue, value)) {\n          // `value` is not an object, default attribute with `key` does not\n          // exist or it is different than the attribute value set on the cell.\n          if (finalAttrs[key] == null) {\n            finalAttrs[key] = {};\n          }\n          finalAttrs[key][name] = value;\n        }\n      });\n    });\n    const finalProps = Object.assign(Object.assign({}, props), {\n      attrs: ObjectExt.isEmpty(finalAttrs) ? undefined : finalAttrs\n    });\n    if (finalProps.attrs == null) {\n      delete finalProps.attrs;\n    }\n    const ret = finalProps;\n    if (ret.angle === 0) {\n      delete ret.angle;\n    }\n    return ObjectExt.cloneDeep(ret);\n  }\n  clone(options = {}) {\n    if (!options.deep) {\n      const data = Object.assign({}, this.store.get());\n      if (!options.keepId) {\n        delete data.id;\n      }\n      delete data.parent;\n      delete data.children;\n      const ctor = this.constructor;\n      return new ctor(data); // eslint-disable-line new-cap\n    }\n    // Deep cloning. Clone the cell itself and all its children.\n    const map = Cell.deepClone(this);\n    return map[this.id];\n  }\n  findView(graph) {\n    return graph.findViewByCell(this);\n  }\n  // #endregion\n  // #region batch\n  startBatch(name, data = {}, model = this.model) {\n    this.notify('batch:start', {\n      name,\n      data,\n      cell: this\n    });\n    if (model) {\n      model.startBatch(name, Object.assign(Object.assign({}, data), {\n        cell: this\n      }));\n    }\n    return this;\n  }\n  stopBatch(name, data = {}, model = this.model) {\n    if (model) {\n      model.stopBatch(name, Object.assign(Object.assign({}, data), {\n        cell: this\n      }));\n    }\n    this.notify('batch:stop', {\n      name,\n      data,\n      cell: this\n    });\n    return this;\n  }\n  batchUpdate(name, execute, data) {\n    // The model is null after cell was removed(remove batch).\n    // So we should temp save model to trigger pairing batch event.\n    const model = this.model;\n    this.startBatch(name, data, model);\n    const result = execute();\n    this.stopBatch(name, data, model);\n    return result;\n  }\n  // #endregion\n  // #region IDisposable\n  dispose() {\n    this.removeFromParent();\n    this.store.dispose();\n  }\n}\nCell.defaults = {};\nCell.attrHooks = {};\nCell.propHooks = [];\n__decorate([Basecoat.dispose()], Cell.prototype, \"dispose\", null);\n(function (Cell) {\n  function normalizeTools(raw) {\n    if (typeof raw === 'string') {\n      return {\n        items: [raw]\n      };\n    }\n    if (Array.isArray(raw)) {\n      return {\n        items: raw\n      };\n    }\n    if (raw.items) {\n      return raw;\n    }\n    return {\n      items: [raw]\n    };\n  }\n  Cell.normalizeTools = normalizeTools;\n})(Cell || (Cell = {}));\n(function (Cell) {\n  Cell.toStringTag = `X6.${Cell.name}`;\n  function isCell(instance) {\n    if (instance == null) {\n      return false;\n    }\n    if (instance instanceof Cell) {\n      return true;\n    }\n    const tag = instance[Symbol.toStringTag];\n    const cell = instance;\n    if ((tag == null || tag === Cell.toStringTag) && typeof cell.isNode === 'function' && typeof cell.isEdge === 'function' && typeof cell.prop === 'function' && typeof cell.attr === 'function') {\n      return true;\n    }\n    return false;\n  }\n  Cell.isCell = isCell;\n})(Cell || (Cell = {}));\n(function (Cell) {\n  function getCommonAncestor(...cells) {\n    const ancestors = cells.filter(cell => cell != null).map(cell => cell.getAncestors()).sort((a, b) => {\n      return a.length - b.length;\n    });\n    const first = ancestors.shift();\n    return first.find(cell => ancestors.every(item => item.includes(cell))) || null;\n  }\n  Cell.getCommonAncestor = getCommonAncestor;\n  function getCellsBBox(cells, options = {}) {\n    let bbox = null;\n    for (let i = 0, ii = cells.length; i < ii; i += 1) {\n      const cell = cells[i];\n      let rect = cell.getBBox(options);\n      if (rect) {\n        if (cell.isNode()) {\n          const angle = cell.getAngle();\n          if (angle != null && angle !== 0) {\n            rect = rect.bbox(angle);\n          }\n        }\n        bbox = bbox == null ? rect : bbox.union(rect);\n      }\n    }\n    return bbox;\n  }\n  Cell.getCellsBBox = getCellsBBox;\n  function deepClone(cell) {\n    const cells = [cell, ...cell.getDescendants({\n      deep: true\n    })];\n    return Cell.cloneCells(cells);\n  }\n  Cell.deepClone = deepClone;\n  function cloneCells(cells) {\n    const inputs = ArrayExt.uniq(cells);\n    const cloneMap = inputs.reduce((map, cell) => {\n      map[cell.id] = cell.clone();\n      return map;\n    }, {});\n    inputs.forEach(cell => {\n      const clone = cloneMap[cell.id];\n      if (clone.isEdge()) {\n        const sourceId = clone.getSourceCellId();\n        const targetId = clone.getTargetCellId();\n        if (sourceId && cloneMap[sourceId]) {\n          // Source is a node and the node is among the clones.\n          // Then update the source of the cloned edge.\n          clone.setSource(Object.assign(Object.assign({}, clone.getSource()), {\n            cell: cloneMap[sourceId].id\n          }));\n        }\n        if (targetId && cloneMap[targetId]) {\n          // Target is a node and the node is among the clones.\n          // Then update the target of the cloned edge.\n          clone.setTarget(Object.assign(Object.assign({}, clone.getTarget()), {\n            cell: cloneMap[targetId].id\n          }));\n        }\n      }\n      // Find the parent of the original cell\n      const parent = cell.getParent();\n      if (parent && cloneMap[parent.id]) {\n        clone.setParent(cloneMap[parent.id]);\n      }\n      // Find the children of the original cell\n      const children = cell.getChildren();\n      if (children && children.length) {\n        const embeds = children.reduce((memo, child) => {\n          // Embedded cells that are not being cloned can not be carried\n          // over with other embedded cells.\n          if (cloneMap[child.id]) {\n            memo.push(cloneMap[child.id]);\n          }\n          return memo;\n        }, []);\n        if (embeds.length > 0) {\n          clone.setChildren(embeds);\n        }\n      }\n    });\n    return cloneMap;\n  }\n  Cell.cloneCells = cloneCells;\n})(Cell || (Cell = {}));\n(function (Cell) {\n  Cell.config({\n    propHooks(_a) {\n      var {\n          tools\n        } = _a,\n        metadata = __rest(_a, [\"tools\"]);\n      if (tools) {\n        metadata.tools = Cell.normalizeTools(tools);\n      }\n      return metadata;\n    }\n  });\n})(Cell || (Cell = {}));","map":{"version":3,"names":["ArrayExt","StringExt","ObjectExt","FunctionExt","Basecoat","Rectangle","Point","Attr","Store","Animation","Cell","config","presets","markup","propHooks","attrHooks","others","__rest","slice","Array","isArray","push","Object","values","forEach","hook","assign","defaults","merge","getMarkup","getDefaults","raw","cloneDeep","getAttrHooks","applyPropHooks","cell","metadata","reduce","memo","call","Symbol","toStringTag","constructor","ctor","props","preprocess","id","uuid","store","animation","setup","init","postprocess","model","_model","ignoreIdCheck","on","key","current","previous","options","notify","type","name","args","trigger","isNode","node","isEdge","edge","isSameStore","view","get","shape","getProp","defaultValue","setProp","value","set","removeProp","removeByPath","remove","hasChanged","getPropByPath","path","getByPath","setPropByPath","_children","map","getCell","filter","child","_parent","setByPath","removePropByPath","paths","split","dirty","prop","arguments","length","getPrevious","zIndex","getZIndex","z","removeZIndex","setZIndex","toFront","getMaxZIndex","cells","deep","getDescendants","breadthFirst","unshift","count","total","changed","indexOf","some","index","batchUpdate","toBack","getMinZIndex","removeMarkup","setMarkup","attrs","getAttrs","removeAttrs","setAttrs","result","overwrite","prev","replaceAttrs","updateAttrs","getAttrDefinition","attrName","hooks","definition","registry","camelCase","getAttrByPath","prefixAttrPath","setAttrByPath","removeAttrByPath","concat","attr","visible","isVisible","setVisible","show","hide","toggleVisible","localOptions","data","getData","val","setData","removeData","replaceData","updateData","parent","getParent","children","getChildren","getParentId","parentId","childrenIds","_a","hasParent","isParentOf","isChildOf","eachChild","iterator","context","filterChild","getChildCount","getChildIndex","getChildAt","getAncestors","ancestors","queue","shift","isDescendantOf","ancestor","isAncestorOf","descendant","contains","getCommonAncestor","setParent","setChildren","unembed","splice","embed","addTo","target","isCell","addChild","addCell","insertTo","insertChild","undefined","oldParent","pos","incomings","getIncomingEdges","outgoings","getOutgoingEdges","updateParent","removeFromParent","removeChildAt","removeChild","removeCell","transition","delim","start","stopTransition","stop","getTransitions","translate","tx","ty","scale","sx","sy","origin","addTools","items","obj","toolItems","reset","setTools","local","tools","getTools","removeTools","normalizeTools","hasTools","hasTool","item","removeTool","nameOrIndex","updated","i","exist","getBBox","getConnectionPoint","toJSON","toString","prototype","cellType","Error","diff","defaultAttrs","finalAttrs","entries","isPlainObject","preset","isEqual","keys","defaultAttr","subName","subValue","isObject","tmp","finalProps","isEmpty","ret","angle","clone","keepId","deepClone","findView","graph","findViewByCell","startBatch","stopBatch","execute","dispose","__decorate","instance","tag","sort","a","b","first","find","every","includes","getCellsBBox","bbox","ii","rect","getAngle","union","cloneCells","inputs","uniq","cloneMap","sourceId","getSourceCellId","targetId","getTargetCellId","setSource","getSource","setTarget","getTarget","embeds"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/src/model/cell.ts"],"sourcesContent":["/* eslint-disable no-underscore-dangle */\n\nimport {\n  ArrayExt,\n  StringExt,\n  ObjectExt,\n  FunctionExt,\n  KeyValue,\n  Size,\n  Basecoat,\n} from '@antv/x6-common'\nimport { Rectangle, Point } from '@antv/x6-geometry'\nimport { NonUndefined } from 'utility-types'\nimport { Attr } from '../registry'\nimport { Model } from './model'\nimport { PortManager } from './port'\nimport { Store } from './store'\nimport { Edge } from './edge'\nimport { Animation } from './animation'\nimport { CellView, Markup } from '../view'\nimport { Node } from './node'\nimport { Graph } from '../graph'\n\nexport class Cell<\n  Properties extends Cell.Properties = Cell.Properties,\n> extends Basecoat<Cell.EventArgs> {\n  // #region static\n\n  protected static markup: Markup\n  protected static defaults: Cell.Defaults = {}\n  protected static attrHooks: Attr.Definitions = {}\n  protected static propHooks: Cell.PropHook[] = []\n\n  public static config<C extends Cell.Config = Cell.Config>(presets: C) {\n    const { markup, propHooks, attrHooks, ...others } = presets\n\n    if (markup != null) {\n      this.markup = markup\n    }\n\n    if (propHooks) {\n      this.propHooks = this.propHooks.slice()\n      if (Array.isArray(propHooks)) {\n        this.propHooks.push(...propHooks)\n      } else if (typeof propHooks === 'function') {\n        this.propHooks.push(propHooks)\n      } else {\n        Object.values(propHooks).forEach((hook) => {\n          if (typeof hook === 'function') {\n            this.propHooks.push(hook)\n          }\n        })\n      }\n    }\n\n    if (attrHooks) {\n      this.attrHooks = { ...this.attrHooks, ...attrHooks }\n    }\n\n    this.defaults = ObjectExt.merge({}, this.defaults, others)\n  }\n\n  public static getMarkup() {\n    return this.markup\n  }\n\n  public static getDefaults<T extends Cell.Defaults = Cell.Defaults>(\n    raw?: boolean,\n  ): T {\n    return (raw ? this.defaults : ObjectExt.cloneDeep(this.defaults)) as T\n  }\n\n  public static getAttrHooks() {\n    return this.attrHooks\n  }\n\n  public static applyPropHooks(\n    cell: Cell,\n    metadata: Cell.Metadata,\n  ): Cell.Metadata {\n    return this.propHooks.reduce((memo, hook) => {\n      return hook ? FunctionExt.call(hook, cell, memo) : memo\n    }, metadata)\n  }\n\n  // #endregion\n\n  protected get [Symbol.toStringTag]() {\n    return Cell.toStringTag\n  }\n\n  public readonly id: string\n  protected readonly store: Store<Cell.Properties>\n  protected readonly animation: Animation\n  protected _model: Model | null // eslint-disable-line\n  protected _parent: Cell | null // eslint-disable-line\n  protected _children: Cell[] | null // eslint-disable-line\n\n  constructor(metadata: Cell.Metadata = {}) {\n    super()\n\n    const ctor = this.constructor as typeof Cell\n    const defaults = ctor.getDefaults(true)\n    const props = ObjectExt.merge(\n      {},\n      this.preprocess(defaults),\n      this.preprocess(metadata),\n    )\n\n    this.id = props.id || StringExt.uuid()\n    this.store = new Store(props)\n    this.animation = new Animation(this)\n    this.setup()\n    this.init()\n    this.postprocess(metadata)\n  }\n\n  init() {}\n\n  // #region model\n\n  get model() {\n    return this._model\n  }\n\n  set model(model: Model | null) {\n    if (this._model !== model) {\n      this._model = model\n    }\n  }\n\n  // #endregion\n\n  protected preprocess(\n    metadata: Cell.Metadata,\n    ignoreIdCheck?: boolean,\n  ): Properties {\n    const id = metadata.id\n    const ctor = this.constructor as typeof Cell\n    const props = ctor.applyPropHooks(this, metadata)\n\n    if (id == null && ignoreIdCheck !== true) {\n      props.id = StringExt.uuid()\n    }\n\n    return props as Properties\n  }\n\n  protected postprocess(metadata: Cell.Metadata) {} // eslint-disable-line\n\n  protected setup() {\n    this.store.on('change:*', (metadata) => {\n      const { key, current, previous, options } = metadata\n\n      this.notify('change:*', {\n        key,\n        options,\n        current,\n        previous,\n        cell: this,\n      })\n\n      this.notify(`change:${key}` as keyof Cell.EventArgs, {\n        options,\n        current,\n        previous,\n        cell: this,\n      })\n\n      const type = key as Edge.TerminalType\n      if (type === 'source' || type === 'target') {\n        this.notify(`change:terminal`, {\n          type,\n          current,\n          previous,\n          options,\n          cell: this,\n        })\n      }\n    })\n\n    this.store.on('changed', ({ options }) =>\n      this.notify('changed', { options, cell: this }),\n    )\n  }\n\n  notify<Key extends keyof Cell.EventArgs>(\n    name: Key,\n    args: Cell.EventArgs[Key],\n  ): this\n  notify(name: Exclude<string, keyof Cell.EventArgs>, args: any): this\n  notify<Key extends keyof Cell.EventArgs>(\n    name: Key,\n    args: Cell.EventArgs[Key],\n  ) {\n    this.trigger(name, args)\n    const model = this.model\n    if (model) {\n      model.notify(`cell:${name}`, args)\n      if (this.isNode()) {\n        model.notify(`node:${name}`, { ...args, node: this })\n      } else if (this.isEdge()) {\n        model.notify(`edge:${name}`, { ...args, edge: this })\n      }\n    }\n    return this\n  }\n\n  isNode(): this is Node {\n    return false\n  }\n\n  isEdge(): this is Edge {\n    return false\n  }\n\n  isSameStore(cell: Cell) {\n    return this.store === cell.store\n  }\n\n  get view() {\n    return this.store.get('view')\n  }\n\n  get shape() {\n    return this.store.get('shape', '')\n  }\n\n  // #region get/set\n\n  getProp(): Properties\n  getProp<K extends keyof Properties>(key: K): Properties[K]\n  getProp<K extends keyof Properties>(\n    key: K,\n    defaultValue: Properties[K],\n  ): NonUndefined<Properties[K]>\n  getProp<T>(key: string): T\n  getProp<T>(key: string, defaultValue: T): T\n  getProp(key?: string, defaultValue?: any) {\n    if (key == null) {\n      return this.store.get()\n    }\n\n    return this.store.get(key, defaultValue)\n  }\n\n  setProp<K extends keyof Properties>(\n    key: K,\n    value: Properties[K] | null | undefined | void,\n    options?: Cell.SetOptions,\n  ): this\n  setProp(key: string, value: any, options?: Cell.SetOptions): this\n  setProp(props: Partial<Properties>, options?: Cell.SetOptions): this\n  setProp(\n    key: string | Partial<Properties>,\n    value?: any,\n    options?: Cell.SetOptions,\n  ) {\n    if (typeof key === 'string') {\n      this.store.set(key, value, options)\n    } else {\n      const props = this.preprocess(key, true)\n      this.store.set(ObjectExt.merge({}, this.getProp(), props), value)\n      this.postprocess(key)\n    }\n    return this\n  }\n\n  removeProp<K extends keyof Properties>(\n    key: K | K[],\n    options?: Cell.SetOptions,\n  ): this\n  removeProp(key: string | string[], options?: Cell.SetOptions): this\n  removeProp(options?: Cell.SetOptions): this\n  removeProp(\n    key?: string | string[] | Cell.SetOptions,\n    options?: Cell.SetOptions,\n  ) {\n    if (typeof key === 'string' || Array.isArray(key)) {\n      this.store.removeByPath(key, options)\n    } else {\n      this.store.remove(options)\n    }\n    return this\n  }\n\n  hasChanged(): boolean\n  hasChanged<K extends keyof Properties>(key: K | null): boolean\n  hasChanged(key: string | null): boolean\n  hasChanged(key?: string | null) {\n    return key == null ? this.store.hasChanged() : this.store.hasChanged(key)\n  }\n\n  getPropByPath<T>(path: string | string[]) {\n    return this.store.getByPath<T>(path)\n  }\n\n  setPropByPath(\n    path: string | string[],\n    value: any,\n    options: Cell.SetByPathOptions = {},\n  ) {\n    if (this.model) {\n      // update inner reference\n      if (path === 'children') {\n        this._children = value\n          ? value\n              .map((id: string) => this.model!.getCell(id))\n              .filter((child: Cell) => child != null)\n          : null\n      } else if (path === 'parent') {\n        this._parent = value ? this.model.getCell(value) : null\n      }\n    }\n\n    this.store.setByPath(path, value, options)\n    return this\n  }\n\n  removePropByPath(path: string | string[], options: Cell.SetOptions = {}) {\n    const paths = Array.isArray(path) ? path : path.split('/')\n    // Once a property is removed from the `attrs` the CellView will\n    // recognize a `dirty` flag and re-render itself in order to remove\n    // the attribute from SVGElement.\n    if (paths[0] === 'attrs') {\n      options.dirty = true\n    }\n    this.store.removeByPath(paths, options)\n    return this\n  }\n\n  prop(): Properties\n  prop<K extends keyof Properties>(key: K): Properties[K]\n  prop<T>(key: string): T\n  prop<T>(path: string[]): T\n  prop<K extends keyof Properties>(\n    key: K,\n    value: Properties[K] | null | undefined | void,\n    options?: Cell.SetOptions,\n  ): this\n  prop(key: string, value: any, options?: Cell.SetOptions): this\n  prop(path: string[], value: any, options?: Cell.SetOptions): this\n  prop(props: Partial<Properties>, options?: Cell.SetOptions): this\n  prop(\n    key?: string | string[] | Partial<Properties>,\n    value?: any,\n    options?: Cell.SetOptions,\n  ) {\n    if (key == null) {\n      return this.getProp()\n    }\n\n    if (typeof key === 'string' || Array.isArray(key)) {\n      if (arguments.length === 1) {\n        return this.getPropByPath(key)\n      }\n\n      if (value == null) {\n        return this.removePropByPath(key, options || {})\n      }\n\n      return this.setPropByPath(key, value, options || {})\n    }\n\n    return this.setProp(key, value || {})\n  }\n\n  previous<K extends keyof Properties>(name: K): Properties[K] | undefined\n  previous<T>(name: string): T | undefined\n  previous(name: string) {\n    return this.store.getPrevious(name as keyof Cell.Properties)\n  }\n\n  // #endregion\n\n  // #region zIndex\n\n  get zIndex() {\n    return this.getZIndex()\n  }\n\n  set zIndex(z: number | undefined | null) {\n    if (z == null) {\n      this.removeZIndex()\n    } else {\n      this.setZIndex(z)\n    }\n  }\n\n  getZIndex() {\n    return this.store.get('zIndex')\n  }\n\n  setZIndex(z: number, options: Cell.SetOptions = {}) {\n    this.store.set('zIndex', z, options)\n    return this\n  }\n\n  removeZIndex(options: Cell.SetOptions = {}) {\n    this.store.remove('zIndex', options)\n    return this\n  }\n\n  toFront(options: Cell.ToFrontOptions = {}) {\n    const model = this.model\n    if (model) {\n      let z = model.getMaxZIndex()\n      let cells: Cell[]\n      if (options.deep) {\n        cells = this.getDescendants({ deep: true, breadthFirst: true })\n        cells.unshift(this)\n      } else {\n        cells = [this]\n      }\n\n      z = z - cells.length + 1\n\n      const count = model.total()\n      let changed = model.indexOf(this) !== count - cells.length\n      if (!changed) {\n        changed = cells.some((cell, index) => cell.getZIndex() !== z + index)\n      }\n\n      if (changed) {\n        this.batchUpdate('to-front', () => {\n          z += cells.length\n          cells.forEach((cell, index) => {\n            cell.setZIndex(z + index, options)\n          })\n        })\n      }\n    }\n\n    return this\n  }\n\n  toBack(options: Cell.ToBackOptions = {}) {\n    const model = this.model\n    if (model) {\n      let z = model.getMinZIndex()\n      let cells: Cell[]\n\n      if (options.deep) {\n        cells = this.getDescendants({ deep: true, breadthFirst: true })\n        cells.unshift(this)\n      } else {\n        cells = [this]\n      }\n\n      let changed = model.indexOf(this) !== 0\n      if (!changed) {\n        changed = cells.some((cell, index) => cell.getZIndex() !== z + index)\n      }\n\n      if (changed) {\n        this.batchUpdate('to-back', () => {\n          z -= cells.length\n          cells.forEach((cell, index) => {\n            cell.setZIndex(z + index, options)\n          })\n        })\n      }\n    }\n\n    return this\n  }\n\n  // #endregion\n\n  // #region markup\n\n  get markup() {\n    return this.getMarkup()\n  }\n\n  set markup(value: Markup | undefined | null) {\n    if (value == null) {\n      this.removeMarkup()\n    } else {\n      this.setMarkup(value)\n    }\n  }\n\n  getMarkup() {\n    let markup = this.store.get('markup')\n    if (markup == null) {\n      const ctor = this.constructor as typeof Cell\n      markup = ctor.getMarkup()\n    }\n    return markup\n  }\n\n  setMarkup(markup: Markup, options: Cell.SetOptions = {}) {\n    this.store.set('markup', markup, options)\n    return this\n  }\n\n  removeMarkup(options: Cell.SetOptions = {}) {\n    this.store.remove('markup', options)\n    return this\n  }\n\n  // #endregion\n\n  // #region attrs\n\n  get attrs() {\n    return this.getAttrs()\n  }\n\n  set attrs(value: Attr.CellAttrs | null | undefined) {\n    if (value == null) {\n      this.removeAttrs()\n    } else {\n      this.setAttrs(value)\n    }\n  }\n\n  getAttrs() {\n    const result = this.store.get('attrs')\n    return result ? { ...result } : {}\n  }\n\n  setAttrs(\n    attrs: Attr.CellAttrs | null | undefined,\n    options: Cell.SetAttrOptions = {},\n  ) {\n    if (attrs == null) {\n      this.removeAttrs(options)\n    } else {\n      const set = (attrs: Attr.CellAttrs) =>\n        this.store.set('attrs', attrs, options)\n\n      if (options.overwrite === true) {\n        set(attrs)\n      } else {\n        const prev = this.getAttrs()\n        if (options.deep === false) {\n          set({ ...prev, ...attrs })\n        } else {\n          set(ObjectExt.merge({}, prev, attrs))\n        }\n      }\n    }\n\n    return this\n  }\n\n  replaceAttrs(attrs: Attr.CellAttrs, options: Cell.SetOptions = {}) {\n    return this.setAttrs(attrs, { ...options, overwrite: true })\n  }\n\n  updateAttrs(attrs: Attr.CellAttrs, options: Cell.SetOptions = {}) {\n    return this.setAttrs(attrs, { ...options, deep: false })\n  }\n\n  removeAttrs(options: Cell.SetOptions = {}) {\n    this.store.remove('attrs', options)\n    return this\n  }\n\n  getAttrDefinition(attrName: string) {\n    if (!attrName) {\n      return null\n    }\n\n    const ctor = this.constructor as typeof Cell\n    const hooks = ctor.getAttrHooks() || {}\n    let definition = hooks[attrName] || Attr.registry.get(attrName)\n    if (!definition) {\n      const name = StringExt.camelCase(attrName)\n      definition = hooks[name] || Attr.registry.get(name)\n    }\n\n    return definition || null\n  }\n\n  getAttrByPath(): Attr.CellAttrs\n  getAttrByPath<T>(path: string | string[]): T\n  getAttrByPath<T>(path?: string | string[]) {\n    if (path == null || path === '') {\n      return this.getAttrs()\n    }\n    return this.getPropByPath<T>(this.prefixAttrPath(path))\n  }\n\n  setAttrByPath(\n    path: string | string[],\n    value: Attr.ComplexAttrValue,\n    options: Cell.SetOptions = {},\n  ) {\n    this.setPropByPath(this.prefixAttrPath(path), value, options)\n    return this\n  }\n\n  removeAttrByPath(path: string | string[], options: Cell.SetOptions = {}) {\n    this.removePropByPath(this.prefixAttrPath(path), options)\n    return this\n  }\n\n  protected prefixAttrPath(path: string | string[]) {\n    return Array.isArray(path) ? ['attrs'].concat(path) : `attrs/${path}`\n  }\n\n  attr(): Attr.CellAttrs\n  attr<T>(path: string | string[]): T\n  attr(\n    path: string | string[],\n    value: Attr.ComplexAttrValue | null,\n    options?: Cell.SetOptions,\n  ): this\n  attr(attrs: Attr.CellAttrs, options?: Cell.SetAttrOptions): this\n  attr(\n    path?: string | string[] | Attr.CellAttrs,\n    value?: Attr.ComplexAttrValue | Cell.SetOptions,\n    options?: Cell.SetOptions,\n  ) {\n    if (path == null) {\n      return this.getAttrByPath()\n    }\n\n    if (typeof path === 'string' || Array.isArray(path)) {\n      if (arguments.length === 1) {\n        return this.getAttrByPath(path)\n      }\n      if (value == null) {\n        return this.removeAttrByPath(path, options || {})\n      }\n      return this.setAttrByPath(\n        path,\n        value as Attr.ComplexAttrValue,\n        options || {},\n      )\n    }\n\n    return this.setAttrs(path, (value || {}) as Cell.SetOptions)\n  }\n\n  // #endregion\n\n  // #region visible\n\n  get visible() {\n    return this.isVisible()\n  }\n\n  set visible(value: boolean) {\n    this.setVisible(value)\n  }\n\n  setVisible(visible: boolean, options: Cell.SetOptions = {}) {\n    this.store.set('visible', visible, options)\n    return this\n  }\n\n  isVisible() {\n    return this.store.get('visible') !== false\n  }\n\n  show(options: Cell.SetOptions = {}) {\n    if (!this.isVisible()) {\n      this.setVisible(true, options)\n    }\n    return this\n  }\n\n  hide(options: Cell.SetOptions = {}) {\n    if (this.isVisible()) {\n      this.setVisible(false, options)\n    }\n    return this\n  }\n\n  toggleVisible(visible: boolean, options?: Cell.SetOptions): this\n  toggleVisible(options?: Cell.SetOptions): this\n  toggleVisible(\n    isVisible?: boolean | Cell.SetOptions,\n    options: Cell.SetOptions = {},\n  ) {\n    const visible =\n      typeof isVisible === 'boolean' ? isVisible : !this.isVisible()\n    const localOptions = typeof isVisible === 'boolean' ? options : isVisible\n    if (visible) {\n      this.show(localOptions)\n    } else {\n      this.hide(localOptions)\n    }\n    return this\n  }\n\n  // #endregion\n\n  // #region data\n\n  get data(): Properties['data'] {\n    return this.getData()\n  }\n\n  set data(val: Properties['data']) {\n    this.setData(val)\n  }\n\n  getData<T = Properties['data']>(): T {\n    return this.store.get<T>('data')\n  }\n\n  setData<T = Properties['data']>(data: T, options: Cell.SetDataOptions = {}) {\n    if (data == null) {\n      this.removeData(options)\n    } else {\n      const set = (data: T) => this.store.set('data', data, options)\n\n      if (options.overwrite === true) {\n        set(data)\n      } else {\n        const prev = this.getData<Record<string, any>>()\n        if (options.deep === false) {\n          set(typeof data === 'object' ? { ...prev, ...data } : data)\n        } else {\n          set(ObjectExt.merge({}, prev, data))\n        }\n      }\n    }\n\n    return this\n  }\n\n  replaceData<T = Properties['data']>(data: T, options: Cell.SetOptions = {}) {\n    return this.setData(data, { ...options, overwrite: true })\n  }\n\n  updateData<T = Properties['data']>(data: T, options: Cell.SetOptions = {}) {\n    return this.setData(data, { ...options, deep: false })\n  }\n\n  removeData(options: Cell.SetOptions = {}) {\n    this.store.remove('data', options)\n    return this\n  }\n\n  // #endregion\n\n  // #region parent children\n\n  get parent(): Cell | null {\n    return this.getParent()\n  }\n\n  get children() {\n    return this.getChildren()\n  }\n\n  getParentId() {\n    return this.store.get('parent')\n  }\n\n  getParent<T extends Cell = Cell>(): T | null {\n    const parentId = this.getParentId()\n    if (parentId && this.model) {\n      const parent = this.model.getCell<T>(parentId)\n      this._parent = parent\n      return parent\n    }\n    return null\n  }\n\n  getChildren() {\n    const childrenIds = this.store.get('children')\n    if (childrenIds && childrenIds.length && this.model) {\n      const children = childrenIds\n        .map((id) => this.model?.getCell(id))\n        .filter((cell) => cell != null) as Cell[]\n      this._children = children\n      return [...children]\n    }\n    return null\n  }\n\n  hasParent() {\n    return this.parent != null\n  }\n\n  isParentOf(child: Cell | null): boolean {\n    return child != null && child.getParent() === this\n  }\n\n  isChildOf(parent: Cell | null): boolean {\n    return parent != null && this.getParent() === parent\n  }\n\n  eachChild(\n    iterator: (child: Cell, index: number, children: Cell[]) => void,\n    context?: any,\n  ) {\n    if (this.children) {\n      this.children.forEach(iterator, context)\n    }\n    return this\n  }\n\n  filterChild(\n    filter: (cell: Cell, index: number, arr: Cell[]) => boolean,\n    context?: any,\n  ): Cell[] {\n    return this.children ? this.children.filter(filter, context) : []\n  }\n\n  getChildCount() {\n    return this.children == null ? 0 : this.children.length\n  }\n\n  getChildIndex(child: Cell) {\n    return this.children == null ? -1 : this.children.indexOf(child)\n  }\n\n  getChildAt(index: number) {\n    return this.children != null && index >= 0 ? this.children[index] : null\n  }\n\n  getAncestors(options: { deep?: boolean } = {}): Cell[] {\n    const ancestors: Cell[] = []\n    let parent = this.getParent()\n    while (parent) {\n      ancestors.push(parent)\n      parent = options.deep !== false ? parent.getParent() : null\n    }\n    return ancestors\n  }\n\n  getDescendants(options: Cell.GetDescendantsOptions = {}): Cell[] {\n    if (options.deep !== false) {\n      // breadth first\n      if (options.breadthFirst) {\n        const cells = []\n        const queue = this.getChildren() || []\n\n        while (queue.length > 0) {\n          const parent = queue.shift()!\n          const children = parent.getChildren()\n          cells.push(parent)\n          if (children) {\n            queue.push(...children)\n          }\n        }\n        return cells\n      }\n\n      // depth first\n      {\n        const cells = this.getChildren() || []\n        cells.forEach((cell) => {\n          cells.push(...cell.getDescendants(options))\n        })\n        return cells\n      }\n    }\n\n    return this.getChildren() || []\n  }\n\n  isDescendantOf(\n    ancestor: Cell | null,\n    options: { deep?: boolean } = {},\n  ): boolean {\n    if (ancestor == null) {\n      return false\n    }\n\n    if (options.deep !== false) {\n      let current = this.getParent()\n      while (current) {\n        if (current === ancestor) {\n          return true\n        }\n        current = current.getParent()\n      }\n\n      return false\n    }\n\n    return this.isChildOf(ancestor)\n  }\n\n  isAncestorOf(\n    descendant: Cell | null,\n    options: { deep?: boolean } = {},\n  ): boolean {\n    if (descendant == null) {\n      return false\n    }\n\n    return descendant.isDescendantOf(this, options)\n  }\n\n  contains(cell: Cell | null) {\n    return this.isAncestorOf(cell)\n  }\n\n  getCommonAncestor(...cells: (Cell | null | undefined)[]): Cell | null {\n    return Cell.getCommonAncestor(this, ...cells)\n  }\n\n  setParent(parent: Cell | null, options: Cell.SetOptions = {}) {\n    this._parent = parent\n    if (parent) {\n      this.store.set('parent', parent.id, options)\n    } else {\n      this.store.remove('parent', options)\n    }\n    return this\n  }\n\n  setChildren(children: Cell[] | null, options: Cell.SetOptions = {}) {\n    this._children = children\n    if (children != null) {\n      this.store.set(\n        'children',\n        children.map((child) => child.id),\n        options,\n      )\n    } else {\n      this.store.remove('children', options)\n    }\n    return this\n  }\n\n  unembed(child: Cell, options: Cell.SetOptions = {}) {\n    const children = this.children\n    if (children != null && child != null) {\n      const index = this.getChildIndex(child)\n      if (index !== -1) {\n        children.splice(index, 1)\n        child.setParent(null, options)\n        this.setChildren(children, options)\n      }\n    }\n    return this\n  }\n\n  embed(child: Cell, options: Cell.SetOptions = {}) {\n    child.addTo(this, options)\n    return this\n  }\n\n  addTo(model: Model, options?: Cell.SetOptions): this\n  addTo(graph: Graph, options?: Cell.SetOptions): this\n  addTo(parent: Cell, options?: Cell.SetOptions): this\n  addTo(target: Model | Graph | Cell, options: Cell.SetOptions = {}) {\n    if (Cell.isCell(target)) {\n      target.addChild(this, options)\n    } else {\n      target.addCell(this, options)\n    }\n    return this\n  }\n\n  insertTo(parent: Cell, index?: number, options: Cell.SetOptions = {}) {\n    parent.insertChild(this, index, options)\n    return this\n  }\n\n  addChild(child: Cell | null, options: Cell.SetOptions = {}) {\n    return this.insertChild(child, undefined, options)\n  }\n\n  insertChild(\n    child: Cell | null,\n    index?: number,\n    options: Cell.SetOptions = {},\n  ): this {\n    if (child != null && child !== this) {\n      const oldParent = child.getParent()\n      const changed = this !== oldParent\n\n      let pos = index\n      if (pos == null) {\n        pos = this.getChildCount()\n        if (!changed) {\n          pos -= 1\n        }\n      }\n\n      // remove from old parent\n      if (oldParent) {\n        const children = oldParent.getChildren()\n        if (children) {\n          const index = children.indexOf(child)\n          if (index >= 0) {\n            child.setParent(null, options)\n            children.splice(index, 1)\n            oldParent.setChildren(children, options)\n          }\n        }\n      }\n\n      let children = this.children\n      if (children == null) {\n        children = []\n        children.push(child)\n      } else {\n        children.splice(pos, 0, child)\n      }\n\n      child.setParent(this, options)\n      this.setChildren(children, options)\n\n      if (changed && this.model) {\n        const incomings = this.model.getIncomingEdges(this)\n        const outgoings = this.model.getOutgoingEdges(this)\n\n        if (incomings) {\n          incomings.forEach((edge) => edge.updateParent(options))\n        }\n\n        if (outgoings) {\n          outgoings.forEach((edge) => edge.updateParent(options))\n        }\n      }\n\n      if (this.model) {\n        this.model.addCell(child, options)\n      }\n    }\n\n    return this\n  }\n\n  removeFromParent(options: Cell.RemoveOptions = {}) {\n    const parent = this.getParent()\n    if (parent != null) {\n      const index = parent.getChildIndex(this)\n      parent.removeChildAt(index, options)\n    }\n    return this\n  }\n\n  removeChild(child: Cell, options: Cell.RemoveOptions = {}) {\n    const index = this.getChildIndex(child)\n    return this.removeChildAt(index, options)\n  }\n\n  removeChildAt(index: number, options: Cell.RemoveOptions = {}) {\n    const child = this.getChildAt(index)\n    const children = this.children\n\n    if (children != null && child != null) {\n      this.unembed(child, options)\n      child.remove(options)\n    }\n\n    return child\n  }\n\n  remove(options: Cell.RemoveOptions = {}) {\n    this.batchUpdate('remove', () => {\n      const parent = this.getParent()\n      if (parent) {\n        parent.removeChild(this, options)\n      }\n\n      if (options.deep !== false) {\n        this.eachChild((child) => child.remove(options))\n      }\n\n      if (this.model) {\n        this.model.removeCell(this, options)\n      }\n    })\n    return this\n  }\n\n  // #endregion\n\n  // #region transition\n\n  transition<K extends keyof Properties>(\n    path: K,\n    target: Properties[K],\n    options?: Animation.StartOptions<Properties[K]>,\n    delim?: string,\n  ): () => void\n  transition<T extends Animation.TargetValue>(\n    path: string | string[],\n    target: T,\n    options?: Animation.StartOptions<T>,\n    delim?: string,\n  ): () => void\n  transition<T extends Animation.TargetValue>(\n    path: string | string[],\n    target: T,\n    options: Animation.StartOptions<T> = {},\n    delim = '/',\n  ) {\n    return this.animation.start(path, target, options, delim)\n  }\n\n  stopTransition<T extends Animation.TargetValue>(\n    path: string | string[],\n    options?: Animation.StopOptions<T>,\n    delim = '/',\n  ) {\n    this.animation.stop(path, options, delim)\n    return this\n  }\n\n  getTransitions() {\n    return this.animation.get()\n  }\n\n  // #endregion\n\n  // #region transform\n\n  // eslint-disable-next-line\n  translate(tx: number, ty: number, options?: Cell.TranslateOptions) {\n    return this\n  }\n\n  scale(\n    sx: number, // eslint-disable-line\n    sy: number, // eslint-disable-line\n    origin?: Point | Point.PointLike, // eslint-disable-line\n    options?: Node.SetOptions, // eslint-disable-line\n  ) {\n    return this\n  }\n\n  // #endregion\n\n  // #region tools\n\n  addTools(\n    items: Cell.ToolItem | Cell.ToolItem[],\n    options?: Cell.AddToolOptions,\n  ): void\n  addTools(\n    items: Cell.ToolItem | Cell.ToolItem[],\n    name: string,\n    options?: Cell.AddToolOptions,\n  ): void\n  addTools(\n    items: Cell.ToolItem | Cell.ToolItem[],\n    obj?: string | Cell.AddToolOptions,\n    options?: Cell.AddToolOptions,\n  ) {\n    const toolItems = Array.isArray(items) ? items : [items]\n    const name = typeof obj === 'string' ? obj : null\n    const config =\n      typeof obj === 'object' ? obj : typeof options === 'object' ? options : {}\n\n    if (config.reset) {\n      return this.setTools(\n        { name, items: toolItems, local: config.local },\n        config,\n      )\n    }\n    let tools = ObjectExt.cloneDeep(this.getTools())\n    if (tools == null || name == null || tools.name === name) {\n      if (tools == null) {\n        tools = {} as Cell.Tools\n      }\n\n      if (!tools.items) {\n        tools.items = []\n      }\n\n      tools.name = name\n      tools.items = [...tools.items, ...toolItems]\n\n      return this.setTools({ ...tools }, config)\n    }\n  }\n\n  setTools(tools?: Cell.ToolsLoose | null, options: Cell.SetOptions = {}) {\n    if (tools == null) {\n      this.removeTools()\n    } else {\n      this.store.set('tools', Cell.normalizeTools(tools), options)\n    }\n    return this\n  }\n\n  getTools(): Cell.Tools | null {\n    return this.store.get<Cell.Tools>('tools')\n  }\n\n  removeTools(options: Cell.SetOptions = {}) {\n    this.store.remove('tools', options)\n    return this\n  }\n\n  hasTools(name?: string) {\n    const tools = this.getTools()\n    if (tools == null) {\n      return false\n    }\n\n    if (name == null) {\n      return true\n    }\n\n    return tools.name === name\n  }\n\n  hasTool(name: string) {\n    const tools = this.getTools()\n    if (tools == null) {\n      return false\n    }\n    return tools.items.some((item) =>\n      typeof item === 'string' ? item === name : item.name === name,\n    )\n  }\n\n  removeTool(name: string, options?: Cell.SetOptions): this\n  removeTool(index: number, options?: Cell.SetOptions): this\n  removeTool(nameOrIndex: string | number, options: Cell.SetOptions = {}) {\n    const tools = ObjectExt.cloneDeep(this.getTools())\n    if (tools) {\n      let updated = false\n      const items = tools.items.slice()\n      const remove = (index: number) => {\n        items.splice(index, 1)\n        updated = true\n      }\n\n      if (typeof nameOrIndex === 'number') {\n        remove(nameOrIndex)\n      } else {\n        for (let i = items.length - 1; i >= 0; i -= 1) {\n          const item = items[i]\n          const exist =\n            typeof item === 'string'\n              ? item === nameOrIndex\n              : item.name === nameOrIndex\n          if (exist) {\n            remove(i)\n          }\n        }\n      }\n\n      if (updated) {\n        tools.items = items\n        this.setTools(tools, options)\n      }\n    }\n    return this\n  }\n\n  // #endregion\n\n  // #region common\n\n  // eslint-disable-next-line\n  getBBox(options?: { deep?: boolean }) {\n    return new Rectangle()\n  }\n\n  // eslint-disable-next-line\n  getConnectionPoint(edge: Edge, type: Edge.TerminalType) {\n    return new Point()\n  }\n\n  toJSON(\n    options: Cell.ToJSONOptions = {},\n  ): this extends Node\n    ? Node.Properties\n    : this extends Edge\n    ? Edge.Properties\n    : Properties {\n    const props = { ...this.store.get() }\n    const toString = Object.prototype.toString\n    const cellType = this.isNode() ? 'node' : this.isEdge() ? 'edge' : 'cell'\n\n    if (!props.shape) {\n      const ctor = this.constructor\n      throw new Error(\n        `Unable to serialize ${cellType} missing \"shape\" prop, check the ${cellType} \"${\n          ctor.name || toString.call(ctor)\n        }\"`,\n      )\n    }\n\n    const ctor = this.constructor as typeof Cell\n    const diff = options.diff === true\n    const attrs = props.attrs || {}\n    const presets = ctor.getDefaults(true) as Properties\n    // When `options.diff` is `true`, we should process the custom options,\n    // such as `width`, `height` etc. to ensure the comparing work correctly.\n    const defaults = diff ? this.preprocess(presets, true) : presets\n    const defaultAttrs = defaults.attrs || {}\n    const finalAttrs: Attr.CellAttrs = {}\n\n    Object.entries(props).forEach(([key, val]) => {\n      if (\n        val != null &&\n        !Array.isArray(val) &&\n        typeof val === 'object' &&\n        !ObjectExt.isPlainObject(val)\n      ) {\n        throw new Error(\n          `Can only serialize ${cellType} with plain-object props, but got a \"${toString.call(\n            val,\n          )}\" type of key \"${key}\" on ${cellType} \"${this.id}\"`,\n        )\n      }\n\n      if (key !== 'attrs' && key !== 'shape' && diff) {\n        const preset = defaults[key]\n        if (ObjectExt.isEqual(val, preset)) {\n          delete props[key]\n        }\n      }\n    })\n\n    Object.keys(attrs).forEach((key) => {\n      const attr = attrs[key]\n      const defaultAttr = defaultAttrs[key]\n\n      Object.keys(attr).forEach((name) => {\n        const value = attr[name] as KeyValue\n        const defaultValue = defaultAttr ? defaultAttr[name] : null\n\n        if (\n          value != null &&\n          typeof value === 'object' &&\n          !Array.isArray(value)\n        ) {\n          Object.keys(value).forEach((subName) => {\n            const subValue = value[subName]\n            if (\n              defaultAttr == null ||\n              defaultValue == null ||\n              !ObjectExt.isObject(defaultValue) ||\n              !ObjectExt.isEqual(defaultValue[subName], subValue)\n            ) {\n              if (finalAttrs[key] == null) {\n                finalAttrs[key] = {}\n              }\n              if (finalAttrs[key][name] == null) {\n                finalAttrs[key][name] = {}\n              }\n              const tmp = finalAttrs[key][name] as KeyValue\n              tmp[subName] = subValue\n            }\n          })\n        } else if (\n          defaultAttr == null ||\n          !ObjectExt.isEqual(defaultValue, value)\n        ) {\n          // `value` is not an object, default attribute with `key` does not\n          // exist or it is different than the attribute value set on the cell.\n          if (finalAttrs[key] == null) {\n            finalAttrs[key] = {}\n          }\n          finalAttrs[key][name] = value as any\n        }\n      })\n    })\n\n    const finalProps = {\n      ...props,\n      attrs: ObjectExt.isEmpty(finalAttrs) ? undefined : finalAttrs,\n    }\n\n    if (finalProps.attrs == null) {\n      delete finalProps.attrs\n    }\n\n    const ret = finalProps as any\n    if (ret.angle === 0) {\n      delete ret.angle\n    }\n\n    return ObjectExt.cloneDeep(ret)\n  }\n\n  clone(\n    options: Cell.CloneOptions = {},\n  ): this extends Node ? Node : this extends Edge ? Edge : Cell {\n    if (!options.deep) {\n      const data = { ...this.store.get() }\n      if (!options.keepId) {\n        delete data.id\n      }\n      delete data.parent\n      delete data.children\n      const ctor = this.constructor as typeof Cell\n      return new ctor(data) as any // eslint-disable-line new-cap\n    }\n\n    // Deep cloning. Clone the cell itself and all its children.\n    const map = Cell.deepClone(this)\n    return map[this.id] as any\n  }\n\n  findView(graph: Graph): CellView | null {\n    return graph.findViewByCell(this)\n  }\n\n  // #endregion\n\n  // #region batch\n\n  startBatch(\n    name: Model.BatchName,\n    data: KeyValue = {},\n    model: Model | null = this.model,\n  ) {\n    this.notify('batch:start', { name, data, cell: this })\n\n    if (model) {\n      model.startBatch(name, { ...data, cell: this })\n    }\n\n    return this\n  }\n\n  stopBatch(\n    name: Model.BatchName,\n    data: KeyValue = {},\n    model: Model | null = this.model,\n  ) {\n    if (model) {\n      model.stopBatch(name, { ...data, cell: this })\n    }\n\n    this.notify('batch:stop', { name, data, cell: this })\n    return this\n  }\n\n  batchUpdate<T>(name: Model.BatchName, execute: () => T, data?: KeyValue): T {\n    // The model is null after cell was removed(remove batch).\n    // So we should temp save model to trigger pairing batch event.\n    const model = this.model\n    this.startBatch(name, data, model)\n    const result = execute()\n    this.stopBatch(name, data, model)\n    return result\n  }\n\n  // #endregion\n\n  // #region IDisposable\n\n  @Basecoat.dispose()\n  dispose() {\n    this.removeFromParent()\n    this.store.dispose()\n  }\n\n  // #endregion\n}\n\nexport namespace Cell {\n  export interface Common {\n    view?: string\n    shape?: string\n    markup?: Markup\n    attrs?: Attr.CellAttrs\n    zIndex?: number\n    visible?: boolean\n    data?: any\n  }\n\n  export interface Defaults extends Common {}\n\n  export interface Metadata extends Common, KeyValue {\n    id?: string\n    tools?: ToolsLoose\n  }\n\n  export interface Properties extends Defaults, Metadata {\n    parent?: string\n    children?: string[]\n    tools?: Tools\n  }\n}\n\nexport namespace Cell {\n  export type ToolItem =\n    | string\n    | {\n        name: string\n        args?: any\n      }\n\n  export interface Tools {\n    name?: string | null\n    local?: boolean\n    items: ToolItem[]\n  }\n\n  export type ToolsLoose = ToolItem | ToolItem[] | Tools\n\n  export function normalizeTools(raw: ToolsLoose): Tools {\n    if (typeof raw === 'string') {\n      return { items: [raw] }\n    }\n\n    if (Array.isArray(raw)) {\n      return { items: raw }\n    }\n\n    if ((raw as Tools).items) {\n      return raw as Tools\n    }\n\n    return {\n      items: [raw as ToolItem],\n    }\n  }\n}\n\nexport namespace Cell {\n  export interface SetOptions extends Store.SetOptions {}\n\n  export interface MutateOptions extends Store.MutateOptions {}\n\n  export interface RemoveOptions extends SetOptions {\n    deep?: boolean\n  }\n\n  export interface SetAttrOptions extends SetOptions {\n    deep?: boolean\n    overwrite?: boolean\n  }\n\n  export interface SetDataOptions extends SetOptions {\n    deep?: boolean\n    overwrite?: boolean\n  }\n\n  export interface SetByPathOptions extends Store.SetByPathOptions {}\n\n  export interface ToFrontOptions extends SetOptions {\n    deep?: boolean\n  }\n\n  export interface ToBackOptions extends ToFrontOptions {}\n\n  export interface TranslateOptions extends SetOptions {\n    tx?: number\n    ty?: number\n    translateBy?: string | number\n  }\n\n  export interface AddToolOptions extends SetOptions {\n    reset?: boolean\n    local?: boolean\n  }\n\n  export interface GetDescendantsOptions {\n    deep?: boolean\n    breadthFirst?: boolean\n  }\n\n  export interface ToJSONOptions {\n    diff?: boolean\n  }\n\n  export interface CloneOptions {\n    deep?: boolean\n    keepId?: boolean\n  }\n}\n\nexport namespace Cell {\n  export interface EventArgs {\n    'transition:start': Animation.CallbackArgs<Animation.TargetValue>\n    'transition:progress': Animation.ProgressArgs<Animation.TargetValue>\n    'transition:complete': Animation.CallbackArgs<Animation.TargetValue>\n    'transition:stop': Animation.StopArgs<Animation.TargetValue>\n    'transition:finish': Animation.CallbackArgs<Animation.TargetValue>\n\n    // common\n    'change:*': ChangeAnyKeyArgs\n    'change:attrs': ChangeArgs<Attr.CellAttrs>\n    'change:zIndex': ChangeArgs<number>\n    'change:markup': ChangeArgs<Markup>\n    'change:visible': ChangeArgs<boolean>\n    'change:parent': ChangeArgs<string>\n    'change:children': ChangeArgs<string[]>\n    'change:tools': ChangeArgs<Tools>\n    'change:view': ChangeArgs<string>\n    'change:data': ChangeArgs<any>\n\n    // node\n    'change:size': NodeChangeArgs<Size>\n    'change:angle': NodeChangeArgs<number>\n    'change:position': NodeChangeArgs<Point.PointLike>\n    'change:ports': NodeChangeArgs<PortManager.Port[]>\n    'change:portMarkup': NodeChangeArgs<Markup>\n    'change:portLabelMarkup': NodeChangeArgs<Markup>\n    'change:portContainerMarkup': NodeChangeArgs<Markup>\n    'ports:removed': {\n      cell: Cell\n      node: Node\n      removed: PortManager.Port[]\n    }\n    'ports:added': {\n      cell: Cell\n      node: Node\n      added: PortManager.Port[]\n    }\n\n    // edge\n    'change:source': EdgeChangeArgs<Edge.TerminalData>\n    'change:target': EdgeChangeArgs<Edge.TerminalData>\n    'change:terminal': EdgeChangeArgs<Edge.TerminalData> & {\n      type: Edge.TerminalType\n    }\n    'change:router': EdgeChangeArgs<Edge.RouterData>\n    'change:connector': EdgeChangeArgs<Edge.ConnectorData>\n    'change:vertices': EdgeChangeArgs<Point.PointLike[]>\n    'change:labels': EdgeChangeArgs<Edge.Label[]>\n    'change:defaultLabel': EdgeChangeArgs<Edge.Label>\n    'vertexs:added': {\n      cell: Cell\n      edge: Edge\n      added: Point.PointLike[]\n    }\n    'vertexs:removed': {\n      cell: Cell\n      edge: Edge\n      removed: Point.PointLike[]\n    }\n    'labels:added': {\n      cell: Cell\n      edge: Edge\n      added: Edge.Label[]\n    }\n    'labels:removed': {\n      cell: Cell\n      edge: Edge\n      removed: Edge.Label[]\n    }\n\n    'batch:start': {\n      name: Model.BatchName\n      data: KeyValue\n      cell: Cell\n    }\n\n    'batch:stop': {\n      name: Model.BatchName\n      data: KeyValue\n      cell: Cell\n    }\n\n    changed: {\n      cell: Cell\n      options: MutateOptions\n    }\n\n    added: {\n      cell: Cell\n      index: number\n      options: Cell.SetOptions\n    }\n\n    removed: {\n      cell: Cell\n      index: number\n      options: Cell.RemoveOptions\n    }\n  }\n\n  interface ChangeAnyKeyArgs<T extends keyof Properties = keyof Properties> {\n    key: T\n    current: Properties[T]\n    previous: Properties[T]\n    options: MutateOptions\n    cell: Cell\n  }\n\n  export interface ChangeArgs<T> {\n    cell: Cell\n    current?: T\n    previous?: T\n    options: MutateOptions\n  }\n\n  interface NodeChangeArgs<T> extends ChangeArgs<T> {\n    node: Node\n  }\n\n  interface EdgeChangeArgs<T> extends ChangeArgs<T> {\n    edge: Edge\n  }\n}\n\nexport namespace Cell {\n  export const toStringTag = `X6.${Cell.name}`\n\n  export function isCell(instance: any): instance is Cell {\n    if (instance == null) {\n      return false\n    }\n\n    if (instance instanceof Cell) {\n      return true\n    }\n\n    const tag = instance[Symbol.toStringTag]\n    const cell = instance as Cell\n\n    if (\n      (tag == null || tag === toStringTag) &&\n      typeof cell.isNode === 'function' &&\n      typeof cell.isEdge === 'function' &&\n      typeof cell.prop === 'function' &&\n      typeof cell.attr === 'function'\n    ) {\n      return true\n    }\n\n    return false\n  }\n}\n\nexport namespace Cell {\n  export function getCommonAncestor(\n    ...cells: (Cell | null | undefined)[]\n  ): Cell | null {\n    const ancestors = cells\n      .filter((cell) => cell != null)\n      .map((cell) => cell!.getAncestors())\n      .sort((a, b) => {\n        return a.length - b.length\n      })\n\n    const first = ancestors.shift()!\n    return (\n      first.find((cell) => ancestors.every((item) => item.includes(cell))) ||\n      null\n    )\n  }\n\n  export interface GetCellsBBoxOptions {\n    deep?: boolean\n  }\n\n  export function getCellsBBox(\n    cells: Cell[],\n    options: GetCellsBBoxOptions = {},\n  ) {\n    let bbox: Rectangle | null = null\n\n    for (let i = 0, ii = cells.length; i < ii; i += 1) {\n      const cell = cells[i]\n      let rect = cell.getBBox(options)\n      if (rect) {\n        if (cell.isNode()) {\n          const angle = cell.getAngle()\n          if (angle != null && angle !== 0) {\n            rect = rect.bbox(angle)\n          }\n        }\n        bbox = bbox == null ? rect : bbox.union(rect)\n      }\n    }\n\n    return bbox\n  }\n\n  export function deepClone(cell: Cell) {\n    const cells = [cell, ...cell.getDescendants({ deep: true })]\n    return Cell.cloneCells(cells)\n  }\n\n  export function cloneCells(cells: Cell[]) {\n    const inputs = ArrayExt.uniq(cells)\n    const cloneMap = inputs.reduce<KeyValue<Cell>>((map, cell) => {\n      map[cell.id] = cell.clone()\n      return map\n    }, {})\n\n    inputs.forEach((cell) => {\n      const clone = cloneMap[cell.id]\n      if (clone.isEdge()) {\n        const sourceId = clone.getSourceCellId()\n        const targetId = clone.getTargetCellId()\n        if (sourceId && cloneMap[sourceId]) {\n          // Source is a node and the node is among the clones.\n          // Then update the source of the cloned edge.\n          clone.setSource({\n            ...clone.getSource(),\n            cell: cloneMap[sourceId].id,\n          })\n        }\n        if (targetId && cloneMap[targetId]) {\n          // Target is a node and the node is among the clones.\n          // Then update the target of the cloned edge.\n          clone.setTarget({\n            ...clone.getTarget(),\n            cell: cloneMap[targetId].id,\n          })\n        }\n      }\n\n      // Find the parent of the original cell\n      const parent = cell.getParent()\n      if (parent && cloneMap[parent.id]) {\n        clone.setParent(cloneMap[parent.id])\n      }\n\n      // Find the children of the original cell\n      const children = cell.getChildren()\n      if (children && children.length) {\n        const embeds = children.reduce<Cell[]>((memo, child) => {\n          // Embedded cells that are not being cloned can not be carried\n          // over with other embedded cells.\n          if (cloneMap[child.id]) {\n            memo.push(cloneMap[child.id])\n          }\n          return memo\n        }, [])\n\n        if (embeds.length > 0) {\n          clone.setChildren(embeds)\n        }\n      }\n    })\n\n    return cloneMap\n  }\n}\n\nexport namespace Cell {\n  export type Definition = typeof Cell\n\n  export type PropHook<M extends Metadata = Metadata, C extends Cell = Cell> = (\n    this: C,\n    metadata: M,\n  ) => M\n\n  export type PropHooks<M extends Metadata = Metadata, C extends Cell = Cell> =\n    | KeyValue<PropHook<M, C>>\n    | PropHook<M, C>\n    | PropHook<M, C>[]\n\n  export interface Config<M extends Metadata = Metadata, C extends Cell = Cell>\n    extends Defaults,\n      KeyValue {\n    constructorName?: string\n    overwrite?: boolean\n    propHooks?: PropHooks<M, C>\n    attrHooks?: Attr.Definitions\n  }\n}\n\nexport namespace Cell {\n  Cell.config({\n    propHooks({ tools, ...metadata }) {\n      if (tools) {\n        metadata.tools = normalizeTools(tools)\n      }\n      return metadata\n    },\n  })\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}