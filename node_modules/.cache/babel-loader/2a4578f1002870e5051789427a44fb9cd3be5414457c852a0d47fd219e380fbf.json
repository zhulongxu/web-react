{"ast":null,"code":"import { toResult } from './util';\nexport const outside = (portPosition, elemBBox, args) => outsideLayout(portPosition, elemBBox, false, args);\nexport const outsideOriented = (portPosition, elemBBox, args) => outsideLayout(portPosition, elemBBox, true, args);\nexport const inside = (portPosition, elemBBox, args) => insideLayout(portPosition, elemBBox, false, args);\nexport const insideOriented = (portPosition, elemBBox, args) => insideLayout(portPosition, elemBBox, true, args);\nfunction outsideLayout(portPosition, elemBBox, autoOrient, args) {\n  const offset = args.offset != null ? args.offset : 15;\n  const angle = elemBBox.getCenter().theta(portPosition);\n  const bboxAngles = getBBoxAngles(elemBBox);\n  let y;\n  let tx;\n  let ty;\n  let textAnchor;\n  let orientAngle = 0;\n  if (angle < bboxAngles[1] || angle > bboxAngles[2]) {\n    y = '.3em';\n    tx = offset;\n    ty = 0;\n    textAnchor = 'start';\n  } else if (angle < bboxAngles[0]) {\n    y = '0';\n    tx = 0;\n    ty = -offset;\n    if (autoOrient) {\n      orientAngle = -90;\n      textAnchor = 'start';\n    } else {\n      textAnchor = 'middle';\n    }\n  } else if (angle < bboxAngles[3]) {\n    y = '.3em';\n    tx = -offset;\n    ty = 0;\n    textAnchor = 'end';\n  } else {\n    y = '.6em';\n    tx = 0;\n    ty = offset;\n    if (autoOrient) {\n      orientAngle = 90;\n      textAnchor = 'start';\n    } else {\n      textAnchor = 'middle';\n    }\n  }\n  return toResult({\n    position: {\n      x: Math.round(tx),\n      y: Math.round(ty)\n    },\n    angle: orientAngle,\n    attrs: {\n      '.': {\n        y,\n        'text-anchor': textAnchor\n      }\n    }\n  }, args);\n}\nfunction insideLayout(portPosition, elemBBox, autoOrient, args) {\n  const offset = args.offset != null ? args.offset : 15;\n  const angle = elemBBox.getCenter().theta(portPosition);\n  const bboxAngles = getBBoxAngles(elemBBox);\n  let y;\n  let tx;\n  let ty;\n  let textAnchor;\n  let orientAngle = 0;\n  if (angle < bboxAngles[1] || angle > bboxAngles[2]) {\n    y = '.3em';\n    tx = -offset;\n    ty = 0;\n    textAnchor = 'end';\n  } else if (angle < bboxAngles[0]) {\n    y = '.6em';\n    tx = 0;\n    ty = offset;\n    if (autoOrient) {\n      orientAngle = 90;\n      textAnchor = 'start';\n    } else {\n      textAnchor = 'middle';\n    }\n  } else if (angle < bboxAngles[3]) {\n    y = '.3em';\n    tx = offset;\n    ty = 0;\n    textAnchor = 'start';\n  } else {\n    y = '0em';\n    tx = 0;\n    ty = -offset;\n    if (autoOrient) {\n      orientAngle = -90;\n      textAnchor = 'start';\n    } else {\n      textAnchor = 'middle';\n    }\n  }\n  return toResult({\n    position: {\n      x: Math.round(tx),\n      y: Math.round(ty)\n    },\n    angle: orientAngle,\n    attrs: {\n      '.': {\n        y,\n        'text-anchor': textAnchor\n      }\n    }\n  }, args);\n}\nfunction getBBoxAngles(elemBBox) {\n  const center = elemBBox.getCenter();\n  const tl = center.theta(elemBBox.getTopLeft());\n  const bl = center.theta(elemBBox.getBottomLeft());\n  const br = center.theta(elemBBox.getBottomRight());\n  const tr = center.theta(elemBBox.getTopRight());\n  return [tl, tr, br, bl];\n}","map":{"version":3,"names":["toResult","outside","portPosition","elemBBox","args","outsideLayout","outsideOriented","inside","insideLayout","insideOriented","autoOrient","offset","angle","getCenter","theta","bboxAngles","getBBoxAngles","y","tx","ty","textAnchor","orientAngle","position","x","Math","round","attrs","center","tl","getTopLeft","bl","getBottomLeft","br","getBottomRight","tr","getTopRight"],"sources":["/home/devbox/project/node_modules/.pnpm/@antv+x6@2.18.1/node_modules/@antv/x6/src/registry/port-label-layout/inout.ts"],"sourcesContent":["import { Point, Rectangle } from '@antv/x6-geometry'\nimport { PortLabelLayout } from './index'\nimport { toResult } from './util'\n\nexport interface InOutArgs extends PortLabelLayout.CommonOptions {\n  offset?: number\n}\n\nexport const outside: PortLabelLayout.Definition<InOutArgs> = (\n  portPosition,\n  elemBBox,\n  args,\n) => outsideLayout(portPosition, elemBBox, false, args)\n\nexport const outsideOriented: PortLabelLayout.Definition<InOutArgs> = (\n  portPosition,\n  elemBBox,\n  args,\n) => outsideLayout(portPosition, elemBBox, true, args)\n\nexport const inside: PortLabelLayout.Definition<InOutArgs> = (\n  portPosition,\n  elemBBox,\n  args,\n) => insideLayout(portPosition, elemBBox, false, args)\n\nexport const insideOriented: PortLabelLayout.Definition<InOutArgs> = (\n  portPosition,\n  elemBBox,\n  args,\n) => insideLayout(portPosition, elemBBox, true, args)\n\nfunction outsideLayout(\n  portPosition: Point,\n  elemBBox: Rectangle,\n  autoOrient: boolean,\n  args: InOutArgs,\n) {\n  const offset = args.offset != null ? args.offset : 15\n  const angle = elemBBox.getCenter().theta(portPosition)\n  const bboxAngles = getBBoxAngles(elemBBox)\n\n  let y\n  let tx\n  let ty\n  let textAnchor\n  let orientAngle = 0\n\n  if (angle < bboxAngles[1] || angle > bboxAngles[2]) {\n    y = '.3em'\n    tx = offset\n    ty = 0\n    textAnchor = 'start'\n  } else if (angle < bboxAngles[0]) {\n    y = '0'\n    tx = 0\n    ty = -offset\n    if (autoOrient) {\n      orientAngle = -90\n      textAnchor = 'start'\n    } else {\n      textAnchor = 'middle'\n    }\n  } else if (angle < bboxAngles[3]) {\n    y = '.3em'\n    tx = -offset\n    ty = 0\n    textAnchor = 'end'\n  } else {\n    y = '.6em'\n    tx = 0\n    ty = offset\n    if (autoOrient) {\n      orientAngle = 90\n      textAnchor = 'start'\n    } else {\n      textAnchor = 'middle'\n    }\n  }\n\n  return toResult(\n    {\n      position: {\n        x: Math.round(tx),\n        y: Math.round(ty),\n      },\n      angle: orientAngle,\n      attrs: {\n        '.': {\n          y,\n          'text-anchor': textAnchor,\n        },\n      },\n    },\n    args,\n  )\n}\n\nfunction insideLayout(\n  portPosition: Point,\n  elemBBox: Rectangle,\n  autoOrient: boolean,\n  args: InOutArgs,\n) {\n  const offset = args.offset != null ? args.offset : 15\n  const angle = elemBBox.getCenter().theta(portPosition)\n  const bboxAngles = getBBoxAngles(elemBBox)\n\n  let y\n  let tx\n  let ty\n  let textAnchor\n  let orientAngle = 0\n\n  if (angle < bboxAngles[1] || angle > bboxAngles[2]) {\n    y = '.3em'\n    tx = -offset\n    ty = 0\n    textAnchor = 'end'\n  } else if (angle < bboxAngles[0]) {\n    y = '.6em'\n    tx = 0\n    ty = offset\n    if (autoOrient) {\n      orientAngle = 90\n      textAnchor = 'start'\n    } else {\n      textAnchor = 'middle'\n    }\n  } else if (angle < bboxAngles[3]) {\n    y = '.3em'\n    tx = offset\n    ty = 0\n    textAnchor = 'start'\n  } else {\n    y = '0em'\n    tx = 0\n    ty = -offset\n    if (autoOrient) {\n      orientAngle = -90\n      textAnchor = 'start'\n    } else {\n      textAnchor = 'middle'\n    }\n  }\n\n  return toResult(\n    {\n      position: {\n        x: Math.round(tx),\n        y: Math.round(ty),\n      },\n      angle: orientAngle,\n      attrs: {\n        '.': {\n          y,\n          'text-anchor': textAnchor,\n        },\n      },\n    },\n    args,\n  )\n}\n\nfunction getBBoxAngles(elemBBox: Rectangle) {\n  const center = elemBBox.getCenter()\n\n  const tl = center.theta(elemBBox.getTopLeft())\n  const bl = center.theta(elemBBox.getBottomLeft())\n  const br = center.theta(elemBBox.getBottomRight())\n  const tr = center.theta(elemBBox.getTopRight())\n\n  return [tl, tr, br, bl]\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}